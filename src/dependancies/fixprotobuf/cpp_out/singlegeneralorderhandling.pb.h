// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: singlegeneralorderhandling.proto

#ifndef PROTOBUF_singlegeneralorderhandling_2eproto__INCLUDED
#define PROTOBUF_singlegeneralorderhandling_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "meta.pb.h"
#include "fix.pb.h"
#include "session.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace SingleGeneralOrderHandling {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

class AcctIdSourceUnion;
class SettlTypeUnion;
class TargetStrategyUnion;
class NewOrderSingle;
class OrderCancelReplaceRequest;
class OrderCancelRequest;
class CxlRejReasonUnion;
class OrderCancelReject;
class FillsGrp;
class OrdRejReasonUnion;
class ExecRestatementReasonUnion;
class ExecutionReport;
class OrderStatusRequest;
class ExecutionAcknowledgement;
class DontKnowTrade;

enum AcctIdSourceEnum {
  ACCT_ID_SOURCE_BIC = 0,
  ACCT_ID_SOURCE_DTCCCODE = 1,
  ACCT_ID_SOURCE_OMGEO = 2,
  ACCT_ID_SOURCE_OTHER = 3,
  ACCT_ID_SOURCE_SID_CODE = 4,
  ACCT_ID_SOURCE_TFM = 5
};
bool AcctIdSourceEnum_IsValid(int value);
const AcctIdSourceEnum AcctIdSourceEnum_MIN = ACCT_ID_SOURCE_BIC;
const AcctIdSourceEnum AcctIdSourceEnum_MAX = ACCT_ID_SOURCE_TFM;
const int AcctIdSourceEnum_ARRAYSIZE = AcctIdSourceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* AcctIdSourceEnum_descriptor();
inline const ::std::string& AcctIdSourceEnum_Name(AcctIdSourceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    AcctIdSourceEnum_descriptor(), value);
}
inline bool AcctIdSourceEnum_Parse(
    const ::std::string& name, AcctIdSourceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AcctIdSourceEnum>(
    AcctIdSourceEnum_descriptor(), name, value);
}
enum AccountTypeEnum {
  ACCOUNT_TYPE_CARRIED_CUSTOMER_SIDE = 0,
  ACCOUNT_TYPE_CARRIED_NON_CUSTOMER_SIDE = 1,
  ACCOUNT_TYPE_CARRIED_NON_CUSTOMER_SIDE_CROSS_MARGINED = 2,
  ACCOUNT_TYPE_FLOOR_TRADER = 3,
  ACCOUNT_TYPE_HOUSE_TRADER = 4,
  ACCOUNT_TYPE_HOUSE_TRADER_CROSS_MARGINED = 5,
  ACCOUNT_TYPE_JOINT_BACK_OFFICE_ACCOUNT = 6
};
bool AccountTypeEnum_IsValid(int value);
const AccountTypeEnum AccountTypeEnum_MIN = ACCOUNT_TYPE_CARRIED_CUSTOMER_SIDE;
const AccountTypeEnum AccountTypeEnum_MAX = ACCOUNT_TYPE_JOINT_BACK_OFFICE_ACCOUNT;
const int AccountTypeEnum_ARRAYSIZE = AccountTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountTypeEnum_descriptor();
inline const ::std::string& AccountTypeEnum_Name(AccountTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountTypeEnum_descriptor(), value);
}
inline bool AccountTypeEnum_Parse(
    const ::std::string& name, AccountTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountTypeEnum>(
    AccountTypeEnum_descriptor(), name, value);
}
enum DayBookingInstEnum {
  DAY_BOOKING_INST_AUTO = 0,
  DAY_BOOKING_INST_SPEAK_WITH_ORDER_INITIATOR_BEFORE_BOOKING = 1,
  DAY_BOOKING_INST_ACCUMULATE = 2
};
bool DayBookingInstEnum_IsValid(int value);
const DayBookingInstEnum DayBookingInstEnum_MIN = DAY_BOOKING_INST_AUTO;
const DayBookingInstEnum DayBookingInstEnum_MAX = DAY_BOOKING_INST_ACCUMULATE;
const int DayBookingInstEnum_ARRAYSIZE = DayBookingInstEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DayBookingInstEnum_descriptor();
inline const ::std::string& DayBookingInstEnum_Name(DayBookingInstEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DayBookingInstEnum_descriptor(), value);
}
inline bool DayBookingInstEnum_Parse(
    const ::std::string& name, DayBookingInstEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DayBookingInstEnum>(
    DayBookingInstEnum_descriptor(), name, value);
}
enum BookingUnitEnum {
  BOOKING_UNIT_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL = 0,
  BOOKING_UNIT_AGGREGATE_PARTIAL_EXECUTIONS_ON_THIS_ORDER = 1,
  BOOKING_UNIT_EACH_PARTIAL_EXECUTION_IS_ABOOKABLE_UNIT = 2
};
bool BookingUnitEnum_IsValid(int value);
const BookingUnitEnum BookingUnitEnum_MIN = BOOKING_UNIT_AGGREGATE_EXECUTIONS_FOR_THIS_SYMBOL;
const BookingUnitEnum BookingUnitEnum_MAX = BOOKING_UNIT_EACH_PARTIAL_EXECUTION_IS_ABOOKABLE_UNIT;
const int BookingUnitEnum_ARRAYSIZE = BookingUnitEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* BookingUnitEnum_descriptor();
inline const ::std::string& BookingUnitEnum_Name(BookingUnitEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    BookingUnitEnum_descriptor(), value);
}
inline bool BookingUnitEnum_Parse(
    const ::std::string& name, BookingUnitEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BookingUnitEnum>(
    BookingUnitEnum_descriptor(), name, value);
}
enum PreallocMethodEnum {
  PREALLOC_METHOD_DO_NOT_PRO_RATA = 0,
  PREALLOC_METHOD_PRO_RATA = 1
};
bool PreallocMethodEnum_IsValid(int value);
const PreallocMethodEnum PreallocMethodEnum_MIN = PREALLOC_METHOD_DO_NOT_PRO_RATA;
const PreallocMethodEnum PreallocMethodEnum_MAX = PREALLOC_METHOD_PRO_RATA;
const int PreallocMethodEnum_ARRAYSIZE = PreallocMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PreallocMethodEnum_descriptor();
inline const ::std::string& PreallocMethodEnum_Name(PreallocMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PreallocMethodEnum_descriptor(), value);
}
inline bool PreallocMethodEnum_Parse(
    const ::std::string& name, PreallocMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PreallocMethodEnum>(
    PreallocMethodEnum_descriptor(), name, value);
}
enum SettlTypeEnum {
  SETTL_TYPE_CASH = 0,
  SETTL_TYPE_FUTURE = 1,
  SETTL_TYPE_NEXT_DAY = 2,
  SETTL_TYPE_REGULAR = 3,
  SETTL_TYPE_SELLERS_OPTION = 4,
  SETTL_TYPE_TPLUS2 = 5,
  SETTL_TYPE_TPLUS3 = 6,
  SETTL_TYPE_TPLUS4 = 7,
  SETTL_TYPE_WHEN_AND_IF_ISSUED = 8,
  SETTL_TYPE_TPLUS5 = 9,
  SETTL_TYPE_FX_SPOT_NEXT_SETTLEMENT = 10,
  SETTL_TYPE_BROKEN_DATE = 11
};
bool SettlTypeEnum_IsValid(int value);
const SettlTypeEnum SettlTypeEnum_MIN = SETTL_TYPE_CASH;
const SettlTypeEnum SettlTypeEnum_MAX = SETTL_TYPE_BROKEN_DATE;
const int SettlTypeEnum_ARRAYSIZE = SettlTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SettlTypeEnum_descriptor();
inline const ::std::string& SettlTypeEnum_Name(SettlTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SettlTypeEnum_descriptor(), value);
}
inline bool SettlTypeEnum_Parse(
    const ::std::string& name, SettlTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SettlTypeEnum>(
    SettlTypeEnum_descriptor(), name, value);
}
enum CashMarginEnum {
  CASH_MARGIN_CASH = 0,
  CASH_MARGIN_MARGIN_CLOSE = 1,
  CASH_MARGIN_MARGIN_OPEN = 2
};
bool CashMarginEnum_IsValid(int value);
const CashMarginEnum CashMarginEnum_MIN = CASH_MARGIN_CASH;
const CashMarginEnum CashMarginEnum_MAX = CASH_MARGIN_MARGIN_OPEN;
const int CashMarginEnum_ARRAYSIZE = CashMarginEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CashMarginEnum_descriptor();
inline const ::std::string& CashMarginEnum_Name(CashMarginEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CashMarginEnum_descriptor(), value);
}
inline bool CashMarginEnum_Parse(
    const ::std::string& name, CashMarginEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CashMarginEnum>(
    CashMarginEnum_descriptor(), name, value);
}
enum ClearingFeeIndicatorEnum {
  CLEARING_FEE_INDICATOR_ALL_OTHER_OWNERSHIP_TYPES = 0,
  CLEARING_FEE_INDICATOR_CBOEMEMBER = 1,
  CLEARING_FEE_INDICATOR_EQUITY_MEMBER_AND_CLEARING_MEMBER = 2,
  CLEARING_FEE_INDICATOR_FIFTH_YEAR_DELEGATE = 3,
  CLEARING_FEE_INDICATOR_FIRMS106HAND106J = 4,
  CLEARING_FEE_INDICATOR_FIRST_YEAR_DELEGATE = 5,
  CLEARING_FEE_INDICATOR_FOURTH_YEAR_DELEGATE = 6,
  CLEARING_FEE_INDICATOR_FULL_AND_ASSOCIATE_MEMBER = 7,
  CLEARING_FEE_INDICATOR_GIM = 8,
  CLEARING_FEE_INDICATOR_LESSEE106FEMPLOYEES = 9,
  CLEARING_FEE_INDICATOR_NON_MEMBER_AND_CUSTOMER = 10,
  CLEARING_FEE_INDICATOR_SECOND_YEAR_DELEGATE = 11,
  CLEARING_FEE_INDICATOR_SIXTH_YEAR_DELEGATE = 12,
  CLEARING_FEE_INDICATOR_THIRD_YEAR_DELEGATE = 13
};
bool ClearingFeeIndicatorEnum_IsValid(int value);
const ClearingFeeIndicatorEnum ClearingFeeIndicatorEnum_MIN = CLEARING_FEE_INDICATOR_ALL_OTHER_OWNERSHIP_TYPES;
const ClearingFeeIndicatorEnum ClearingFeeIndicatorEnum_MAX = CLEARING_FEE_INDICATOR_THIRD_YEAR_DELEGATE;
const int ClearingFeeIndicatorEnum_ARRAYSIZE = ClearingFeeIndicatorEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ClearingFeeIndicatorEnum_descriptor();
inline const ::std::string& ClearingFeeIndicatorEnum_Name(ClearingFeeIndicatorEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ClearingFeeIndicatorEnum_descriptor(), value);
}
inline bool ClearingFeeIndicatorEnum_Parse(
    const ::std::string& name, ClearingFeeIndicatorEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ClearingFeeIndicatorEnum>(
    ClearingFeeIndicatorEnum_descriptor(), name, value);
}
enum HandlInstEnum {
  HANDL_INST_AUTOMATED_EXECUTION_INTERVENTION_OK = 0,
  HANDL_INST_AUTOMATED_EXECUTION_NO_INTERVENTION = 1,
  HANDL_INST_MANUAL_ORDER = 2
};
bool HandlInstEnum_IsValid(int value);
const HandlInstEnum HandlInstEnum_MIN = HANDL_INST_AUTOMATED_EXECUTION_INTERVENTION_OK;
const HandlInstEnum HandlInstEnum_MAX = HANDL_INST_MANUAL_ORDER;
const int HandlInstEnum_ARRAYSIZE = HandlInstEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* HandlInstEnum_descriptor();
inline const ::std::string& HandlInstEnum_Name(HandlInstEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    HandlInstEnum_descriptor(), value);
}
inline bool HandlInstEnum_Parse(
    const ::std::string& name, HandlInstEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HandlInstEnum>(
    HandlInstEnum_descriptor(), name, value);
}
enum ExecInstEnum {
  EXEC_INST_ALL_OR_NONE = 0,
  EXEC_INST_CALL_FIRST = 1,
  EXEC_INST_DO_NOT_INCREASE = 2,
  EXEC_INST_DO_NOT_REDUCE = 3,
  EXEC_INST_GO_ALONG = 4,
  EXEC_INST_HELD = 5,
  EXEC_INST_NO_CROSS = 6,
  EXEC_INST_NOT_HELD = 7,
  EXEC_INST_OKTO_CROSS = 8,
  EXEC_INST_OVER_THE_DAY = 9,
  EXEC_INST_PARTICIPATE_DO_NOT_INITIATE = 10,
  EXEC_INST_PERCENT_OF_VOLUME = 11,
  EXEC_INST_STAY_ON_BID_SIDE = 12,
  EXEC_INST_STAY_ON_OFFER_SIDE = 13,
  EXEC_INST_STRICT_SCALE = 14,
  EXEC_INST_TRY_TO_SCALE = 15,
  EXEC_INST_WORK = 16,
  EXEC_INST_INSTITUTIONS_ONLY = 17,
  EXEC_INST_LAST_PEG = 18,
  EXEC_INST_MARKET_PEG = 19,
  EXEC_INST_MID_PRICE_PEG = 20,
  EXEC_INST_NON_NEGOTIABLE = 21,
  EXEC_INST_OPENING_PEG = 22,
  EXEC_INST_PRIMARY_PEG = 23,
  EXEC_INST_SUSPEND = 24,
  EXEC_INST_CUSTOMER_DISPLAY_INSTRUCTION = 25,
  EXEC_INST_NETTING = 26,
  EXEC_INST_PEG_TO_VWAP = 27,
  EXEC_INST_CANCEL_ON_SYSTEM_FAILURE = 28,
  EXEC_INST_CANCEL_ON_TRADING_HALT = 29,
  EXEC_INST_REINSTATE_ON_SYSTEM_FAILURE = 30,
  EXEC_INST_REINSTATE_ON_TRADING_HALT = 31,
  EXEC_INST_TRADE_ALONG = 32,
  EXEC_INST_TRY_TO_STOP = 33,
  EXEC_INST_CANCEL_IF_NOT_BEST = 34,
  EXEC_INST_IGNORE_PRICE_VALIDITY_CHECKS = 35,
  EXEC_INST_PEG_TO_LIMIT_PRICE = 36,
  EXEC_INST_STRICT_LIMIT = 37,
  EXEC_INST_TRAILING_STOP_PEG = 38,
  EXEC_INST_WORK_TO_TARGET_STRATEGY = 39,
  EXEC_INST_INTERMARKET_SWEEP = 40,
  EXEC_INST_SINGLE_EXECUTION_REQUESTED_FOR_BLOCK_TRADE = 41,
  EXEC_INST_EXTERNAL_ROUTING_ALLOWED = 42,
  EXEC_INST_EXTERNAL_ROUTING_NOT_ALLOWED = 43,
  EXEC_INST_IMBALANCE_ONLY = 44,
  EXEC_INST_BEST_EXECUTION = 45,
  EXEC_INST_FIXED_PEG_TO_LOCAL_BEST_BID_OR_OFFER_AT_TIME_OF_ORDER = 46,
  EXEC_INST_CANCEL_ON_CONNECTION_LOSS = 47,
  EXEC_INST_REINSTATE_ON_CONNECTION_LOSS = 48,
  EXEC_INST_RELEASE_FROM_SUSPENSION = 49,
  EXEC_INST_SUSPEND_ON_CONNECTION_LOSS = 50,
  EXEC_INST_SUSPEND_ON_SYSTEM_FAILURE = 51,
  EXEC_INST_SUSPEND_ON_TRADING_HALT = 52,
  EXEC_INST_EXECUTE_AS_DELTA_NEUTRAL = 53,
  EXEC_INST_EXECUTE_AS_DURATION_NEUTRAL = 54,
  EXEC_INST_EXECUTE_AS_FX_NEUTRAL = 55
};
bool ExecInstEnum_IsValid(int value);
const ExecInstEnum ExecInstEnum_MIN = EXEC_INST_ALL_OR_NONE;
const ExecInstEnum ExecInstEnum_MAX = EXEC_INST_EXECUTE_AS_FX_NEUTRAL;
const int ExecInstEnum_ARRAYSIZE = ExecInstEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecInstEnum_descriptor();
inline const ::std::string& ExecInstEnum_Name(ExecInstEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecInstEnum_descriptor(), value);
}
inline bool ExecInstEnum_Parse(
    const ::std::string& name, ExecInstEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecInstEnum>(
    ExecInstEnum_descriptor(), name, value);
}
enum ExDestinationIdSourceEnum {
  EX_DESTINATION_ID_SOURCE_BIC = 0,
  EX_DESTINATION_ID_SOURCE_GENERAL_IDENTIFIER = 1,
  EX_DESTINATION_ID_SOURCE_ISO_COUNTRY_CODE = 2,
  EX_DESTINATION_ID_SOURCE_MIC = 3,
  EX_DESTINATION_ID_SOURCE_PROPRIETARY = 4
};
bool ExDestinationIdSourceEnum_IsValid(int value);
const ExDestinationIdSourceEnum ExDestinationIdSourceEnum_MIN = EX_DESTINATION_ID_SOURCE_BIC;
const ExDestinationIdSourceEnum ExDestinationIdSourceEnum_MAX = EX_DESTINATION_ID_SOURCE_PROPRIETARY;
const int ExDestinationIdSourceEnum_ARRAYSIZE = ExDestinationIdSourceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExDestinationIdSourceEnum_descriptor();
inline const ::std::string& ExDestinationIdSourceEnum_Name(ExDestinationIdSourceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExDestinationIdSourceEnum_descriptor(), value);
}
inline bool ExDestinationIdSourceEnum_Parse(
    const ::std::string& name, ExDestinationIdSourceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExDestinationIdSourceEnum>(
    ExDestinationIdSourceEnum_descriptor(), name, value);
}
enum ProcessCodeEnum {
  PROCESS_CODE_REGULAR = 0,
  PROCESS_CODE_SOFT_DOLLAR = 1,
  PROCESS_CODE_SOFT_DOLLAR_STEP_IN = 2,
  PROCESS_CODE_SOFT_DOLLAR_STEP_OUT = 3,
  PROCESS_CODE_STEP_IN = 4,
  PROCESS_CODE_STEP_OUT = 5,
  PROCESS_CODE_PLAN_SPONSOR = 6
};
bool ProcessCodeEnum_IsValid(int value);
const ProcessCodeEnum ProcessCodeEnum_MIN = PROCESS_CODE_REGULAR;
const ProcessCodeEnum ProcessCodeEnum_MAX = PROCESS_CODE_PLAN_SPONSOR;
const int ProcessCodeEnum_ARRAYSIZE = ProcessCodeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcessCodeEnum_descriptor();
inline const ::std::string& ProcessCodeEnum_Name(ProcessCodeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcessCodeEnum_descriptor(), value);
}
inline bool ProcessCodeEnum_Parse(
    const ::std::string& name, ProcessCodeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcessCodeEnum>(
    ProcessCodeEnum_descriptor(), name, value);
}
enum SideEnum {
  SIDE_BUY = 0,
  SIDE_BUY_MINUS = 1,
  SIDE_SELL = 2,
  SIDE_SELL_PLUS = 3,
  SIDE_SELL_SHORT = 4,
  SIDE_SELL_SHORT_EXEMPT = 5,
  SIDE_CROSS = 6,
  SIDE_UNDISCLOSED = 7,
  SIDE_CROSS_SHORT = 8,
  SIDE_AS_DEFINED = 9,
  SIDE_CROSS_SHORT_EXEMPT = 10,
  SIDE_OPPOSITE = 11,
  SIDE_BORROW = 12,
  SIDE_LEND = 13,
  SIDE_REDEEM = 14,
  SIDE_SUBSCRIBE = 15
};
bool SideEnum_IsValid(int value);
const SideEnum SideEnum_MIN = SIDE_BUY;
const SideEnum SideEnum_MAX = SIDE_SUBSCRIBE;
const int SideEnum_ARRAYSIZE = SideEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SideEnum_descriptor();
inline const ::std::string& SideEnum_Name(SideEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SideEnum_descriptor(), value);
}
inline bool SideEnum_Parse(
    const ::std::string& name, SideEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SideEnum>(
    SideEnum_descriptor(), name, value);
}
enum LocateReqdEnum {
  LOCATE_REQD_NO = 0,
  LOCATE_REQD_YES = 1
};
bool LocateReqdEnum_IsValid(int value);
const LocateReqdEnum LocateReqdEnum_MIN = LOCATE_REQD_NO;
const LocateReqdEnum LocateReqdEnum_MAX = LOCATE_REQD_YES;
const int LocateReqdEnum_ARRAYSIZE = LocateReqdEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocateReqdEnum_descriptor();
inline const ::std::string& LocateReqdEnum_Name(LocateReqdEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocateReqdEnum_descriptor(), value);
}
inline bool LocateReqdEnum_Parse(
    const ::std::string& name, LocateReqdEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocateReqdEnum>(
    LocateReqdEnum_descriptor(), name, value);
}
enum QtyTypeEnum {
  QTY_TYPE_CONTRACTS = 0,
  QTY_TYPE_UNITS = 1,
  QTY_TYPE_UNITS_OF_MEASURE_PER_TIME_UNIT = 2
};
bool QtyTypeEnum_IsValid(int value);
const QtyTypeEnum QtyTypeEnum_MIN = QTY_TYPE_CONTRACTS;
const QtyTypeEnum QtyTypeEnum_MAX = QTY_TYPE_UNITS_OF_MEASURE_PER_TIME_UNIT;
const int QtyTypeEnum_ARRAYSIZE = QtyTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* QtyTypeEnum_descriptor();
inline const ::std::string& QtyTypeEnum_Name(QtyTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    QtyTypeEnum_descriptor(), value);
}
inline bool QtyTypeEnum_Parse(
    const ::std::string& name, QtyTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<QtyTypeEnum>(
    QtyTypeEnum_descriptor(), name, value);
}
enum OrdTypeEnum {
  ORD_TYPE_LIMIT = 0,
  ORD_TYPE_LIMIT_ON_CLOSE = 1,
  ORD_TYPE_LIMIT_OR_BETTER = 2,
  ORD_TYPE_LIMIT_WITH_OR_WITHOUT = 3,
  ORD_TYPE_MARKET = 4,
  ORD_TYPE_MARKET_ON_CLOSE = 5,
  ORD_TYPE_ON_BASIS = 6,
  ORD_TYPE_ON_CLOSE = 7,
  ORD_TYPE_STOP = 8,
  ORD_TYPE_STOP_LIMIT = 9,
  ORD_TYPE_WITH_OR_WITHOUT = 10,
  ORD_TYPE_PEGGED = 11,
  ORD_TYPE_FOREX_MARKET = 12,
  ORD_TYPE_PREVIOUSLY_INDICATED = 13,
  ORD_TYPE_PREVIOUSLY_QUOTED = 14,
  ORD_TYPE_FOREX_LIMIT = 15,
  ORD_TYPE_FOREX_PREVIOUSLY_QUOTED = 16,
  ORD_TYPE_FOREX_SWAP = 17,
  ORD_TYPE_FUNARI = 18,
  ORD_TYPE_MARKET_IF_TOUCHED = 19,
  ORD_TYPE_MARKET_WITH_LEFT_OVER_AS_LIMIT = 20,
  ORD_TYPE_NEXT_FUND_VALUATION_POINT = 21,
  ORD_TYPE_PREVIOUS_FUND_VALUATION_POINT = 22,
  ORD_TYPE_COUNTER_ORDER_SELECTION = 23
};
bool OrdTypeEnum_IsValid(int value);
const OrdTypeEnum OrdTypeEnum_MIN = ORD_TYPE_LIMIT;
const OrdTypeEnum OrdTypeEnum_MAX = ORD_TYPE_COUNTER_ORDER_SELECTION;
const int OrdTypeEnum_ARRAYSIZE = OrdTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrdTypeEnum_descriptor();
inline const ::std::string& OrdTypeEnum_Name(OrdTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrdTypeEnum_descriptor(), value);
}
inline bool OrdTypeEnum_Parse(
    const ::std::string& name, OrdTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrdTypeEnum>(
    OrdTypeEnum_descriptor(), name, value);
}
enum PriceTypeEnum {
  PRICE_TYPE_FIXED_AMOUNT = 0,
  PRICE_TYPE_PER_UNIT = 1,
  PRICE_TYPE_PERCENTAGE = 2,
  PRICE_TYPE_DISCOUNT = 3,
  PRICE_TYPE_PREMIUM = 4,
  PRICE_TYPE_SPREAD = 5,
  PRICE_TYPE_TEDPRICE = 6,
  PRICE_TYPE_TEDYIELD = 7,
  PRICE_TYPE_FIXED_CABINET_TRADE_PRICE = 8,
  PRICE_TYPE_VARIABLE_CABINET_TRADE_PRICE = 9,
  PRICE_TYPE_YIELD = 10,
  PRICE_TYPE_PRODUCT_TICKS_IN_EIGHTS = 11,
  PRICE_TYPE_PRODUCT_TICKS_IN_FOURTHS = 12,
  PRICE_TYPE_PRODUCT_TICKS_IN_HALFS = 13,
  PRICE_TYPE_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTS = 14,
  PRICE_TYPE_PRODUCT_TICKS_IN_SIXTEENTHS = 15,
  PRICE_TYPE_PRODUCT_TICKS_IN_SIXTY_FORTHS = 16,
  PRICE_TYPE_PRODUCT_TICKS_IN_THIRTY_SECONDS = 17
};
bool PriceTypeEnum_IsValid(int value);
const PriceTypeEnum PriceTypeEnum_MIN = PRICE_TYPE_FIXED_AMOUNT;
const PriceTypeEnum PriceTypeEnum_MAX = PRICE_TYPE_PRODUCT_TICKS_IN_THIRTY_SECONDS;
const int PriceTypeEnum_ARRAYSIZE = PriceTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriceTypeEnum_descriptor();
inline const ::std::string& PriceTypeEnum_Name(PriceTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriceTypeEnum_descriptor(), value);
}
inline bool PriceTypeEnum_Parse(
    const ::std::string& name, PriceTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriceTypeEnum>(
    PriceTypeEnum_descriptor(), name, value);
}
enum PriceProtectionScopeEnum {
  PRICE_PROTECTION_SCOPE_GLOBAL = 0,
  PRICE_PROTECTION_SCOPE_LOCAL = 1,
  PRICE_PROTECTION_SCOPE_NATIONAL = 2,
  PRICE_PROTECTION_SCOPE_NONE = 3
};
bool PriceProtectionScopeEnum_IsValid(int value);
const PriceProtectionScopeEnum PriceProtectionScopeEnum_MIN = PRICE_PROTECTION_SCOPE_GLOBAL;
const PriceProtectionScopeEnum PriceProtectionScopeEnum_MAX = PRICE_PROTECTION_SCOPE_NONE;
const int PriceProtectionScopeEnum_ARRAYSIZE = PriceProtectionScopeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriceProtectionScopeEnum_descriptor();
inline const ::std::string& PriceProtectionScopeEnum_Name(PriceProtectionScopeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriceProtectionScopeEnum_descriptor(), value);
}
inline bool PriceProtectionScopeEnum_Parse(
    const ::std::string& name, PriceProtectionScopeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriceProtectionScopeEnum>(
    PriceProtectionScopeEnum_descriptor(), name, value);
}
enum SolicitedFlagEnum {
  SOLICITED_FLAG_WAS_NOT_SOLICITED = 0,
  SOLICITED_FLAG_WAS_SOLICITED = 1
};
bool SolicitedFlagEnum_IsValid(int value);
const SolicitedFlagEnum SolicitedFlagEnum_MIN = SOLICITED_FLAG_WAS_NOT_SOLICITED;
const SolicitedFlagEnum SolicitedFlagEnum_MAX = SOLICITED_FLAG_WAS_SOLICITED;
const int SolicitedFlagEnum_ARRAYSIZE = SolicitedFlagEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SolicitedFlagEnum_descriptor();
inline const ::std::string& SolicitedFlagEnum_Name(SolicitedFlagEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SolicitedFlagEnum_descriptor(), value);
}
inline bool SolicitedFlagEnum_Parse(
    const ::std::string& name, SolicitedFlagEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SolicitedFlagEnum>(
    SolicitedFlagEnum_descriptor(), name, value);
}
enum TimeInForceEnum {
  TIME_IN_FORCE_AT_THE_OPENING = 0,
  TIME_IN_FORCE_DAY = 1,
  TIME_IN_FORCE_FILL_OR_KILL = 2,
  TIME_IN_FORCE_GOOD_TILL_CANCEL = 3,
  TIME_IN_FORCE_GOOD_TILL_CROSSING = 4,
  TIME_IN_FORCE_IMMEDIATE_OR_CANCEL = 5,
  TIME_IN_FORCE_GOOD_TILL_DATE = 6,
  TIME_IN_FORCE_AT_THE_CLOSE = 7,
  TIME_IN_FORCE_AT_CROSSING = 8,
  TIME_IN_FORCE_GOOD_THROUGH_CROSSING = 9
};
bool TimeInForceEnum_IsValid(int value);
const TimeInForceEnum TimeInForceEnum_MIN = TIME_IN_FORCE_AT_THE_OPENING;
const TimeInForceEnum TimeInForceEnum_MAX = TIME_IN_FORCE_GOOD_THROUGH_CROSSING;
const int TimeInForceEnum_ARRAYSIZE = TimeInForceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeInForceEnum_descriptor();
inline const ::std::string& TimeInForceEnum_Name(TimeInForceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeInForceEnum_descriptor(), value);
}
inline bool TimeInForceEnum_Parse(
    const ::std::string& name, TimeInForceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeInForceEnum>(
    TimeInForceEnum_descriptor(), name, value);
}
enum GtBookingInstEnum {
  GT_BOOKING_INST_ACCUMULATE_UNTIL_FILLED_OR_EXPIRED = 0,
  GT_BOOKING_INST_ACCUMULATE_UNTIL_VERBALLLY_NOTIFIED_OTHERWISE = 1,
  GT_BOOKING_INST_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION = 2
};
bool GtBookingInstEnum_IsValid(int value);
const GtBookingInstEnum GtBookingInstEnum_MIN = GT_BOOKING_INST_ACCUMULATE_UNTIL_FILLED_OR_EXPIRED;
const GtBookingInstEnum GtBookingInstEnum_MAX = GT_BOOKING_INST_BOOK_OUT_ALL_TRADES_ON_DAY_OF_EXECUTION;
const int GtBookingInstEnum_ARRAYSIZE = GtBookingInstEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* GtBookingInstEnum_descriptor();
inline const ::std::string& GtBookingInstEnum_Name(GtBookingInstEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    GtBookingInstEnum_descriptor(), value);
}
inline bool GtBookingInstEnum_Parse(
    const ::std::string& name, GtBookingInstEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GtBookingInstEnum>(
    GtBookingInstEnum_descriptor(), name, value);
}
enum OrderCapacityEnum {
  ORDER_CAPACITY_AGENCY = 0,
  ORDER_CAPACITY_AGENT_FOR_OTHER_MEMBER = 1,
  ORDER_CAPACITY_INDIVIDUAL = 2,
  ORDER_CAPACITY_PRINCIPAL = 3,
  ORDER_CAPACITY_PROPRIETARY = 4,
  ORDER_CAPACITY_RISKLESS_PRINCIPAL = 5
};
bool OrderCapacityEnum_IsValid(int value);
const OrderCapacityEnum OrderCapacityEnum_MIN = ORDER_CAPACITY_AGENCY;
const OrderCapacityEnum OrderCapacityEnum_MAX = ORDER_CAPACITY_RISKLESS_PRINCIPAL;
const int OrderCapacityEnum_ARRAYSIZE = OrderCapacityEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderCapacityEnum_descriptor();
inline const ::std::string& OrderCapacityEnum_Name(OrderCapacityEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderCapacityEnum_descriptor(), value);
}
inline bool OrderCapacityEnum_Parse(
    const ::std::string& name, OrderCapacityEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderCapacityEnum>(
    OrderCapacityEnum_descriptor(), name, value);
}
enum OrderRestrictionsEnum {
  ORDER_RESTRICTIONS_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_SECURITY = 0,
  ORDER_RESTRICTIONS_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_UNDERLYING = 1,
  ORDER_RESTRICTIONS_COMPETING_MARKET_MAKER = 2,
  ORDER_RESTRICTIONS_EXTERNAL_INTER_CONNECTED_MARKET_LINKAGE = 3,
  ORDER_RESTRICTIONS_EXTERNAL_MARKET_PARTICIPANT = 4,
  ORDER_RESTRICTIONS_FOREIGN_ENTITY = 5,
  ORDER_RESTRICTIONS_INDEX_ARBITRAGE = 6,
  ORDER_RESTRICTIONS_NON_INDEX_ARBITRAGE = 7,
  ORDER_RESTRICTIONS_PROGRAM_TRADE = 8,
  ORDER_RESTRICTIONS_RISKLESS_ARBITRAGE = 9,
  ORDER_RESTRICTIONS_ALGORITHMIC = 10,
  ORDER_RESTRICTIONS_NON_ALGORITHMIC = 11,
  ORDER_RESTRICTIONS_ISSUE_PRICE_STABILIZATION = 12,
  ORDER_RESTRICTIONS_ISSUER_HOLDING = 13,
  ORDER_RESTRICTIONS_CROSS = 14
};
bool OrderRestrictionsEnum_IsValid(int value);
const OrderRestrictionsEnum OrderRestrictionsEnum_MIN = ORDER_RESTRICTIONS_ACTING_AS_MARKET_MAKER_OR_SPECIALIST_IN_SECURITY;
const OrderRestrictionsEnum OrderRestrictionsEnum_MAX = ORDER_RESTRICTIONS_CROSS;
const int OrderRestrictionsEnum_ARRAYSIZE = OrderRestrictionsEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderRestrictionsEnum_descriptor();
inline const ::std::string& OrderRestrictionsEnum_Name(OrderRestrictionsEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderRestrictionsEnum_descriptor(), value);
}
inline bool OrderRestrictionsEnum_Parse(
    const ::std::string& name, OrderRestrictionsEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderRestrictionsEnum>(
    OrderRestrictionsEnum_descriptor(), name, value);
}
enum CustOrderCapacityEnum {
  CUST_ORDER_CAPACITY_ALL_OTHER = 0,
  CUST_ORDER_CAPACITY_CLEARING_FIRM_TRADING_FOR_ITS_PROPRIETARY_ACCOUNT = 1,
  CUST_ORDER_CAPACITY_MEMBER_TRADING_FOR_ANOTHER_MEMBER = 2,
  CUST_ORDER_CAPACITY_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT = 3
};
bool CustOrderCapacityEnum_IsValid(int value);
const CustOrderCapacityEnum CustOrderCapacityEnum_MIN = CUST_ORDER_CAPACITY_ALL_OTHER;
const CustOrderCapacityEnum CustOrderCapacityEnum_MAX = CUST_ORDER_CAPACITY_MEMBER_TRADING_FOR_THEIR_OWN_ACCOUNT;
const int CustOrderCapacityEnum_ARRAYSIZE = CustOrderCapacityEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CustOrderCapacityEnum_descriptor();
inline const ::std::string& CustOrderCapacityEnum_Name(CustOrderCapacityEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CustOrderCapacityEnum_descriptor(), value);
}
inline bool CustOrderCapacityEnum_Parse(
    const ::std::string& name, CustOrderCapacityEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustOrderCapacityEnum>(
    CustOrderCapacityEnum_descriptor(), name, value);
}
enum ForexReqEnum {
  FOREX_REQ_DO_NOT_EXECUTE_FOREX_AFTER_SECURITY_TRADE = 0,
  FOREX_REQ_EXECUTE_FOREX_AFTER_SECURITY_TRADE = 1
};
bool ForexReqEnum_IsValid(int value);
const ForexReqEnum ForexReqEnum_MIN = FOREX_REQ_DO_NOT_EXECUTE_FOREX_AFTER_SECURITY_TRADE;
const ForexReqEnum ForexReqEnum_MAX = FOREX_REQ_EXECUTE_FOREX_AFTER_SECURITY_TRADE;
const int ForexReqEnum_ARRAYSIZE = ForexReqEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ForexReqEnum_descriptor();
inline const ::std::string& ForexReqEnum_Name(ForexReqEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ForexReqEnum_descriptor(), value);
}
inline bool ForexReqEnum_Parse(
    const ::std::string& name, ForexReqEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ForexReqEnum>(
    ForexReqEnum_descriptor(), name, value);
}
enum BookingTypeEnum {
  BOOKING_TYPE_CFD = 0,
  BOOKING_TYPE_REGULAR_BOOKING = 1,
  BOOKING_TYPE_TOTAL_RETURN_SWAP = 2
};
bool BookingTypeEnum_IsValid(int value);
const BookingTypeEnum BookingTypeEnum_MIN = BOOKING_TYPE_CFD;
const BookingTypeEnum BookingTypeEnum_MAX = BOOKING_TYPE_TOTAL_RETURN_SWAP;
const int BookingTypeEnum_ARRAYSIZE = BookingTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* BookingTypeEnum_descriptor();
inline const ::std::string& BookingTypeEnum_Name(BookingTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    BookingTypeEnum_descriptor(), value);
}
inline bool BookingTypeEnum_Parse(
    const ::std::string& name, BookingTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BookingTypeEnum>(
    BookingTypeEnum_descriptor(), name, value);
}
enum PositionEffectEnum {
  POSITION_EFFECT_CLOSE = 0,
  POSITION_EFFECT_OPEN = 1,
  POSITION_EFFECT_FIFO = 2,
  POSITION_EFFECT_ROLLED = 3,
  POSITION_EFFECT_CLOSE_BUT_NOTIFY_ON_OPEN = 4,
  POSITION_EFFECT_DEFAULT = 5
};
bool PositionEffectEnum_IsValid(int value);
const PositionEffectEnum PositionEffectEnum_MIN = POSITION_EFFECT_CLOSE;
const PositionEffectEnum PositionEffectEnum_MAX = POSITION_EFFECT_DEFAULT;
const int PositionEffectEnum_ARRAYSIZE = PositionEffectEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PositionEffectEnum_descriptor();
inline const ::std::string& PositionEffectEnum_Name(PositionEffectEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PositionEffectEnum_descriptor(), value);
}
inline bool PositionEffectEnum_Parse(
    const ::std::string& name, PositionEffectEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PositionEffectEnum>(
    PositionEffectEnum_descriptor(), name, value);
}
enum CoveredOrUncoveredEnum {
  COVERED_OR_UNCOVERED_COVERED = 0,
  COVERED_OR_UNCOVERED_UNCOVERED = 1
};
bool CoveredOrUncoveredEnum_IsValid(int value);
const CoveredOrUncoveredEnum CoveredOrUncoveredEnum_MIN = COVERED_OR_UNCOVERED_COVERED;
const CoveredOrUncoveredEnum CoveredOrUncoveredEnum_MAX = COVERED_OR_UNCOVERED_UNCOVERED;
const int CoveredOrUncoveredEnum_ARRAYSIZE = CoveredOrUncoveredEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CoveredOrUncoveredEnum_descriptor();
inline const ::std::string& CoveredOrUncoveredEnum_Name(CoveredOrUncoveredEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CoveredOrUncoveredEnum_descriptor(), value);
}
inline bool CoveredOrUncoveredEnum_Parse(
    const ::std::string& name, CoveredOrUncoveredEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CoveredOrUncoveredEnum>(
    CoveredOrUncoveredEnum_descriptor(), name, value);
}
enum TargetStrategyEnum {
  TARGET_STRATEGY_MININIZE_MARKET_IMPACT = 0,
  TARGET_STRATEGY_PARTICIPATE = 1,
  TARGET_STRATEGY_VWAP = 2
};
bool TargetStrategyEnum_IsValid(int value);
const TargetStrategyEnum TargetStrategyEnum_MIN = TARGET_STRATEGY_MININIZE_MARKET_IMPACT;
const TargetStrategyEnum TargetStrategyEnum_MAX = TARGET_STRATEGY_VWAP;
const int TargetStrategyEnum_ARRAYSIZE = TargetStrategyEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TargetStrategyEnum_descriptor();
inline const ::std::string& TargetStrategyEnum_Name(TargetStrategyEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TargetStrategyEnum_descriptor(), value);
}
inline bool TargetStrategyEnum_Parse(
    const ::std::string& name, TargetStrategyEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TargetStrategyEnum>(
    TargetStrategyEnum_descriptor(), name, value);
}
enum CancellationRightsEnum {
  CANCELLATION_RIGHTS_NO_EXECUTION_ONLY = 0,
  CANCELLATION_RIGHTS_NO_INSTITUTIONAL = 1,
  CANCELLATION_RIGHTS_NO_WAIVER_AGREEMENT = 2,
  CANCELLATION_RIGHTS_YES = 3
};
bool CancellationRightsEnum_IsValid(int value);
const CancellationRightsEnum CancellationRightsEnum_MIN = CANCELLATION_RIGHTS_NO_EXECUTION_ONLY;
const CancellationRightsEnum CancellationRightsEnum_MAX = CANCELLATION_RIGHTS_YES;
const int CancellationRightsEnum_ARRAYSIZE = CancellationRightsEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CancellationRightsEnum_descriptor();
inline const ::std::string& CancellationRightsEnum_Name(CancellationRightsEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CancellationRightsEnum_descriptor(), value);
}
inline bool CancellationRightsEnum_Parse(
    const ::std::string& name, CancellationRightsEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CancellationRightsEnum>(
    CancellationRightsEnum_descriptor(), name, value);
}
enum MoneyLaunderingStatusEnum {
  MONEY_LAUNDERING_STATUS_EXEMPT_AUTHORISED = 0,
  MONEY_LAUNDERING_STATUS_EXEMPT_BELOW_LIMIT = 1,
  MONEY_LAUNDERING_STATUS_EXEMPT_MONEY_TYPE = 2,
  MONEY_LAUNDERING_STATUS_NOT_CHECKED = 3,
  MONEY_LAUNDERING_STATUS_PASSED = 4
};
bool MoneyLaunderingStatusEnum_IsValid(int value);
const MoneyLaunderingStatusEnum MoneyLaunderingStatusEnum_MIN = MONEY_LAUNDERING_STATUS_EXEMPT_AUTHORISED;
const MoneyLaunderingStatusEnum MoneyLaunderingStatusEnum_MAX = MONEY_LAUNDERING_STATUS_PASSED;
const int MoneyLaunderingStatusEnum_ARRAYSIZE = MoneyLaunderingStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MoneyLaunderingStatusEnum_descriptor();
inline const ::std::string& MoneyLaunderingStatusEnum_Name(MoneyLaunderingStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MoneyLaunderingStatusEnum_descriptor(), value);
}
inline bool MoneyLaunderingStatusEnum_Parse(
    const ::std::string& name, MoneyLaunderingStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MoneyLaunderingStatusEnum>(
    MoneyLaunderingStatusEnum_descriptor(), name, value);
}
enum CustOrderHandlingInstEnum {
  CUST_ORDER_HANDLING_INST_ADD_ON_ORDER = 0,
  CUST_ORDER_HANDLING_INST_ALL_OR_NONE = 1,
  CUST_ORDER_HANDLING_INST_CASH_NOT_HELD = 2,
  CUST_ORDER_HANDLING_INST_DIRECTED_ORDER = 3,
  CUST_ORDER_HANDLING_INST_EXCHANGE_FOR_PHYSICAL_TRANSACTION = 4,
  CUST_ORDER_HANDLING_INST_FILL_OR_KILL = 5,
  CUST_ORDER_HANDLING_INST_IMBALANCE_ONLY = 6,
  CUST_ORDER_HANDLING_INST_IMMEDIATE_OR_CANCEL = 7,
  CUST_ORDER_HANDLING_INST_LIMIT_ON_CLOSE = 8,
  CUST_ORDER_HANDLING_INST_LIMIT_ON_OPEN = 9,
  CUST_ORDER_HANDLING_INST_MARKET_AT_CLOSE = 10,
  CUST_ORDER_HANDLING_INST_MARKET_AT_OPEN = 11,
  CUST_ORDER_HANDLING_INST_MARKET_ON_CLOSE = 12,
  CUST_ORDER_HANDLING_INST_MARKET_ON_OPEN = 13,
  CUST_ORDER_HANDLING_INST_MINIMUM_QUANTITY = 14,
  CUST_ORDER_HANDLING_INST_NOT_HELD = 15,
  CUST_ORDER_HANDLING_INST_OVER_THE_DAY = 16,
  CUST_ORDER_HANDLING_INST_PEGGED = 17,
  CUST_ORDER_HANDLING_INST_RESERVE_SIZE_ORDER = 18,
  CUST_ORDER_HANDLING_INST_SCALE = 19,
  CUST_ORDER_HANDLING_INST_STOP_STOCK_TRANSACTION = 20,
  CUST_ORDER_HANDLING_INST_TIME_ORDER = 21,
  CUST_ORDER_HANDLING_INST_TRAILING_STOP = 22,
  CUST_ORDER_HANDLING_INST_WORK = 23
};
bool CustOrderHandlingInstEnum_IsValid(int value);
const CustOrderHandlingInstEnum CustOrderHandlingInstEnum_MIN = CUST_ORDER_HANDLING_INST_ADD_ON_ORDER;
const CustOrderHandlingInstEnum CustOrderHandlingInstEnum_MAX = CUST_ORDER_HANDLING_INST_WORK;
const int CustOrderHandlingInstEnum_ARRAYSIZE = CustOrderHandlingInstEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CustOrderHandlingInstEnum_descriptor();
inline const ::std::string& CustOrderHandlingInstEnum_Name(CustOrderHandlingInstEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CustOrderHandlingInstEnum_descriptor(), value);
}
inline bool CustOrderHandlingInstEnum_Parse(
    const ::std::string& name, CustOrderHandlingInstEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CustOrderHandlingInstEnum>(
    CustOrderHandlingInstEnum_descriptor(), name, value);
}
enum OrderHandlingInstSourceEnum {
  ORDER_HANDLING_INST_SOURCE_NASDOATS = 0
};
bool OrderHandlingInstSourceEnum_IsValid(int value);
const OrderHandlingInstSourceEnum OrderHandlingInstSourceEnum_MIN = ORDER_HANDLING_INST_SOURCE_NASDOATS;
const OrderHandlingInstSourceEnum OrderHandlingInstSourceEnum_MAX = ORDER_HANDLING_INST_SOURCE_NASDOATS;
const int OrderHandlingInstSourceEnum_ARRAYSIZE = OrderHandlingInstSourceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderHandlingInstSourceEnum_descriptor();
inline const ::std::string& OrderHandlingInstSourceEnum_Name(OrderHandlingInstSourceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderHandlingInstSourceEnum_descriptor(), value);
}
inline bool OrderHandlingInstSourceEnum_Parse(
    const ::std::string& name, OrderHandlingInstSourceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderHandlingInstSourceEnum>(
    OrderHandlingInstSourceEnum_descriptor(), name, value);
}
enum RefOrderIdSourceEnum {
  REF_ORDER_ID_SOURCE_MD_ENTRY_ID = 0,
  REF_ORDER_ID_SOURCE_ORDER_ID = 1,
  REF_ORDER_ID_SOURCE_QUOTE_ENTRY_ID = 2,
  REF_ORDER_ID_SOURCE_SECONDARY_ORDER_ID = 3,
  REF_ORDER_ID_SOURCE_ORIGINAL_ORDER_ID = 4
};
bool RefOrderIdSourceEnum_IsValid(int value);
const RefOrderIdSourceEnum RefOrderIdSourceEnum_MIN = REF_ORDER_ID_SOURCE_MD_ENTRY_ID;
const RefOrderIdSourceEnum RefOrderIdSourceEnum_MAX = REF_ORDER_ID_SOURCE_ORIGINAL_ORDER_ID;
const int RefOrderIdSourceEnum_ARRAYSIZE = RefOrderIdSourceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RefOrderIdSourceEnum_descriptor();
inline const ::std::string& RefOrderIdSourceEnum_Name(RefOrderIdSourceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RefOrderIdSourceEnum_descriptor(), value);
}
inline bool RefOrderIdSourceEnum_Parse(
    const ::std::string& name, RefOrderIdSourceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RefOrderIdSourceEnum>(
    RefOrderIdSourceEnum_descriptor(), name, value);
}
enum OrdStatusEnum {
  ORD_STATUS_CANCELED = 0,
  ORD_STATUS_DONE_FOR_DAY = 1,
  ORD_STATUS_FILLED = 2,
  ORD_STATUS_NEW = 3,
  ORD_STATUS_PARTIALLY_FILLED = 4,
  ORD_STATUS_PENDING_CANCEL = 5,
  ORD_STATUS_REJECTED = 6,
  ORD_STATUS_STOPPED = 7,
  ORD_STATUS_PENDING_NEW = 8,
  ORD_STATUS_SUSPENDED = 9,
  ORD_STATUS_CALCULATED = 10,
  ORD_STATUS_EXPIRED = 11,
  ORD_STATUS_ACCEPTED_FOR_BIDDING = 12,
  ORD_STATUS_PENDING_REPLACE = 13,
  ORD_STATUS_REPLACED = 14
};
bool OrdStatusEnum_IsValid(int value);
const OrdStatusEnum OrdStatusEnum_MIN = ORD_STATUS_CANCELED;
const OrdStatusEnum OrdStatusEnum_MAX = ORD_STATUS_REPLACED;
const int OrdStatusEnum_ARRAYSIZE = OrdStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrdStatusEnum_descriptor();
inline const ::std::string& OrdStatusEnum_Name(OrdStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrdStatusEnum_descriptor(), value);
}
inline bool OrdStatusEnum_Parse(
    const ::std::string& name, OrdStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrdStatusEnum>(
    OrdStatusEnum_descriptor(), name, value);
}
enum WorkingIndicatorEnum {
  WORKING_INDICATOR_NOT_WORKING = 0,
  WORKING_INDICATOR_WORKING = 1
};
bool WorkingIndicatorEnum_IsValid(int value);
const WorkingIndicatorEnum WorkingIndicatorEnum_MIN = WORKING_INDICATOR_NOT_WORKING;
const WorkingIndicatorEnum WorkingIndicatorEnum_MAX = WORKING_INDICATOR_WORKING;
const int WorkingIndicatorEnum_ARRAYSIZE = WorkingIndicatorEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* WorkingIndicatorEnum_descriptor();
inline const ::std::string& WorkingIndicatorEnum_Name(WorkingIndicatorEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    WorkingIndicatorEnum_descriptor(), value);
}
inline bool WorkingIndicatorEnum_Parse(
    const ::std::string& name, WorkingIndicatorEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WorkingIndicatorEnum>(
    WorkingIndicatorEnum_descriptor(), name, value);
}
enum CxlRejResponseToEnum {
  CXL_REJ_RESPONSE_TO_ORDER_CANCEL = 0,
  CXL_REJ_RESPONSE_TO_ORDER_CANCEL_REQUEST = 1
};
bool CxlRejResponseToEnum_IsValid(int value);
const CxlRejResponseToEnum CxlRejResponseToEnum_MIN = CXL_REJ_RESPONSE_TO_ORDER_CANCEL;
const CxlRejResponseToEnum CxlRejResponseToEnum_MAX = CXL_REJ_RESPONSE_TO_ORDER_CANCEL_REQUEST;
const int CxlRejResponseToEnum_ARRAYSIZE = CxlRejResponseToEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CxlRejResponseToEnum_descriptor();
inline const ::std::string& CxlRejResponseToEnum_Name(CxlRejResponseToEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CxlRejResponseToEnum_descriptor(), value);
}
inline bool CxlRejResponseToEnum_Parse(
    const ::std::string& name, CxlRejResponseToEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CxlRejResponseToEnum>(
    CxlRejResponseToEnum_descriptor(), name, value);
}
enum CxlRejReasonEnum {
  CXL_REJ_REASON_TOO_LATE_TO_CANCEL = 0,
  CXL_REJ_REASON_UNKNOWN_ORDER = 1,
  CXL_REJ_REASON_BROKER_CREDIT = 2,
  CXL_REJ_REASON_ORDER_ALREADY_IN_PENDING_STATUS = 3,
  CXL_REJ_REASON_DUPLICATE_CL_ORD_ID = 4,
  CXL_REJ_REASON_ORIG_ORD_MOD_TIME = 5,
  CXL_REJ_REASON_UNABLE_TO_PROCESS_ORDER_MASS_CANCEL_REQUEST = 6,
  CXL_REJ_REASON_OTHER = 7,
  CXL_REJ_REASON_INVALID_PRICE_INCREMENT = 8,
  CXL_REJ_REASON_PRICE_EXCEEDS_CURRENT_PRICE = 9,
  CXL_REJ_REASON_PRICE_EXCEEDS_CURRENT_PRICE_BAND = 10
};
bool CxlRejReasonEnum_IsValid(int value);
const CxlRejReasonEnum CxlRejReasonEnum_MIN = CXL_REJ_REASON_TOO_LATE_TO_CANCEL;
const CxlRejReasonEnum CxlRejReasonEnum_MAX = CXL_REJ_REASON_PRICE_EXCEEDS_CURRENT_PRICE_BAND;
const int CxlRejReasonEnum_ARRAYSIZE = CxlRejReasonEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CxlRejReasonEnum_descriptor();
inline const ::std::string& CxlRejReasonEnum_Name(CxlRejReasonEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CxlRejReasonEnum_descriptor(), value);
}
inline bool CxlRejReasonEnum_Parse(
    const ::std::string& name, CxlRejReasonEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CxlRejReasonEnum>(
    CxlRejReasonEnum_descriptor(), name, value);
}
enum LastRptRequestedEnum {
  LAST_RPT_REQUESTED_LAST_MESSAGE = 0,
  LAST_RPT_REQUESTED_NOT_LAST_MESSAGE = 1
};
bool LastRptRequestedEnum_IsValid(int value);
const LastRptRequestedEnum LastRptRequestedEnum_MIN = LAST_RPT_REQUESTED_LAST_MESSAGE;
const LastRptRequestedEnum LastRptRequestedEnum_MAX = LAST_RPT_REQUESTED_NOT_LAST_MESSAGE;
const int LastRptRequestedEnum_ARRAYSIZE = LastRptRequestedEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LastRptRequestedEnum_descriptor();
inline const ::std::string& LastRptRequestedEnum_Name(LastRptRequestedEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LastRptRequestedEnum_descriptor(), value);
}
inline bool LastRptRequestedEnum_Parse(
    const ::std::string& name, LastRptRequestedEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LastRptRequestedEnum>(
    LastRptRequestedEnum_descriptor(), name, value);
}
enum CrossTypeEnum {
  CROSS_TYPE_CROSS_AON = 0,
  CROSS_TYPE_CROSS_IOC = 1,
  CROSS_TYPE_CROSS_ONE_SIDE = 2,
  CROSS_TYPE_CROSS_SAME_PRICE = 3
};
bool CrossTypeEnum_IsValid(int value);
const CrossTypeEnum CrossTypeEnum_MIN = CROSS_TYPE_CROSS_AON;
const CrossTypeEnum CrossTypeEnum_MAX = CROSS_TYPE_CROSS_SAME_PRICE;
const int CrossTypeEnum_ARRAYSIZE = CrossTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CrossTypeEnum_descriptor();
inline const ::std::string& CrossTypeEnum_Name(CrossTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CrossTypeEnum_descriptor(), value);
}
inline bool CrossTypeEnum_Parse(
    const ::std::string& name, CrossTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CrossTypeEnum>(
    CrossTypeEnum_descriptor(), name, value);
}
enum ExecTypeEnum {
  EXEC_TYPE_CALCULATED = 0,
  EXEC_TYPE_CANCELED = 1,
  EXEC_TYPE_DONE_FOR_DAY = 2,
  EXEC_TYPE_EXPIRED = 3,
  EXEC_TYPE_NEW = 4,
  EXEC_TYPE_PENDING_CANCEL = 5,
  EXEC_TYPE_PENDING_NEW = 6,
  EXEC_TYPE_REJECTED = 7,
  EXEC_TYPE_REPLACED = 8,
  EXEC_TYPE_STOPPED = 9,
  EXEC_TYPE_SUSPENDED = 10,
  EXEC_TYPE_PENDING_REPLACE = 11,
  EXEC_TYPE_RESTATED = 12,
  EXEC_TYPE_ORDER_STATUS = 13,
  EXEC_TYPE_TRADE = 14,
  EXEC_TYPE_TRADE_CANCEL = 15,
  EXEC_TYPE_TRADE_CORRECT = 16,
  EXEC_TYPE_TRADE_HAS_BEEN_RELEASED_TO_CLEARING = 17,
  EXEC_TYPE_TRADE_IN_ACLEARING_HOLD = 18,
  EXEC_TYPE_TRIGGERED_OR_ACTIVATED_BY_SYSTEM = 19
};
bool ExecTypeEnum_IsValid(int value);
const ExecTypeEnum ExecTypeEnum_MIN = EXEC_TYPE_CALCULATED;
const ExecTypeEnum ExecTypeEnum_MAX = EXEC_TYPE_TRIGGERED_OR_ACTIVATED_BY_SYSTEM;
const int ExecTypeEnum_ARRAYSIZE = ExecTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecTypeEnum_descriptor();
inline const ::std::string& ExecTypeEnum_Name(ExecTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecTypeEnum_descriptor(), value);
}
inline bool ExecTypeEnum_Parse(
    const ::std::string& name, ExecTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecTypeEnum>(
    ExecTypeEnum_descriptor(), name, value);
}
enum OrdRejReasonEnum {
  ORD_REJ_REASON_BROKER_CREDIT = 0,
  ORD_REJ_REASON_EXCHANGE_CLOSED = 1,
  ORD_REJ_REASON_ORDER_EXCEEDS_LIMIT = 2,
  ORD_REJ_REASON_UNKNOWN_SYMBOL = 3,
  ORD_REJ_REASON_TOO_LATE_TO_ENTER = 4,
  ORD_REJ_REASON_DUPLICATE_ORDER = 5,
  ORD_REJ_REASON_UNKNOWN_ORDER = 6,
  ORD_REJ_REASON_DUPLICATE_OF_AVERBALLY_COMMUNICATED_ORDER = 7,
  ORD_REJ_REASON_STALE_ORDER = 8,
  ORD_REJ_REASON_INVALID_INVESTOR_ID = 9,
  ORD_REJ_REASON_SURVEILLENCE_OPTION = 10,
  ORD_REJ_REASON_TRADE_ALONG_REQUIRED = 11,
  ORD_REJ_REASON_UNSUPPORTED_ORDER_CHARACTERISTIC = 12,
  ORD_REJ_REASON_INCORRECT_ALLOCATED_QUANTITY = 13,
  ORD_REJ_REASON_INCORRECT_QUANTITY = 14,
  ORD_REJ_REASON_OTHER = 15,
  ORD_REJ_REASON_UNKNOWN_ACCOUNT = 16,
  ORD_REJ_REASON_INVALID_PRICE_INCREMENT = 17,
  ORD_REJ_REASON_PRICE_EXCEEDS_CURRENT_PRICE_BAND = 18
};
bool OrdRejReasonEnum_IsValid(int value);
const OrdRejReasonEnum OrdRejReasonEnum_MIN = ORD_REJ_REASON_BROKER_CREDIT;
const OrdRejReasonEnum OrdRejReasonEnum_MAX = ORD_REJ_REASON_PRICE_EXCEEDS_CURRENT_PRICE_BAND;
const int OrdRejReasonEnum_ARRAYSIZE = OrdRejReasonEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrdRejReasonEnum_descriptor();
inline const ::std::string& OrdRejReasonEnum_Name(OrdRejReasonEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrdRejReasonEnum_descriptor(), value);
}
inline bool OrdRejReasonEnum_Parse(
    const ::std::string& name, OrdRejReasonEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrdRejReasonEnum>(
    OrdRejReasonEnum_descriptor(), name, value);
}
enum ExecRestatementReasonEnum {
  EXEC_RESTATEMENT_REASON_BROKER_OPTION = 0,
  EXEC_RESTATEMENT_REASON_GT_CORPORATE_ACTION = 1,
  EXEC_RESTATEMENT_REASON_GT_RENEWAL = 2,
  EXEC_RESTATEMENT_REASON_PARTIAL_DECLINE_OF_ORDER_QTY = 3,
  EXEC_RESTATEMENT_REASON_REPRICING_OF_ORDER = 4,
  EXEC_RESTATEMENT_REASON_VERBAL_CHANGE = 5,
  EXEC_RESTATEMENT_REASON_CANCEL_ON_SYSTEM_FAILURE = 6,
  EXEC_RESTATEMENT_REASON_CANCEL_ON_TRADING_HALT = 7,
  EXEC_RESTATEMENT_REASON_MARKET = 8,
  EXEC_RESTATEMENT_REASON_CANCELED = 9,
  EXEC_RESTATEMENT_REASON_OTHER = 10,
  EXEC_RESTATEMENT_REASON_WAREHOUSE_RECAP = 11,
  EXEC_RESTATEMENT_REASON_PEG_REFRESH = 12
};
bool ExecRestatementReasonEnum_IsValid(int value);
const ExecRestatementReasonEnum ExecRestatementReasonEnum_MIN = EXEC_RESTATEMENT_REASON_BROKER_OPTION;
const ExecRestatementReasonEnum ExecRestatementReasonEnum_MAX = EXEC_RESTATEMENT_REASON_PEG_REFRESH;
const int ExecRestatementReasonEnum_ARRAYSIZE = ExecRestatementReasonEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecRestatementReasonEnum_descriptor();
inline const ::std::string& ExecRestatementReasonEnum_Name(ExecRestatementReasonEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecRestatementReasonEnum_descriptor(), value);
}
inline bool ExecRestatementReasonEnum_Parse(
    const ::std::string& name, ExecRestatementReasonEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecRestatementReasonEnum>(
    ExecRestatementReasonEnum_descriptor(), name, value);
}
enum MatchTypeEnum {
  MATCH_TYPE_A1EXACT_MATCH_SUMMARIZED_QUANTITY = 0,
  MATCH_TYPE_A2EXACT_MATCH_SUMMARIZED_QUANTITY = 1,
  MATCH_TYPE_A3EXACT_MATCH_SUMMARIZED_QUANTITY = 2,
  MATCH_TYPE_A4EXACT_MATCH_SUMMARIZED_QUANTITY = 3,
  MATCH_TYPE_A5EXACT_MATCH_SUMMARIZED_QUANTITY = 4,
  MATCH_TYPE_ACTACCEPTED_TRADE = 5,
  MATCH_TYPE_ACTDEFAULT_AFTER_M2 = 6,
  MATCH_TYPE_ACTDEFAULT_TRADE = 7,
  MATCH_TYPE_ACTM6MATCH = 8,
  MATCH_TYPE_EXACT_MATCH_MINUS_BADGES_TIMES = 9,
  MATCH_TYPE_EXACT_MATCH_PLUS2BADGES = 10,
  MATCH_TYPE_EXACT_MATCH_PLUS2BADGES_EXEC_TIME = 11,
  MATCH_TYPE_EXACT_MATCH_PLUS4BADGES = 12,
  MATCH_TYPE_EXACT_MATCH_PLUS4BADGES_EXEC_TIME = 13,
  MATCH_TYPE_EXACT_MATCH_PLUS_EXEC_TIME = 14,
  MATCH_TYPE_OCSLOCKED_IN = 15,
  MATCH_TYPE_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS = 16,
  MATCH_TYPE_SUMMARIZED_MATCH_MINUS_BADGES_TIMES = 17,
  MATCH_TYPE_AUTO_MATCH = 18,
  MATCH_TYPE_CALL_AUCTION = 19,
  MATCH_TYPE_CONFIRMED_TRADE_REPORT = 20,
  MATCH_TYPE_COUNTER_ORDER_SELECTION = 21,
  MATCH_TYPE_CROSS_AUCTION = 22,
  MATCH_TYPE_ONE_PARTY_TRADE_REPORT = 23,
  MATCH_TYPE_TWO_PARTY_TRADE_REPORT = 24,
  MATCH_TYPE_ISSUING = 25
};
bool MatchTypeEnum_IsValid(int value);
const MatchTypeEnum MatchTypeEnum_MIN = MATCH_TYPE_A1EXACT_MATCH_SUMMARIZED_QUANTITY;
const MatchTypeEnum MatchTypeEnum_MAX = MATCH_TYPE_ISSUING;
const int MatchTypeEnum_ARRAYSIZE = MatchTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MatchTypeEnum_descriptor();
inline const ::std::string& MatchTypeEnum_Name(MatchTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MatchTypeEnum_descriptor(), value);
}
inline bool MatchTypeEnum_Parse(
    const ::std::string& name, MatchTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatchTypeEnum>(
    MatchTypeEnum_descriptor(), name, value);
}
enum OrderCategoryEnum {
  ORDER_CATEGORY_CROSS_ORDER = 0,
  ORDER_CATEGORY_IMPLIED_ORDER = 1,
  ORDER_CATEGORY_LINKED_ORDER = 2,
  ORDER_CATEGORY_MULTILEG_ORDER = 3,
  ORDER_CATEGORY_ORDER = 4,
  ORDER_CATEGORY_PRIVATELY_NEGOTIATED_TRADE = 5,
  ORDER_CATEGORY_QUOTE = 6,
  ORDER_CATEGORY_QUOTE_REQUEST = 7,
  ORDER_CATEGORY_STREAMING_PRICE = 8
};
bool OrderCategoryEnum_IsValid(int value);
const OrderCategoryEnum OrderCategoryEnum_MIN = ORDER_CATEGORY_CROSS_ORDER;
const OrderCategoryEnum OrderCategoryEnum_MAX = ORDER_CATEGORY_STREAMING_PRICE;
const int OrderCategoryEnum_ARRAYSIZE = OrderCategoryEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrderCategoryEnum_descriptor();
inline const ::std::string& OrderCategoryEnum_Name(OrderCategoryEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrderCategoryEnum_descriptor(), value);
}
inline bool OrderCategoryEnum_Parse(
    const ::std::string& name, OrderCategoryEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrderCategoryEnum>(
    OrderCategoryEnum_descriptor(), name, value);
}
enum LotTypeEnum {
  LOT_TYPE_BLOCK_LOT = 0,
  LOT_TYPE_ODD_LOT = 1,
  LOT_TYPE_ROUND_LOT = 2,
  LOT_TYPE_ROUND_LOT_BASED_UPON = 3
};
bool LotTypeEnum_IsValid(int value);
const LotTypeEnum LotTypeEnum_MIN = LOT_TYPE_BLOCK_LOT;
const LotTypeEnum LotTypeEnum_MAX = LOT_TYPE_ROUND_LOT_BASED_UPON;
const int LotTypeEnum_ARRAYSIZE = LotTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LotTypeEnum_descriptor();
inline const ::std::string& LotTypeEnum_Name(LotTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LotTypeEnum_descriptor(), value);
}
inline bool LotTypeEnum_Parse(
    const ::std::string& name, LotTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LotTypeEnum>(
    LotTypeEnum_descriptor(), name, value);
}
enum AggressorIndicatorEnum {
  AGGRESSOR_INDICATOR_ORDER_INITIATOR_IS_AGGRESSOR = 0,
  AGGRESSOR_INDICATOR_ORDER_INITIATOR_IS_PASSIVE = 1
};
bool AggressorIndicatorEnum_IsValid(int value);
const AggressorIndicatorEnum AggressorIndicatorEnum_MIN = AGGRESSOR_INDICATOR_ORDER_INITIATOR_IS_AGGRESSOR;
const AggressorIndicatorEnum AggressorIndicatorEnum_MAX = AGGRESSOR_INDICATOR_ORDER_INITIATOR_IS_PASSIVE;
const int AggressorIndicatorEnum_ARRAYSIZE = AggressorIndicatorEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* AggressorIndicatorEnum_descriptor();
inline const ::std::string& AggressorIndicatorEnum_Name(AggressorIndicatorEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    AggressorIndicatorEnum_descriptor(), value);
}
inline bool AggressorIndicatorEnum_Parse(
    const ::std::string& name, AggressorIndicatorEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AggressorIndicatorEnum>(
    AggressorIndicatorEnum_descriptor(), name, value);
}
enum TradingSessionIdEnum {
  TRADING_SESSION_ID_AFTER_HOURS = 0,
  TRADING_SESSION_ID_AFTERNOON = 1,
  TRADING_SESSION_ID_DAY = 2,
  TRADING_SESSION_ID_EVENING = 3,
  TRADING_SESSION_ID_HALF_DAY = 4,
  TRADING_SESSION_ID_MORNING = 5
};
bool TradingSessionIdEnum_IsValid(int value);
const TradingSessionIdEnum TradingSessionIdEnum_MIN = TRADING_SESSION_ID_AFTER_HOURS;
const TradingSessionIdEnum TradingSessionIdEnum_MAX = TRADING_SESSION_ID_MORNING;
const int TradingSessionIdEnum_ARRAYSIZE = TradingSessionIdEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradingSessionIdEnum_descriptor();
inline const ::std::string& TradingSessionIdEnum_Name(TradingSessionIdEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradingSessionIdEnum_descriptor(), value);
}
inline bool TradingSessionIdEnum_Parse(
    const ::std::string& name, TradingSessionIdEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradingSessionIdEnum>(
    TradingSessionIdEnum_descriptor(), name, value);
}
enum TradingSessionSubIdEnum {
  TRADING_SESSION_SUB_ID_CLOSING_OR_CLOSING_AUCTION = 0,
  TRADING_SESSION_SUB_ID_CONTINUOUS = 1,
  TRADING_SESSION_SUB_ID_INTRADAY_AUCTION = 2,
  TRADING_SESSION_SUB_ID_OPENING_OR_OPENING_AUCTION = 3,
  TRADING_SESSION_SUB_ID_POST_TRADING = 4,
  TRADING_SESSION_SUB_ID_PRE_TRADING = 5,
  TRADING_SESSION_SUB_ID_QUIESCENT = 6
};
bool TradingSessionSubIdEnum_IsValid(int value);
const TradingSessionSubIdEnum TradingSessionSubIdEnum_MIN = TRADING_SESSION_SUB_ID_CLOSING_OR_CLOSING_AUCTION;
const TradingSessionSubIdEnum TradingSessionSubIdEnum_MAX = TRADING_SESSION_SUB_ID_QUIESCENT;
const int TradingSessionSubIdEnum_ARRAYSIZE = TradingSessionSubIdEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradingSessionSubIdEnum_descriptor();
inline const ::std::string& TradingSessionSubIdEnum_Name(TradingSessionSubIdEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradingSessionSubIdEnum_descriptor(), value);
}
inline bool TradingSessionSubIdEnum_Parse(
    const ::std::string& name, TradingSessionSubIdEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradingSessionSubIdEnum>(
    TradingSessionSubIdEnum_descriptor(), name, value);
}
enum LastCapacityEnum {
  LAST_CAPACITY_AGENT = 0,
  LAST_CAPACITY_CROSS_AS_AGENT = 1,
  LAST_CAPACITY_CROSS_AS_PRINCIPAL = 2,
  LAST_CAPACITY_PRINCIPAL = 3
};
bool LastCapacityEnum_IsValid(int value);
const LastCapacityEnum LastCapacityEnum_MIN = LAST_CAPACITY_AGENT;
const LastCapacityEnum LastCapacityEnum_MAX = LAST_CAPACITY_PRINCIPAL;
const int LastCapacityEnum_ARRAYSIZE = LastCapacityEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LastCapacityEnum_descriptor();
inline const ::std::string& LastCapacityEnum_Name(LastCapacityEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LastCapacityEnum_descriptor(), value);
}
inline bool LastCapacityEnum_Parse(
    const ::std::string& name, LastCapacityEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LastCapacityEnum>(
    LastCapacityEnum_descriptor(), name, value);
}
enum LastFragmentEnum {
  LAST_FRAGMENT_LAST_MESSAGE = 0,
  LAST_FRAGMENT_NOT_LAST_MESSAGE = 1
};
bool LastFragmentEnum_IsValid(int value);
const LastFragmentEnum LastFragmentEnum_MIN = LAST_FRAGMENT_LAST_MESSAGE;
const LastFragmentEnum LastFragmentEnum_MAX = LAST_FRAGMENT_NOT_LAST_MESSAGE;
const int LastFragmentEnum_ARRAYSIZE = LastFragmentEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LastFragmentEnum_descriptor();
inline const ::std::string& LastFragmentEnum_Name(LastFragmentEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LastFragmentEnum_descriptor(), value);
}
inline bool LastFragmentEnum_Parse(
    const ::std::string& name, LastFragmentEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LastFragmentEnum>(
    LastFragmentEnum_descriptor(), name, value);
}
enum ReportToExchEnum {
  REPORT_TO_EXCH_RECEIVER_REPORTS = 0,
  REPORT_TO_EXCH_SENDER_REPORTS = 1
};
bool ReportToExchEnum_IsValid(int value);
const ReportToExchEnum ReportToExchEnum_MIN = REPORT_TO_EXCH_RECEIVER_REPORTS;
const ReportToExchEnum ReportToExchEnum_MAX = REPORT_TO_EXCH_SENDER_REPORTS;
const int ReportToExchEnum_ARRAYSIZE = ReportToExchEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReportToExchEnum_descriptor();
inline const ::std::string& ReportToExchEnum_Name(ReportToExchEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReportToExchEnum_descriptor(), value);
}
inline bool ReportToExchEnum_Parse(
    const ::std::string& name, ReportToExchEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReportToExchEnum>(
    ReportToExchEnum_descriptor(), name, value);
}
enum TradedFlatSwitchEnum {
  TRADED_FLAT_SWITCH_NOT_TRADED_FLAT = 0,
  TRADED_FLAT_SWITCH_TRADED_FLAT = 1
};
bool TradedFlatSwitchEnum_IsValid(int value);
const TradedFlatSwitchEnum TradedFlatSwitchEnum_MIN = TRADED_FLAT_SWITCH_NOT_TRADED_FLAT;
const TradedFlatSwitchEnum TradedFlatSwitchEnum_MAX = TRADED_FLAT_SWITCH_TRADED_FLAT;
const int TradedFlatSwitchEnum_ARRAYSIZE = TradedFlatSwitchEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradedFlatSwitchEnum_descriptor();
inline const ::std::string& TradedFlatSwitchEnum_Name(TradedFlatSwitchEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradedFlatSwitchEnum_descriptor(), value);
}
inline bool TradedFlatSwitchEnum_Parse(
    const ::std::string& name, TradedFlatSwitchEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradedFlatSwitchEnum>(
    TradedFlatSwitchEnum_descriptor(), name, value);
}
enum SettlCurrFxRateCalcEnum {
  SETTL_CURR_FX_RATE_CALC_DIVIDE = 0,
  SETTL_CURR_FX_RATE_CALC_MULTIPLY = 1
};
bool SettlCurrFxRateCalcEnum_IsValid(int value);
const SettlCurrFxRateCalcEnum SettlCurrFxRateCalcEnum_MIN = SETTL_CURR_FX_RATE_CALC_DIVIDE;
const SettlCurrFxRateCalcEnum SettlCurrFxRateCalcEnum_MAX = SETTL_CURR_FX_RATE_CALC_MULTIPLY;
const int SettlCurrFxRateCalcEnum_ARRAYSIZE = SettlCurrFxRateCalcEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SettlCurrFxRateCalcEnum_descriptor();
inline const ::std::string& SettlCurrFxRateCalcEnum_Name(SettlCurrFxRateCalcEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SettlCurrFxRateCalcEnum_descriptor(), value);
}
inline bool SettlCurrFxRateCalcEnum_Parse(
    const ::std::string& name, SettlCurrFxRateCalcEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SettlCurrFxRateCalcEnum>(
    SettlCurrFxRateCalcEnum_descriptor(), name, value);
}
enum MultiLegReportingTypeEnum {
  MULTI_LEG_REPORTING_TYPE_INDIVIDUAL_LEG_OF_AMULTI_LEG_SECURITY = 0,
  MULTI_LEG_REPORTING_TYPE_MULTI_LEG_SECURITY = 1,
  MULTI_LEG_REPORTING_TYPE_SINGLE_SECURITY = 2
};
bool MultiLegReportingTypeEnum_IsValid(int value);
const MultiLegReportingTypeEnum MultiLegReportingTypeEnum_MIN = MULTI_LEG_REPORTING_TYPE_INDIVIDUAL_LEG_OF_AMULTI_LEG_SECURITY;
const MultiLegReportingTypeEnum MultiLegReportingTypeEnum_MAX = MULTI_LEG_REPORTING_TYPE_SINGLE_SECURITY;
const int MultiLegReportingTypeEnum_ARRAYSIZE = MultiLegReportingTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MultiLegReportingTypeEnum_descriptor();
inline const ::std::string& MultiLegReportingTypeEnum_Name(MultiLegReportingTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MultiLegReportingTypeEnum_descriptor(), value);
}
inline bool MultiLegReportingTypeEnum_Parse(
    const ::std::string& name, MultiLegReportingTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultiLegReportingTypeEnum>(
    MultiLegReportingTypeEnum_descriptor(), name, value);
}
enum ExecPriceTypeEnum {
  EXEC_PRICE_TYPE_BID_PRICE = 0,
  EXEC_PRICE_TYPE_CREATION_PRICE = 1,
  EXEC_PRICE_TYPE_CREATION_PRICE_PLUS_ADJUSTMENT_AMOUNT = 2,
  EXEC_PRICE_TYPE_CREATION_PRICE_PLUS_ADJUSTMENT_PERCENT = 3,
  EXEC_PRICE_TYPE_OFFER_PRICE = 4,
  EXEC_PRICE_TYPE_OFFER_PRICE_MINUS_ADJUSTMENT_AMOUNT = 5,
  EXEC_PRICE_TYPE_OFFER_PRICE_MINUS_ADJUSTMENT_PERCENT = 6,
  EXEC_PRICE_TYPE_SINGLE_PRICE = 7
};
bool ExecPriceTypeEnum_IsValid(int value);
const ExecPriceTypeEnum ExecPriceTypeEnum_MIN = EXEC_PRICE_TYPE_BID_PRICE;
const ExecPriceTypeEnum ExecPriceTypeEnum_MAX = EXEC_PRICE_TYPE_SINGLE_PRICE;
const int ExecPriceTypeEnum_ARRAYSIZE = ExecPriceTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecPriceTypeEnum_descriptor();
inline const ::std::string& ExecPriceTypeEnum_Name(ExecPriceTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecPriceTypeEnum_descriptor(), value);
}
inline bool ExecPriceTypeEnum_Parse(
    const ::std::string& name, ExecPriceTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecPriceTypeEnum>(
    ExecPriceTypeEnum_descriptor(), name, value);
}
enum PriorityIndicatorEnum {
  PRIORITY_INDICATOR_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE = 0,
  PRIORITY_INDICATOR_PRIORITY_UNCHANGED = 1
};
bool PriorityIndicatorEnum_IsValid(int value);
const PriorityIndicatorEnum PriorityIndicatorEnum_MIN = PRIORITY_INDICATOR_LOST_PRIORITY_AS_RESULT_OF_ORDER_CHANGE;
const PriorityIndicatorEnum PriorityIndicatorEnum_MAX = PRIORITY_INDICATOR_PRIORITY_UNCHANGED;
const int PriorityIndicatorEnum_ARRAYSIZE = PriorityIndicatorEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriorityIndicatorEnum_descriptor();
inline const ::std::string& PriorityIndicatorEnum_Name(PriorityIndicatorEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriorityIndicatorEnum_descriptor(), value);
}
inline bool PriorityIndicatorEnum_Parse(
    const ::std::string& name, PriorityIndicatorEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriorityIndicatorEnum>(
    PriorityIndicatorEnum_descriptor(), name, value);
}
enum LastLiquidityIndEnum {
  LAST_LIQUIDITY_IND_ADDED_LIQUIDITY = 0,
  LAST_LIQUIDITY_IND_LIQUIDITY_ROUTED_OUT = 1,
  LAST_LIQUIDITY_IND_REMOVED_LIQUIDITY = 2,
  LAST_LIQUIDITY_IND_AUCTION = 3
};
bool LastLiquidityIndEnum_IsValid(int value);
const LastLiquidityIndEnum LastLiquidityIndEnum_MIN = LAST_LIQUIDITY_IND_ADDED_LIQUIDITY;
const LastLiquidityIndEnum LastLiquidityIndEnum_MAX = LAST_LIQUIDITY_IND_AUCTION;
const int LastLiquidityIndEnum_ARRAYSIZE = LastLiquidityIndEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LastLiquidityIndEnum_descriptor();
inline const ::std::string& LastLiquidityIndEnum_Name(LastLiquidityIndEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LastLiquidityIndEnum_descriptor(), value);
}
inline bool LastLiquidityIndEnum_Parse(
    const ::std::string& name, LastLiquidityIndEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LastLiquidityIndEnum>(
    LastLiquidityIndEnum_descriptor(), name, value);
}
enum ExecAckStatusEnum {
  EXEC_ACK_STATUS_ACCEPTED = 0,
  EXEC_ACK_STATUS_DON = 1,
  EXEC_ACK_STATUS_RECEIVED = 2
};
bool ExecAckStatusEnum_IsValid(int value);
const ExecAckStatusEnum ExecAckStatusEnum_MIN = EXEC_ACK_STATUS_ACCEPTED;
const ExecAckStatusEnum ExecAckStatusEnum_MAX = EXEC_ACK_STATUS_RECEIVED;
const int ExecAckStatusEnum_ARRAYSIZE = ExecAckStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExecAckStatusEnum_descriptor();
inline const ::std::string& ExecAckStatusEnum_Name(ExecAckStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExecAckStatusEnum_descriptor(), value);
}
inline bool ExecAckStatusEnum_Parse(
    const ::std::string& name, ExecAckStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExecAckStatusEnum>(
    ExecAckStatusEnum_descriptor(), name, value);
}
enum DKReasonEnum {
  DKREASON_NO_MATCHING_ORDER = 0,
  DKREASON_OTHER = 1,
  DKREASON_PRICE_EXCEEDS_LIMIT = 2,
  DKREASON_QUANTITY_EXCEEDS_ORDER = 3,
  DKREASON_UNKNOWN_SYMBOL = 4,
  DKREASON_WRONG_SIDE = 5,
  DKREASON_CALCULATION_DIFFERENCE = 6
};
bool DKReasonEnum_IsValid(int value);
const DKReasonEnum DKReasonEnum_MIN = DKREASON_NO_MATCHING_ORDER;
const DKReasonEnum DKReasonEnum_MAX = DKREASON_CALCULATION_DIFFERENCE;
const int DKReasonEnum_ARRAYSIZE = DKReasonEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DKReasonEnum_descriptor();
inline const ::std::string& DKReasonEnum_Name(DKReasonEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DKReasonEnum_descriptor(), value);
}
inline bool DKReasonEnum_Parse(
    const ::std::string& name, DKReasonEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DKReasonEnum>(
    DKReasonEnum_descriptor(), name, value);
}
// ===================================================================

class AcctIdSourceUnion : public ::google::protobuf::Message {
 public:
  AcctIdSourceUnion();
  virtual ~AcctIdSourceUnion();

  AcctIdSourceUnion(const AcctIdSourceUnion& from);

  inline AcctIdSourceUnion& operator=(const AcctIdSourceUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AcctIdSourceUnion& default_instance();

  void Swap(AcctIdSourceUnion* other);

  // implements Message ----------------------------------------------

  AcctIdSourceUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AcctIdSourceUnion& from);
  void MergeFrom(const AcctIdSourceUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 1;
  inline bool has_acct_id_source() const;
  inline void clear_acct_id_source();
  static const int kAcctIdSourceFieldNumber = 1;
  inline ::SingleGeneralOrderHandling::AcctIdSourceEnum acct_id_source() const;
  inline void set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value);

  // optional sfixed64 acct_id_source_sfixed64 = 2;
  inline bool has_acct_id_source_sfixed64() const;
  inline void clear_acct_id_source_sfixed64();
  static const int kAcctIdSourceSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 acct_id_source_sfixed64() const;
  inline void set_acct_id_source_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.AcctIdSourceUnion)
 private:
  inline void set_has_acct_id_source();
  inline void clear_has_acct_id_source();
  inline void set_has_acct_id_source_sfixed64();
  inline void clear_has_acct_id_source_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 acct_id_source_sfixed64_;
  int acct_id_source_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static AcctIdSourceUnion* default_instance_;
};
// -------------------------------------------------------------------

class SettlTypeUnion : public ::google::protobuf::Message {
 public:
  SettlTypeUnion();
  virtual ~SettlTypeUnion();

  SettlTypeUnion(const SettlTypeUnion& from);

  inline SettlTypeUnion& operator=(const SettlTypeUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SettlTypeUnion& default_instance();

  void Swap(SettlTypeUnion* other);

  // implements Message ----------------------------------------------

  SettlTypeUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SettlTypeUnion& from);
  void MergeFrom(const SettlTypeUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SingleGeneralOrderHandling.SettlTypeEnum settl_type = 1;
  inline bool has_settl_type() const;
  inline void clear_settl_type();
  static const int kSettlTypeFieldNumber = 1;
  inline ::SingleGeneralOrderHandling::SettlTypeEnum settl_type() const;
  inline void set_settl_type(::SingleGeneralOrderHandling::SettlTypeEnum value);

  // optional .fix.Tenor settl_type_tenor = 2;
  inline bool has_settl_type_tenor() const;
  inline void clear_settl_type_tenor();
  static const int kSettlTypeTenorFieldNumber = 2;
  inline const ::fix::Tenor& settl_type_tenor() const;
  inline ::fix::Tenor* mutable_settl_type_tenor();
  inline ::fix::Tenor* release_settl_type_tenor();
  inline void set_allocated_settl_type_tenor(::fix::Tenor* settl_type_tenor);

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.SettlTypeUnion)
 private:
  inline void set_has_settl_type();
  inline void clear_has_settl_type();
  inline void set_has_settl_type_tenor();
  inline void clear_has_settl_type_tenor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::fix::Tenor* settl_type_tenor_;
  int settl_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static SettlTypeUnion* default_instance_;
};
// -------------------------------------------------------------------

class TargetStrategyUnion : public ::google::protobuf::Message {
 public:
  TargetStrategyUnion();
  virtual ~TargetStrategyUnion();

  TargetStrategyUnion(const TargetStrategyUnion& from);

  inline TargetStrategyUnion& operator=(const TargetStrategyUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TargetStrategyUnion& default_instance();

  void Swap(TargetStrategyUnion* other);

  // implements Message ----------------------------------------------

  TargetStrategyUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TargetStrategyUnion& from);
  void MergeFrom(const TargetStrategyUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SingleGeneralOrderHandling.TargetStrategyEnum target_strategy = 1;
  inline bool has_target_strategy() const;
  inline void clear_target_strategy();
  static const int kTargetStrategyFieldNumber = 1;
  inline ::SingleGeneralOrderHandling::TargetStrategyEnum target_strategy() const;
  inline void set_target_strategy(::SingleGeneralOrderHandling::TargetStrategyEnum value);

  // optional sfixed64 target_strategy_sfixed64 = 2;
  inline bool has_target_strategy_sfixed64() const;
  inline void clear_target_strategy_sfixed64();
  static const int kTargetStrategySfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 target_strategy_sfixed64() const;
  inline void set_target_strategy_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.TargetStrategyUnion)
 private:
  inline void set_has_target_strategy();
  inline void clear_has_target_strategy();
  inline void set_has_target_strategy_sfixed64();
  inline void clear_has_target_strategy_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 target_strategy_sfixed64_;
  int target_strategy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static TargetStrategyUnion* default_instance_;
};
// -------------------------------------------------------------------

class NewOrderSingle : public ::google::protobuf::Message {
 public:
  NewOrderSingle();
  virtual ~NewOrderSingle();

  NewOrderSingle(const NewOrderSingle& from);

  inline NewOrderSingle& operator=(const NewOrderSingle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewOrderSingle& default_instance();

  void Swap(NewOrderSingle* other);

  // implements Message ----------------------------------------------

  NewOrderSingle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewOrderSingle& from);
  void MergeFrom(const NewOrderSingle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string cl_ord_id = 2;
  inline bool has_cl_ord_id() const;
  inline void clear_cl_ord_id();
  static const int kClOrdIdFieldNumber = 2;
  inline const ::std::string& cl_ord_id() const;
  inline void set_cl_ord_id(const ::std::string& value);
  inline void set_cl_ord_id(const char* value);
  inline void set_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_id();
  inline ::std::string* release_cl_ord_id();
  inline void set_allocated_cl_ord_id(::std::string* cl_ord_id);

  // optional string currency = 3;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 3;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional string ex_destination = 4;
  inline bool has_ex_destination() const;
  inline void clear_ex_destination();
  static const int kExDestinationFieldNumber = 4;
  inline const ::std::string& ex_destination() const;
  inline void set_ex_destination(const ::std::string& value);
  inline void set_ex_destination(const char* value);
  inline void set_ex_destination(const char* value, size_t size);
  inline ::std::string* mutable_ex_destination();
  inline ::std::string* release_ex_destination();
  inline void set_allocated_ex_destination(::std::string* ex_destination);

  // repeated .SingleGeneralOrderHandling.ExecInstEnum exec_inst = 5 [packed = true];
  inline int exec_inst_size() const;
  inline void clear_exec_inst();
  static const int kExecInstFieldNumber = 5;
  inline ::SingleGeneralOrderHandling::ExecInstEnum exec_inst(int index) const;
  inline void set_exec_inst(int index, ::SingleGeneralOrderHandling::ExecInstEnum value);
  inline void add_exec_inst(::SingleGeneralOrderHandling::ExecInstEnum value);
  inline const ::google::protobuf::RepeatedField<int>& exec_inst() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_exec_inst();

  // optional .SingleGeneralOrderHandling.HandlInstEnum handl_inst = 6;
  inline bool has_handl_inst() const;
  inline void clear_handl_inst();
  static const int kHandlInstFieldNumber = 6;
  inline ::SingleGeneralOrderHandling::HandlInstEnum handl_inst() const;
  inline void set_handl_inst(::SingleGeneralOrderHandling::HandlInstEnum value);

  // optional string ioi_id = 7;
  inline bool has_ioi_id() const;
  inline void clear_ioi_id();
  static const int kIoiIdFieldNumber = 7;
  inline const ::std::string& ioi_id() const;
  inline void set_ioi_id(const ::std::string& value);
  inline void set_ioi_id(const char* value);
  inline void set_ioi_id(const char* value, size_t size);
  inline ::std::string* mutable_ioi_id();
  inline ::std::string* release_ioi_id();
  inline void set_allocated_ioi_id(::std::string* ioi_id);

  // optional sfixed64 max_floor = 8;
  inline bool has_max_floor() const;
  inline void clear_max_floor();
  static const int kMaxFloorFieldNumber = 8;
  inline ::google::protobuf::int64 max_floor() const;
  inline void set_max_floor(::google::protobuf::int64 value);

  // optional sfixed32 max_floor_exponent = 9;
  inline bool has_max_floor_exponent() const;
  inline void clear_max_floor_exponent();
  static const int kMaxFloorExponentFieldNumber = 9;
  inline ::google::protobuf::int32 max_floor_exponent() const;
  inline void set_max_floor_exponent(::google::protobuf::int32 value);

  // optional sfixed64 min_qty = 10;
  inline bool has_min_qty() const;
  inline void clear_min_qty();
  static const int kMinQtyFieldNumber = 10;
  inline ::google::protobuf::int64 min_qty() const;
  inline void set_min_qty(::google::protobuf::int64 value);

  // optional sfixed32 min_qty_exponent = 11;
  inline bool has_min_qty_exponent() const;
  inline void clear_min_qty_exponent();
  static const int kMinQtyExponentFieldNumber = 11;
  inline ::google::protobuf::int32 min_qty_exponent() const;
  inline void set_min_qty_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.OrdTypeEnum ord_type = 12;
  inline bool has_ord_type() const;
  inline void clear_ord_type();
  static const int kOrdTypeFieldNumber = 12;
  inline ::SingleGeneralOrderHandling::OrdTypeEnum ord_type() const;
  inline void set_ord_type(::SingleGeneralOrderHandling::OrdTypeEnum value);

  // optional sfixed64 price = 13;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 13;
  inline ::google::protobuf::int64 price() const;
  inline void set_price(::google::protobuf::int64 value);

  // optional sfixed32 price_exponent = 14;
  inline bool has_price_exponent() const;
  inline void clear_price_exponent();
  static const int kPriceExponentFieldNumber = 14;
  inline ::google::protobuf::int32 price_exponent() const;
  inline void set_price_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.ProcessCodeEnum process_code = 15;
  inline bool has_process_code() const;
  inline void clear_process_code();
  static const int kProcessCodeFieldNumber = 15;
  inline ::SingleGeneralOrderHandling::ProcessCodeEnum process_code() const;
  inline void set_process_code(::SingleGeneralOrderHandling::ProcessCodeEnum value);

  // optional sfixed32 settl_date = 16;
  inline bool has_settl_date() const;
  inline void clear_settl_date();
  static const int kSettlDateFieldNumber = 16;
  inline ::google::protobuf::int32 settl_date() const;
  inline void set_settl_date(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.SettlTypeEnum settl_type = 17;
  inline bool has_settl_type() const;
  inline void clear_settl_type();
  static const int kSettlTypeFieldNumber = 17;
  inline ::SingleGeneralOrderHandling::SettlTypeEnum settl_type() const;
  inline void set_settl_type(::SingleGeneralOrderHandling::SettlTypeEnum value);

  // optional .SingleGeneralOrderHandling.SideEnum side = 18;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 18;
  inline ::SingleGeneralOrderHandling::SideEnum side() const;
  inline void set_side(::SingleGeneralOrderHandling::SideEnum value);

  // optional .Session.StandardHeader standard_header = 19;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 19;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 20;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 20;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional sfixed64 stop_px = 21;
  inline bool has_stop_px() const;
  inline void clear_stop_px();
  static const int kStopPxFieldNumber = 21;
  inline ::google::protobuf::int64 stop_px() const;
  inline void set_stop_px(::google::protobuf::int64 value);

  // optional sfixed32 stop_px_exponent = 22;
  inline bool has_stop_px_exponent() const;
  inline void clear_stop_px_exponent();
  static const int kStopPxExponentFieldNumber = 22;
  inline ::google::protobuf::int32 stop_px_exponent() const;
  inline void set_stop_px_exponent(::google::protobuf::int32 value);

  // optional string text = 23;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 23;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .SingleGeneralOrderHandling.TimeInForceEnum time_in_force = 24;
  inline bool has_time_in_force() const;
  inline void clear_time_in_force();
  static const int kTimeInForceFieldNumber = 24;
  inline ::SingleGeneralOrderHandling::TimeInForceEnum time_in_force() const;
  inline void set_time_in_force(::SingleGeneralOrderHandling::TimeInForceEnum value);

  // optional sfixed64 expire_time = 25;
  inline bool has_expire_time() const;
  inline void clear_expire_time();
  static const int kExpireTimeFieldNumber = 25;
  inline ::google::protobuf::int64 expire_time() const;
  inline void set_expire_time(::google::protobuf::int64 value);

  // optional bool forex_req = 26;
  inline bool has_forex_req() const;
  inline void clear_forex_req();
  static const int kForexReqFieldNumber = 26;
  inline bool forex_req() const;
  inline void set_forex_req(bool value);

  // optional bool locate_reqd = 27;
  inline bool has_locate_reqd() const;
  inline void clear_locate_reqd();
  static const int kLocateReqdFieldNumber = 27;
  inline bool locate_reqd() const;
  inline void set_locate_reqd(bool value);

  // optional sfixed64 prev_close_px = 28;
  inline bool has_prev_close_px() const;
  inline void clear_prev_close_px();
  static const int kPrevClosePxFieldNumber = 28;
  inline ::google::protobuf::int64 prev_close_px() const;
  inline void set_prev_close_px(::google::protobuf::int64 value);

  // optional sfixed32 prev_close_px_exponent = 29;
  inline bool has_prev_close_px_exponent() const;
  inline void clear_prev_close_px_exponent();
  static const int kPrevClosePxExponentFieldNumber = 29;
  inline ::google::protobuf::int32 prev_close_px_exponent() const;
  inline void set_prev_close_px_exponent(::google::protobuf::int32 value);

  // optional string quote_id = 30;
  inline bool has_quote_id() const;
  inline void clear_quote_id();
  static const int kQuoteIdFieldNumber = 30;
  inline const ::std::string& quote_id() const;
  inline void set_quote_id(const ::std::string& value);
  inline void set_quote_id(const char* value);
  inline void set_quote_id(const char* value, size_t size);
  inline ::std::string* mutable_quote_id();
  inline ::std::string* release_quote_id();
  inline void set_allocated_quote_id(::std::string* quote_id);

  // optional string settl_currency = 31;
  inline bool has_settl_currency() const;
  inline void clear_settl_currency();
  static const int kSettlCurrencyFieldNumber = 31;
  inline const ::std::string& settl_currency() const;
  inline void set_settl_currency(const ::std::string& value);
  inline void set_settl_currency(const char* value);
  inline void set_settl_currency(const char* value, size_t size);
  inline ::std::string* mutable_settl_currency();
  inline ::std::string* release_settl_currency();
  inline void set_allocated_settl_currency(::std::string* settl_currency);

  // optional .SingleGeneralOrderHandling.CoveredOrUncoveredEnum covered_or_uncovered = 32;
  inline bool has_covered_or_uncovered() const;
  inline void clear_covered_or_uncovered();
  static const int kCoveredOrUncoveredFieldNumber = 32;
  inline ::SingleGeneralOrderHandling::CoveredOrUncoveredEnum covered_or_uncovered() const;
  inline void set_covered_or_uncovered(::SingleGeneralOrderHandling::CoveredOrUncoveredEnum value);

  // optional sfixed64 max_show = 33;
  inline bool has_max_show() const;
  inline void clear_max_show();
  static const int kMaxShowFieldNumber = 33;
  inline ::google::protobuf::int64 max_show() const;
  inline void set_max_show(::google::protobuf::int64 value);

  // optional sfixed32 max_show_exponent = 34;
  inline bool has_max_show_exponent() const;
  inline void clear_max_show_exponent();
  static const int kMaxShowExponentFieldNumber = 34;
  inline ::google::protobuf::int32 max_show_exponent() const;
  inline void set_max_show_exponent(::google::protobuf::int32 value);

  // optional sfixed64 order_qty2 = 35;
  inline bool has_order_qty2() const;
  inline void clear_order_qty2();
  static const int kOrderQty2FieldNumber = 35;
  inline ::google::protobuf::int64 order_qty2() const;
  inline void set_order_qty2(::google::protobuf::int64 value);

  // optional sfixed32 order_qty2_exponent = 36;
  inline bool has_order_qty2_exponent() const;
  inline void clear_order_qty2_exponent();
  static const int kOrderQty2ExponentFieldNumber = 36;
  inline ::google::protobuf::int32 order_qty2_exponent() const;
  inline void set_order_qty2_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.PositionEffectEnum position_effect = 37;
  inline bool has_position_effect() const;
  inline void clear_position_effect();
  static const int kPositionEffectFieldNumber = 37;
  inline ::SingleGeneralOrderHandling::PositionEffectEnum position_effect() const;
  inline void set_position_effect(::SingleGeneralOrderHandling::PositionEffectEnum value);

  // optional sfixed32 settl_date2 = 38;
  inline bool has_settl_date2() const;
  inline void clear_settl_date2();
  static const int kSettlDate2FieldNumber = 38;
  inline ::google::protobuf::int32 settl_date2() const;
  inline void set_settl_date2(::google::protobuf::int32 value);

  // optional string compliance_id = 39;
  inline bool has_compliance_id() const;
  inline void clear_compliance_id();
  static const int kComplianceIdFieldNumber = 39;
  inline const ::std::string& compliance_id() const;
  inline void set_compliance_id(const ::std::string& value);
  inline void set_compliance_id(const char* value);
  inline void set_compliance_id(const char* value, size_t size);
  inline ::std::string* mutable_compliance_id();
  inline ::std::string* release_compliance_id();
  inline void set_allocated_compliance_id(::std::string* compliance_id);

  // optional sfixed64 effective_time = 40;
  inline bool has_effective_time() const;
  inline void clear_effective_time();
  static const int kEffectiveTimeFieldNumber = 40;
  inline ::google::protobuf::int64 effective_time() const;
  inline void set_effective_time(::google::protobuf::int64 value);

  // optional bytes encoded_text = 41;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 41;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 42;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 42;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional sfixed32 expire_date = 43;
  inline bool has_expire_date() const;
  inline void clear_expire_date();
  static const int kExpireDateFieldNumber = 43;
  inline ::google::protobuf::int32 expire_date() const;
  inline void set_expire_date(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.GtBookingInstEnum gt_booking_inst = 44;
  inline bool has_gt_booking_inst() const;
  inline void clear_gt_booking_inst();
  static const int kGtBookingInstFieldNumber = 44;
  inline ::SingleGeneralOrderHandling::GtBookingInstEnum gt_booking_inst() const;
  inline void set_gt_booking_inst(::SingleGeneralOrderHandling::GtBookingInstEnum value);

  // optional bool solicited_flag = 45;
  inline bool has_solicited_flag() const;
  inline void clear_solicited_flag();
  static const int kSolicitedFlagFieldNumber = 45;
  inline bool solicited_flag() const;
  inline void set_solicited_flag(bool value);

  // optional sfixed64 transact_time = 46;
  inline bool has_transact_time() const;
  inline void clear_transact_time();
  static const int kTransactTimeFieldNumber = 46;
  inline ::google::protobuf::int64 transact_time() const;
  inline void set_transact_time(::google::protobuf::int64 value);

  // optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 47;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 47;
  inline ::SingleGeneralOrderHandling::AccountTypeEnum account_type() const;
  inline void set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value);

  // optional .SingleGeneralOrderHandling.BookingUnitEnum booking_unit = 48;
  inline bool has_booking_unit() const;
  inline void clear_booking_unit();
  static const int kBookingUnitFieldNumber = 48;
  inline ::SingleGeneralOrderHandling::BookingUnitEnum booking_unit() const;
  inline void set_booking_unit(::SingleGeneralOrderHandling::BookingUnitEnum value);

  // optional .SingleGeneralOrderHandling.CancellationRightsEnum cancellation_rights = 49;
  inline bool has_cancellation_rights() const;
  inline void clear_cancellation_rights();
  static const int kCancellationRightsFieldNumber = 49;
  inline ::SingleGeneralOrderHandling::CancellationRightsEnum cancellation_rights() const;
  inline void set_cancellation_rights(::SingleGeneralOrderHandling::CancellationRightsEnum value);

  // optional .SingleGeneralOrderHandling.CashMarginEnum cash_margin = 50;
  inline bool has_cash_margin() const;
  inline void clear_cash_margin();
  static const int kCashMarginFieldNumber = 50;
  inline ::SingleGeneralOrderHandling::CashMarginEnum cash_margin() const;
  inline void set_cash_margin(::SingleGeneralOrderHandling::CashMarginEnum value);

  // optional string cl_ord_link_id = 51;
  inline bool has_cl_ord_link_id() const;
  inline void clear_cl_ord_link_id();
  static const int kClOrdLinkIdFieldNumber = 51;
  inline const ::std::string& cl_ord_link_id() const;
  inline void set_cl_ord_link_id(const ::std::string& value);
  inline void set_cl_ord_link_id(const char* value);
  inline void set_cl_ord_link_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_link_id();
  inline ::std::string* release_cl_ord_link_id();
  inline void set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id);

  // optional .SingleGeneralOrderHandling.ClearingFeeIndicatorEnum clearing_fee_indicator = 52;
  inline bool has_clearing_fee_indicator() const;
  inline void clear_clearing_fee_indicator();
  static const int kClearingFeeIndicatorFieldNumber = 52;
  inline ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum clearing_fee_indicator() const;
  inline void set_clearing_fee_indicator(::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum value);

  // optional .Common.CommissionData commission_data = 53;
  inline bool has_commission_data() const;
  inline void clear_commission_data();
  static const int kCommissionDataFieldNumber = 53;
  inline const ::Common::CommissionData& commission_data() const;
  inline ::Common::CommissionData* mutable_commission_data();
  inline ::Common::CommissionData* release_commission_data();
  inline void set_allocated_commission_data(::Common::CommissionData* commission_data);

  // optional .SingleGeneralOrderHandling.CustOrderCapacityEnum cust_order_capacity = 54;
  inline bool has_cust_order_capacity() const;
  inline void clear_cust_order_capacity();
  static const int kCustOrderCapacityFieldNumber = 54;
  inline ::SingleGeneralOrderHandling::CustOrderCapacityEnum cust_order_capacity() const;
  inline void set_cust_order_capacity(::SingleGeneralOrderHandling::CustOrderCapacityEnum value);

  // optional .SingleGeneralOrderHandling.DayBookingInstEnum day_booking_inst = 55;
  inline bool has_day_booking_inst() const;
  inline void clear_day_booking_inst();
  static const int kDayBookingInstFieldNumber = 55;
  inline ::SingleGeneralOrderHandling::DayBookingInstEnum day_booking_inst() const;
  inline void set_day_booking_inst(::SingleGeneralOrderHandling::DayBookingInstEnum value);

  // optional string designation = 56;
  inline bool has_designation() const;
  inline void clear_designation();
  static const int kDesignationFieldNumber = 56;
  inline const ::std::string& designation() const;
  inline void set_designation(const ::std::string& value);
  inline void set_designation(const char* value);
  inline void set_designation(const char* value, size_t size);
  inline ::std::string* mutable_designation();
  inline ::std::string* release_designation();
  inline void set_allocated_designation(::std::string* designation);

  // optional .Common.Instrument instrument = 57;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 57;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional .SingleGeneralOrderHandling.MoneyLaunderingStatusEnum money_laundering_status = 58;
  inline bool has_money_laundering_status() const;
  inline void clear_money_laundering_status();
  static const int kMoneyLaunderingStatusFieldNumber = 58;
  inline ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum money_laundering_status() const;
  inline void set_money_laundering_status(::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum value);

  // optional .SingleGeneralOrderHandling.OrderCapacityEnum order_capacity = 59;
  inline bool has_order_capacity() const;
  inline void clear_order_capacity();
  static const int kOrderCapacityFieldNumber = 59;
  inline ::SingleGeneralOrderHandling::OrderCapacityEnum order_capacity() const;
  inline void set_order_capacity(::SingleGeneralOrderHandling::OrderCapacityEnum value);

  // optional .Common.OrderQtyData order_qty_data = 60;
  inline bool has_order_qty_data() const;
  inline void clear_order_qty_data();
  static const int kOrderQtyDataFieldNumber = 60;
  inline const ::Common::OrderQtyData& order_qty_data() const;
  inline ::Common::OrderQtyData* mutable_order_qty_data();
  inline ::Common::OrderQtyData* release_order_qty_data();
  inline void set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data);

  // repeated .SingleGeneralOrderHandling.OrderRestrictionsEnum order_restrictions = 61 [packed = true];
  inline int order_restrictions_size() const;
  inline void clear_order_restrictions();
  static const int kOrderRestrictionsFieldNumber = 61;
  inline ::SingleGeneralOrderHandling::OrderRestrictionsEnum order_restrictions(int index) const;
  inline void set_order_restrictions(int index, ::SingleGeneralOrderHandling::OrderRestrictionsEnum value);
  inline void add_order_restrictions(::SingleGeneralOrderHandling::OrderRestrictionsEnum value);
  inline const ::google::protobuf::RepeatedField<int>& order_restrictions() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_order_restrictions();

  // repeated .Common.Parties parties = 62;
  inline int parties_size() const;
  inline void clear_parties();
  static const int kPartiesFieldNumber = 62;
  inline const ::Common::Parties& parties(int index) const;
  inline ::Common::Parties* mutable_parties(int index);
  inline ::Common::Parties* add_parties();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
      parties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
      mutable_parties();

  // optional .SingleGeneralOrderHandling.PreallocMethodEnum prealloc_method = 63;
  inline bool has_prealloc_method() const;
  inline void clear_prealloc_method();
  static const int kPreallocMethodFieldNumber = 63;
  inline ::SingleGeneralOrderHandling::PreallocMethodEnum prealloc_method() const;
  inline void set_prealloc_method(::SingleGeneralOrderHandling::PreallocMethodEnum value);

  // optional sfixed64 price2 = 64;
  inline bool has_price2() const;
  inline void clear_price2();
  static const int kPrice2FieldNumber = 64;
  inline ::google::protobuf::int64 price2() const;
  inline void set_price2(::google::protobuf::int64 value);

  // optional sfixed32 price2_exponent = 65;
  inline bool has_price2_exponent() const;
  inline void clear_price2_exponent();
  static const int kPrice2ExponentFieldNumber = 65;
  inline ::google::protobuf::int32 price2_exponent() const;
  inline void set_price2_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.PriceTypeEnum price_type = 66;
  inline bool has_price_type() const;
  inline void clear_price_type();
  static const int kPriceTypeFieldNumber = 66;
  inline ::SingleGeneralOrderHandling::PriceTypeEnum price_type() const;
  inline void set_price_type(::SingleGeneralOrderHandling::PriceTypeEnum value);

  // optional string regist_id = 67;
  inline bool has_regist_id() const;
  inline void clear_regist_id();
  static const int kRegistIdFieldNumber = 67;
  inline const ::std::string& regist_id() const;
  inline void set_regist_id(const ::std::string& value);
  inline void set_regist_id(const char* value);
  inline void set_regist_id(const char* value, size_t size);
  inline ::std::string* mutable_regist_id();
  inline ::std::string* release_regist_id();
  inline void set_allocated_regist_id(::std::string* regist_id);

  // optional string secondary_cl_ord_id = 68;
  inline bool has_secondary_cl_ord_id() const;
  inline void clear_secondary_cl_ord_id();
  static const int kSecondaryClOrdIdFieldNumber = 68;
  inline const ::std::string& secondary_cl_ord_id() const;
  inline void set_secondary_cl_ord_id(const ::std::string& value);
  inline void set_secondary_cl_ord_id(const char* value);
  inline void set_secondary_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_cl_ord_id();
  inline ::std::string* release_secondary_cl_ord_id();
  inline void set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id);

  // optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 69;
  inline bool has_spread_or_benchmark_curve_data() const;
  inline void clear_spread_or_benchmark_curve_data();
  static const int kSpreadOrBenchmarkCurveDataFieldNumber = 69;
  inline const ::Common::SpreadOrBenchmarkCurveData& spread_or_benchmark_curve_data() const;
  inline ::Common::SpreadOrBenchmarkCurveData* mutable_spread_or_benchmark_curve_data();
  inline ::Common::SpreadOrBenchmarkCurveData* release_spread_or_benchmark_curve_data();
  inline void set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data);

  // repeated .Common.Stipulations stipulations = 70;
  inline int stipulations_size() const;
  inline void clear_stipulations();
  static const int kStipulationsFieldNumber = 70;
  inline const ::Common::Stipulations& stipulations(int index) const;
  inline ::Common::Stipulations* mutable_stipulations(int index);
  inline ::Common::Stipulations* add_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
      stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
      mutable_stipulations();

  // optional sfixed32 trade_origination_date = 71;
  inline bool has_trade_origination_date() const;
  inline void clear_trade_origination_date();
  static const int kTradeOriginationDateFieldNumber = 71;
  inline ::google::protobuf::int32 trade_origination_date() const;
  inline void set_trade_origination_date(::google::protobuf::int32 value);

  // optional .Common.YieldData yield_data = 72;
  inline bool has_yield_data() const;
  inline void clear_yield_data();
  static const int kYieldDataFieldNumber = 72;
  inline const ::Common::YieldData& yield_data() const;
  inline ::Common::YieldData* mutable_yield_data();
  inline ::Common::YieldData* release_yield_data();
  inline void set_allocated_yield_data(::Common::YieldData* yield_data);

  // optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 73;
  inline bool has_acct_id_source() const;
  inline void clear_acct_id_source();
  static const int kAcctIdSourceFieldNumber = 73;
  inline ::SingleGeneralOrderHandling::AcctIdSourceEnum acct_id_source() const;
  inline void set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value);

  // optional string alloc_id = 74;
  inline bool has_alloc_id() const;
  inline void clear_alloc_id();
  static const int kAllocIdFieldNumber = 74;
  inline const ::std::string& alloc_id() const;
  inline void set_alloc_id(const ::std::string& value);
  inline void set_alloc_id(const char* value);
  inline void set_alloc_id(const char* value, size_t size);
  inline ::std::string* mutable_alloc_id();
  inline ::std::string* release_alloc_id();
  inline void set_allocated_alloc_id(::std::string* alloc_id);

  // optional .SingleGeneralOrderHandling.BookingTypeEnum booking_type = 75;
  inline bool has_booking_type() const;
  inline void clear_booking_type();
  static const int kBookingTypeFieldNumber = 75;
  inline ::SingleGeneralOrderHandling::BookingTypeEnum booking_type() const;
  inline void set_booking_type(::SingleGeneralOrderHandling::BookingTypeEnum value);

  // optional bool cust_directed_order = 76;
  inline bool has_cust_directed_order() const;
  inline void clear_cust_directed_order();
  static const int kCustDirectedOrderFieldNumber = 76;
  inline bool cust_directed_order() const;
  inline void set_cust_directed_order(bool value);

  // optional .SingleGeneralOrderHandling.CustOrderHandlingInstEnum cust_order_handling_inst = 77;
  inline bool has_cust_order_handling_inst() const;
  inline void clear_cust_order_handling_inst();
  static const int kCustOrderHandlingInstFieldNumber = 77;
  inline ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum cust_order_handling_inst() const;
  inline void set_cust_order_handling_inst(::SingleGeneralOrderHandling::CustOrderHandlingInstEnum value);

  // optional .Common.DiscretionInstructions discretion_instructions = 78;
  inline bool has_discretion_instructions() const;
  inline void clear_discretion_instructions();
  static const int kDiscretionInstructionsFieldNumber = 78;
  inline const ::Common::DiscretionInstructions& discretion_instructions() const;
  inline ::Common::DiscretionInstructions* mutable_discretion_instructions();
  inline ::Common::DiscretionInstructions* release_discretion_instructions();
  inline void set_allocated_discretion_instructions(::Common::DiscretionInstructions* discretion_instructions);

  // optional .Common.DisplayInstruction display_instruction = 79;
  inline bool has_display_instruction() const;
  inline void clear_display_instruction();
  static const int kDisplayInstructionFieldNumber = 79;
  inline const ::Common::DisplayInstruction& display_instruction() const;
  inline ::Common::DisplayInstruction* mutable_display_instruction();
  inline ::Common::DisplayInstruction* release_display_instruction();
  inline void set_allocated_display_instruction(::Common::DisplayInstruction* display_instruction);

  // optional .SingleGeneralOrderHandling.ExDestinationIdSourceEnum ex_destination_id_source = 80;
  inline bool has_ex_destination_id_source() const;
  inline void clear_ex_destination_id_source();
  static const int kExDestinationIdSourceFieldNumber = 80;
  inline ::SingleGeneralOrderHandling::ExDestinationIdSourceEnum ex_destination_id_source() const;
  inline void set_ex_destination_id_source(::SingleGeneralOrderHandling::ExDestinationIdSourceEnum value);

  // optional .Common.FinancingDetails financing_details = 81;
  inline bool has_financing_details() const;
  inline void clear_financing_details();
  static const int kFinancingDetailsFieldNumber = 81;
  inline const ::Common::FinancingDetails& financing_details() const;
  inline ::Common::FinancingDetails* mutable_financing_details();
  inline ::Common::FinancingDetails* release_financing_details();
  inline void set_allocated_financing_details(::Common::FinancingDetails* financing_details);

  // optional bool manual_order_indicator = 82;
  inline bool has_manual_order_indicator() const;
  inline void clear_manual_order_indicator();
  static const int kManualOrderIndicatorFieldNumber = 82;
  inline bool manual_order_indicator() const;
  inline void set_manual_order_indicator(bool value);

  // optional sfixed64 match_increment = 83;
  inline bool has_match_increment() const;
  inline void clear_match_increment();
  static const int kMatchIncrementFieldNumber = 83;
  inline ::google::protobuf::int64 match_increment() const;
  inline void set_match_increment(::google::protobuf::int64 value);

  // optional sfixed32 match_increment_exponent = 84;
  inline bool has_match_increment_exponent() const;
  inline void clear_match_increment_exponent();
  static const int kMatchIncrementExponentFieldNumber = 84;
  inline ::google::protobuf::int32 match_increment_exponent() const;
  inline void set_match_increment_exponent(::google::protobuf::int32 value);

  // optional sfixed64 max_price_levels = 85;
  inline bool has_max_price_levels() const;
  inline void clear_max_price_levels();
  static const int kMaxPriceLevelsFieldNumber = 85;
  inline ::google::protobuf::int64 max_price_levels() const;
  inline void set_max_price_levels(::google::protobuf::int64 value);

  // optional .SingleGeneralOrderHandling.OrderHandlingInstSourceEnum order_handling_inst_source = 86;
  inline bool has_order_handling_inst_source() const;
  inline void clear_order_handling_inst_source();
  static const int kOrderHandlingInstSourceFieldNumber = 86;
  inline ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum order_handling_inst_source() const;
  inline void set_order_handling_inst_source(::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum value);

  // optional sfixed64 participation_rate = 87;
  inline bool has_participation_rate() const;
  inline void clear_participation_rate();
  static const int kParticipationRateFieldNumber = 87;
  inline ::google::protobuf::int64 participation_rate() const;
  inline void set_participation_rate(::google::protobuf::int64 value);

  // optional sfixed32 participation_rate_exponent = 88;
  inline bool has_participation_rate_exponent() const;
  inline void clear_participation_rate_exponent();
  static const int kParticipationRateExponentFieldNumber = 88;
  inline ::google::protobuf::int32 participation_rate_exponent() const;
  inline void set_participation_rate_exponent(::google::protobuf::int32 value);

  // optional .Common.PegInstructions peg_instructions = 89;
  inline bool has_peg_instructions() const;
  inline void clear_peg_instructions();
  static const int kPegInstructionsFieldNumber = 89;
  inline const ::Common::PegInstructions& peg_instructions() const;
  inline ::Common::PegInstructions* mutable_peg_instructions();
  inline ::Common::PegInstructions* release_peg_instructions();
  inline void set_allocated_peg_instructions(::Common::PegInstructions* peg_instructions);

  // repeated .Common.PreAllocGrp pre_alloc_grp = 90;
  inline int pre_alloc_grp_size() const;
  inline void clear_pre_alloc_grp();
  static const int kPreAllocGrpFieldNumber = 90;
  inline const ::Common::PreAllocGrp& pre_alloc_grp(int index) const;
  inline ::Common::PreAllocGrp* mutable_pre_alloc_grp(int index);
  inline ::Common::PreAllocGrp* add_pre_alloc_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >&
      pre_alloc_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >*
      mutable_pre_alloc_grp();

  // optional bool pre_trade_anonymity = 91;
  inline bool has_pre_trade_anonymity() const;
  inline void clear_pre_trade_anonymity();
  static const int kPreTradeAnonymityFieldNumber = 91;
  inline bool pre_trade_anonymity() const;
  inline void set_pre_trade_anonymity(bool value);

  // optional .SingleGeneralOrderHandling.PriceProtectionScopeEnum price_protection_scope = 92;
  inline bool has_price_protection_scope() const;
  inline void clear_price_protection_scope();
  static const int kPriceProtectionScopeFieldNumber = 92;
  inline ::SingleGeneralOrderHandling::PriceProtectionScopeEnum price_protection_scope() const;
  inline void set_price_protection_scope(::SingleGeneralOrderHandling::PriceProtectionScopeEnum value);

  // optional .SingleGeneralOrderHandling.QtyTypeEnum qty_type = 93;
  inline bool has_qty_type() const;
  inline void clear_qty_type();
  static const int kQtyTypeFieldNumber = 93;
  inline ::SingleGeneralOrderHandling::QtyTypeEnum qty_type() const;
  inline void set_qty_type(::SingleGeneralOrderHandling::QtyTypeEnum value);

  // optional string received_dept_id = 94;
  inline bool has_received_dept_id() const;
  inline void clear_received_dept_id();
  static const int kReceivedDeptIdFieldNumber = 94;
  inline const ::std::string& received_dept_id() const;
  inline void set_received_dept_id(const ::std::string& value);
  inline void set_received_dept_id(const char* value);
  inline void set_received_dept_id(const char* value, size_t size);
  inline ::std::string* mutable_received_dept_id();
  inline ::std::string* release_received_dept_id();
  inline void set_allocated_received_dept_id(::std::string* received_dept_id);

  // optional string ref_order_id = 95;
  inline bool has_ref_order_id() const;
  inline void clear_ref_order_id();
  static const int kRefOrderIdFieldNumber = 95;
  inline const ::std::string& ref_order_id() const;
  inline void set_ref_order_id(const ::std::string& value);
  inline void set_ref_order_id(const char* value);
  inline void set_ref_order_id(const char* value, size_t size);
  inline ::std::string* mutable_ref_order_id();
  inline ::std::string* release_ref_order_id();
  inline void set_allocated_ref_order_id(::std::string* ref_order_id);

  // optional .SingleGeneralOrderHandling.RefOrderIdSourceEnum ref_order_id_source = 96;
  inline bool has_ref_order_id_source() const;
  inline void clear_ref_order_id_source();
  static const int kRefOrderIdSourceFieldNumber = 96;
  inline ::SingleGeneralOrderHandling::RefOrderIdSourceEnum ref_order_id_source() const;
  inline void set_ref_order_id_source(::SingleGeneralOrderHandling::RefOrderIdSourceEnum value);

  // repeated .Common.StrategyParametersGrp strategy_parameters_grp = 97;
  inline int strategy_parameters_grp_size() const;
  inline void clear_strategy_parameters_grp();
  static const int kStrategyParametersGrpFieldNumber = 97;
  inline const ::Common::StrategyParametersGrp& strategy_parameters_grp(int index) const;
  inline ::Common::StrategyParametersGrp* mutable_strategy_parameters_grp(int index);
  inline ::Common::StrategyParametersGrp* add_strategy_parameters_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >&
      strategy_parameters_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >*
      mutable_strategy_parameters_grp();

  // optional .SingleGeneralOrderHandling.TargetStrategyEnum target_strategy = 98;
  inline bool has_target_strategy() const;
  inline void clear_target_strategy();
  static const int kTargetStrategyFieldNumber = 98;
  inline ::SingleGeneralOrderHandling::TargetStrategyEnum target_strategy() const;
  inline void set_target_strategy(::SingleGeneralOrderHandling::TargetStrategyEnum value);

  // optional string target_strategy_parameters = 99;
  inline bool has_target_strategy_parameters() const;
  inline void clear_target_strategy_parameters();
  static const int kTargetStrategyParametersFieldNumber = 99;
  inline const ::std::string& target_strategy_parameters() const;
  inline void set_target_strategy_parameters(const ::std::string& value);
  inline void set_target_strategy_parameters(const char* value);
  inline void set_target_strategy_parameters(const char* value, size_t size);
  inline ::std::string* mutable_target_strategy_parameters();
  inline ::std::string* release_target_strategy_parameters();
  inline void set_allocated_target_strategy_parameters(::std::string* target_strategy_parameters);

  // optional sfixed32 trade_date = 100;
  inline bool has_trade_date() const;
  inline void clear_trade_date();
  static const int kTradeDateFieldNumber = 100;
  inline ::google::protobuf::int32 trade_date() const;
  inline void set_trade_date(::google::protobuf::int32 value);

  // repeated .Common.TrdRegTimestamps trd_reg_timestamps = 101;
  inline int trd_reg_timestamps_size() const;
  inline void clear_trd_reg_timestamps();
  static const int kTrdRegTimestampsFieldNumber = 101;
  inline const ::Common::TrdRegTimestamps& trd_reg_timestamps(int index) const;
  inline ::Common::TrdRegTimestamps* mutable_trd_reg_timestamps(int index);
  inline ::Common::TrdRegTimestamps* add_trd_reg_timestamps();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >&
      trd_reg_timestamps() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >*
      mutable_trd_reg_timestamps();

  // repeated .Common.TrdgSesGrp trdg_ses_grp = 102;
  inline int trdg_ses_grp_size() const;
  inline void clear_trdg_ses_grp();
  static const int kTrdgSesGrpFieldNumber = 102;
  inline const ::Common::TrdgSesGrp& trdg_ses_grp(int index) const;
  inline ::Common::TrdgSesGrp* mutable_trdg_ses_grp(int index);
  inline ::Common::TrdgSesGrp* add_trdg_ses_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp >&
      trdg_ses_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp >*
      mutable_trdg_ses_grp();

  // optional .Common.TriggeringInstruction triggering_instruction = 103;
  inline bool has_triggering_instruction() const;
  inline void clear_triggering_instruction();
  static const int kTriggeringInstructionFieldNumber = 103;
  inline const ::Common::TriggeringInstruction& triggering_instruction() const;
  inline ::Common::TriggeringInstruction* mutable_triggering_instruction();
  inline ::Common::TriggeringInstruction* release_triggering_instruction();
  inline void set_allocated_triggering_instruction(::Common::TriggeringInstruction* triggering_instruction);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 104;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 104;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.NewOrderSingle)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_cl_ord_id();
  inline void clear_has_cl_ord_id();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_ex_destination();
  inline void clear_has_ex_destination();
  inline void set_has_handl_inst();
  inline void clear_has_handl_inst();
  inline void set_has_ioi_id();
  inline void clear_has_ioi_id();
  inline void set_has_max_floor();
  inline void clear_has_max_floor();
  inline void set_has_max_floor_exponent();
  inline void clear_has_max_floor_exponent();
  inline void set_has_min_qty();
  inline void clear_has_min_qty();
  inline void set_has_min_qty_exponent();
  inline void clear_has_min_qty_exponent();
  inline void set_has_ord_type();
  inline void clear_has_ord_type();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_price_exponent();
  inline void clear_has_price_exponent();
  inline void set_has_process_code();
  inline void clear_has_process_code();
  inline void set_has_settl_date();
  inline void clear_has_settl_date();
  inline void set_has_settl_type();
  inline void clear_has_settl_type();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_stop_px();
  inline void clear_has_stop_px();
  inline void set_has_stop_px_exponent();
  inline void clear_has_stop_px_exponent();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_time_in_force();
  inline void clear_has_time_in_force();
  inline void set_has_expire_time();
  inline void clear_has_expire_time();
  inline void set_has_forex_req();
  inline void clear_has_forex_req();
  inline void set_has_locate_reqd();
  inline void clear_has_locate_reqd();
  inline void set_has_prev_close_px();
  inline void clear_has_prev_close_px();
  inline void set_has_prev_close_px_exponent();
  inline void clear_has_prev_close_px_exponent();
  inline void set_has_quote_id();
  inline void clear_has_quote_id();
  inline void set_has_settl_currency();
  inline void clear_has_settl_currency();
  inline void set_has_covered_or_uncovered();
  inline void clear_has_covered_or_uncovered();
  inline void set_has_max_show();
  inline void clear_has_max_show();
  inline void set_has_max_show_exponent();
  inline void clear_has_max_show_exponent();
  inline void set_has_order_qty2();
  inline void clear_has_order_qty2();
  inline void set_has_order_qty2_exponent();
  inline void clear_has_order_qty2_exponent();
  inline void set_has_position_effect();
  inline void clear_has_position_effect();
  inline void set_has_settl_date2();
  inline void clear_has_settl_date2();
  inline void set_has_compliance_id();
  inline void clear_has_compliance_id();
  inline void set_has_effective_time();
  inline void clear_has_effective_time();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_expire_date();
  inline void clear_has_expire_date();
  inline void set_has_gt_booking_inst();
  inline void clear_has_gt_booking_inst();
  inline void set_has_solicited_flag();
  inline void clear_has_solicited_flag();
  inline void set_has_transact_time();
  inline void clear_has_transact_time();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_booking_unit();
  inline void clear_has_booking_unit();
  inline void set_has_cancellation_rights();
  inline void clear_has_cancellation_rights();
  inline void set_has_cash_margin();
  inline void clear_has_cash_margin();
  inline void set_has_cl_ord_link_id();
  inline void clear_has_cl_ord_link_id();
  inline void set_has_clearing_fee_indicator();
  inline void clear_has_clearing_fee_indicator();
  inline void set_has_commission_data();
  inline void clear_has_commission_data();
  inline void set_has_cust_order_capacity();
  inline void clear_has_cust_order_capacity();
  inline void set_has_day_booking_inst();
  inline void clear_has_day_booking_inst();
  inline void set_has_designation();
  inline void clear_has_designation();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_money_laundering_status();
  inline void clear_has_money_laundering_status();
  inline void set_has_order_capacity();
  inline void clear_has_order_capacity();
  inline void set_has_order_qty_data();
  inline void clear_has_order_qty_data();
  inline void set_has_prealloc_method();
  inline void clear_has_prealloc_method();
  inline void set_has_price2();
  inline void clear_has_price2();
  inline void set_has_price2_exponent();
  inline void clear_has_price2_exponent();
  inline void set_has_price_type();
  inline void clear_has_price_type();
  inline void set_has_regist_id();
  inline void clear_has_regist_id();
  inline void set_has_secondary_cl_ord_id();
  inline void clear_has_secondary_cl_ord_id();
  inline void set_has_spread_or_benchmark_curve_data();
  inline void clear_has_spread_or_benchmark_curve_data();
  inline void set_has_trade_origination_date();
  inline void clear_has_trade_origination_date();
  inline void set_has_yield_data();
  inline void clear_has_yield_data();
  inline void set_has_acct_id_source();
  inline void clear_has_acct_id_source();
  inline void set_has_alloc_id();
  inline void clear_has_alloc_id();
  inline void set_has_booking_type();
  inline void clear_has_booking_type();
  inline void set_has_cust_directed_order();
  inline void clear_has_cust_directed_order();
  inline void set_has_cust_order_handling_inst();
  inline void clear_has_cust_order_handling_inst();
  inline void set_has_discretion_instructions();
  inline void clear_has_discretion_instructions();
  inline void set_has_display_instruction();
  inline void clear_has_display_instruction();
  inline void set_has_ex_destination_id_source();
  inline void clear_has_ex_destination_id_source();
  inline void set_has_financing_details();
  inline void clear_has_financing_details();
  inline void set_has_manual_order_indicator();
  inline void clear_has_manual_order_indicator();
  inline void set_has_match_increment();
  inline void clear_has_match_increment();
  inline void set_has_match_increment_exponent();
  inline void clear_has_match_increment_exponent();
  inline void set_has_max_price_levels();
  inline void clear_has_max_price_levels();
  inline void set_has_order_handling_inst_source();
  inline void clear_has_order_handling_inst_source();
  inline void set_has_participation_rate();
  inline void clear_has_participation_rate();
  inline void set_has_participation_rate_exponent();
  inline void clear_has_participation_rate_exponent();
  inline void set_has_peg_instructions();
  inline void clear_has_peg_instructions();
  inline void set_has_pre_trade_anonymity();
  inline void clear_has_pre_trade_anonymity();
  inline void set_has_price_protection_scope();
  inline void clear_has_price_protection_scope();
  inline void set_has_qty_type();
  inline void clear_has_qty_type();
  inline void set_has_received_dept_id();
  inline void clear_has_received_dept_id();
  inline void set_has_ref_order_id();
  inline void clear_has_ref_order_id();
  inline void set_has_ref_order_id_source();
  inline void clear_has_ref_order_id_source();
  inline void set_has_target_strategy();
  inline void clear_has_target_strategy();
  inline void set_has_target_strategy_parameters();
  inline void clear_has_target_strategy_parameters();
  inline void set_has_trade_date();
  inline void clear_has_trade_date();
  inline void set_has_triggering_instruction();
  inline void clear_has_triggering_instruction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* cl_ord_id_;
  ::std::string* currency_;
  ::std::string* ex_destination_;
  ::google::protobuf::RepeatedField<int> exec_inst_;
  mutable int _exec_inst_cached_byte_size_;
  ::std::string* ioi_id_;
  int handl_inst_;
  ::google::protobuf::int32 max_floor_exponent_;
  ::google::protobuf::int64 max_floor_;
  ::google::protobuf::int64 min_qty_;
  ::google::protobuf::int32 min_qty_exponent_;
  int ord_type_;
  ::google::protobuf::int64 price_;
  ::google::protobuf::int32 price_exponent_;
  int process_code_;
  ::google::protobuf::int32 settl_date_;
  int settl_type_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  int side_;
  ::google::protobuf::int32 stop_px_exponent_;
  ::google::protobuf::int64 stop_px_;
  ::std::string* text_;
  ::google::protobuf::int64 expire_time_;
  int time_in_force_;
  ::google::protobuf::int32 prev_close_px_exponent_;
  ::google::protobuf::int64 prev_close_px_;
  ::std::string* quote_id_;
  ::std::string* settl_currency_;
  int covered_or_uncovered_;
  ::google::protobuf::int32 max_show_exponent_;
  ::google::protobuf::int64 max_show_;
  ::google::protobuf::int64 order_qty2_;
  ::google::protobuf::int32 order_qty2_exponent_;
  int position_effect_;
  ::std::string* compliance_id_;
  ::google::protobuf::int64 effective_time_;
  ::google::protobuf::int32 settl_date2_;
  ::google::protobuf::uint32 encoded_text_len_;
  ::std::string* encoded_text_;
  ::google::protobuf::int32 expire_date_;
  bool forex_req_;
  bool locate_reqd_;
  bool solicited_flag_;
  bool cust_directed_order_;
  int gt_booking_inst_;
  int account_type_;
  ::google::protobuf::int64 transact_time_;
  int booking_unit_;
  int cancellation_rights_;
  int cash_margin_;
  int clearing_fee_indicator_;
  ::std::string* cl_ord_link_id_;
  ::Common::CommissionData* commission_data_;
  int cust_order_capacity_;
  int day_booking_inst_;
  ::std::string* designation_;
  ::Common::Instrument* instrument_;
  int money_laundering_status_;
  int order_capacity_;
  ::Common::OrderQtyData* order_qty_data_;
  ::google::protobuf::RepeatedField<int> order_restrictions_;
  mutable int _order_restrictions_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::Common::Parties > parties_;
  int prealloc_method_;
  ::google::protobuf::int32 price2_exponent_;
  ::google::protobuf::int64 price2_;
  ::std::string* regist_id_;
  ::std::string* secondary_cl_ord_id_;
  int price_type_;
  ::google::protobuf::int32 trade_origination_date_;
  ::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data_;
  ::google::protobuf::RepeatedPtrField< ::Common::Stipulations > stipulations_;
  ::Common::YieldData* yield_data_;
  int acct_id_source_;
  int booking_type_;
  ::std::string* alloc_id_;
  ::Common::DiscretionInstructions* discretion_instructions_;
  int cust_order_handling_inst_;
  int ex_destination_id_source_;
  ::Common::DisplayInstruction* display_instruction_;
  ::Common::FinancingDetails* financing_details_;
  ::google::protobuf::int64 match_increment_;
  ::google::protobuf::int32 match_increment_exponent_;
  int order_handling_inst_source_;
  ::google::protobuf::int64 max_price_levels_;
  bool manual_order_indicator_;
  bool pre_trade_anonymity_;
  ::google::protobuf::int32 participation_rate_exponent_;
  ::google::protobuf::int64 participation_rate_;
  ::Common::PegInstructions* peg_instructions_;
  ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp > pre_alloc_grp_;
  int price_protection_scope_;
  int qty_type_;
  ::std::string* received_dept_id_;
  ::std::string* ref_order_id_;
  int ref_order_id_source_;
  int target_strategy_;
  ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp > strategy_parameters_grp_;
  ::std::string* target_strategy_parameters_;
  ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps > trd_reg_timestamps_;
  ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp > trdg_ses_grp_;
  ::Common::TriggeringInstruction* triggering_instruction_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;
  ::google::protobuf::int32 trade_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(104 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static NewOrderSingle* default_instance_;
};
// -------------------------------------------------------------------

class OrderCancelReplaceRequest : public ::google::protobuf::Message {
 public:
  OrderCancelReplaceRequest();
  virtual ~OrderCancelReplaceRequest();

  OrderCancelReplaceRequest(const OrderCancelReplaceRequest& from);

  inline OrderCancelReplaceRequest& operator=(const OrderCancelReplaceRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderCancelReplaceRequest& default_instance();

  void Swap(OrderCancelReplaceRequest* other);

  // implements Message ----------------------------------------------

  OrderCancelReplaceRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderCancelReplaceRequest& from);
  void MergeFrom(const OrderCancelReplaceRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string cl_ord_id = 2;
  inline bool has_cl_ord_id() const;
  inline void clear_cl_ord_id();
  static const int kClOrdIdFieldNumber = 2;
  inline const ::std::string& cl_ord_id() const;
  inline void set_cl_ord_id(const ::std::string& value);
  inline void set_cl_ord_id(const char* value);
  inline void set_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_id();
  inline ::std::string* release_cl_ord_id();
  inline void set_allocated_cl_ord_id(::std::string* cl_ord_id);

  // optional string currency = 3;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 3;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // repeated .SingleGeneralOrderHandling.ExecInstEnum exec_inst = 4 [packed = true];
  inline int exec_inst_size() const;
  inline void clear_exec_inst();
  static const int kExecInstFieldNumber = 4;
  inline ::SingleGeneralOrderHandling::ExecInstEnum exec_inst(int index) const;
  inline void set_exec_inst(int index, ::SingleGeneralOrderHandling::ExecInstEnum value);
  inline void add_exec_inst(::SingleGeneralOrderHandling::ExecInstEnum value);
  inline const ::google::protobuf::RepeatedField<int>& exec_inst() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_exec_inst();

  // optional .SingleGeneralOrderHandling.HandlInstEnum handl_inst = 5;
  inline bool has_handl_inst() const;
  inline void clear_handl_inst();
  static const int kHandlInstFieldNumber = 5;
  inline ::SingleGeneralOrderHandling::HandlInstEnum handl_inst() const;
  inline void set_handl_inst(::SingleGeneralOrderHandling::HandlInstEnum value);

  // optional string list_id = 6;
  inline bool has_list_id() const;
  inline void clear_list_id();
  static const int kListIdFieldNumber = 6;
  inline const ::std::string& list_id() const;
  inline void set_list_id(const ::std::string& value);
  inline void set_list_id(const char* value);
  inline void set_list_id(const char* value, size_t size);
  inline ::std::string* mutable_list_id();
  inline ::std::string* release_list_id();
  inline void set_allocated_list_id(::std::string* list_id);

  // optional .SingleGeneralOrderHandling.OrdTypeEnum ord_type = 7;
  inline bool has_ord_type() const;
  inline void clear_ord_type();
  static const int kOrdTypeFieldNumber = 7;
  inline ::SingleGeneralOrderHandling::OrdTypeEnum ord_type() const;
  inline void set_ord_type(::SingleGeneralOrderHandling::OrdTypeEnum value);

  // optional string order_id = 8;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 8;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional string orig_cl_ord_id = 9;
  inline bool has_orig_cl_ord_id() const;
  inline void clear_orig_cl_ord_id();
  static const int kOrigClOrdIdFieldNumber = 9;
  inline const ::std::string& orig_cl_ord_id() const;
  inline void set_orig_cl_ord_id(const ::std::string& value);
  inline void set_orig_cl_ord_id(const char* value);
  inline void set_orig_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_orig_cl_ord_id();
  inline ::std::string* release_orig_cl_ord_id();
  inline void set_allocated_orig_cl_ord_id(::std::string* orig_cl_ord_id);

  // optional sfixed64 price = 10;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 10;
  inline ::google::protobuf::int64 price() const;
  inline void set_price(::google::protobuf::int64 value);

  // optional sfixed32 price_exponent = 11;
  inline bool has_price_exponent() const;
  inline void clear_price_exponent();
  static const int kPriceExponentFieldNumber = 11;
  inline ::google::protobuf::int32 price_exponent() const;
  inline void set_price_exponent(::google::protobuf::int32 value);

  // optional sfixed32 settl_date = 12;
  inline bool has_settl_date() const;
  inline void clear_settl_date();
  static const int kSettlDateFieldNumber = 12;
  inline ::google::protobuf::int32 settl_date() const;
  inline void set_settl_date(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.SettlTypeEnum settl_type = 13;
  inline bool has_settl_type() const;
  inline void clear_settl_type();
  static const int kSettlTypeFieldNumber = 13;
  inline ::SingleGeneralOrderHandling::SettlTypeEnum settl_type() const;
  inline void set_settl_type(::SingleGeneralOrderHandling::SettlTypeEnum value);

  // optional .SingleGeneralOrderHandling.SideEnum side = 14;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 14;
  inline ::SingleGeneralOrderHandling::SideEnum side() const;
  inline void set_side(::SingleGeneralOrderHandling::SideEnum value);

  // optional .Session.StandardHeader standard_header = 15;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 15;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 16;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 16;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional sfixed64 stop_px = 17;
  inline bool has_stop_px() const;
  inline void clear_stop_px();
  static const int kStopPxFieldNumber = 17;
  inline ::google::protobuf::int64 stop_px() const;
  inline void set_stop_px(::google::protobuf::int64 value);

  // optional sfixed32 stop_px_exponent = 18;
  inline bool has_stop_px_exponent() const;
  inline void clear_stop_px_exponent();
  static const int kStopPxExponentFieldNumber = 18;
  inline ::google::protobuf::int32 stop_px_exponent() const;
  inline void set_stop_px_exponent(::google::protobuf::int32 value);

  // optional string text = 19;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 19;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .SingleGeneralOrderHandling.TimeInForceEnum time_in_force = 20;
  inline bool has_time_in_force() const;
  inline void clear_time_in_force();
  static const int kTimeInForceFieldNumber = 20;
  inline ::SingleGeneralOrderHandling::TimeInForceEnum time_in_force() const;
  inline void set_time_in_force(::SingleGeneralOrderHandling::TimeInForceEnum value);

  // optional string ex_destination = 21;
  inline bool has_ex_destination() const;
  inline void clear_ex_destination();
  static const int kExDestinationFieldNumber = 21;
  inline const ::std::string& ex_destination() const;
  inline void set_ex_destination(const ::std::string& value);
  inline void set_ex_destination(const char* value);
  inline void set_ex_destination(const char* value, size_t size);
  inline ::std::string* mutable_ex_destination();
  inline ::std::string* release_ex_destination();
  inline void set_allocated_ex_destination(::std::string* ex_destination);

  // optional sfixed64 max_floor = 22;
  inline bool has_max_floor() const;
  inline void clear_max_floor();
  static const int kMaxFloorFieldNumber = 22;
  inline ::google::protobuf::int64 max_floor() const;
  inline void set_max_floor(::google::protobuf::int64 value);

  // optional sfixed32 max_floor_exponent = 23;
  inline bool has_max_floor_exponent() const;
  inline void clear_max_floor_exponent();
  static const int kMaxFloorExponentFieldNumber = 23;
  inline ::google::protobuf::int32 max_floor_exponent() const;
  inline void set_max_floor_exponent(::google::protobuf::int32 value);

  // optional sfixed64 min_qty = 24;
  inline bool has_min_qty() const;
  inline void clear_min_qty();
  static const int kMinQtyFieldNumber = 24;
  inline ::google::protobuf::int64 min_qty() const;
  inline void set_min_qty(::google::protobuf::int64 value);

  // optional sfixed32 min_qty_exponent = 25;
  inline bool has_min_qty_exponent() const;
  inline void clear_min_qty_exponent();
  static const int kMinQtyExponentFieldNumber = 25;
  inline ::google::protobuf::int32 min_qty_exponent() const;
  inline void set_min_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 expire_time = 26;
  inline bool has_expire_time() const;
  inline void clear_expire_time();
  static const int kExpireTimeFieldNumber = 26;
  inline ::google::protobuf::int64 expire_time() const;
  inline void set_expire_time(::google::protobuf::int64 value);

  // optional bool forex_req = 27;
  inline bool has_forex_req() const;
  inline void clear_forex_req();
  static const int kForexReqFieldNumber = 27;
  inline bool forex_req() const;
  inline void set_forex_req(bool value);

  // optional string settl_currency = 28;
  inline bool has_settl_currency() const;
  inline void clear_settl_currency();
  static const int kSettlCurrencyFieldNumber = 28;
  inline const ::std::string& settl_currency() const;
  inline void set_settl_currency(const ::std::string& value);
  inline void set_settl_currency(const char* value);
  inline void set_settl_currency(const char* value, size_t size);
  inline ::std::string* mutable_settl_currency();
  inline ::std::string* release_settl_currency();
  inline void set_allocated_settl_currency(::std::string* settl_currency);

  // optional .SingleGeneralOrderHandling.CoveredOrUncoveredEnum covered_or_uncovered = 29;
  inline bool has_covered_or_uncovered() const;
  inline void clear_covered_or_uncovered();
  static const int kCoveredOrUncoveredFieldNumber = 29;
  inline ::SingleGeneralOrderHandling::CoveredOrUncoveredEnum covered_or_uncovered() const;
  inline void set_covered_or_uncovered(::SingleGeneralOrderHandling::CoveredOrUncoveredEnum value);

  // optional bool locate_reqd = 30;
  inline bool has_locate_reqd() const;
  inline void clear_locate_reqd();
  static const int kLocateReqdFieldNumber = 30;
  inline bool locate_reqd() const;
  inline void set_locate_reqd(bool value);

  // optional sfixed64 max_show = 31;
  inline bool has_max_show() const;
  inline void clear_max_show();
  static const int kMaxShowFieldNumber = 31;
  inline ::google::protobuf::int64 max_show() const;
  inline void set_max_show(::google::protobuf::int64 value);

  // optional sfixed32 max_show_exponent = 32;
  inline bool has_max_show_exponent() const;
  inline void clear_max_show_exponent();
  static const int kMaxShowExponentFieldNumber = 32;
  inline ::google::protobuf::int32 max_show_exponent() const;
  inline void set_max_show_exponent(::google::protobuf::int32 value);

  // optional sfixed64 order_qty2 = 33;
  inline bool has_order_qty2() const;
  inline void clear_order_qty2();
  static const int kOrderQty2FieldNumber = 33;
  inline ::google::protobuf::int64 order_qty2() const;
  inline void set_order_qty2(::google::protobuf::int64 value);

  // optional sfixed32 order_qty2_exponent = 34;
  inline bool has_order_qty2_exponent() const;
  inline void clear_order_qty2_exponent();
  static const int kOrderQty2ExponentFieldNumber = 34;
  inline ::google::protobuf::int32 order_qty2_exponent() const;
  inline void set_order_qty2_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.PositionEffectEnum position_effect = 35;
  inline bool has_position_effect() const;
  inline void clear_position_effect();
  static const int kPositionEffectFieldNumber = 35;
  inline ::SingleGeneralOrderHandling::PositionEffectEnum position_effect() const;
  inline void set_position_effect(::SingleGeneralOrderHandling::PositionEffectEnum value);

  // optional sfixed32 settl_date2 = 36;
  inline bool has_settl_date2() const;
  inline void clear_settl_date2();
  static const int kSettlDate2FieldNumber = 36;
  inline ::google::protobuf::int32 settl_date2() const;
  inline void set_settl_date2(::google::protobuf::int32 value);

  // optional string compliance_id = 37;
  inline bool has_compliance_id() const;
  inline void clear_compliance_id();
  static const int kComplianceIdFieldNumber = 37;
  inline const ::std::string& compliance_id() const;
  inline void set_compliance_id(const ::std::string& value);
  inline void set_compliance_id(const char* value);
  inline void set_compliance_id(const char* value, size_t size);
  inline ::std::string* mutable_compliance_id();
  inline ::std::string* release_compliance_id();
  inline void set_allocated_compliance_id(::std::string* compliance_id);

  // optional sfixed64 effective_time = 38;
  inline bool has_effective_time() const;
  inline void clear_effective_time();
  static const int kEffectiveTimeFieldNumber = 38;
  inline ::google::protobuf::int64 effective_time() const;
  inline void set_effective_time(::google::protobuf::int64 value);

  // optional bytes encoded_text = 39;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 39;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 40;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 40;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional sfixed32 expire_date = 41;
  inline bool has_expire_date() const;
  inline void clear_expire_date();
  static const int kExpireDateFieldNumber = 41;
  inline ::google::protobuf::int32 expire_date() const;
  inline void set_expire_date(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.GtBookingInstEnum gt_booking_inst = 42;
  inline bool has_gt_booking_inst() const;
  inline void clear_gt_booking_inst();
  static const int kGtBookingInstFieldNumber = 42;
  inline ::SingleGeneralOrderHandling::GtBookingInstEnum gt_booking_inst() const;
  inline void set_gt_booking_inst(::SingleGeneralOrderHandling::GtBookingInstEnum value);

  // optional bool solicited_flag = 43;
  inline bool has_solicited_flag() const;
  inline void clear_solicited_flag();
  static const int kSolicitedFlagFieldNumber = 43;
  inline bool solicited_flag() const;
  inline void set_solicited_flag(bool value);

  // optional sfixed64 transact_time = 44;
  inline bool has_transact_time() const;
  inline void clear_transact_time();
  static const int kTransactTimeFieldNumber = 44;
  inline ::google::protobuf::int64 transact_time() const;
  inline void set_transact_time(::google::protobuf::int64 value);

  // optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 45;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 45;
  inline ::SingleGeneralOrderHandling::AccountTypeEnum account_type() const;
  inline void set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value);

  // optional .SingleGeneralOrderHandling.BookingUnitEnum booking_unit = 46;
  inline bool has_booking_unit() const;
  inline void clear_booking_unit();
  static const int kBookingUnitFieldNumber = 46;
  inline ::SingleGeneralOrderHandling::BookingUnitEnum booking_unit() const;
  inline void set_booking_unit(::SingleGeneralOrderHandling::BookingUnitEnum value);

  // optional .SingleGeneralOrderHandling.CancellationRightsEnum cancellation_rights = 47;
  inline bool has_cancellation_rights() const;
  inline void clear_cancellation_rights();
  static const int kCancellationRightsFieldNumber = 47;
  inline ::SingleGeneralOrderHandling::CancellationRightsEnum cancellation_rights() const;
  inline void set_cancellation_rights(::SingleGeneralOrderHandling::CancellationRightsEnum value);

  // optional .SingleGeneralOrderHandling.CashMarginEnum cash_margin = 48;
  inline bool has_cash_margin() const;
  inline void clear_cash_margin();
  static const int kCashMarginFieldNumber = 48;
  inline ::SingleGeneralOrderHandling::CashMarginEnum cash_margin() const;
  inline void set_cash_margin(::SingleGeneralOrderHandling::CashMarginEnum value);

  // optional string cl_ord_link_id = 49;
  inline bool has_cl_ord_link_id() const;
  inline void clear_cl_ord_link_id();
  static const int kClOrdLinkIdFieldNumber = 49;
  inline const ::std::string& cl_ord_link_id() const;
  inline void set_cl_ord_link_id(const ::std::string& value);
  inline void set_cl_ord_link_id(const char* value);
  inline void set_cl_ord_link_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_link_id();
  inline ::std::string* release_cl_ord_link_id();
  inline void set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id);

  // optional .SingleGeneralOrderHandling.ClearingFeeIndicatorEnum clearing_fee_indicator = 50;
  inline bool has_clearing_fee_indicator() const;
  inline void clear_clearing_fee_indicator();
  static const int kClearingFeeIndicatorFieldNumber = 50;
  inline ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum clearing_fee_indicator() const;
  inline void set_clearing_fee_indicator(::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum value);

  // optional .Common.CommissionData commission_data = 51;
  inline bool has_commission_data() const;
  inline void clear_commission_data();
  static const int kCommissionDataFieldNumber = 51;
  inline const ::Common::CommissionData& commission_data() const;
  inline ::Common::CommissionData* mutable_commission_data();
  inline ::Common::CommissionData* release_commission_data();
  inline void set_allocated_commission_data(::Common::CommissionData* commission_data);

  // optional .SingleGeneralOrderHandling.CustOrderCapacityEnum cust_order_capacity = 52;
  inline bool has_cust_order_capacity() const;
  inline void clear_cust_order_capacity();
  static const int kCustOrderCapacityFieldNumber = 52;
  inline ::SingleGeneralOrderHandling::CustOrderCapacityEnum cust_order_capacity() const;
  inline void set_cust_order_capacity(::SingleGeneralOrderHandling::CustOrderCapacityEnum value);

  // optional .SingleGeneralOrderHandling.DayBookingInstEnum day_booking_inst = 53;
  inline bool has_day_booking_inst() const;
  inline void clear_day_booking_inst();
  static const int kDayBookingInstFieldNumber = 53;
  inline ::SingleGeneralOrderHandling::DayBookingInstEnum day_booking_inst() const;
  inline void set_day_booking_inst(::SingleGeneralOrderHandling::DayBookingInstEnum value);

  // optional string designation = 54;
  inline bool has_designation() const;
  inline void clear_designation();
  static const int kDesignationFieldNumber = 54;
  inline const ::std::string& designation() const;
  inline void set_designation(const ::std::string& value);
  inline void set_designation(const char* value);
  inline void set_designation(const char* value, size_t size);
  inline ::std::string* mutable_designation();
  inline ::std::string* release_designation();
  inline void set_allocated_designation(::std::string* designation);

  // optional .Common.Instrument instrument = 55;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 55;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional .SingleGeneralOrderHandling.MoneyLaunderingStatusEnum money_laundering_status = 56;
  inline bool has_money_laundering_status() const;
  inline void clear_money_laundering_status();
  static const int kMoneyLaunderingStatusFieldNumber = 56;
  inline ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum money_laundering_status() const;
  inline void set_money_laundering_status(::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum value);

  // optional .SingleGeneralOrderHandling.OrderCapacityEnum order_capacity = 57;
  inline bool has_order_capacity() const;
  inline void clear_order_capacity();
  static const int kOrderCapacityFieldNumber = 57;
  inline ::SingleGeneralOrderHandling::OrderCapacityEnum order_capacity() const;
  inline void set_order_capacity(::SingleGeneralOrderHandling::OrderCapacityEnum value);

  // optional .Common.OrderQtyData order_qty_data = 58;
  inline bool has_order_qty_data() const;
  inline void clear_order_qty_data();
  static const int kOrderQtyDataFieldNumber = 58;
  inline const ::Common::OrderQtyData& order_qty_data() const;
  inline ::Common::OrderQtyData* mutable_order_qty_data();
  inline ::Common::OrderQtyData* release_order_qty_data();
  inline void set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data);

  // repeated .SingleGeneralOrderHandling.OrderRestrictionsEnum order_restrictions = 59 [packed = true];
  inline int order_restrictions_size() const;
  inline void clear_order_restrictions();
  static const int kOrderRestrictionsFieldNumber = 59;
  inline ::SingleGeneralOrderHandling::OrderRestrictionsEnum order_restrictions(int index) const;
  inline void set_order_restrictions(int index, ::SingleGeneralOrderHandling::OrderRestrictionsEnum value);
  inline void add_order_restrictions(::SingleGeneralOrderHandling::OrderRestrictionsEnum value);
  inline const ::google::protobuf::RepeatedField<int>& order_restrictions() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_order_restrictions();

  // optional sfixed64 orig_ord_mod_time = 60;
  inline bool has_orig_ord_mod_time() const;
  inline void clear_orig_ord_mod_time();
  static const int kOrigOrdModTimeFieldNumber = 60;
  inline ::google::protobuf::int64 orig_ord_mod_time() const;
  inline void set_orig_ord_mod_time(::google::protobuf::int64 value);

  // repeated .Common.Parties parties = 61;
  inline int parties_size() const;
  inline void clear_parties();
  static const int kPartiesFieldNumber = 61;
  inline const ::Common::Parties& parties(int index) const;
  inline ::Common::Parties* mutable_parties(int index);
  inline ::Common::Parties* add_parties();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
      parties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
      mutable_parties();

  // optional .SingleGeneralOrderHandling.PreallocMethodEnum prealloc_method = 62;
  inline bool has_prealloc_method() const;
  inline void clear_prealloc_method();
  static const int kPreallocMethodFieldNumber = 62;
  inline ::SingleGeneralOrderHandling::PreallocMethodEnum prealloc_method() const;
  inline void set_prealloc_method(::SingleGeneralOrderHandling::PreallocMethodEnum value);

  // optional sfixed64 price2 = 63;
  inline bool has_price2() const;
  inline void clear_price2();
  static const int kPrice2FieldNumber = 63;
  inline ::google::protobuf::int64 price2() const;
  inline void set_price2(::google::protobuf::int64 value);

  // optional sfixed32 price2_exponent = 64;
  inline bool has_price2_exponent() const;
  inline void clear_price2_exponent();
  static const int kPrice2ExponentFieldNumber = 64;
  inline ::google::protobuf::int32 price2_exponent() const;
  inline void set_price2_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.PriceTypeEnum price_type = 65;
  inline bool has_price_type() const;
  inline void clear_price_type();
  static const int kPriceTypeFieldNumber = 65;
  inline ::SingleGeneralOrderHandling::PriceTypeEnum price_type() const;
  inline void set_price_type(::SingleGeneralOrderHandling::PriceTypeEnum value);

  // optional string regist_id = 66;
  inline bool has_regist_id() const;
  inline void clear_regist_id();
  static const int kRegistIdFieldNumber = 66;
  inline const ::std::string& regist_id() const;
  inline void set_regist_id(const ::std::string& value);
  inline void set_regist_id(const char* value);
  inline void set_regist_id(const char* value, size_t size);
  inline ::std::string* mutable_regist_id();
  inline ::std::string* release_regist_id();
  inline void set_allocated_regist_id(::std::string* regist_id);

  // optional string secondary_cl_ord_id = 67;
  inline bool has_secondary_cl_ord_id() const;
  inline void clear_secondary_cl_ord_id();
  static const int kSecondaryClOrdIdFieldNumber = 67;
  inline const ::std::string& secondary_cl_ord_id() const;
  inline void set_secondary_cl_ord_id(const ::std::string& value);
  inline void set_secondary_cl_ord_id(const char* value);
  inline void set_secondary_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_cl_ord_id();
  inline ::std::string* release_secondary_cl_ord_id();
  inline void set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id);

  // optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 68;
  inline bool has_spread_or_benchmark_curve_data() const;
  inline void clear_spread_or_benchmark_curve_data();
  static const int kSpreadOrBenchmarkCurveDataFieldNumber = 68;
  inline const ::Common::SpreadOrBenchmarkCurveData& spread_or_benchmark_curve_data() const;
  inline ::Common::SpreadOrBenchmarkCurveData* mutable_spread_or_benchmark_curve_data();
  inline ::Common::SpreadOrBenchmarkCurveData* release_spread_or_benchmark_curve_data();
  inline void set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data);

  // optional sfixed32 trade_origination_date = 69;
  inline bool has_trade_origination_date() const;
  inline void clear_trade_origination_date();
  static const int kTradeOriginationDateFieldNumber = 69;
  inline ::google::protobuf::int32 trade_origination_date() const;
  inline void set_trade_origination_date(::google::protobuf::int32 value);

  // optional .Common.YieldData yield_data = 70;
  inline bool has_yield_data() const;
  inline void clear_yield_data();
  static const int kYieldDataFieldNumber = 70;
  inline const ::Common::YieldData& yield_data() const;
  inline ::Common::YieldData* mutable_yield_data();
  inline ::Common::YieldData* release_yield_data();
  inline void set_allocated_yield_data(::Common::YieldData* yield_data);

  // optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 71;
  inline bool has_acct_id_source() const;
  inline void clear_acct_id_source();
  static const int kAcctIdSourceFieldNumber = 71;
  inline ::SingleGeneralOrderHandling::AcctIdSourceEnum acct_id_source() const;
  inline void set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value);

  // optional string alloc_id = 72;
  inline bool has_alloc_id() const;
  inline void clear_alloc_id();
  static const int kAllocIdFieldNumber = 72;
  inline const ::std::string& alloc_id() const;
  inline void set_alloc_id(const ::std::string& value);
  inline void set_alloc_id(const char* value);
  inline void set_alloc_id(const char* value, size_t size);
  inline ::std::string* mutable_alloc_id();
  inline ::std::string* release_alloc_id();
  inline void set_allocated_alloc_id(::std::string* alloc_id);

  // optional .SingleGeneralOrderHandling.BookingTypeEnum booking_type = 73;
  inline bool has_booking_type() const;
  inline void clear_booking_type();
  static const int kBookingTypeFieldNumber = 73;
  inline ::SingleGeneralOrderHandling::BookingTypeEnum booking_type() const;
  inline void set_booking_type(::SingleGeneralOrderHandling::BookingTypeEnum value);

  // optional bool cust_directed_order = 74;
  inline bool has_cust_directed_order() const;
  inline void clear_cust_directed_order();
  static const int kCustDirectedOrderFieldNumber = 74;
  inline bool cust_directed_order() const;
  inline void set_cust_directed_order(bool value);

  // optional .SingleGeneralOrderHandling.CustOrderHandlingInstEnum cust_order_handling_inst = 75;
  inline bool has_cust_order_handling_inst() const;
  inline void clear_cust_order_handling_inst();
  static const int kCustOrderHandlingInstFieldNumber = 75;
  inline ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum cust_order_handling_inst() const;
  inline void set_cust_order_handling_inst(::SingleGeneralOrderHandling::CustOrderHandlingInstEnum value);

  // optional .Common.DiscretionInstructions discretion_instructions = 76;
  inline bool has_discretion_instructions() const;
  inline void clear_discretion_instructions();
  static const int kDiscretionInstructionsFieldNumber = 76;
  inline const ::Common::DiscretionInstructions& discretion_instructions() const;
  inline ::Common::DiscretionInstructions* mutable_discretion_instructions();
  inline ::Common::DiscretionInstructions* release_discretion_instructions();
  inline void set_allocated_discretion_instructions(::Common::DiscretionInstructions* discretion_instructions);

  // optional .Common.DisplayInstruction display_instruction = 77;
  inline bool has_display_instruction() const;
  inline void clear_display_instruction();
  static const int kDisplayInstructionFieldNumber = 77;
  inline const ::Common::DisplayInstruction& display_instruction() const;
  inline ::Common::DisplayInstruction* mutable_display_instruction();
  inline ::Common::DisplayInstruction* release_display_instruction();
  inline void set_allocated_display_instruction(::Common::DisplayInstruction* display_instruction);

  // optional .SingleGeneralOrderHandling.ExDestinationIdSourceEnum ex_destination_id_source = 78;
  inline bool has_ex_destination_id_source() const;
  inline void clear_ex_destination_id_source();
  static const int kExDestinationIdSourceFieldNumber = 78;
  inline ::SingleGeneralOrderHandling::ExDestinationIdSourceEnum ex_destination_id_source() const;
  inline void set_ex_destination_id_source(::SingleGeneralOrderHandling::ExDestinationIdSourceEnum value);

  // optional .Common.FinancingDetails financing_details = 79;
  inline bool has_financing_details() const;
  inline void clear_financing_details();
  static const int kFinancingDetailsFieldNumber = 79;
  inline const ::Common::FinancingDetails& financing_details() const;
  inline ::Common::FinancingDetails* mutable_financing_details();
  inline ::Common::FinancingDetails* release_financing_details();
  inline void set_allocated_financing_details(::Common::FinancingDetails* financing_details);

  // optional bool manual_order_indicator = 80;
  inline bool has_manual_order_indicator() const;
  inline void clear_manual_order_indicator();
  static const int kManualOrderIndicatorFieldNumber = 80;
  inline bool manual_order_indicator() const;
  inline void set_manual_order_indicator(bool value);

  // optional sfixed64 match_increment = 81;
  inline bool has_match_increment() const;
  inline void clear_match_increment();
  static const int kMatchIncrementFieldNumber = 81;
  inline ::google::protobuf::int64 match_increment() const;
  inline void set_match_increment(::google::protobuf::int64 value);

  // optional sfixed32 match_increment_exponent = 82;
  inline bool has_match_increment_exponent() const;
  inline void clear_match_increment_exponent();
  static const int kMatchIncrementExponentFieldNumber = 82;
  inline ::google::protobuf::int32 match_increment_exponent() const;
  inline void set_match_increment_exponent(::google::protobuf::int32 value);

  // optional sfixed64 max_price_levels = 83;
  inline bool has_max_price_levels() const;
  inline void clear_max_price_levels();
  static const int kMaxPriceLevelsFieldNumber = 83;
  inline ::google::protobuf::int64 max_price_levels() const;
  inline void set_max_price_levels(::google::protobuf::int64 value);

  // optional .SingleGeneralOrderHandling.OrderHandlingInstSourceEnum order_handling_inst_source = 84;
  inline bool has_order_handling_inst_source() const;
  inline void clear_order_handling_inst_source();
  static const int kOrderHandlingInstSourceFieldNumber = 84;
  inline ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum order_handling_inst_source() const;
  inline void set_order_handling_inst_source(::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum value);

  // optional sfixed64 participation_rate = 85;
  inline bool has_participation_rate() const;
  inline void clear_participation_rate();
  static const int kParticipationRateFieldNumber = 85;
  inline ::google::protobuf::int64 participation_rate() const;
  inline void set_participation_rate(::google::protobuf::int64 value);

  // optional sfixed32 participation_rate_exponent = 86;
  inline bool has_participation_rate_exponent() const;
  inline void clear_participation_rate_exponent();
  static const int kParticipationRateExponentFieldNumber = 86;
  inline ::google::protobuf::int32 participation_rate_exponent() const;
  inline void set_participation_rate_exponent(::google::protobuf::int32 value);

  // optional .Common.PegInstructions peg_instructions = 87;
  inline bool has_peg_instructions() const;
  inline void clear_peg_instructions();
  static const int kPegInstructionsFieldNumber = 87;
  inline const ::Common::PegInstructions& peg_instructions() const;
  inline ::Common::PegInstructions* mutable_peg_instructions();
  inline ::Common::PegInstructions* release_peg_instructions();
  inline void set_allocated_peg_instructions(::Common::PegInstructions* peg_instructions);

  // repeated .Common.PreAllocGrp pre_alloc_grp = 88;
  inline int pre_alloc_grp_size() const;
  inline void clear_pre_alloc_grp();
  static const int kPreAllocGrpFieldNumber = 88;
  inline const ::Common::PreAllocGrp& pre_alloc_grp(int index) const;
  inline ::Common::PreAllocGrp* mutable_pre_alloc_grp(int index);
  inline ::Common::PreAllocGrp* add_pre_alloc_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >&
      pre_alloc_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >*
      mutable_pre_alloc_grp();

  // optional bool pre_trade_anonymity = 89;
  inline bool has_pre_trade_anonymity() const;
  inline void clear_pre_trade_anonymity();
  static const int kPreTradeAnonymityFieldNumber = 89;
  inline bool pre_trade_anonymity() const;
  inline void set_pre_trade_anonymity(bool value);

  // optional .SingleGeneralOrderHandling.PriceProtectionScopeEnum price_protection_scope = 90;
  inline bool has_price_protection_scope() const;
  inline void clear_price_protection_scope();
  static const int kPriceProtectionScopeFieldNumber = 90;
  inline ::SingleGeneralOrderHandling::PriceProtectionScopeEnum price_protection_scope() const;
  inline void set_price_protection_scope(::SingleGeneralOrderHandling::PriceProtectionScopeEnum value);

  // optional .SingleGeneralOrderHandling.QtyTypeEnum qty_type = 91;
  inline bool has_qty_type() const;
  inline void clear_qty_type();
  static const int kQtyTypeFieldNumber = 91;
  inline ::SingleGeneralOrderHandling::QtyTypeEnum qty_type() const;
  inline void set_qty_type(::SingleGeneralOrderHandling::QtyTypeEnum value);

  // optional string received_dept_id = 92;
  inline bool has_received_dept_id() const;
  inline void clear_received_dept_id();
  static const int kReceivedDeptIdFieldNumber = 92;
  inline const ::std::string& received_dept_id() const;
  inline void set_received_dept_id(const ::std::string& value);
  inline void set_received_dept_id(const char* value);
  inline void set_received_dept_id(const char* value, size_t size);
  inline ::std::string* mutable_received_dept_id();
  inline ::std::string* release_received_dept_id();
  inline void set_allocated_received_dept_id(::std::string* received_dept_id);

  // repeated .Common.StrategyParametersGrp strategy_parameters_grp = 93;
  inline int strategy_parameters_grp_size() const;
  inline void clear_strategy_parameters_grp();
  static const int kStrategyParametersGrpFieldNumber = 93;
  inline const ::Common::StrategyParametersGrp& strategy_parameters_grp(int index) const;
  inline ::Common::StrategyParametersGrp* mutable_strategy_parameters_grp(int index);
  inline ::Common::StrategyParametersGrp* add_strategy_parameters_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >&
      strategy_parameters_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >*
      mutable_strategy_parameters_grp();

  // optional .SingleGeneralOrderHandling.TargetStrategyEnum target_strategy = 94;
  inline bool has_target_strategy() const;
  inline void clear_target_strategy();
  static const int kTargetStrategyFieldNumber = 94;
  inline ::SingleGeneralOrderHandling::TargetStrategyEnum target_strategy() const;
  inline void set_target_strategy(::SingleGeneralOrderHandling::TargetStrategyEnum value);

  // optional string target_strategy_parameters = 95;
  inline bool has_target_strategy_parameters() const;
  inline void clear_target_strategy_parameters();
  static const int kTargetStrategyParametersFieldNumber = 95;
  inline const ::std::string& target_strategy_parameters() const;
  inline void set_target_strategy_parameters(const ::std::string& value);
  inline void set_target_strategy_parameters(const char* value);
  inline void set_target_strategy_parameters(const char* value, size_t size);
  inline ::std::string* mutable_target_strategy_parameters();
  inline ::std::string* release_target_strategy_parameters();
  inline void set_allocated_target_strategy_parameters(::std::string* target_strategy_parameters);

  // optional sfixed32 trade_date = 96;
  inline bool has_trade_date() const;
  inline void clear_trade_date();
  static const int kTradeDateFieldNumber = 96;
  inline ::google::protobuf::int32 trade_date() const;
  inline void set_trade_date(::google::protobuf::int32 value);

  // repeated .Common.TrdRegTimestamps trd_reg_timestamps = 97;
  inline int trd_reg_timestamps_size() const;
  inline void clear_trd_reg_timestamps();
  static const int kTrdRegTimestampsFieldNumber = 97;
  inline const ::Common::TrdRegTimestamps& trd_reg_timestamps(int index) const;
  inline ::Common::TrdRegTimestamps* mutable_trd_reg_timestamps(int index);
  inline ::Common::TrdRegTimestamps* add_trd_reg_timestamps();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >&
      trd_reg_timestamps() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >*
      mutable_trd_reg_timestamps();

  // repeated .Common.TrdgSesGrp trdg_ses_grp = 98;
  inline int trdg_ses_grp_size() const;
  inline void clear_trdg_ses_grp();
  static const int kTrdgSesGrpFieldNumber = 98;
  inline const ::Common::TrdgSesGrp& trdg_ses_grp(int index) const;
  inline ::Common::TrdgSesGrp* mutable_trdg_ses_grp(int index);
  inline ::Common::TrdgSesGrp* add_trdg_ses_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp >&
      trdg_ses_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp >*
      mutable_trdg_ses_grp();

  // optional .Common.TriggeringInstruction triggering_instruction = 99;
  inline bool has_triggering_instruction() const;
  inline void clear_triggering_instruction();
  static const int kTriggeringInstructionFieldNumber = 99;
  inline const ::Common::TriggeringInstruction& triggering_instruction() const;
  inline ::Common::TriggeringInstruction* mutable_triggering_instruction();
  inline ::Common::TriggeringInstruction* release_triggering_instruction();
  inline void set_allocated_triggering_instruction(::Common::TriggeringInstruction* triggering_instruction);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 100;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 100;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.OrderCancelReplaceRequest)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_cl_ord_id();
  inline void clear_has_cl_ord_id();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_handl_inst();
  inline void clear_has_handl_inst();
  inline void set_has_list_id();
  inline void clear_has_list_id();
  inline void set_has_ord_type();
  inline void clear_has_ord_type();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_orig_cl_ord_id();
  inline void clear_has_orig_cl_ord_id();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_price_exponent();
  inline void clear_has_price_exponent();
  inline void set_has_settl_date();
  inline void clear_has_settl_date();
  inline void set_has_settl_type();
  inline void clear_has_settl_type();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_stop_px();
  inline void clear_has_stop_px();
  inline void set_has_stop_px_exponent();
  inline void clear_has_stop_px_exponent();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_time_in_force();
  inline void clear_has_time_in_force();
  inline void set_has_ex_destination();
  inline void clear_has_ex_destination();
  inline void set_has_max_floor();
  inline void clear_has_max_floor();
  inline void set_has_max_floor_exponent();
  inline void clear_has_max_floor_exponent();
  inline void set_has_min_qty();
  inline void clear_has_min_qty();
  inline void set_has_min_qty_exponent();
  inline void clear_has_min_qty_exponent();
  inline void set_has_expire_time();
  inline void clear_has_expire_time();
  inline void set_has_forex_req();
  inline void clear_has_forex_req();
  inline void set_has_settl_currency();
  inline void clear_has_settl_currency();
  inline void set_has_covered_or_uncovered();
  inline void clear_has_covered_or_uncovered();
  inline void set_has_locate_reqd();
  inline void clear_has_locate_reqd();
  inline void set_has_max_show();
  inline void clear_has_max_show();
  inline void set_has_max_show_exponent();
  inline void clear_has_max_show_exponent();
  inline void set_has_order_qty2();
  inline void clear_has_order_qty2();
  inline void set_has_order_qty2_exponent();
  inline void clear_has_order_qty2_exponent();
  inline void set_has_position_effect();
  inline void clear_has_position_effect();
  inline void set_has_settl_date2();
  inline void clear_has_settl_date2();
  inline void set_has_compliance_id();
  inline void clear_has_compliance_id();
  inline void set_has_effective_time();
  inline void clear_has_effective_time();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_expire_date();
  inline void clear_has_expire_date();
  inline void set_has_gt_booking_inst();
  inline void clear_has_gt_booking_inst();
  inline void set_has_solicited_flag();
  inline void clear_has_solicited_flag();
  inline void set_has_transact_time();
  inline void clear_has_transact_time();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_booking_unit();
  inline void clear_has_booking_unit();
  inline void set_has_cancellation_rights();
  inline void clear_has_cancellation_rights();
  inline void set_has_cash_margin();
  inline void clear_has_cash_margin();
  inline void set_has_cl_ord_link_id();
  inline void clear_has_cl_ord_link_id();
  inline void set_has_clearing_fee_indicator();
  inline void clear_has_clearing_fee_indicator();
  inline void set_has_commission_data();
  inline void clear_has_commission_data();
  inline void set_has_cust_order_capacity();
  inline void clear_has_cust_order_capacity();
  inline void set_has_day_booking_inst();
  inline void clear_has_day_booking_inst();
  inline void set_has_designation();
  inline void clear_has_designation();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_money_laundering_status();
  inline void clear_has_money_laundering_status();
  inline void set_has_order_capacity();
  inline void clear_has_order_capacity();
  inline void set_has_order_qty_data();
  inline void clear_has_order_qty_data();
  inline void set_has_orig_ord_mod_time();
  inline void clear_has_orig_ord_mod_time();
  inline void set_has_prealloc_method();
  inline void clear_has_prealloc_method();
  inline void set_has_price2();
  inline void clear_has_price2();
  inline void set_has_price2_exponent();
  inline void clear_has_price2_exponent();
  inline void set_has_price_type();
  inline void clear_has_price_type();
  inline void set_has_regist_id();
  inline void clear_has_regist_id();
  inline void set_has_secondary_cl_ord_id();
  inline void clear_has_secondary_cl_ord_id();
  inline void set_has_spread_or_benchmark_curve_data();
  inline void clear_has_spread_or_benchmark_curve_data();
  inline void set_has_trade_origination_date();
  inline void clear_has_trade_origination_date();
  inline void set_has_yield_data();
  inline void clear_has_yield_data();
  inline void set_has_acct_id_source();
  inline void clear_has_acct_id_source();
  inline void set_has_alloc_id();
  inline void clear_has_alloc_id();
  inline void set_has_booking_type();
  inline void clear_has_booking_type();
  inline void set_has_cust_directed_order();
  inline void clear_has_cust_directed_order();
  inline void set_has_cust_order_handling_inst();
  inline void clear_has_cust_order_handling_inst();
  inline void set_has_discretion_instructions();
  inline void clear_has_discretion_instructions();
  inline void set_has_display_instruction();
  inline void clear_has_display_instruction();
  inline void set_has_ex_destination_id_source();
  inline void clear_has_ex_destination_id_source();
  inline void set_has_financing_details();
  inline void clear_has_financing_details();
  inline void set_has_manual_order_indicator();
  inline void clear_has_manual_order_indicator();
  inline void set_has_match_increment();
  inline void clear_has_match_increment();
  inline void set_has_match_increment_exponent();
  inline void clear_has_match_increment_exponent();
  inline void set_has_max_price_levels();
  inline void clear_has_max_price_levels();
  inline void set_has_order_handling_inst_source();
  inline void clear_has_order_handling_inst_source();
  inline void set_has_participation_rate();
  inline void clear_has_participation_rate();
  inline void set_has_participation_rate_exponent();
  inline void clear_has_participation_rate_exponent();
  inline void set_has_peg_instructions();
  inline void clear_has_peg_instructions();
  inline void set_has_pre_trade_anonymity();
  inline void clear_has_pre_trade_anonymity();
  inline void set_has_price_protection_scope();
  inline void clear_has_price_protection_scope();
  inline void set_has_qty_type();
  inline void clear_has_qty_type();
  inline void set_has_received_dept_id();
  inline void clear_has_received_dept_id();
  inline void set_has_target_strategy();
  inline void clear_has_target_strategy();
  inline void set_has_target_strategy_parameters();
  inline void clear_has_target_strategy_parameters();
  inline void set_has_trade_date();
  inline void clear_has_trade_date();
  inline void set_has_triggering_instruction();
  inline void clear_has_triggering_instruction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* cl_ord_id_;
  ::std::string* currency_;
  ::google::protobuf::RepeatedField<int> exec_inst_;
  mutable int _exec_inst_cached_byte_size_;
  ::std::string* list_id_;
  int handl_inst_;
  int ord_type_;
  ::std::string* order_id_;
  ::std::string* orig_cl_ord_id_;
  ::google::protobuf::int64 price_;
  ::google::protobuf::int32 price_exponent_;
  ::google::protobuf::int32 settl_date_;
  int settl_type_;
  int side_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::google::protobuf::int64 stop_px_;
  ::std::string* text_;
  ::google::protobuf::int32 stop_px_exponent_;
  int time_in_force_;
  ::std::string* ex_destination_;
  ::google::protobuf::int64 max_floor_;
  ::google::protobuf::int32 max_floor_exponent_;
  ::google::protobuf::int32 min_qty_exponent_;
  ::google::protobuf::int64 min_qty_;
  ::google::protobuf::int64 expire_time_;
  ::std::string* settl_currency_;
  int covered_or_uncovered_;
  ::google::protobuf::int32 max_show_exponent_;
  ::google::protobuf::int64 max_show_;
  ::google::protobuf::int64 order_qty2_;
  ::google::protobuf::int32 order_qty2_exponent_;
  int position_effect_;
  ::std::string* compliance_id_;
  ::google::protobuf::int64 effective_time_;
  ::google::protobuf::int32 settl_date2_;
  ::google::protobuf::uint32 encoded_text_len_;
  ::std::string* encoded_text_;
  ::google::protobuf::int32 expire_date_;
  int gt_booking_inst_;
  bool forex_req_;
  bool locate_reqd_;
  bool solicited_flag_;
  bool cust_directed_order_;
  int account_type_;
  ::google::protobuf::int64 transact_time_;
  int booking_unit_;
  int cancellation_rights_;
  int cash_margin_;
  int clearing_fee_indicator_;
  ::std::string* cl_ord_link_id_;
  ::Common::CommissionData* commission_data_;
  int cust_order_capacity_;
  int day_booking_inst_;
  ::std::string* designation_;
  ::Common::Instrument* instrument_;
  int money_laundering_status_;
  int order_capacity_;
  ::Common::OrderQtyData* order_qty_data_;
  ::google::protobuf::RepeatedField<int> order_restrictions_;
  mutable int _order_restrictions_cached_byte_size_;
  ::google::protobuf::int64 orig_ord_mod_time_;
  ::google::protobuf::RepeatedPtrField< ::Common::Parties > parties_;
  int prealloc_method_;
  ::google::protobuf::int32 price2_exponent_;
  ::google::protobuf::int64 price2_;
  ::std::string* regist_id_;
  int price_type_;
  ::google::protobuf::int32 trade_origination_date_;
  ::std::string* secondary_cl_ord_id_;
  ::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data_;
  ::Common::YieldData* yield_data_;
  int acct_id_source_;
  int booking_type_;
  ::std::string* alloc_id_;
  ::Common::DiscretionInstructions* discretion_instructions_;
  int cust_order_handling_inst_;
  int ex_destination_id_source_;
  ::Common::DisplayInstruction* display_instruction_;
  ::Common::FinancingDetails* financing_details_;
  ::google::protobuf::int64 match_increment_;
  ::google::protobuf::int32 match_increment_exponent_;
  int order_handling_inst_source_;
  ::google::protobuf::int64 max_price_levels_;
  bool manual_order_indicator_;
  bool pre_trade_anonymity_;
  ::google::protobuf::int32 participation_rate_exponent_;
  ::google::protobuf::int64 participation_rate_;
  ::Common::PegInstructions* peg_instructions_;
  ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp > pre_alloc_grp_;
  int price_protection_scope_;
  int qty_type_;
  ::std::string* received_dept_id_;
  ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp > strategy_parameters_grp_;
  int target_strategy_;
  ::google::protobuf::int32 trade_date_;
  ::std::string* target_strategy_parameters_;
  ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps > trd_reg_timestamps_;
  ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp > trdg_ses_grp_;
  ::Common::TriggeringInstruction* triggering_instruction_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(100 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static OrderCancelReplaceRequest* default_instance_;
};
// -------------------------------------------------------------------

class OrderCancelRequest : public ::google::protobuf::Message {
 public:
  OrderCancelRequest();
  virtual ~OrderCancelRequest();

  OrderCancelRequest(const OrderCancelRequest& from);

  inline OrderCancelRequest& operator=(const OrderCancelRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderCancelRequest& default_instance();

  void Swap(OrderCancelRequest* other);

  // implements Message ----------------------------------------------

  OrderCancelRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderCancelRequest& from);
  void MergeFrom(const OrderCancelRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cl_ord_id = 1;
  inline bool has_cl_ord_id() const;
  inline void clear_cl_ord_id();
  static const int kClOrdIdFieldNumber = 1;
  inline const ::std::string& cl_ord_id() const;
  inline void set_cl_ord_id(const ::std::string& value);
  inline void set_cl_ord_id(const char* value);
  inline void set_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_id();
  inline ::std::string* release_cl_ord_id();
  inline void set_allocated_cl_ord_id(::std::string* cl_ord_id);

  // optional string list_id = 2;
  inline bool has_list_id() const;
  inline void clear_list_id();
  static const int kListIdFieldNumber = 2;
  inline const ::std::string& list_id() const;
  inline void set_list_id(const ::std::string& value);
  inline void set_list_id(const char* value);
  inline void set_list_id(const char* value, size_t size);
  inline ::std::string* mutable_list_id();
  inline ::std::string* release_list_id();
  inline void set_allocated_list_id(::std::string* list_id);

  // optional string order_id = 3;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 3;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional string orig_cl_ord_id = 4;
  inline bool has_orig_cl_ord_id() const;
  inline void clear_orig_cl_ord_id();
  static const int kOrigClOrdIdFieldNumber = 4;
  inline const ::std::string& orig_cl_ord_id() const;
  inline void set_orig_cl_ord_id(const ::std::string& value);
  inline void set_orig_cl_ord_id(const char* value);
  inline void set_orig_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_orig_cl_ord_id();
  inline ::std::string* release_orig_cl_ord_id();
  inline void set_allocated_orig_cl_ord_id(::std::string* orig_cl_ord_id);

  // optional .SingleGeneralOrderHandling.SideEnum side = 5;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 5;
  inline ::SingleGeneralOrderHandling::SideEnum side() const;
  inline void set_side(::SingleGeneralOrderHandling::SideEnum value);

  // optional .Session.StandardHeader standard_header = 6;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 6;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 7;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 7;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional string text = 8;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 8;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string account = 9;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 9;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string compliance_id = 10;
  inline bool has_compliance_id() const;
  inline void clear_compliance_id();
  static const int kComplianceIdFieldNumber = 10;
  inline const ::std::string& compliance_id() const;
  inline void set_compliance_id(const ::std::string& value);
  inline void set_compliance_id(const char* value);
  inline void set_compliance_id(const char* value, size_t size);
  inline ::std::string* mutable_compliance_id();
  inline ::std::string* release_compliance_id();
  inline void set_allocated_compliance_id(::std::string* compliance_id);

  // optional bytes encoded_text = 11;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 11;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 12;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 12;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional sfixed64 transact_time = 13;
  inline bool has_transact_time() const;
  inline void clear_transact_time();
  static const int kTransactTimeFieldNumber = 13;
  inline ::google::protobuf::int64 transact_time() const;
  inline void set_transact_time(::google::protobuf::int64 value);

  // optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 14;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 14;
  inline ::SingleGeneralOrderHandling::AccountTypeEnum account_type() const;
  inline void set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value);

  // optional string cl_ord_link_id = 15;
  inline bool has_cl_ord_link_id() const;
  inline void clear_cl_ord_link_id();
  static const int kClOrdLinkIdFieldNumber = 15;
  inline const ::std::string& cl_ord_link_id() const;
  inline void set_cl_ord_link_id(const ::std::string& value);
  inline void set_cl_ord_link_id(const char* value);
  inline void set_cl_ord_link_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_link_id();
  inline ::std::string* release_cl_ord_link_id();
  inline void set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id);

  // optional .Common.Instrument instrument = 16;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 16;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional .Common.OrderQtyData order_qty_data = 17;
  inline bool has_order_qty_data() const;
  inline void clear_order_qty_data();
  static const int kOrderQtyDataFieldNumber = 17;
  inline const ::Common::OrderQtyData& order_qty_data() const;
  inline ::Common::OrderQtyData* mutable_order_qty_data();
  inline ::Common::OrderQtyData* release_order_qty_data();
  inline void set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data);

  // optional sfixed64 orig_ord_mod_time = 18;
  inline bool has_orig_ord_mod_time() const;
  inline void clear_orig_ord_mod_time();
  static const int kOrigOrdModTimeFieldNumber = 18;
  inline ::google::protobuf::int64 orig_ord_mod_time() const;
  inline void set_orig_ord_mod_time(::google::protobuf::int64 value);

  // repeated .Common.Parties parties = 19;
  inline int parties_size() const;
  inline void clear_parties();
  static const int kPartiesFieldNumber = 19;
  inline const ::Common::Parties& parties(int index) const;
  inline ::Common::Parties* mutable_parties(int index);
  inline ::Common::Parties* add_parties();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
      parties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
      mutable_parties();

  // optional string secondary_cl_ord_id = 20;
  inline bool has_secondary_cl_ord_id() const;
  inline void clear_secondary_cl_ord_id();
  static const int kSecondaryClOrdIdFieldNumber = 20;
  inline const ::std::string& secondary_cl_ord_id() const;
  inline void set_secondary_cl_ord_id(const ::std::string& value);
  inline void set_secondary_cl_ord_id(const char* value);
  inline void set_secondary_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_cl_ord_id();
  inline ::std::string* release_secondary_cl_ord_id();
  inline void set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id);

  // optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 21;
  inline bool has_acct_id_source() const;
  inline void clear_acct_id_source();
  static const int kAcctIdSourceFieldNumber = 21;
  inline ::SingleGeneralOrderHandling::AcctIdSourceEnum acct_id_source() const;
  inline void set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value);

  // optional .Common.FinancingDetails financing_details = 22;
  inline bool has_financing_details() const;
  inline void clear_financing_details();
  static const int kFinancingDetailsFieldNumber = 22;
  inline const ::Common::FinancingDetails& financing_details() const;
  inline ::Common::FinancingDetails* mutable_financing_details();
  inline ::Common::FinancingDetails* release_financing_details();
  inline void set_allocated_financing_details(::Common::FinancingDetails* financing_details);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 23;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 23;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.OrderCancelRequest)
 private:
  inline void set_has_cl_ord_id();
  inline void clear_has_cl_ord_id();
  inline void set_has_list_id();
  inline void clear_has_list_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_orig_cl_ord_id();
  inline void clear_has_orig_cl_ord_id();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_compliance_id();
  inline void clear_has_compliance_id();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_transact_time();
  inline void clear_has_transact_time();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_cl_ord_link_id();
  inline void clear_has_cl_ord_link_id();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_order_qty_data();
  inline void clear_has_order_qty_data();
  inline void set_has_orig_ord_mod_time();
  inline void clear_has_orig_ord_mod_time();
  inline void set_has_secondary_cl_ord_id();
  inline void clear_has_secondary_cl_ord_id();
  inline void set_has_acct_id_source();
  inline void clear_has_acct_id_source();
  inline void set_has_financing_details();
  inline void clear_has_financing_details();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cl_ord_id_;
  ::std::string* list_id_;
  ::std::string* order_id_;
  ::std::string* orig_cl_ord_id_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::std::string* text_;
  int side_;
  ::google::protobuf::uint32 encoded_text_len_;
  ::std::string* account_;
  ::std::string* compliance_id_;
  ::std::string* encoded_text_;
  ::google::protobuf::int64 transact_time_;
  ::std::string* cl_ord_link_id_;
  ::Common::Instrument* instrument_;
  ::Common::OrderQtyData* order_qty_data_;
  int account_type_;
  int acct_id_source_;
  ::google::protobuf::int64 orig_ord_mod_time_;
  ::google::protobuf::RepeatedPtrField< ::Common::Parties > parties_;
  ::std::string* secondary_cl_ord_id_;
  ::Common::FinancingDetails* financing_details_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static OrderCancelRequest* default_instance_;
};
// -------------------------------------------------------------------

class CxlRejReasonUnion : public ::google::protobuf::Message {
 public:
  CxlRejReasonUnion();
  virtual ~CxlRejReasonUnion();

  CxlRejReasonUnion(const CxlRejReasonUnion& from);

  inline CxlRejReasonUnion& operator=(const CxlRejReasonUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CxlRejReasonUnion& default_instance();

  void Swap(CxlRejReasonUnion* other);

  // implements Message ----------------------------------------------

  CxlRejReasonUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CxlRejReasonUnion& from);
  void MergeFrom(const CxlRejReasonUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SingleGeneralOrderHandling.CxlRejReasonEnum cxl_rej_reason = 1;
  inline bool has_cxl_rej_reason() const;
  inline void clear_cxl_rej_reason();
  static const int kCxlRejReasonFieldNumber = 1;
  inline ::SingleGeneralOrderHandling::CxlRejReasonEnum cxl_rej_reason() const;
  inline void set_cxl_rej_reason(::SingleGeneralOrderHandling::CxlRejReasonEnum value);

  // optional sfixed64 cxl_rej_reason_sfixed64 = 2;
  inline bool has_cxl_rej_reason_sfixed64() const;
  inline void clear_cxl_rej_reason_sfixed64();
  static const int kCxlRejReasonSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 cxl_rej_reason_sfixed64() const;
  inline void set_cxl_rej_reason_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.CxlRejReasonUnion)
 private:
  inline void set_has_cxl_rej_reason();
  inline void clear_has_cxl_rej_reason();
  inline void set_has_cxl_rej_reason_sfixed64();
  inline void clear_has_cxl_rej_reason_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 cxl_rej_reason_sfixed64_;
  int cxl_rej_reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static CxlRejReasonUnion* default_instance_;
};
// -------------------------------------------------------------------

class OrderCancelReject : public ::google::protobuf::Message {
 public:
  OrderCancelReject();
  virtual ~OrderCancelReject();

  OrderCancelReject(const OrderCancelReject& from);

  inline OrderCancelReject& operator=(const OrderCancelReject& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderCancelReject& default_instance();

  void Swap(OrderCancelReject* other);

  // implements Message ----------------------------------------------

  OrderCancelReject* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderCancelReject& from);
  void MergeFrom(const OrderCancelReject& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cl_ord_id = 1;
  inline bool has_cl_ord_id() const;
  inline void clear_cl_ord_id();
  static const int kClOrdIdFieldNumber = 1;
  inline const ::std::string& cl_ord_id() const;
  inline void set_cl_ord_id(const ::std::string& value);
  inline void set_cl_ord_id(const char* value);
  inline void set_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_id();
  inline ::std::string* release_cl_ord_id();
  inline void set_allocated_cl_ord_id(::std::string* cl_ord_id);

  // optional .SingleGeneralOrderHandling.CxlRejReasonEnum cxl_rej_reason = 2;
  inline bool has_cxl_rej_reason() const;
  inline void clear_cxl_rej_reason();
  static const int kCxlRejReasonFieldNumber = 2;
  inline ::SingleGeneralOrderHandling::CxlRejReasonEnum cxl_rej_reason() const;
  inline void set_cxl_rej_reason(::SingleGeneralOrderHandling::CxlRejReasonEnum value);

  // optional string list_id = 3;
  inline bool has_list_id() const;
  inline void clear_list_id();
  static const int kListIdFieldNumber = 3;
  inline const ::std::string& list_id() const;
  inline void set_list_id(const ::std::string& value);
  inline void set_list_id(const char* value);
  inline void set_list_id(const char* value, size_t size);
  inline ::std::string* mutable_list_id();
  inline ::std::string* release_list_id();
  inline void set_allocated_list_id(::std::string* list_id);

  // optional string order_id = 4;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 4;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional .Session.StandardHeader standard_header = 5;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 5;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 6;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 6;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional string text = 7;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 7;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .SingleGeneralOrderHandling.OrdStatusEnum ord_status = 8;
  inline bool has_ord_status() const;
  inline void clear_ord_status();
  static const int kOrdStatusFieldNumber = 8;
  inline ::SingleGeneralOrderHandling::OrdStatusEnum ord_status() const;
  inline void set_ord_status(::SingleGeneralOrderHandling::OrdStatusEnum value);

  // optional string orig_cl_ord_id = 9;
  inline bool has_orig_cl_ord_id() const;
  inline void clear_orig_cl_ord_id();
  static const int kOrigClOrdIdFieldNumber = 9;
  inline const ::std::string& orig_cl_ord_id() const;
  inline void set_orig_cl_ord_id(const ::std::string& value);
  inline void set_orig_cl_ord_id(const char* value);
  inline void set_orig_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_orig_cl_ord_id();
  inline ::std::string* release_orig_cl_ord_id();
  inline void set_allocated_orig_cl_ord_id(::std::string* orig_cl_ord_id);

  // optional string secondary_order_id = 10;
  inline bool has_secondary_order_id() const;
  inline void clear_secondary_order_id();
  static const int kSecondaryOrderIdFieldNumber = 10;
  inline const ::std::string& secondary_order_id() const;
  inline void set_secondary_order_id(const ::std::string& value);
  inline void set_secondary_order_id(const char* value);
  inline void set_secondary_order_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_order_id();
  inline ::std::string* release_secondary_order_id();
  inline void set_allocated_secondary_order_id(::std::string* secondary_order_id);

  // optional string account = 11;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 11;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional .SingleGeneralOrderHandling.CxlRejResponseToEnum cxl_rej_response_to = 12;
  inline bool has_cxl_rej_response_to() const;
  inline void clear_cxl_rej_response_to();
  static const int kCxlRejResponseToFieldNumber = 12;
  inline ::SingleGeneralOrderHandling::CxlRejResponseToEnum cxl_rej_response_to() const;
  inline void set_cxl_rej_response_to(::SingleGeneralOrderHandling::CxlRejResponseToEnum value);

  // optional bytes encoded_text = 13;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 13;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 14;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 14;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional sfixed64 transact_time = 15;
  inline bool has_transact_time() const;
  inline void clear_transact_time();
  static const int kTransactTimeFieldNumber = 15;
  inline ::google::protobuf::int64 transact_time() const;
  inline void set_transact_time(::google::protobuf::int64 value);

  // optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 16;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 16;
  inline ::SingleGeneralOrderHandling::AccountTypeEnum account_type() const;
  inline void set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value);

  // optional string cl_ord_link_id = 17;
  inline bool has_cl_ord_link_id() const;
  inline void clear_cl_ord_link_id();
  static const int kClOrdLinkIdFieldNumber = 17;
  inline const ::std::string& cl_ord_link_id() const;
  inline void set_cl_ord_link_id(const ::std::string& value);
  inline void set_cl_ord_link_id(const char* value);
  inline void set_cl_ord_link_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_link_id();
  inline ::std::string* release_cl_ord_link_id();
  inline void set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id);

  // optional sfixed64 orig_ord_mod_time = 18;
  inline bool has_orig_ord_mod_time() const;
  inline void clear_orig_ord_mod_time();
  static const int kOrigOrdModTimeFieldNumber = 18;
  inline ::google::protobuf::int64 orig_ord_mod_time() const;
  inline void set_orig_ord_mod_time(::google::protobuf::int64 value);

  // optional string secondary_cl_ord_id = 19;
  inline bool has_secondary_cl_ord_id() const;
  inline void clear_secondary_cl_ord_id();
  static const int kSecondaryClOrdIdFieldNumber = 19;
  inline const ::std::string& secondary_cl_ord_id() const;
  inline void set_secondary_cl_ord_id(const ::std::string& value);
  inline void set_secondary_cl_ord_id(const char* value);
  inline void set_secondary_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_cl_ord_id();
  inline ::std::string* release_secondary_cl_ord_id();
  inline void set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id);

  // optional sfixed32 trade_origination_date = 20;
  inline bool has_trade_origination_date() const;
  inline void clear_trade_origination_date();
  static const int kTradeOriginationDateFieldNumber = 20;
  inline ::google::protobuf::int32 trade_origination_date() const;
  inline void set_trade_origination_date(::google::protobuf::int32 value);

  // optional bool working_indicator = 21;
  inline bool has_working_indicator() const;
  inline void clear_working_indicator();
  static const int kWorkingIndicatorFieldNumber = 21;
  inline bool working_indicator() const;
  inline void set_working_indicator(bool value);

  // optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 22;
  inline bool has_acct_id_source() const;
  inline void clear_acct_id_source();
  static const int kAcctIdSourceFieldNumber = 22;
  inline ::SingleGeneralOrderHandling::AcctIdSourceEnum acct_id_source() const;
  inline void set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value);

  // optional sfixed32 trade_date = 23;
  inline bool has_trade_date() const;
  inline void clear_trade_date();
  static const int kTradeDateFieldNumber = 23;
  inline ::google::protobuf::int32 trade_date() const;
  inline void set_trade_date(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.OrderCancelReject)
 private:
  inline void set_has_cl_ord_id();
  inline void clear_has_cl_ord_id();
  inline void set_has_cxl_rej_reason();
  inline void clear_has_cxl_rej_reason();
  inline void set_has_list_id();
  inline void clear_has_list_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_ord_status();
  inline void clear_has_ord_status();
  inline void set_has_orig_cl_ord_id();
  inline void clear_has_orig_cl_ord_id();
  inline void set_has_secondary_order_id();
  inline void clear_has_secondary_order_id();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_cxl_rej_response_to();
  inline void clear_has_cxl_rej_response_to();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_transact_time();
  inline void clear_has_transact_time();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_cl_ord_link_id();
  inline void clear_has_cl_ord_link_id();
  inline void set_has_orig_ord_mod_time();
  inline void clear_has_orig_ord_mod_time();
  inline void set_has_secondary_cl_ord_id();
  inline void clear_has_secondary_cl_ord_id();
  inline void set_has_trade_origination_date();
  inline void clear_has_trade_origination_date();
  inline void set_has_working_indicator();
  inline void clear_has_working_indicator();
  inline void set_has_acct_id_source();
  inline void clear_has_acct_id_source();
  inline void set_has_trade_date();
  inline void clear_has_trade_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cl_ord_id_;
  ::std::string* list_id_;
  ::std::string* order_id_;
  ::Session::StandardHeader* standard_header_;
  int cxl_rej_reason_;
  int ord_status_;
  ::Session::StandardTrailer* standard_trailer_;
  ::std::string* text_;
  ::std::string* orig_cl_ord_id_;
  ::std::string* secondary_order_id_;
  ::std::string* account_;
  ::std::string* encoded_text_;
  int cxl_rej_response_to_;
  ::google::protobuf::uint32 encoded_text_len_;
  ::google::protobuf::int64 transact_time_;
  ::std::string* cl_ord_link_id_;
  ::google::protobuf::int64 orig_ord_mod_time_;
  int account_type_;
  ::google::protobuf::int32 trade_origination_date_;
  ::std::string* secondary_cl_ord_id_;
  bool working_indicator_;
  int acct_id_source_;
  ::google::protobuf::int32 trade_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static OrderCancelReject* default_instance_;
};
// -------------------------------------------------------------------

class FillsGrp : public ::google::protobuf::Message {
 public:
  FillsGrp();
  virtual ~FillsGrp();

  FillsGrp(const FillsGrp& from);

  inline FillsGrp& operator=(const FillsGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FillsGrp& default_instance();

  void Swap(FillsGrp* other);

  // implements Message ----------------------------------------------

  FillsGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FillsGrp& from);
  void MergeFrom(const FillsGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fill_exec_id = 1;
  inline bool has_fill_exec_id() const;
  inline void clear_fill_exec_id();
  static const int kFillExecIdFieldNumber = 1;
  inline const ::std::string& fill_exec_id() const;
  inline void set_fill_exec_id(const ::std::string& value);
  inline void set_fill_exec_id(const char* value);
  inline void set_fill_exec_id(const char* value, size_t size);
  inline ::std::string* mutable_fill_exec_id();
  inline ::std::string* release_fill_exec_id();
  inline void set_allocated_fill_exec_id(::std::string* fill_exec_id);

  // optional sfixed64 fill_px = 2;
  inline bool has_fill_px() const;
  inline void clear_fill_px();
  static const int kFillPxFieldNumber = 2;
  inline ::google::protobuf::int64 fill_px() const;
  inline void set_fill_px(::google::protobuf::int64 value);

  // optional sfixed32 fill_px_exponent = 3;
  inline bool has_fill_px_exponent() const;
  inline void clear_fill_px_exponent();
  static const int kFillPxExponentFieldNumber = 3;
  inline ::google::protobuf::int32 fill_px_exponent() const;
  inline void set_fill_px_exponent(::google::protobuf::int32 value);

  // optional sfixed64 fill_qty = 4;
  inline bool has_fill_qty() const;
  inline void clear_fill_qty();
  static const int kFillQtyFieldNumber = 4;
  inline ::google::protobuf::int64 fill_qty() const;
  inline void set_fill_qty(::google::protobuf::int64 value);

  // optional sfixed32 fill_qty_exponent = 5;
  inline bool has_fill_qty_exponent() const;
  inline void clear_fill_qty_exponent();
  static const int kFillQtyExponentFieldNumber = 5;
  inline ::google::protobuf::int32 fill_qty_exponent() const;
  inline void set_fill_qty_exponent(::google::protobuf::int32 value);

  // repeated .Common.NestedParties4 nested_parties4 = 6;
  inline int nested_parties4_size() const;
  inline void clear_nested_parties4();
  static const int kNestedParties4FieldNumber = 6;
  inline const ::Common::NestedParties4& nested_parties4(int index) const;
  inline ::Common::NestedParties4* mutable_nested_parties4(int index);
  inline ::Common::NestedParties4* add_nested_parties4();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedParties4 >&
      nested_parties4() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NestedParties4 >*
      mutable_nested_parties4();

  // optional sfixed64 fill_liquidity_ind = 7;
  inline bool has_fill_liquidity_ind() const;
  inline void clear_fill_liquidity_ind();
  static const int kFillLiquidityIndFieldNumber = 7;
  inline ::google::protobuf::int64 fill_liquidity_ind() const;
  inline void set_fill_liquidity_ind(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.FillsGrp)
 private:
  inline void set_has_fill_exec_id();
  inline void clear_has_fill_exec_id();
  inline void set_has_fill_px();
  inline void clear_has_fill_px();
  inline void set_has_fill_px_exponent();
  inline void clear_has_fill_px_exponent();
  inline void set_has_fill_qty();
  inline void clear_has_fill_qty();
  inline void set_has_fill_qty_exponent();
  inline void clear_has_fill_qty_exponent();
  inline void set_has_fill_liquidity_ind();
  inline void clear_has_fill_liquidity_ind();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fill_exec_id_;
  ::google::protobuf::int64 fill_px_;
  ::google::protobuf::int64 fill_qty_;
  ::google::protobuf::int32 fill_px_exponent_;
  ::google::protobuf::int32 fill_qty_exponent_;
  ::google::protobuf::RepeatedPtrField< ::Common::NestedParties4 > nested_parties4_;
  ::google::protobuf::int64 fill_liquidity_ind_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static FillsGrp* default_instance_;
};
// -------------------------------------------------------------------

class OrdRejReasonUnion : public ::google::protobuf::Message {
 public:
  OrdRejReasonUnion();
  virtual ~OrdRejReasonUnion();

  OrdRejReasonUnion(const OrdRejReasonUnion& from);

  inline OrdRejReasonUnion& operator=(const OrdRejReasonUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrdRejReasonUnion& default_instance();

  void Swap(OrdRejReasonUnion* other);

  // implements Message ----------------------------------------------

  OrdRejReasonUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrdRejReasonUnion& from);
  void MergeFrom(const OrdRejReasonUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SingleGeneralOrderHandling.OrdRejReasonEnum ord_rej_reason = 1;
  inline bool has_ord_rej_reason() const;
  inline void clear_ord_rej_reason();
  static const int kOrdRejReasonFieldNumber = 1;
  inline ::SingleGeneralOrderHandling::OrdRejReasonEnum ord_rej_reason() const;
  inline void set_ord_rej_reason(::SingleGeneralOrderHandling::OrdRejReasonEnum value);

  // optional sfixed64 ord_rej_reason_sfixed64 = 2;
  inline bool has_ord_rej_reason_sfixed64() const;
  inline void clear_ord_rej_reason_sfixed64();
  static const int kOrdRejReasonSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 ord_rej_reason_sfixed64() const;
  inline void set_ord_rej_reason_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.OrdRejReasonUnion)
 private:
  inline void set_has_ord_rej_reason();
  inline void clear_has_ord_rej_reason();
  inline void set_has_ord_rej_reason_sfixed64();
  inline void clear_has_ord_rej_reason_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 ord_rej_reason_sfixed64_;
  int ord_rej_reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static OrdRejReasonUnion* default_instance_;
};
// -------------------------------------------------------------------

class ExecRestatementReasonUnion : public ::google::protobuf::Message {
 public:
  ExecRestatementReasonUnion();
  virtual ~ExecRestatementReasonUnion();

  ExecRestatementReasonUnion(const ExecRestatementReasonUnion& from);

  inline ExecRestatementReasonUnion& operator=(const ExecRestatementReasonUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecRestatementReasonUnion& default_instance();

  void Swap(ExecRestatementReasonUnion* other);

  // implements Message ----------------------------------------------

  ExecRestatementReasonUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecRestatementReasonUnion& from);
  void MergeFrom(const ExecRestatementReasonUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SingleGeneralOrderHandling.ExecRestatementReasonEnum exec_restatement_reason = 1;
  inline bool has_exec_restatement_reason() const;
  inline void clear_exec_restatement_reason();
  static const int kExecRestatementReasonFieldNumber = 1;
  inline ::SingleGeneralOrderHandling::ExecRestatementReasonEnum exec_restatement_reason() const;
  inline void set_exec_restatement_reason(::SingleGeneralOrderHandling::ExecRestatementReasonEnum value);

  // optional sfixed64 exec_restatement_reason_sfixed64 = 2;
  inline bool has_exec_restatement_reason_sfixed64() const;
  inline void clear_exec_restatement_reason_sfixed64();
  static const int kExecRestatementReasonSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 exec_restatement_reason_sfixed64() const;
  inline void set_exec_restatement_reason_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.ExecRestatementReasonUnion)
 private:
  inline void set_has_exec_restatement_reason();
  inline void clear_has_exec_restatement_reason();
  inline void set_has_exec_restatement_reason_sfixed64();
  inline void clear_has_exec_restatement_reason_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 exec_restatement_reason_sfixed64_;
  int exec_restatement_reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static ExecRestatementReasonUnion* default_instance_;
};
// -------------------------------------------------------------------

class ExecutionReport : public ::google::protobuf::Message {
 public:
  ExecutionReport();
  virtual ~ExecutionReport();

  ExecutionReport(const ExecutionReport& from);

  inline ExecutionReport& operator=(const ExecutionReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutionReport& default_instance();

  void Swap(ExecutionReport* other);

  // implements Message ----------------------------------------------

  ExecutionReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutionReport& from);
  void MergeFrom(const ExecutionReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional sfixed64 avg_px = 2;
  inline bool has_avg_px() const;
  inline void clear_avg_px();
  static const int kAvgPxFieldNumber = 2;
  inline ::google::protobuf::int64 avg_px() const;
  inline void set_avg_px(::google::protobuf::int64 value);

  // optional string cl_ord_id = 3;
  inline bool has_cl_ord_id() const;
  inline void clear_cl_ord_id();
  static const int kClOrdIdFieldNumber = 3;
  inline const ::std::string& cl_ord_id() const;
  inline void set_cl_ord_id(const ::std::string& value);
  inline void set_cl_ord_id(const char* value);
  inline void set_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_id();
  inline ::std::string* release_cl_ord_id();
  inline void set_allocated_cl_ord_id(::std::string* cl_ord_id);

  // optional sfixed64 cum_qty = 4;
  inline bool has_cum_qty() const;
  inline void clear_cum_qty();
  static const int kCumQtyFieldNumber = 4;
  inline ::google::protobuf::int64 cum_qty() const;
  inline void set_cum_qty(::google::protobuf::int64 value);

  // optional sfixed32 cum_qty_exponent = 5;
  inline bool has_cum_qty_exponent() const;
  inline void clear_cum_qty_exponent();
  static const int kCumQtyExponentFieldNumber = 5;
  inline ::google::protobuf::int32 cum_qty_exponent() const;
  inline void set_cum_qty_exponent(::google::protobuf::int32 value);

  // optional string currency = 6;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 6;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional string exec_id = 7;
  inline bool has_exec_id() const;
  inline void clear_exec_id();
  static const int kExecIdFieldNumber = 7;
  inline const ::std::string& exec_id() const;
  inline void set_exec_id(const ::std::string& value);
  inline void set_exec_id(const char* value);
  inline void set_exec_id(const char* value, size_t size);
  inline ::std::string* mutable_exec_id();
  inline ::std::string* release_exec_id();
  inline void set_allocated_exec_id(::std::string* exec_id);

  // repeated .SingleGeneralOrderHandling.ExecInstEnum exec_inst = 8 [packed = true];
  inline int exec_inst_size() const;
  inline void clear_exec_inst();
  static const int kExecInstFieldNumber = 8;
  inline ::SingleGeneralOrderHandling::ExecInstEnum exec_inst(int index) const;
  inline void set_exec_inst(int index, ::SingleGeneralOrderHandling::ExecInstEnum value);
  inline void add_exec_inst(::SingleGeneralOrderHandling::ExecInstEnum value);
  inline const ::google::protobuf::RepeatedField<int>& exec_inst() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_exec_inst();

  // optional string exec_ref_id = 9;
  inline bool has_exec_ref_id() const;
  inline void clear_exec_ref_id();
  static const int kExecRefIdFieldNumber = 9;
  inline const ::std::string& exec_ref_id() const;
  inline void set_exec_ref_id(const ::std::string& value);
  inline void set_exec_ref_id(const char* value);
  inline void set_exec_ref_id(const char* value, size_t size);
  inline ::std::string* mutable_exec_ref_id();
  inline ::std::string* release_exec_ref_id();
  inline void set_allocated_exec_ref_id(::std::string* exec_ref_id);

  // optional .SingleGeneralOrderHandling.LastCapacityEnum last_capacity = 10;
  inline bool has_last_capacity() const;
  inline void clear_last_capacity();
  static const int kLastCapacityFieldNumber = 10;
  inline ::SingleGeneralOrderHandling::LastCapacityEnum last_capacity() const;
  inline void set_last_capacity(::SingleGeneralOrderHandling::LastCapacityEnum value);

  // optional string last_mkt = 11;
  inline bool has_last_mkt() const;
  inline void clear_last_mkt();
  static const int kLastMktFieldNumber = 11;
  inline const ::std::string& last_mkt() const;
  inline void set_last_mkt(const ::std::string& value);
  inline void set_last_mkt(const char* value);
  inline void set_last_mkt(const char* value, size_t size);
  inline ::std::string* mutable_last_mkt();
  inline ::std::string* release_last_mkt();
  inline void set_allocated_last_mkt(::std::string* last_mkt);

  // optional double last_px = 12;
  inline bool has_last_px() const;
  inline void clear_last_px();
  static const int kLastPxFieldNumber = 12;
  inline double last_px() const;
  inline void set_last_px(double value);

  // optional sfixed64 last_qty = 13;
  inline bool has_last_qty() const;
  inline void clear_last_qty();
  static const int kLastQtyFieldNumber = 13;
  inline ::google::protobuf::int64 last_qty() const;
  inline void set_last_qty(::google::protobuf::int64 value);

  // optional sfixed32 last_qty_exponent = 14;
  inline bool has_last_qty_exponent() const;
  inline void clear_last_qty_exponent();
  static const int kLastQtyExponentFieldNumber = 14;
  inline ::google::protobuf::int32 last_qty_exponent() const;
  inline void set_last_qty_exponent(::google::protobuf::int32 value);

  // optional string list_id = 15;
  inline bool has_list_id() const;
  inline void clear_list_id();
  static const int kListIdFieldNumber = 15;
  inline const ::std::string& list_id() const;
  inline void set_list_id(const ::std::string& value);
  inline void set_list_id(const char* value);
  inline void set_list_id(const char* value, size_t size);
  inline ::std::string* mutable_list_id();
  inline ::std::string* release_list_id();
  inline void set_allocated_list_id(::std::string* list_id);

  // optional .SingleGeneralOrderHandling.OrdRejReasonEnum ord_rej_reason = 16;
  inline bool has_ord_rej_reason() const;
  inline void clear_ord_rej_reason();
  static const int kOrdRejReasonFieldNumber = 16;
  inline ::SingleGeneralOrderHandling::OrdRejReasonEnum ord_rej_reason() const;
  inline void set_ord_rej_reason(::SingleGeneralOrderHandling::OrdRejReasonEnum value);

  // optional .SingleGeneralOrderHandling.OrdStatusEnum ord_status = 17;
  inline bool has_ord_status() const;
  inline void clear_ord_status();
  static const int kOrdStatusFieldNumber = 17;
  inline ::SingleGeneralOrderHandling::OrdStatusEnum ord_status() const;
  inline void set_ord_status(::SingleGeneralOrderHandling::OrdStatusEnum value);

  // optional .SingleGeneralOrderHandling.OrdTypeEnum ord_type = 18;
  inline bool has_ord_type() const;
  inline void clear_ord_type();
  static const int kOrdTypeFieldNumber = 18;
  inline ::SingleGeneralOrderHandling::OrdTypeEnum ord_type() const;
  inline void set_ord_type(::SingleGeneralOrderHandling::OrdTypeEnum value);

  // optional string order_id = 19;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 19;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional sfixed64 price = 20;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 20;
  inline ::google::protobuf::int64 price() const;
  inline void set_price(::google::protobuf::int64 value);

  // optional sfixed32 price_exponent = 21;
  inline bool has_price_exponent() const;
  inline void clear_price_exponent();
  static const int kPriceExponentFieldNumber = 21;
  inline ::google::protobuf::int32 price_exponent() const;
  inline void set_price_exponent(::google::protobuf::int32 value);

  // optional sfixed32 settl_date = 22;
  inline bool has_settl_date() const;
  inline void clear_settl_date();
  static const int kSettlDateFieldNumber = 22;
  inline ::google::protobuf::int32 settl_date() const;
  inline void set_settl_date(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.SettlTypeEnum settl_type = 23;
  inline bool has_settl_type() const;
  inline void clear_settl_type();
  static const int kSettlTypeFieldNumber = 23;
  inline ::SingleGeneralOrderHandling::SettlTypeEnum settl_type() const;
  inline void set_settl_type(::SingleGeneralOrderHandling::SettlTypeEnum value);

  // optional .SingleGeneralOrderHandling.SideEnum side = 24;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 24;
  inline ::SingleGeneralOrderHandling::SideEnum side() const;
  inline void set_side(::SingleGeneralOrderHandling::SideEnum value);

  // optional .Session.StandardHeader standard_header = 25;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 25;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 26;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 26;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional sfixed64 stop_px = 27;
  inline bool has_stop_px() const;
  inline void clear_stop_px();
  static const int kStopPxFieldNumber = 27;
  inline ::google::protobuf::int64 stop_px() const;
  inline void set_stop_px(::google::protobuf::int64 value);

  // optional sfixed32 stop_px_exponent = 28;
  inline bool has_stop_px_exponent() const;
  inline void clear_stop_px_exponent();
  static const int kStopPxExponentFieldNumber = 28;
  inline ::google::protobuf::int32 stop_px_exponent() const;
  inline void set_stop_px_exponent(::google::protobuf::int32 value);

  // optional string text = 29;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 29;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .SingleGeneralOrderHandling.TimeInForceEnum time_in_force = 30;
  inline bool has_time_in_force() const;
  inline void clear_time_in_force();
  static const int kTimeInForceFieldNumber = 30;
  inline ::SingleGeneralOrderHandling::TimeInForceEnum time_in_force() const;
  inline void set_time_in_force(::SingleGeneralOrderHandling::TimeInForceEnum value);

  // optional sfixed32 trade_date = 31;
  inline bool has_trade_date() const;
  inline void clear_trade_date();
  static const int kTradeDateFieldNumber = 31;
  inline ::google::protobuf::int32 trade_date() const;
  inline void set_trade_date(::google::protobuf::int32 value);

  // optional sfixed64 transact_time = 32;
  inline bool has_transact_time() const;
  inline void clear_transact_time();
  static const int kTransactTimeFieldNumber = 32;
  inline ::google::protobuf::int64 transact_time() const;
  inline void set_transact_time(::google::protobuf::int64 value);

  // optional bool report_to_exch = 33;
  inline bool has_report_to_exch() const;
  inline void clear_report_to_exch();
  static const int kReportToExchFieldNumber = 33;
  inline bool report_to_exch() const;
  inline void set_report_to_exch(bool value);

  // optional sfixed64 expire_time = 34;
  inline bool has_expire_time() const;
  inline void clear_expire_time();
  static const int kExpireTimeFieldNumber = 34;
  inline ::google::protobuf::int64 expire_time() const;
  inline void set_expire_time(::google::protobuf::int64 value);

  // optional sfixed64 net_money = 35;
  inline bool has_net_money() const;
  inline void clear_net_money();
  static const int kNetMoneyFieldNumber = 35;
  inline ::google::protobuf::int64 net_money() const;
  inline void set_net_money(::google::protobuf::int64 value);

  // optional sfixed32 net_money_exponent = 36;
  inline bool has_net_money_exponent() const;
  inline void clear_net_money_exponent();
  static const int kNetMoneyExponentFieldNumber = 36;
  inline ::google::protobuf::int32 net_money_exponent() const;
  inline void set_net_money_exponent(::google::protobuf::int32 value);

  // optional sfixed64 settl_curr_amt = 37;
  inline bool has_settl_curr_amt() const;
  inline void clear_settl_curr_amt();
  static const int kSettlCurrAmtFieldNumber = 37;
  inline ::google::protobuf::int64 settl_curr_amt() const;
  inline void set_settl_curr_amt(::google::protobuf::int64 value);

  // optional sfixed32 settl_curr_amt_exponent = 38;
  inline bool has_settl_curr_amt_exponent() const;
  inline void clear_settl_curr_amt_exponent();
  static const int kSettlCurrAmtExponentFieldNumber = 38;
  inline ::google::protobuf::int32 settl_curr_amt_exponent() const;
  inline void set_settl_curr_amt_exponent(::google::protobuf::int32 value);

  // optional string settl_currency = 39;
  inline bool has_settl_currency() const;
  inline void clear_settl_currency();
  static const int kSettlCurrencyFieldNumber = 39;
  inline const ::std::string& settl_currency() const;
  inline void set_settl_currency(const ::std::string& value);
  inline void set_settl_currency(const char* value);
  inline void set_settl_currency(const char* value, size_t size);
  inline ::std::string* mutable_settl_currency();
  inline ::std::string* release_settl_currency();
  inline void set_allocated_settl_currency(::std::string* settl_currency);

  // optional .SingleGeneralOrderHandling.ExecTypeEnum exec_type = 40;
  inline bool has_exec_type() const;
  inline void clear_exec_type();
  static const int kExecTypeFieldNumber = 40;
  inline ::SingleGeneralOrderHandling::ExecTypeEnum exec_type() const;
  inline void set_exec_type(::SingleGeneralOrderHandling::ExecTypeEnum value);

  // optional sfixed64 last_forward_points = 41;
  inline bool has_last_forward_points() const;
  inline void clear_last_forward_points();
  static const int kLastForwardPointsFieldNumber = 41;
  inline ::google::protobuf::int64 last_forward_points() const;
  inline void set_last_forward_points(::google::protobuf::int64 value);

  // optional sfixed32 last_forward_points_exponent = 42;
  inline bool has_last_forward_points_exponent() const;
  inline void clear_last_forward_points_exponent();
  static const int kLastForwardPointsExponentFieldNumber = 42;
  inline ::google::protobuf::int32 last_forward_points_exponent() const;
  inline void set_last_forward_points_exponent(::google::protobuf::int32 value);

  // optional sfixed64 last_spot_rate = 43;
  inline bool has_last_spot_rate() const;
  inline void clear_last_spot_rate();
  static const int kLastSpotRateFieldNumber = 43;
  inline ::google::protobuf::int64 last_spot_rate() const;
  inline void set_last_spot_rate(::google::protobuf::int64 value);

  // optional sfixed32 last_spot_rate_exponent = 44;
  inline bool has_last_spot_rate_exponent() const;
  inline void clear_last_spot_rate_exponent();
  static const int kLastSpotRateExponentFieldNumber = 44;
  inline ::google::protobuf::int32 last_spot_rate_exponent() const;
  inline void set_last_spot_rate_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leaves_qty = 45;
  inline bool has_leaves_qty() const;
  inline void clear_leaves_qty();
  static const int kLeavesQtyFieldNumber = 45;
  inline ::google::protobuf::int64 leaves_qty() const;
  inline void set_leaves_qty(::google::protobuf::int64 value);

  // optional sfixed32 leaves_qty_exponent = 46;
  inline bool has_leaves_qty_exponent() const;
  inline void clear_leaves_qty_exponent();
  static const int kLeavesQtyExponentFieldNumber = 46;
  inline ::google::protobuf::int32 leaves_qty_exponent() const;
  inline void set_leaves_qty_exponent(::google::protobuf::int32 value);

  // optional string orig_cl_ord_id = 47;
  inline bool has_orig_cl_ord_id() const;
  inline void clear_orig_cl_ord_id();
  static const int kOrigClOrdIdFieldNumber = 47;
  inline const ::std::string& orig_cl_ord_id() const;
  inline void set_orig_cl_ord_id(const ::std::string& value);
  inline void set_orig_cl_ord_id(const char* value);
  inline void set_orig_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_orig_cl_ord_id();
  inline ::std::string* release_orig_cl_ord_id();
  inline void set_allocated_orig_cl_ord_id(::std::string* orig_cl_ord_id);

  // optional string secondary_order_id = 48;
  inline bool has_secondary_order_id() const;
  inline void clear_secondary_order_id();
  static const int kSecondaryOrderIdFieldNumber = 48;
  inline const ::std::string& secondary_order_id() const;
  inline void set_secondary_order_id(const ::std::string& value);
  inline void set_secondary_order_id(const char* value);
  inline void set_secondary_order_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_order_id();
  inline ::std::string* release_secondary_order_id();
  inline void set_allocated_secondary_order_id(::std::string* secondary_order_id);

  // optional double settl_curr_fx_rate = 49;
  inline bool has_settl_curr_fx_rate() const;
  inline void clear_settl_curr_fx_rate();
  static const int kSettlCurrFxRateFieldNumber = 49;
  inline double settl_curr_fx_rate() const;
  inline void set_settl_curr_fx_rate(double value);

  // optional .SingleGeneralOrderHandling.SettlCurrFxRateCalcEnum settl_curr_fx_rate_calc = 50;
  inline bool has_settl_curr_fx_rate_calc() const;
  inline void clear_settl_curr_fx_rate_calc();
  static const int kSettlCurrFxRateCalcFieldNumber = 50;
  inline ::SingleGeneralOrderHandling::SettlCurrFxRateCalcEnum settl_curr_fx_rate_calc() const;
  inline void set_settl_curr_fx_rate_calc(::SingleGeneralOrderHandling::SettlCurrFxRateCalcEnum value);

  // optional string compliance_id = 51;
  inline bool has_compliance_id() const;
  inline void clear_compliance_id();
  static const int kComplianceIdFieldNumber = 51;
  inline const ::std::string& compliance_id() const;
  inline void set_compliance_id(const ::std::string& value);
  inline void set_compliance_id(const char* value);
  inline void set_compliance_id(const char* value, size_t size);
  inline ::std::string* mutable_compliance_id();
  inline ::std::string* release_compliance_id();
  inline void set_allocated_compliance_id(::std::string* compliance_id);

  // optional sfixed64 day_avg_px = 52;
  inline bool has_day_avg_px() const;
  inline void clear_day_avg_px();
  static const int kDayAvgPxFieldNumber = 52;
  inline ::google::protobuf::int64 day_avg_px() const;
  inline void set_day_avg_px(::google::protobuf::int64 value);

  // optional sfixed32 day_avg_px_exponent = 53;
  inline bool has_day_avg_px_exponent() const;
  inline void clear_day_avg_px_exponent();
  static const int kDayAvgPxExponentFieldNumber = 53;
  inline ::google::protobuf::int32 day_avg_px_exponent() const;
  inline void set_day_avg_px_exponent(::google::protobuf::int32 value);

  // optional sfixed64 day_cum_qty = 54;
  inline bool has_day_cum_qty() const;
  inline void clear_day_cum_qty();
  static const int kDayCumQtyFieldNumber = 54;
  inline ::google::protobuf::int64 day_cum_qty() const;
  inline void set_day_cum_qty(::google::protobuf::int64 value);

  // optional sfixed32 day_cum_qty_exponent = 55;
  inline bool has_day_cum_qty_exponent() const;
  inline void clear_day_cum_qty_exponent();
  static const int kDayCumQtyExponentFieldNumber = 55;
  inline ::google::protobuf::int32 day_cum_qty_exponent() const;
  inline void set_day_cum_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 day_order_qty = 56;
  inline bool has_day_order_qty() const;
  inline void clear_day_order_qty();
  static const int kDayOrderQtyFieldNumber = 56;
  inline ::google::protobuf::int64 day_order_qty() const;
  inline void set_day_order_qty(::google::protobuf::int64 value);

  // optional sfixed32 day_order_qty_exponent = 57;
  inline bool has_day_order_qty_exponent() const;
  inline void clear_day_order_qty_exponent();
  static const int kDayOrderQtyExponentFieldNumber = 57;
  inline ::google::protobuf::int32 day_order_qty_exponent() const;
  inline void set_day_order_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 effective_time = 58;
  inline bool has_effective_time() const;
  inline void clear_effective_time();
  static const int kEffectiveTimeFieldNumber = 58;
  inline ::google::protobuf::int64 effective_time() const;
  inline void set_effective_time(::google::protobuf::int64 value);

  // optional bytes encoded_text = 59;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 59;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 60;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 60;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional .SingleGeneralOrderHandling.ExecRestatementReasonEnum exec_restatement_reason = 61;
  inline bool has_exec_restatement_reason() const;
  inline void clear_exec_restatement_reason();
  static const int kExecRestatementReasonFieldNumber = 61;
  inline ::SingleGeneralOrderHandling::ExecRestatementReasonEnum exec_restatement_reason() const;
  inline void set_exec_restatement_reason(::SingleGeneralOrderHandling::ExecRestatementReasonEnum value);

  // optional sfixed32 expire_date = 62;
  inline bool has_expire_date() const;
  inline void clear_expire_date();
  static const int kExpireDateFieldNumber = 62;
  inline ::google::protobuf::int32 expire_date() const;
  inline void set_expire_date(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.GtBookingInstEnum gt_booking_inst = 63;
  inline bool has_gt_booking_inst() const;
  inline void clear_gt_booking_inst();
  static const int kGtBookingInstFieldNumber = 63;
  inline ::SingleGeneralOrderHandling::GtBookingInstEnum gt_booking_inst() const;
  inline void set_gt_booking_inst(::SingleGeneralOrderHandling::GtBookingInstEnum value);

  // optional sfixed64 gross_trade_amt = 64;
  inline bool has_gross_trade_amt() const;
  inline void clear_gross_trade_amt();
  static const int kGrossTradeAmtFieldNumber = 64;
  inline ::google::protobuf::int64 gross_trade_amt() const;
  inline void set_gross_trade_amt(::google::protobuf::int64 value);

  // optional sfixed32 gross_trade_amt_exponent = 65;
  inline bool has_gross_trade_amt_exponent() const;
  inline void clear_gross_trade_amt_exponent();
  static const int kGrossTradeAmtExponentFieldNumber = 65;
  inline ::google::protobuf::int32 gross_trade_amt_exponent() const;
  inline void set_gross_trade_amt_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.HandlInstEnum handl_inst = 66;
  inline bool has_handl_inst() const;
  inline void clear_handl_inst();
  static const int kHandlInstFieldNumber = 66;
  inline ::SingleGeneralOrderHandling::HandlInstEnum handl_inst() const;
  inline void set_handl_inst(::SingleGeneralOrderHandling::HandlInstEnum value);

  // optional sfixed64 max_floor = 67;
  inline bool has_max_floor() const;
  inline void clear_max_floor();
  static const int kMaxFloorFieldNumber = 67;
  inline ::google::protobuf::int64 max_floor() const;
  inline void set_max_floor(::google::protobuf::int64 value);

  // optional sfixed32 max_floor_exponent = 68;
  inline bool has_max_floor_exponent() const;
  inline void clear_max_floor_exponent();
  static const int kMaxFloorExponentFieldNumber = 68;
  inline ::google::protobuf::int32 max_floor_exponent() const;
  inline void set_max_floor_exponent(::google::protobuf::int32 value);

  // optional sfixed64 max_show = 69;
  inline bool has_max_show() const;
  inline void clear_max_show();
  static const int kMaxShowFieldNumber = 69;
  inline ::google::protobuf::int64 max_show() const;
  inline void set_max_show(::google::protobuf::int64 value);

  // optional sfixed32 max_show_exponent = 70;
  inline bool has_max_show_exponent() const;
  inline void clear_max_show_exponent();
  static const int kMaxShowExponentFieldNumber = 70;
  inline ::google::protobuf::int32 max_show_exponent() const;
  inline void set_max_show_exponent(::google::protobuf::int32 value);

  // optional sfixed64 min_qty = 71;
  inline bool has_min_qty() const;
  inline void clear_min_qty();
  static const int kMinQtyFieldNumber = 71;
  inline ::google::protobuf::int64 min_qty() const;
  inline void set_min_qty(::google::protobuf::int64 value);

  // optional sfixed32 min_qty_exponent = 72;
  inline bool has_min_qty_exponent() const;
  inline void clear_min_qty_exponent();
  static const int kMinQtyExponentFieldNumber = 72;
  inline ::google::protobuf::int32 min_qty_exponent() const;
  inline void set_min_qty_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.MultiLegReportingTypeEnum multi_leg_reporting_type = 73;
  inline bool has_multi_leg_reporting_type() const;
  inline void clear_multi_leg_reporting_type();
  static const int kMultiLegReportingTypeFieldNumber = 73;
  inline ::SingleGeneralOrderHandling::MultiLegReportingTypeEnum multi_leg_reporting_type() const;
  inline void set_multi_leg_reporting_type(::SingleGeneralOrderHandling::MultiLegReportingTypeEnum value);

  // optional sfixed64 order_qty2 = 74;
  inline bool has_order_qty2() const;
  inline void clear_order_qty2();
  static const int kOrderQty2FieldNumber = 74;
  inline ::google::protobuf::int64 order_qty2() const;
  inline void set_order_qty2(::google::protobuf::int64 value);

  // optional sfixed32 order_qty2_exponent = 75;
  inline bool has_order_qty2_exponent() const;
  inline void clear_order_qty2_exponent();
  static const int kOrderQty2ExponentFieldNumber = 75;
  inline ::google::protobuf::int32 order_qty2_exponent() const;
  inline void set_order_qty2_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.PositionEffectEnum position_effect = 76;
  inline bool has_position_effect() const;
  inline void clear_position_effect();
  static const int kPositionEffectFieldNumber = 76;
  inline ::SingleGeneralOrderHandling::PositionEffectEnum position_effect() const;
  inline void set_position_effect(::SingleGeneralOrderHandling::PositionEffectEnum value);

  // optional sfixed32 settl_date2 = 77;
  inline bool has_settl_date2() const;
  inline void clear_settl_date2();
  static const int kSettlDate2FieldNumber = 77;
  inline ::google::protobuf::int32 settl_date2() const;
  inline void set_settl_date2(::google::protobuf::int32 value);

  // optional bool solicited_flag = 78;
  inline bool has_solicited_flag() const;
  inline void clear_solicited_flag();
  static const int kSolicitedFlagFieldNumber = 78;
  inline bool solicited_flag() const;
  inline void set_solicited_flag(bool value);

  // optional .SingleGeneralOrderHandling.TradingSessionIdEnum trading_session_id = 79;
  inline bool has_trading_session_id() const;
  inline void clear_trading_session_id();
  static const int kTradingSessionIdFieldNumber = 79;
  inline ::SingleGeneralOrderHandling::TradingSessionIdEnum trading_session_id() const;
  inline void set_trading_session_id(::SingleGeneralOrderHandling::TradingSessionIdEnum value);

  // optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 80;
  inline bool has_account_type() const;
  inline void clear_account_type();
  static const int kAccountTypeFieldNumber = 80;
  inline ::SingleGeneralOrderHandling::AccountTypeEnum account_type() const;
  inline void set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value);

  // optional sfixed64 accrued_interest_amt = 81;
  inline bool has_accrued_interest_amt() const;
  inline void clear_accrued_interest_amt();
  static const int kAccruedInterestAmtFieldNumber = 81;
  inline ::google::protobuf::int64 accrued_interest_amt() const;
  inline void set_accrued_interest_amt(::google::protobuf::int64 value);

  // optional sfixed32 accrued_interest_amt_exponent = 82;
  inline bool has_accrued_interest_amt_exponent() const;
  inline void clear_accrued_interest_amt_exponent();
  static const int kAccruedInterestAmtExponentFieldNumber = 82;
  inline ::google::protobuf::int32 accrued_interest_amt_exponent() const;
  inline void set_accrued_interest_amt_exponent(::google::protobuf::int32 value);

  // optional sfixed64 accrued_interest_rate = 83;
  inline bool has_accrued_interest_rate() const;
  inline void clear_accrued_interest_rate();
  static const int kAccruedInterestRateFieldNumber = 83;
  inline ::google::protobuf::int64 accrued_interest_rate() const;
  inline void set_accrued_interest_rate(::google::protobuf::int64 value);

  // optional sfixed32 accrued_interest_rate_exponent = 84;
  inline bool has_accrued_interest_rate_exponent() const;
  inline void clear_accrued_interest_rate_exponent();
  static const int kAccruedInterestRateExponentFieldNumber = 84;
  inline ::google::protobuf::int32 accrued_interest_rate_exponent() const;
  inline void set_accrued_interest_rate_exponent(::google::protobuf::int32 value);

  // optional sfixed32 basis_feature_date = 85;
  inline bool has_basis_feature_date() const;
  inline void clear_basis_feature_date();
  static const int kBasisFeatureDateFieldNumber = 85;
  inline ::google::protobuf::int32 basis_feature_date() const;
  inline void set_basis_feature_date(::google::protobuf::int32 value);

  // optional sfixed64 basis_feature_price = 86;
  inline bool has_basis_feature_price() const;
  inline void clear_basis_feature_price();
  static const int kBasisFeaturePriceFieldNumber = 86;
  inline ::google::protobuf::int64 basis_feature_price() const;
  inline void set_basis_feature_price(::google::protobuf::int64 value);

  // optional sfixed32 basis_feature_price_exponent = 87;
  inline bool has_basis_feature_price_exponent() const;
  inline void clear_basis_feature_price_exponent();
  static const int kBasisFeaturePriceExponentFieldNumber = 87;
  inline ::google::protobuf::int32 basis_feature_price_exponent() const;
  inline void set_basis_feature_price_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.BookingUnitEnum booking_unit = 88;
  inline bool has_booking_unit() const;
  inline void clear_booking_unit();
  static const int kBookingUnitFieldNumber = 88;
  inline ::SingleGeneralOrderHandling::BookingUnitEnum booking_unit() const;
  inline void set_booking_unit(::SingleGeneralOrderHandling::BookingUnitEnum value);

  // optional .SingleGeneralOrderHandling.CancellationRightsEnum cancellation_rights = 89;
  inline bool has_cancellation_rights() const;
  inline void clear_cancellation_rights();
  static const int kCancellationRightsFieldNumber = 89;
  inline ::SingleGeneralOrderHandling::CancellationRightsEnum cancellation_rights() const;
  inline void set_cancellation_rights(::SingleGeneralOrderHandling::CancellationRightsEnum value);

  // optional .SingleGeneralOrderHandling.CashMarginEnum cash_margin = 90;
  inline bool has_cash_margin() const;
  inline void clear_cash_margin();
  static const int kCashMarginFieldNumber = 90;
  inline ::SingleGeneralOrderHandling::CashMarginEnum cash_margin() const;
  inline void set_cash_margin(::SingleGeneralOrderHandling::CashMarginEnum value);

  // optional string cl_ord_link_id = 91;
  inline bool has_cl_ord_link_id() const;
  inline void clear_cl_ord_link_id();
  static const int kClOrdLinkIdFieldNumber = 91;
  inline const ::std::string& cl_ord_link_id() const;
  inline void set_cl_ord_link_id(const ::std::string& value);
  inline void set_cl_ord_link_id(const char* value);
  inline void set_cl_ord_link_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_link_id();
  inline ::std::string* release_cl_ord_link_id();
  inline void set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id);

  // optional .SingleGeneralOrderHandling.ClearingFeeIndicatorEnum clearing_fee_indicator = 92;
  inline bool has_clearing_fee_indicator() const;
  inline void clear_clearing_fee_indicator();
  static const int kClearingFeeIndicatorFieldNumber = 92;
  inline ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum clearing_fee_indicator() const;
  inline void set_clearing_fee_indicator(::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum value);

  // optional .Common.CommissionData commission_data = 93;
  inline bool has_commission_data() const;
  inline void clear_commission_data();
  static const int kCommissionDataFieldNumber = 93;
  inline const ::Common::CommissionData& commission_data() const;
  inline ::Common::CommissionData* mutable_commission_data();
  inline ::Common::CommissionData* release_commission_data();
  inline void set_allocated_commission_data(::Common::CommissionData* commission_data);

  // optional sfixed64 concession = 94;
  inline bool has_concession() const;
  inline void clear_concession();
  static const int kConcessionFieldNumber = 94;
  inline ::google::protobuf::int64 concession() const;
  inline void set_concession(::google::protobuf::int64 value);

  // optional sfixed32 concession_exponent = 95;
  inline bool has_concession_exponent() const;
  inline void clear_concession_exponent();
  static const int kConcessionExponentFieldNumber = 95;
  inline ::google::protobuf::int32 concession_exponent() const;
  inline void set_concession_exponent(::google::protobuf::int32 value);

  // optional string cross_id = 96;
  inline bool has_cross_id() const;
  inline void clear_cross_id();
  static const int kCrossIdFieldNumber = 96;
  inline const ::std::string& cross_id() const;
  inline void set_cross_id(const ::std::string& value);
  inline void set_cross_id(const char* value);
  inline void set_cross_id(const char* value, size_t size);
  inline ::std::string* mutable_cross_id();
  inline ::std::string* release_cross_id();
  inline void set_allocated_cross_id(::std::string* cross_id);

  // optional .SingleGeneralOrderHandling.CrossTypeEnum cross_type = 97;
  inline bool has_cross_type() const;
  inline void clear_cross_type();
  static const int kCrossTypeFieldNumber = 97;
  inline ::SingleGeneralOrderHandling::CrossTypeEnum cross_type() const;
  inline void set_cross_type(::SingleGeneralOrderHandling::CrossTypeEnum value);

  // optional .SingleGeneralOrderHandling.CustOrderCapacityEnum cust_order_capacity = 98;
  inline bool has_cust_order_capacity() const;
  inline void clear_cust_order_capacity();
  static const int kCustOrderCapacityFieldNumber = 98;
  inline ::SingleGeneralOrderHandling::CustOrderCapacityEnum cust_order_capacity() const;
  inline void set_cust_order_capacity(::SingleGeneralOrderHandling::CustOrderCapacityEnum value);

  // optional .SingleGeneralOrderHandling.DayBookingInstEnum day_booking_inst = 99;
  inline bool has_day_booking_inst() const;
  inline void clear_day_booking_inst();
  static const int kDayBookingInstFieldNumber = 99;
  inline ::SingleGeneralOrderHandling::DayBookingInstEnum day_booking_inst() const;
  inline void set_day_booking_inst(::SingleGeneralOrderHandling::DayBookingInstEnum value);

  // optional string designation = 100;
  inline bool has_designation() const;
  inline void clear_designation();
  static const int kDesignationFieldNumber = 100;
  inline const ::std::string& designation() const;
  inline void set_designation(const ::std::string& value);
  inline void set_designation(const char* value);
  inline void set_designation(const char* value, size_t size);
  inline ::std::string* mutable_designation();
  inline ::std::string* release_designation();
  inline void set_allocated_designation(::std::string* designation);

  // optional sfixed32 ex_date = 101;
  inline bool has_ex_date() const;
  inline void clear_ex_date();
  static const int kExDateFieldNumber = 101;
  inline ::google::protobuf::int32 ex_date() const;
  inline void set_ex_date(::google::protobuf::int32 value);

  // optional double exec_price_adjustment = 102;
  inline bool has_exec_price_adjustment() const;
  inline void clear_exec_price_adjustment();
  static const int kExecPriceAdjustmentFieldNumber = 102;
  inline double exec_price_adjustment() const;
  inline void set_exec_price_adjustment(double value);

  // optional .SingleGeneralOrderHandling.ExecPriceTypeEnum exec_price_type = 103;
  inline bool has_exec_price_type() const;
  inline void clear_exec_price_type();
  static const int kExecPriceTypeFieldNumber = 103;
  inline ::SingleGeneralOrderHandling::ExecPriceTypeEnum exec_price_type() const;
  inline void set_exec_price_type(::SingleGeneralOrderHandling::ExecPriceTypeEnum value);

  // optional sfixed64 exec_valuation_point = 104;
  inline bool has_exec_valuation_point() const;
  inline void clear_exec_valuation_point();
  static const int kExecValuationPointFieldNumber = 104;
  inline ::google::protobuf::int64 exec_valuation_point() const;
  inline void set_exec_valuation_point(::google::protobuf::int64 value);

  // optional .Common.Instrument instrument = 105;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 105;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional sfixed64 last_forward_points2 = 106;
  inline bool has_last_forward_points2() const;
  inline void clear_last_forward_points2();
  static const int kLastForwardPoints2FieldNumber = 106;
  inline ::google::protobuf::int64 last_forward_points2() const;
  inline void set_last_forward_points2(::google::protobuf::int64 value);

  // optional sfixed32 last_forward_points2_exponent = 107;
  inline bool has_last_forward_points2_exponent() const;
  inline void clear_last_forward_points2_exponent();
  static const int kLastForwardPoints2ExponentFieldNumber = 107;
  inline ::google::protobuf::int32 last_forward_points2_exponent() const;
  inline void set_last_forward_points2_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.MoneyLaunderingStatusEnum money_laundering_status = 108;
  inline bool has_money_laundering_status() const;
  inline void clear_money_laundering_status();
  static const int kMoneyLaunderingStatusFieldNumber = 108;
  inline ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum money_laundering_status() const;
  inline void set_money_laundering_status(::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum value);

  // optional sfixed64 num_days_interest = 109;
  inline bool has_num_days_interest() const;
  inline void clear_num_days_interest();
  static const int kNumDaysInterestFieldNumber = 109;
  inline ::google::protobuf::int64 num_days_interest() const;
  inline void set_num_days_interest(::google::protobuf::int64 value);

  // optional .SingleGeneralOrderHandling.OrderCapacityEnum order_capacity = 110;
  inline bool has_order_capacity() const;
  inline void clear_order_capacity();
  static const int kOrderCapacityFieldNumber = 110;
  inline ::SingleGeneralOrderHandling::OrderCapacityEnum order_capacity() const;
  inline void set_order_capacity(::SingleGeneralOrderHandling::OrderCapacityEnum value);

  // optional .Common.OrderQtyData order_qty_data = 111;
  inline bool has_order_qty_data() const;
  inline void clear_order_qty_data();
  static const int kOrderQtyDataFieldNumber = 111;
  inline const ::Common::OrderQtyData& order_qty_data() const;
  inline ::Common::OrderQtyData* mutable_order_qty_data();
  inline ::Common::OrderQtyData* release_order_qty_data();
  inline void set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data);

  // repeated .SingleGeneralOrderHandling.OrderRestrictionsEnum order_restrictions = 112 [packed = true];
  inline int order_restrictions_size() const;
  inline void clear_order_restrictions();
  static const int kOrderRestrictionsFieldNumber = 112;
  inline ::SingleGeneralOrderHandling::OrderRestrictionsEnum order_restrictions(int index) const;
  inline void set_order_restrictions(int index, ::SingleGeneralOrderHandling::OrderRestrictionsEnum value);
  inline void add_order_restrictions(::SingleGeneralOrderHandling::OrderRestrictionsEnum value);
  inline const ::google::protobuf::RepeatedField<int>& order_restrictions() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_order_restrictions();

  // optional string orig_cross_id = 113;
  inline bool has_orig_cross_id() const;
  inline void clear_orig_cross_id();
  static const int kOrigCrossIdFieldNumber = 113;
  inline const ::std::string& orig_cross_id() const;
  inline void set_orig_cross_id(const ::std::string& value);
  inline void set_orig_cross_id(const char* value);
  inline void set_orig_cross_id(const char* value, size_t size);
  inline ::std::string* mutable_orig_cross_id();
  inline ::std::string* release_orig_cross_id();
  inline void set_allocated_orig_cross_id(::std::string* orig_cross_id);

  // repeated .Common.Parties parties = 114;
  inline int parties_size() const;
  inline void clear_parties();
  static const int kPartiesFieldNumber = 114;
  inline const ::Common::Parties& parties(int index) const;
  inline ::Common::Parties* mutable_parties(int index);
  inline ::Common::Parties* add_parties();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
      parties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
      mutable_parties();

  // optional .SingleGeneralOrderHandling.PreallocMethodEnum prealloc_method = 115;
  inline bool has_prealloc_method() const;
  inline void clear_prealloc_method();
  static const int kPreallocMethodFieldNumber = 115;
  inline ::SingleGeneralOrderHandling::PreallocMethodEnum prealloc_method() const;
  inline void set_prealloc_method(::SingleGeneralOrderHandling::PreallocMethodEnum value);

  // optional sfixed64 price_improvement = 116;
  inline bool has_price_improvement() const;
  inline void clear_price_improvement();
  static const int kPriceImprovementFieldNumber = 116;
  inline ::google::protobuf::int64 price_improvement() const;
  inline void set_price_improvement(::google::protobuf::int64 value);

  // optional sfixed32 price_improvement_exponent = 117;
  inline bool has_price_improvement_exponent() const;
  inline void clear_price_improvement_exponent();
  static const int kPriceImprovementExponentFieldNumber = 117;
  inline ::google::protobuf::int32 price_improvement_exponent() const;
  inline void set_price_improvement_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.PriceTypeEnum price_type = 118;
  inline bool has_price_type() const;
  inline void clear_price_type();
  static const int kPriceTypeFieldNumber = 118;
  inline ::SingleGeneralOrderHandling::PriceTypeEnum price_type() const;
  inline void set_price_type(::SingleGeneralOrderHandling::PriceTypeEnum value);

  // optional .SingleGeneralOrderHandling.PriorityIndicatorEnum priority_indicator = 119;
  inline bool has_priority_indicator() const;
  inline void clear_priority_indicator();
  static const int kPriorityIndicatorFieldNumber = 119;
  inline ::SingleGeneralOrderHandling::PriorityIndicatorEnum priority_indicator() const;
  inline void set_priority_indicator(::SingleGeneralOrderHandling::PriorityIndicatorEnum value);

  // optional string regist_id = 120;
  inline bool has_regist_id() const;
  inline void clear_regist_id();
  static const int kRegistIdFieldNumber = 120;
  inline const ::std::string& regist_id() const;
  inline void set_regist_id(const ::std::string& value);
  inline void set_regist_id(const char* value);
  inline void set_regist_id(const char* value, size_t size);
  inline ::std::string* mutable_regist_id();
  inline ::std::string* release_regist_id();
  inline void set_allocated_regist_id(::std::string* regist_id);

  // optional string secondary_cl_ord_id = 121;
  inline bool has_secondary_cl_ord_id() const;
  inline void clear_secondary_cl_ord_id();
  static const int kSecondaryClOrdIdFieldNumber = 121;
  inline const ::std::string& secondary_cl_ord_id() const;
  inline void set_secondary_cl_ord_id(const ::std::string& value);
  inline void set_secondary_cl_ord_id(const char* value);
  inline void set_secondary_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_cl_ord_id();
  inline ::std::string* release_secondary_cl_ord_id();
  inline void set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id);

  // optional string secondary_exec_id = 122;
  inline bool has_secondary_exec_id() const;
  inline void clear_secondary_exec_id();
  static const int kSecondaryExecIdFieldNumber = 122;
  inline const ::std::string& secondary_exec_id() const;
  inline void set_secondary_exec_id(const ::std::string& value);
  inline void set_secondary_exec_id(const char* value);
  inline void set_secondary_exec_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_exec_id();
  inline ::std::string* release_secondary_exec_id();
  inline void set_allocated_secondary_exec_id(::std::string* secondary_exec_id);

  // optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 123;
  inline bool has_spread_or_benchmark_curve_data() const;
  inline void clear_spread_or_benchmark_curve_data();
  static const int kSpreadOrBenchmarkCurveDataFieldNumber = 123;
  inline const ::Common::SpreadOrBenchmarkCurveData& spread_or_benchmark_curve_data() const;
  inline ::Common::SpreadOrBenchmarkCurveData* mutable_spread_or_benchmark_curve_data();
  inline ::Common::SpreadOrBenchmarkCurveData* release_spread_or_benchmark_curve_data();
  inline void set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data);

  // repeated .Common.Stipulations stipulations = 124;
  inline int stipulations_size() const;
  inline void clear_stipulations();
  static const int kStipulationsFieldNumber = 124;
  inline const ::Common::Stipulations& stipulations(int index) const;
  inline ::Common::Stipulations* mutable_stipulations(int index);
  inline ::Common::Stipulations* add_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
      stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
      mutable_stipulations();

  // optional sfixed64 total_takedown = 125;
  inline bool has_total_takedown() const;
  inline void clear_total_takedown();
  static const int kTotalTakedownFieldNumber = 125;
  inline ::google::protobuf::int64 total_takedown() const;
  inline void set_total_takedown(::google::protobuf::int64 value);

  // optional sfixed32 total_takedown_exponent = 126;
  inline bool has_total_takedown_exponent() const;
  inline void clear_total_takedown_exponent();
  static const int kTotalTakedownExponentFieldNumber = 126;
  inline ::google::protobuf::int32 total_takedown_exponent() const;
  inline void set_total_takedown_exponent(::google::protobuf::int32 value);

  // optional sfixed32 trade_origination_date = 127;
  inline bool has_trade_origination_date() const;
  inline void clear_trade_origination_date();
  static const int kTradeOriginationDateFieldNumber = 127;
  inline ::google::protobuf::int32 trade_origination_date() const;
  inline void set_trade_origination_date(::google::protobuf::int32 value);

  // optional bool traded_flat_switch = 128;
  inline bool has_traded_flat_switch() const;
  inline void clear_traded_flat_switch();
  static const int kTradedFlatSwitchFieldNumber = 128;
  inline bool traded_flat_switch() const;
  inline void set_traded_flat_switch(bool value);

  // optional .SingleGeneralOrderHandling.TradingSessionSubIdEnum trading_session_sub_id = 129;
  inline bool has_trading_session_sub_id() const;
  inline void clear_trading_session_sub_id();
  static const int kTradingSessionSubIdFieldNumber = 129;
  inline ::SingleGeneralOrderHandling::TradingSessionSubIdEnum trading_session_sub_id() const;
  inline void set_trading_session_sub_id(::SingleGeneralOrderHandling::TradingSessionSubIdEnum value);

  // optional sfixed64 trans_bkd_time = 130;
  inline bool has_trans_bkd_time() const;
  inline void clear_trans_bkd_time();
  static const int kTransBkdTimeFieldNumber = 130;
  inline ::google::protobuf::int64 trans_bkd_time() const;
  inline void set_trans_bkd_time(::google::protobuf::int64 value);

  // optional sfixed64 underlying_last_px = 131;
  inline bool has_underlying_last_px() const;
  inline void clear_underlying_last_px();
  static const int kUnderlyingLastPxFieldNumber = 131;
  inline ::google::protobuf::int64 underlying_last_px() const;
  inline void set_underlying_last_px(::google::protobuf::int64 value);

  // optional sfixed32 underlying_last_px_exponent = 132;
  inline bool has_underlying_last_px_exponent() const;
  inline void clear_underlying_last_px_exponent();
  static const int kUnderlyingLastPxExponentFieldNumber = 132;
  inline ::google::protobuf::int32 underlying_last_px_exponent() const;
  inline void set_underlying_last_px_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_last_qty = 133;
  inline bool has_underlying_last_qty() const;
  inline void clear_underlying_last_qty();
  static const int kUnderlyingLastQtyFieldNumber = 133;
  inline ::google::protobuf::int64 underlying_last_qty() const;
  inline void set_underlying_last_qty(::google::protobuf::int64 value);

  // optional sfixed32 underlying_last_qty_exponent = 134;
  inline bool has_underlying_last_qty_exponent() const;
  inline void clear_underlying_last_qty_exponent();
  static const int kUnderlyingLastQtyExponentFieldNumber = 134;
  inline ::google::protobuf::int32 underlying_last_qty_exponent() const;
  inline void set_underlying_last_qty_exponent(::google::protobuf::int32 value);

  // optional bool working_indicator = 135;
  inline bool has_working_indicator() const;
  inline void clear_working_indicator();
  static const int kWorkingIndicatorFieldNumber = 135;
  inline bool working_indicator() const;
  inline void set_working_indicator(bool value);

  // optional .Common.YieldData yield_data = 136;
  inline bool has_yield_data() const;
  inline void clear_yield_data();
  static const int kYieldDataFieldNumber = 136;
  inline const ::Common::YieldData& yield_data() const;
  inline ::Common::YieldData* mutable_yield_data();
  inline ::Common::YieldData* release_yield_data();
  inline void set_allocated_yield_data(::Common::YieldData* yield_data);

  // optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 137;
  inline bool has_acct_id_source() const;
  inline void clear_acct_id_source();
  static const int kAcctIdSourceFieldNumber = 137;
  inline ::SingleGeneralOrderHandling::AcctIdSourceEnum acct_id_source() const;
  inline void set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value);

  // optional bool aggressor_indicator = 138;
  inline bool has_aggressor_indicator() const;
  inline void clear_aggressor_indicator();
  static const int kAggressorIndicatorFieldNumber = 138;
  inline bool aggressor_indicator() const;
  inline void set_aggressor_indicator(bool value);

  // optional .SingleGeneralOrderHandling.BookingTypeEnum booking_type = 139;
  inline bool has_booking_type() const;
  inline void clear_booking_type();
  static const int kBookingTypeFieldNumber = 139;
  inline ::SingleGeneralOrderHandling::BookingTypeEnum booking_type() const;
  inline void set_booking_type(::SingleGeneralOrderHandling::BookingTypeEnum value);

  // optional sfixed64 calculated_ccy_last_qty = 140;
  inline bool has_calculated_ccy_last_qty() const;
  inline void clear_calculated_ccy_last_qty();
  static const int kCalculatedCcyLastQtyFieldNumber = 140;
  inline ::google::protobuf::int64 calculated_ccy_last_qty() const;
  inline void set_calculated_ccy_last_qty(::google::protobuf::int64 value);

  // optional sfixed32 calculated_ccy_last_qty_exponent = 141;
  inline bool has_calculated_ccy_last_qty_exponent() const;
  inline void clear_calculated_ccy_last_qty_exponent();
  static const int kCalculatedCcyLastQtyExponentFieldNumber = 141;
  inline ::google::protobuf::int32 calculated_ccy_last_qty_exponent() const;
  inline void set_calculated_ccy_last_qty_exponent(::google::protobuf::int32 value);

  // repeated .Common.ContAmtGrp cont_amt_grp = 142;
  inline int cont_amt_grp_size() const;
  inline void clear_cont_amt_grp();
  static const int kContAmtGrpFieldNumber = 142;
  inline const ::Common::ContAmtGrp& cont_amt_grp(int index) const;
  inline ::Common::ContAmtGrp* mutable_cont_amt_grp(int index);
  inline ::Common::ContAmtGrp* add_cont_amt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::ContAmtGrp >&
      cont_amt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::ContAmtGrp >*
      mutable_cont_amt_grp();

  // repeated .Common.ContraGrp contra_grp = 143;
  inline int contra_grp_size() const;
  inline void clear_contra_grp();
  static const int kContraGrpFieldNumber = 143;
  inline const ::Common::ContraGrp& contra_grp(int index) const;
  inline ::Common::ContraGrp* mutable_contra_grp(int index);
  inline ::Common::ContraGrp* add_contra_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::ContraGrp >&
      contra_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::ContraGrp >*
      mutable_contra_grp();

  // optional bool copy_msg_indicator = 144;
  inline bool has_copy_msg_indicator() const;
  inline void clear_copy_msg_indicator();
  static const int kCopyMsgIndicatorFieldNumber = 144;
  inline bool copy_msg_indicator() const;
  inline void set_copy_msg_indicator(bool value);

  // optional bool cust_directed_order = 145;
  inline bool has_cust_directed_order() const;
  inline void clear_cust_directed_order();
  static const int kCustDirectedOrderFieldNumber = 145;
  inline bool cust_directed_order() const;
  inline void set_cust_directed_order(bool value);

  // optional .SingleGeneralOrderHandling.CustOrderHandlingInstEnum cust_order_handling_inst = 146;
  inline bool has_cust_order_handling_inst() const;
  inline void clear_cust_order_handling_inst();
  static const int kCustOrderHandlingInstFieldNumber = 146;
  inline ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum cust_order_handling_inst() const;
  inline void set_cust_order_handling_inst(::SingleGeneralOrderHandling::CustOrderHandlingInstEnum value);

  // optional .Common.DiscretionInstructions discretion_instructions = 147;
  inline bool has_discretion_instructions() const;
  inline void clear_discretion_instructions();
  static const int kDiscretionInstructionsFieldNumber = 147;
  inline const ::Common::DiscretionInstructions& discretion_instructions() const;
  inline ::Common::DiscretionInstructions* mutable_discretion_instructions();
  inline ::Common::DiscretionInstructions* release_discretion_instructions();
  inline void set_allocated_discretion_instructions(::Common::DiscretionInstructions* discretion_instructions);

  // optional sfixed64 discretion_price = 148;
  inline bool has_discretion_price() const;
  inline void clear_discretion_price();
  static const int kDiscretionPriceFieldNumber = 148;
  inline ::google::protobuf::int64 discretion_price() const;
  inline void set_discretion_price(::google::protobuf::int64 value);

  // optional sfixed32 discretion_price_exponent = 149;
  inline bool has_discretion_price_exponent() const;
  inline void clear_discretion_price_exponent();
  static const int kDiscretionPriceExponentFieldNumber = 149;
  inline ::google::protobuf::int32 discretion_price_exponent() const;
  inline void set_discretion_price_exponent(::google::protobuf::int32 value);

  // optional .Common.DisplayInstruction display_instruction = 150;
  inline bool has_display_instruction() const;
  inline void clear_display_instruction();
  static const int kDisplayInstructionFieldNumber = 150;
  inline const ::Common::DisplayInstruction& display_instruction() const;
  inline ::Common::DisplayInstruction* mutable_display_instruction();
  inline ::Common::DisplayInstruction* release_display_instruction();
  inline void set_allocated_display_instruction(::Common::DisplayInstruction* display_instruction);

  // optional sfixed64 end_accrued_interest_amt = 151;
  inline bool has_end_accrued_interest_amt() const;
  inline void clear_end_accrued_interest_amt();
  static const int kEndAccruedInterestAmtFieldNumber = 151;
  inline ::google::protobuf::int64 end_accrued_interest_amt() const;
  inline void set_end_accrued_interest_amt(::google::protobuf::int64 value);

  // optional sfixed32 end_accrued_interest_amt_exponent = 152;
  inline bool has_end_accrued_interest_amt_exponent() const;
  inline void clear_end_accrued_interest_amt_exponent();
  static const int kEndAccruedInterestAmtExponentFieldNumber = 152;
  inline ::google::protobuf::int32 end_accrued_interest_amt_exponent() const;
  inline void set_end_accrued_interest_amt_exponent(::google::protobuf::int32 value);

  // optional sfixed64 end_cash = 153;
  inline bool has_end_cash() const;
  inline void clear_end_cash();
  static const int kEndCashFieldNumber = 153;
  inline ::google::protobuf::int64 end_cash() const;
  inline void set_end_cash(::google::protobuf::int64 value);

  // optional sfixed32 end_cash_exponent = 154;
  inline bool has_end_cash_exponent() const;
  inline void clear_end_cash_exponent();
  static const int kEndCashExponentFieldNumber = 154;
  inline ::google::protobuf::int32 end_cash_exponent() const;
  inline void set_end_cash_exponent(::google::protobuf::int32 value);

  // optional .Common.FinancingDetails financing_details = 155;
  inline bool has_financing_details() const;
  inline void clear_financing_details();
  static const int kFinancingDetailsFieldNumber = 155;
  inline const ::Common::FinancingDetails& financing_details() const;
  inline ::Common::FinancingDetails* mutable_financing_details();
  inline ::Common::FinancingDetails* release_financing_details();
  inline void set_allocated_financing_details(::Common::FinancingDetails* financing_details);

  // optional string host_cross_id = 156;
  inline bool has_host_cross_id() const;
  inline void clear_host_cross_id();
  static const int kHostCrossIdFieldNumber = 156;
  inline const ::std::string& host_cross_id() const;
  inline void set_host_cross_id(const ::std::string& value);
  inline void set_host_cross_id(const char* value);
  inline void set_host_cross_id(const char* value, size_t size);
  inline ::std::string* mutable_host_cross_id();
  inline ::std::string* release_host_cross_id();
  inline void set_allocated_host_cross_id(::std::string* host_cross_id);

  // repeated .Common.InstrmtLegExecGrp instrmt_leg_exec_grp = 157;
  inline int instrmt_leg_exec_grp_size() const;
  inline void clear_instrmt_leg_exec_grp();
  static const int kInstrmtLegExecGrpFieldNumber = 157;
  inline const ::Common::InstrmtLegExecGrp& instrmt_leg_exec_grp(int index) const;
  inline ::Common::InstrmtLegExecGrp* mutable_instrmt_leg_exec_grp(int index);
  inline ::Common::InstrmtLegExecGrp* add_instrmt_leg_exec_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegExecGrp >&
      instrmt_leg_exec_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegExecGrp >*
      mutable_instrmt_leg_exec_grp();

  // optional sfixed64 interest_at_maturity = 158;
  inline bool has_interest_at_maturity() const;
  inline void clear_interest_at_maturity();
  static const int kInterestAtMaturityFieldNumber = 158;
  inline ::google::protobuf::int64 interest_at_maturity() const;
  inline void set_interest_at_maturity(::google::protobuf::int64 value);

  // optional sfixed32 interest_at_maturity_exponent = 159;
  inline bool has_interest_at_maturity_exponent() const;
  inline void clear_interest_at_maturity_exponent();
  static const int kInterestAtMaturityExponentFieldNumber = 159;
  inline ::google::protobuf::int32 interest_at_maturity_exponent() const;
  inline void set_interest_at_maturity_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.LastLiquidityIndEnum last_liquidity_ind = 160;
  inline bool has_last_liquidity_ind() const;
  inline void clear_last_liquidity_ind();
  static const int kLastLiquidityIndFieldNumber = 160;
  inline ::SingleGeneralOrderHandling::LastLiquidityIndEnum last_liquidity_ind() const;
  inline void set_last_liquidity_ind(::SingleGeneralOrderHandling::LastLiquidityIndEnum value);

  // optional sfixed64 last_par_px = 161;
  inline bool has_last_par_px() const;
  inline void clear_last_par_px();
  static const int kLastParPxFieldNumber = 161;
  inline ::google::protobuf::int64 last_par_px() const;
  inline void set_last_par_px(::google::protobuf::int64 value);

  // optional sfixed32 last_par_px_exponent = 162;
  inline bool has_last_par_px_exponent() const;
  inline void clear_last_par_px_exponent();
  static const int kLastParPxExponentFieldNumber = 162;
  inline ::google::protobuf::int32 last_par_px_exponent() const;
  inline void set_last_par_px_exponent(::google::protobuf::int32 value);

  // optional bool last_rpt_requested = 163;
  inline bool has_last_rpt_requested() const;
  inline void clear_last_rpt_requested();
  static const int kLastRptRequestedFieldNumber = 163;
  inline bool last_rpt_requested() const;
  inline void set_last_rpt_requested(bool value);

  // optional sfixed64 last_swap_points = 164;
  inline bool has_last_swap_points() const;
  inline void clear_last_swap_points();
  static const int kLastSwapPointsFieldNumber = 164;
  inline ::google::protobuf::int64 last_swap_points() const;
  inline void set_last_swap_points(::google::protobuf::int64 value);

  // optional sfixed32 last_swap_points_exponent = 165;
  inline bool has_last_swap_points_exponent() const;
  inline void clear_last_swap_points_exponent();
  static const int kLastSwapPointsExponentFieldNumber = 165;
  inline ::google::protobuf::int32 last_swap_points_exponent() const;
  inline void set_last_swap_points_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.LotTypeEnum lot_type = 166;
  inline bool has_lot_type() const;
  inline void clear_lot_type();
  static const int kLotTypeFieldNumber = 166;
  inline ::SingleGeneralOrderHandling::LotTypeEnum lot_type() const;
  inline void set_lot_type(::SingleGeneralOrderHandling::LotTypeEnum value);

  // optional bool manual_order_indicator = 167;
  inline bool has_manual_order_indicator() const;
  inline void clear_manual_order_indicator();
  static const int kManualOrderIndicatorFieldNumber = 167;
  inline bool manual_order_indicator() const;
  inline void set_manual_order_indicator(bool value);

  // optional string mass_status_req_id = 168;
  inline bool has_mass_status_req_id() const;
  inline void clear_mass_status_req_id();
  static const int kMassStatusReqIdFieldNumber = 168;
  inline const ::std::string& mass_status_req_id() const;
  inline void set_mass_status_req_id(const ::std::string& value);
  inline void set_mass_status_req_id(const char* value);
  inline void set_mass_status_req_id(const char* value, size_t size);
  inline ::std::string* mutable_mass_status_req_id();
  inline ::std::string* release_mass_status_req_id();
  inline void set_allocated_mass_status_req_id(::std::string* mass_status_req_id);

  // optional sfixed64 match_increment = 169;
  inline bool has_match_increment() const;
  inline void clear_match_increment();
  static const int kMatchIncrementFieldNumber = 169;
  inline ::google::protobuf::int64 match_increment() const;
  inline void set_match_increment(::google::protobuf::int64 value);

  // optional sfixed32 match_increment_exponent = 170;
  inline bool has_match_increment_exponent() const;
  inline void clear_match_increment_exponent();
  static const int kMatchIncrementExponentFieldNumber = 170;
  inline ::google::protobuf::int32 match_increment_exponent() const;
  inline void set_match_increment_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.MatchTypeEnum match_type = 171;
  inline bool has_match_type() const;
  inline void clear_match_type();
  static const int kMatchTypeFieldNumber = 171;
  inline ::SingleGeneralOrderHandling::MatchTypeEnum match_type() const;
  inline void set_match_type(::SingleGeneralOrderHandling::MatchTypeEnum value);

  // optional sfixed64 max_price_levels = 172;
  inline bool has_max_price_levels() const;
  inline void clear_max_price_levels();
  static const int kMaxPriceLevelsFieldNumber = 172;
  inline ::google::protobuf::int64 max_price_levels() const;
  inline void set_max_price_levels(::google::protobuf::int64 value);

  // repeated .Common.MiscFeesGrp misc_fees_grp = 173;
  inline int misc_fees_grp_size() const;
  inline void clear_misc_fees_grp();
  static const int kMiscFeesGrpFieldNumber = 173;
  inline const ::Common::MiscFeesGrp& misc_fees_grp(int index) const;
  inline ::Common::MiscFeesGrp* mutable_misc_fees_grp(int index);
  inline ::Common::MiscFeesGrp* add_misc_fees_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::MiscFeesGrp >&
      misc_fees_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::MiscFeesGrp >*
      mutable_misc_fees_grp();

  // optional string ord_status_req_id = 174;
  inline bool has_ord_status_req_id() const;
  inline void clear_ord_status_req_id();
  static const int kOrdStatusReqIdFieldNumber = 174;
  inline const ::std::string& ord_status_req_id() const;
  inline void set_ord_status_req_id(const ::std::string& value);
  inline void set_ord_status_req_id(const char* value);
  inline void set_ord_status_req_id(const char* value, size_t size);
  inline ::std::string* mutable_ord_status_req_id();
  inline ::std::string* release_ord_status_req_id();
  inline void set_allocated_ord_status_req_id(::std::string* ord_status_req_id);

  // optional .SingleGeneralOrderHandling.OrderCategoryEnum order_category = 175;
  inline bool has_order_category() const;
  inline void clear_order_category();
  static const int kOrderCategoryFieldNumber = 175;
  inline ::SingleGeneralOrderHandling::OrderCategoryEnum order_category() const;
  inline void set_order_category(::SingleGeneralOrderHandling::OrderCategoryEnum value);

  // optional .SingleGeneralOrderHandling.OrderHandlingInstSourceEnum order_handling_inst_source = 176;
  inline bool has_order_handling_inst_source() const;
  inline void clear_order_handling_inst_source();
  static const int kOrderHandlingInstSourceFieldNumber = 176;
  inline ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum order_handling_inst_source() const;
  inline void set_order_handling_inst_source(::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum value);

  // optional sfixed64 participation_rate = 177;
  inline bool has_participation_rate() const;
  inline void clear_participation_rate();
  static const int kParticipationRateFieldNumber = 177;
  inline ::google::protobuf::int64 participation_rate() const;
  inline void set_participation_rate(::google::protobuf::int64 value);

  // optional sfixed32 participation_rate_exponent = 178;
  inline bool has_participation_rate_exponent() const;
  inline void clear_participation_rate_exponent();
  static const int kParticipationRateExponentFieldNumber = 178;
  inline ::google::protobuf::int32 participation_rate_exponent() const;
  inline void set_participation_rate_exponent(::google::protobuf::int32 value);

  // optional .Common.PegInstructions peg_instructions = 179;
  inline bool has_peg_instructions() const;
  inline void clear_peg_instructions();
  static const int kPegInstructionsFieldNumber = 179;
  inline const ::Common::PegInstructions& peg_instructions() const;
  inline ::Common::PegInstructions* mutable_peg_instructions();
  inline ::Common::PegInstructions* release_peg_instructions();
  inline void set_allocated_peg_instructions(::Common::PegInstructions* peg_instructions);

  // optional sfixed64 pegged_price = 180;
  inline bool has_pegged_price() const;
  inline void clear_pegged_price();
  static const int kPeggedPriceFieldNumber = 180;
  inline ::google::protobuf::int64 pegged_price() const;
  inline void set_pegged_price(::google::protobuf::int64 value);

  // optional sfixed32 pegged_price_exponent = 181;
  inline bool has_pegged_price_exponent() const;
  inline void clear_pegged_price_exponent();
  static const int kPeggedPriceExponentFieldNumber = 181;
  inline ::google::protobuf::int32 pegged_price_exponent() const;
  inline void set_pegged_price_exponent(::google::protobuf::int32 value);

  // optional sfixed64 pegged_ref_price = 182;
  inline bool has_pegged_ref_price() const;
  inline void clear_pegged_ref_price();
  static const int kPeggedRefPriceFieldNumber = 182;
  inline ::google::protobuf::int64 pegged_ref_price() const;
  inline void set_pegged_ref_price(::google::protobuf::int64 value);

  // optional sfixed32 pegged_ref_price_exponent = 183;
  inline bool has_pegged_ref_price_exponent() const;
  inline void clear_pegged_ref_price_exponent();
  static const int kPeggedRefPriceExponentFieldNumber = 183;
  inline ::google::protobuf::int32 pegged_ref_price_exponent() const;
  inline void set_pegged_ref_price_exponent(::google::protobuf::int32 value);

  // optional bool pre_trade_anonymity = 184;
  inline bool has_pre_trade_anonymity() const;
  inline void clear_pre_trade_anonymity();
  static const int kPreTradeAnonymityFieldNumber = 184;
  inline bool pre_trade_anonymity() const;
  inline void set_pre_trade_anonymity(bool value);

  // optional .SingleGeneralOrderHandling.PriceProtectionScopeEnum price_protection_scope = 185;
  inline bool has_price_protection_scope() const;
  inline void clear_price_protection_scope();
  static const int kPriceProtectionScopeFieldNumber = 185;
  inline ::SingleGeneralOrderHandling::PriceProtectionScopeEnum price_protection_scope() const;
  inline void set_price_protection_scope(::SingleGeneralOrderHandling::PriceProtectionScopeEnum value);

  // optional .SingleGeneralOrderHandling.QtyTypeEnum qty_type = 186;
  inline bool has_qty_type() const;
  inline void clear_qty_type();
  static const int kQtyTypeFieldNumber = 186;
  inline ::SingleGeneralOrderHandling::QtyTypeEnum qty_type() const;
  inline void set_qty_type(::SingleGeneralOrderHandling::QtyTypeEnum value);

  // optional string quote_resp_id = 187;
  inline bool has_quote_resp_id() const;
  inline void clear_quote_resp_id();
  static const int kQuoteRespIdFieldNumber = 187;
  inline const ::std::string& quote_resp_id() const;
  inline void set_quote_resp_id(const ::std::string& value);
  inline void set_quote_resp_id(const char* value);
  inline void set_quote_resp_id(const char* value, size_t size);
  inline ::std::string* mutable_quote_resp_id();
  inline ::std::string* release_quote_resp_id();
  inline void set_allocated_quote_resp_id(::std::string* quote_resp_id);

  // optional string received_dept_id = 188;
  inline bool has_received_dept_id() const;
  inline void clear_received_dept_id();
  static const int kReceivedDeptIdFieldNumber = 188;
  inline const ::std::string& received_dept_id() const;
  inline void set_received_dept_id(const ::std::string& value);
  inline void set_received_dept_id(const char* value);
  inline void set_received_dept_id(const char* value, size_t size);
  inline ::std::string* mutable_received_dept_id();
  inline ::std::string* release_received_dept_id();
  inline void set_allocated_received_dept_id(::std::string* received_dept_id);

  // optional sfixed64 start_cash = 189;
  inline bool has_start_cash() const;
  inline void clear_start_cash();
  static const int kStartCashFieldNumber = 189;
  inline ::google::protobuf::int64 start_cash() const;
  inline void set_start_cash(::google::protobuf::int64 value);

  // optional sfixed32 start_cash_exponent = 190;
  inline bool has_start_cash_exponent() const;
  inline void clear_start_cash_exponent();
  static const int kStartCashExponentFieldNumber = 190;
  inline ::google::protobuf::int32 start_cash_exponent() const;
  inline void set_start_cash_exponent(::google::protobuf::int32 value);

  // repeated .Common.StrategyParametersGrp strategy_parameters_grp = 191;
  inline int strategy_parameters_grp_size() const;
  inline void clear_strategy_parameters_grp();
  static const int kStrategyParametersGrpFieldNumber = 191;
  inline const ::Common::StrategyParametersGrp& strategy_parameters_grp(int index) const;
  inline ::Common::StrategyParametersGrp* mutable_strategy_parameters_grp(int index);
  inline ::Common::StrategyParametersGrp* add_strategy_parameters_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >&
      strategy_parameters_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >*
      mutable_strategy_parameters_grp();

  // optional .SingleGeneralOrderHandling.TargetStrategyEnum target_strategy = 192;
  inline bool has_target_strategy() const;
  inline void clear_target_strategy();
  static const int kTargetStrategyFieldNumber = 192;
  inline ::SingleGeneralOrderHandling::TargetStrategyEnum target_strategy() const;
  inline void set_target_strategy(::SingleGeneralOrderHandling::TargetStrategyEnum value);

  // optional string target_strategy_parameters = 193;
  inline bool has_target_strategy_parameters() const;
  inline void clear_target_strategy_parameters();
  static const int kTargetStrategyParametersFieldNumber = 193;
  inline const ::std::string& target_strategy_parameters() const;
  inline void set_target_strategy_parameters(const ::std::string& value);
  inline void set_target_strategy_parameters(const char* value);
  inline void set_target_strategy_parameters(const char* value, size_t size);
  inline ::std::string* mutable_target_strategy_parameters();
  inline ::std::string* release_target_strategy_parameters();
  inline void set_allocated_target_strategy_parameters(::std::string* target_strategy_parameters);

  // optional double target_strategy_performance = 194;
  inline bool has_target_strategy_performance() const;
  inline void clear_target_strategy_performance();
  static const int kTargetStrategyPerformanceFieldNumber = 194;
  inline double target_strategy_performance() const;
  inline void set_target_strategy_performance(double value);

  // optional string time_bracket = 195;
  inline bool has_time_bracket() const;
  inline void clear_time_bracket();
  static const int kTimeBracketFieldNumber = 195;
  inline const ::std::string& time_bracket() const;
  inline void set_time_bracket(const ::std::string& value);
  inline void set_time_bracket(const char* value);
  inline void set_time_bracket(const char* value, size_t size);
  inline ::std::string* mutable_time_bracket();
  inline ::std::string* release_time_bracket();
  inline void set_allocated_time_bracket(::std::string* time_bracket);

  // optional sfixed64 tot_num_reports = 196;
  inline bool has_tot_num_reports() const;
  inline void clear_tot_num_reports();
  static const int kTotNumReportsFieldNumber = 196;
  inline ::google::protobuf::int64 tot_num_reports() const;
  inline void set_tot_num_reports(::google::protobuf::int64 value);

  // repeated .Common.TrdRegTimestamps trd_reg_timestamps = 197;
  inline int trd_reg_timestamps_size() const;
  inline void clear_trd_reg_timestamps();
  static const int kTrdRegTimestampsFieldNumber = 197;
  inline const ::Common::TrdRegTimestamps& trd_reg_timestamps(int index) const;
  inline ::Common::TrdRegTimestamps* mutable_trd_reg_timestamps(int index);
  inline ::Common::TrdRegTimestamps* add_trd_reg_timestamps();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >&
      trd_reg_timestamps() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >*
      mutable_trd_reg_timestamps();

  // optional .Common.TriggeringInstruction triggering_instruction = 198;
  inline bool has_triggering_instruction() const;
  inline void clear_triggering_instruction();
  static const int kTriggeringInstructionFieldNumber = 198;
  inline const ::Common::TriggeringInstruction& triggering_instruction() const;
  inline ::Common::TriggeringInstruction* mutable_triggering_instruction();
  inline ::Common::TriggeringInstruction* release_triggering_instruction();
  inline void set_allocated_triggering_instruction(::Common::TriggeringInstruction* triggering_instruction);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 199;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 199;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // optional string alloc_id = 200;
  inline bool has_alloc_id() const;
  inline void clear_alloc_id();
  static const int kAllocIdFieldNumber = 200;
  inline const ::std::string& alloc_id() const;
  inline void set_alloc_id(const ::std::string& value);
  inline void set_alloc_id(const char* value);
  inline void set_alloc_id(const char* value, size_t size);
  inline ::std::string* mutable_alloc_id();
  inline ::std::string* release_alloc_id();
  inline void set_allocated_alloc_id(::std::string* alloc_id);

  // optional .Common.ApplicationSequenceControl application_sequence_control = 201;
  inline bool has_application_sequence_control() const;
  inline void clear_application_sequence_control();
  static const int kApplicationSequenceControlFieldNumber = 201;
  inline const ::Common::ApplicationSequenceControl& application_sequence_control() const;
  inline ::Common::ApplicationSequenceControl* mutable_application_sequence_control();
  inline ::Common::ApplicationSequenceControl* release_application_sequence_control();
  inline void set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control);

  // optional sfixed64 dividend_yield = 202;
  inline bool has_dividend_yield() const;
  inline void clear_dividend_yield();
  static const int kDividendYieldFieldNumber = 202;
  inline ::google::protobuf::int64 dividend_yield() const;
  inline void set_dividend_yield(::google::protobuf::int64 value);

  // optional sfixed32 dividend_yield_exponent = 203;
  inline bool has_dividend_yield_exponent() const;
  inline void clear_dividend_yield_exponent();
  static const int kDividendYieldExponentFieldNumber = 203;
  inline ::google::protobuf::int32 dividend_yield_exponent() const;
  inline void set_dividend_yield_exponent(::google::protobuf::int32 value);

  // repeated .SingleGeneralOrderHandling.FillsGrp fills_grp = 204;
  inline int fills_grp_size() const;
  inline void clear_fills_grp();
  static const int kFillsGrpFieldNumber = 204;
  inline const ::SingleGeneralOrderHandling::FillsGrp& fills_grp(int index) const;
  inline ::SingleGeneralOrderHandling::FillsGrp* mutable_fills_grp(int index);
  inline ::SingleGeneralOrderHandling::FillsGrp* add_fills_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::SingleGeneralOrderHandling::FillsGrp >&
      fills_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::SingleGeneralOrderHandling::FillsGrp >*
      mutable_fills_grp();

  // optional bool last_fragment = 205;
  inline bool has_last_fragment() const;
  inline void clear_last_fragment();
  static const int kLastFragmentFieldNumber = 205;
  inline bool last_fragment() const;
  inline void set_last_fragment(bool value);

  // repeated .Common.PreAllocGrp pre_alloc_grp = 206;
  inline int pre_alloc_grp_size() const;
  inline void clear_pre_alloc_grp();
  static const int kPreAllocGrpFieldNumber = 206;
  inline const ::Common::PreAllocGrp& pre_alloc_grp(int index) const;
  inline ::Common::PreAllocGrp* mutable_pre_alloc_grp(int index);
  inline ::Common::PreAllocGrp* add_pre_alloc_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >&
      pre_alloc_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >*
      mutable_pre_alloc_grp();

  // optional double price_delta = 207;
  inline bool has_price_delta() const;
  inline void clear_price_delta();
  static const int kPriceDeltaFieldNumber = 207;
  inline double price_delta() const;
  inline void set_price_delta(double value);

  // optional double risk_free_rate = 208;
  inline bool has_risk_free_rate() const;
  inline void clear_risk_free_rate();
  static const int kRiskFreeRateFieldNumber = 208;
  inline double risk_free_rate() const;
  inline void set_risk_free_rate(double value);

  // optional double time_to_expiration = 209;
  inline bool has_time_to_expiration() const;
  inline void clear_time_to_expiration();
  static const int kTimeToExpirationFieldNumber = 209;
  inline double time_to_expiration() const;
  inline void set_time_to_expiration(double value);

  // optional sfixed64 tot_no_fills = 210;
  inline bool has_tot_no_fills() const;
  inline void clear_tot_no_fills();
  static const int kTotNoFillsFieldNumber = 210;
  inline ::google::protobuf::int64 tot_no_fills() const;
  inline void set_tot_no_fills(::google::protobuf::int64 value);

  // optional string trd_match_id = 211;
  inline bool has_trd_match_id() const;
  inline void clear_trd_match_id();
  static const int kTrdMatchIdFieldNumber = 211;
  inline const ::std::string& trd_match_id() const;
  inline void set_trd_match_id(const ::std::string& value);
  inline void set_trd_match_id(const char* value);
  inline void set_trd_match_id(const char* value, size_t size);
  inline ::std::string* mutable_trd_match_id();
  inline ::std::string* release_trd_match_id();
  inline void set_allocated_trd_match_id(::std::string* trd_match_id);

  // optional double volatility = 212;
  inline bool has_volatility() const;
  inline void clear_volatility();
  static const int kVolatilityFieldNumber = 212;
  inline double volatility() const;
  inline void set_volatility(double value);

  // repeated .Common.RateSource rate_source = 213;
  inline int rate_source_size() const;
  inline void clear_rate_source();
  static const int kRateSourceFieldNumber = 213;
  inline const ::Common::RateSource& rate_source(int index) const;
  inline ::Common::RateSource* mutable_rate_source(int index);
  inline ::Common::RateSource* add_rate_source();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::RateSource >&
      rate_source() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::RateSource >*
      mutable_rate_source();

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.ExecutionReport)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_avg_px();
  inline void clear_has_avg_px();
  inline void set_has_cl_ord_id();
  inline void clear_has_cl_ord_id();
  inline void set_has_cum_qty();
  inline void clear_has_cum_qty();
  inline void set_has_cum_qty_exponent();
  inline void clear_has_cum_qty_exponent();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_exec_id();
  inline void clear_has_exec_id();
  inline void set_has_exec_ref_id();
  inline void clear_has_exec_ref_id();
  inline void set_has_last_capacity();
  inline void clear_has_last_capacity();
  inline void set_has_last_mkt();
  inline void clear_has_last_mkt();
  inline void set_has_last_px();
  inline void clear_has_last_px();
  inline void set_has_last_qty();
  inline void clear_has_last_qty();
  inline void set_has_last_qty_exponent();
  inline void clear_has_last_qty_exponent();
  inline void set_has_list_id();
  inline void clear_has_list_id();
  inline void set_has_ord_rej_reason();
  inline void clear_has_ord_rej_reason();
  inline void set_has_ord_status();
  inline void clear_has_ord_status();
  inline void set_has_ord_type();
  inline void clear_has_ord_type();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_price_exponent();
  inline void clear_has_price_exponent();
  inline void set_has_settl_date();
  inline void clear_has_settl_date();
  inline void set_has_settl_type();
  inline void clear_has_settl_type();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_stop_px();
  inline void clear_has_stop_px();
  inline void set_has_stop_px_exponent();
  inline void clear_has_stop_px_exponent();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_time_in_force();
  inline void clear_has_time_in_force();
  inline void set_has_trade_date();
  inline void clear_has_trade_date();
  inline void set_has_transact_time();
  inline void clear_has_transact_time();
  inline void set_has_report_to_exch();
  inline void clear_has_report_to_exch();
  inline void set_has_expire_time();
  inline void clear_has_expire_time();
  inline void set_has_net_money();
  inline void clear_has_net_money();
  inline void set_has_net_money_exponent();
  inline void clear_has_net_money_exponent();
  inline void set_has_settl_curr_amt();
  inline void clear_has_settl_curr_amt();
  inline void set_has_settl_curr_amt_exponent();
  inline void clear_has_settl_curr_amt_exponent();
  inline void set_has_settl_currency();
  inline void clear_has_settl_currency();
  inline void set_has_exec_type();
  inline void clear_has_exec_type();
  inline void set_has_last_forward_points();
  inline void clear_has_last_forward_points();
  inline void set_has_last_forward_points_exponent();
  inline void clear_has_last_forward_points_exponent();
  inline void set_has_last_spot_rate();
  inline void clear_has_last_spot_rate();
  inline void set_has_last_spot_rate_exponent();
  inline void clear_has_last_spot_rate_exponent();
  inline void set_has_leaves_qty();
  inline void clear_has_leaves_qty();
  inline void set_has_leaves_qty_exponent();
  inline void clear_has_leaves_qty_exponent();
  inline void set_has_orig_cl_ord_id();
  inline void clear_has_orig_cl_ord_id();
  inline void set_has_secondary_order_id();
  inline void clear_has_secondary_order_id();
  inline void set_has_settl_curr_fx_rate();
  inline void clear_has_settl_curr_fx_rate();
  inline void set_has_settl_curr_fx_rate_calc();
  inline void clear_has_settl_curr_fx_rate_calc();
  inline void set_has_compliance_id();
  inline void clear_has_compliance_id();
  inline void set_has_day_avg_px();
  inline void clear_has_day_avg_px();
  inline void set_has_day_avg_px_exponent();
  inline void clear_has_day_avg_px_exponent();
  inline void set_has_day_cum_qty();
  inline void clear_has_day_cum_qty();
  inline void set_has_day_cum_qty_exponent();
  inline void clear_has_day_cum_qty_exponent();
  inline void set_has_day_order_qty();
  inline void clear_has_day_order_qty();
  inline void set_has_day_order_qty_exponent();
  inline void clear_has_day_order_qty_exponent();
  inline void set_has_effective_time();
  inline void clear_has_effective_time();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_exec_restatement_reason();
  inline void clear_has_exec_restatement_reason();
  inline void set_has_expire_date();
  inline void clear_has_expire_date();
  inline void set_has_gt_booking_inst();
  inline void clear_has_gt_booking_inst();
  inline void set_has_gross_trade_amt();
  inline void clear_has_gross_trade_amt();
  inline void set_has_gross_trade_amt_exponent();
  inline void clear_has_gross_trade_amt_exponent();
  inline void set_has_handl_inst();
  inline void clear_has_handl_inst();
  inline void set_has_max_floor();
  inline void clear_has_max_floor();
  inline void set_has_max_floor_exponent();
  inline void clear_has_max_floor_exponent();
  inline void set_has_max_show();
  inline void clear_has_max_show();
  inline void set_has_max_show_exponent();
  inline void clear_has_max_show_exponent();
  inline void set_has_min_qty();
  inline void clear_has_min_qty();
  inline void set_has_min_qty_exponent();
  inline void clear_has_min_qty_exponent();
  inline void set_has_multi_leg_reporting_type();
  inline void clear_has_multi_leg_reporting_type();
  inline void set_has_order_qty2();
  inline void clear_has_order_qty2();
  inline void set_has_order_qty2_exponent();
  inline void clear_has_order_qty2_exponent();
  inline void set_has_position_effect();
  inline void clear_has_position_effect();
  inline void set_has_settl_date2();
  inline void clear_has_settl_date2();
  inline void set_has_solicited_flag();
  inline void clear_has_solicited_flag();
  inline void set_has_trading_session_id();
  inline void clear_has_trading_session_id();
  inline void set_has_account_type();
  inline void clear_has_account_type();
  inline void set_has_accrued_interest_amt();
  inline void clear_has_accrued_interest_amt();
  inline void set_has_accrued_interest_amt_exponent();
  inline void clear_has_accrued_interest_amt_exponent();
  inline void set_has_accrued_interest_rate();
  inline void clear_has_accrued_interest_rate();
  inline void set_has_accrued_interest_rate_exponent();
  inline void clear_has_accrued_interest_rate_exponent();
  inline void set_has_basis_feature_date();
  inline void clear_has_basis_feature_date();
  inline void set_has_basis_feature_price();
  inline void clear_has_basis_feature_price();
  inline void set_has_basis_feature_price_exponent();
  inline void clear_has_basis_feature_price_exponent();
  inline void set_has_booking_unit();
  inline void clear_has_booking_unit();
  inline void set_has_cancellation_rights();
  inline void clear_has_cancellation_rights();
  inline void set_has_cash_margin();
  inline void clear_has_cash_margin();
  inline void set_has_cl_ord_link_id();
  inline void clear_has_cl_ord_link_id();
  inline void set_has_clearing_fee_indicator();
  inline void clear_has_clearing_fee_indicator();
  inline void set_has_commission_data();
  inline void clear_has_commission_data();
  inline void set_has_concession();
  inline void clear_has_concession();
  inline void set_has_concession_exponent();
  inline void clear_has_concession_exponent();
  inline void set_has_cross_id();
  inline void clear_has_cross_id();
  inline void set_has_cross_type();
  inline void clear_has_cross_type();
  inline void set_has_cust_order_capacity();
  inline void clear_has_cust_order_capacity();
  inline void set_has_day_booking_inst();
  inline void clear_has_day_booking_inst();
  inline void set_has_designation();
  inline void clear_has_designation();
  inline void set_has_ex_date();
  inline void clear_has_ex_date();
  inline void set_has_exec_price_adjustment();
  inline void clear_has_exec_price_adjustment();
  inline void set_has_exec_price_type();
  inline void clear_has_exec_price_type();
  inline void set_has_exec_valuation_point();
  inline void clear_has_exec_valuation_point();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_last_forward_points2();
  inline void clear_has_last_forward_points2();
  inline void set_has_last_forward_points2_exponent();
  inline void clear_has_last_forward_points2_exponent();
  inline void set_has_money_laundering_status();
  inline void clear_has_money_laundering_status();
  inline void set_has_num_days_interest();
  inline void clear_has_num_days_interest();
  inline void set_has_order_capacity();
  inline void clear_has_order_capacity();
  inline void set_has_order_qty_data();
  inline void clear_has_order_qty_data();
  inline void set_has_orig_cross_id();
  inline void clear_has_orig_cross_id();
  inline void set_has_prealloc_method();
  inline void clear_has_prealloc_method();
  inline void set_has_price_improvement();
  inline void clear_has_price_improvement();
  inline void set_has_price_improvement_exponent();
  inline void clear_has_price_improvement_exponent();
  inline void set_has_price_type();
  inline void clear_has_price_type();
  inline void set_has_priority_indicator();
  inline void clear_has_priority_indicator();
  inline void set_has_regist_id();
  inline void clear_has_regist_id();
  inline void set_has_secondary_cl_ord_id();
  inline void clear_has_secondary_cl_ord_id();
  inline void set_has_secondary_exec_id();
  inline void clear_has_secondary_exec_id();
  inline void set_has_spread_or_benchmark_curve_data();
  inline void clear_has_spread_or_benchmark_curve_data();
  inline void set_has_total_takedown();
  inline void clear_has_total_takedown();
  inline void set_has_total_takedown_exponent();
  inline void clear_has_total_takedown_exponent();
  inline void set_has_trade_origination_date();
  inline void clear_has_trade_origination_date();
  inline void set_has_traded_flat_switch();
  inline void clear_has_traded_flat_switch();
  inline void set_has_trading_session_sub_id();
  inline void clear_has_trading_session_sub_id();
  inline void set_has_trans_bkd_time();
  inline void clear_has_trans_bkd_time();
  inline void set_has_underlying_last_px();
  inline void clear_has_underlying_last_px();
  inline void set_has_underlying_last_px_exponent();
  inline void clear_has_underlying_last_px_exponent();
  inline void set_has_underlying_last_qty();
  inline void clear_has_underlying_last_qty();
  inline void set_has_underlying_last_qty_exponent();
  inline void clear_has_underlying_last_qty_exponent();
  inline void set_has_working_indicator();
  inline void clear_has_working_indicator();
  inline void set_has_yield_data();
  inline void clear_has_yield_data();
  inline void set_has_acct_id_source();
  inline void clear_has_acct_id_source();
  inline void set_has_aggressor_indicator();
  inline void clear_has_aggressor_indicator();
  inline void set_has_booking_type();
  inline void clear_has_booking_type();
  inline void set_has_calculated_ccy_last_qty();
  inline void clear_has_calculated_ccy_last_qty();
  inline void set_has_calculated_ccy_last_qty_exponent();
  inline void clear_has_calculated_ccy_last_qty_exponent();
  inline void set_has_copy_msg_indicator();
  inline void clear_has_copy_msg_indicator();
  inline void set_has_cust_directed_order();
  inline void clear_has_cust_directed_order();
  inline void set_has_cust_order_handling_inst();
  inline void clear_has_cust_order_handling_inst();
  inline void set_has_discretion_instructions();
  inline void clear_has_discretion_instructions();
  inline void set_has_discretion_price();
  inline void clear_has_discretion_price();
  inline void set_has_discretion_price_exponent();
  inline void clear_has_discretion_price_exponent();
  inline void set_has_display_instruction();
  inline void clear_has_display_instruction();
  inline void set_has_end_accrued_interest_amt();
  inline void clear_has_end_accrued_interest_amt();
  inline void set_has_end_accrued_interest_amt_exponent();
  inline void clear_has_end_accrued_interest_amt_exponent();
  inline void set_has_end_cash();
  inline void clear_has_end_cash();
  inline void set_has_end_cash_exponent();
  inline void clear_has_end_cash_exponent();
  inline void set_has_financing_details();
  inline void clear_has_financing_details();
  inline void set_has_host_cross_id();
  inline void clear_has_host_cross_id();
  inline void set_has_interest_at_maturity();
  inline void clear_has_interest_at_maturity();
  inline void set_has_interest_at_maturity_exponent();
  inline void clear_has_interest_at_maturity_exponent();
  inline void set_has_last_liquidity_ind();
  inline void clear_has_last_liquidity_ind();
  inline void set_has_last_par_px();
  inline void clear_has_last_par_px();
  inline void set_has_last_par_px_exponent();
  inline void clear_has_last_par_px_exponent();
  inline void set_has_last_rpt_requested();
  inline void clear_has_last_rpt_requested();
  inline void set_has_last_swap_points();
  inline void clear_has_last_swap_points();
  inline void set_has_last_swap_points_exponent();
  inline void clear_has_last_swap_points_exponent();
  inline void set_has_lot_type();
  inline void clear_has_lot_type();
  inline void set_has_manual_order_indicator();
  inline void clear_has_manual_order_indicator();
  inline void set_has_mass_status_req_id();
  inline void clear_has_mass_status_req_id();
  inline void set_has_match_increment();
  inline void clear_has_match_increment();
  inline void set_has_match_increment_exponent();
  inline void clear_has_match_increment_exponent();
  inline void set_has_match_type();
  inline void clear_has_match_type();
  inline void set_has_max_price_levels();
  inline void clear_has_max_price_levels();
  inline void set_has_ord_status_req_id();
  inline void clear_has_ord_status_req_id();
  inline void set_has_order_category();
  inline void clear_has_order_category();
  inline void set_has_order_handling_inst_source();
  inline void clear_has_order_handling_inst_source();
  inline void set_has_participation_rate();
  inline void clear_has_participation_rate();
  inline void set_has_participation_rate_exponent();
  inline void clear_has_participation_rate_exponent();
  inline void set_has_peg_instructions();
  inline void clear_has_peg_instructions();
  inline void set_has_pegged_price();
  inline void clear_has_pegged_price();
  inline void set_has_pegged_price_exponent();
  inline void clear_has_pegged_price_exponent();
  inline void set_has_pegged_ref_price();
  inline void clear_has_pegged_ref_price();
  inline void set_has_pegged_ref_price_exponent();
  inline void clear_has_pegged_ref_price_exponent();
  inline void set_has_pre_trade_anonymity();
  inline void clear_has_pre_trade_anonymity();
  inline void set_has_price_protection_scope();
  inline void clear_has_price_protection_scope();
  inline void set_has_qty_type();
  inline void clear_has_qty_type();
  inline void set_has_quote_resp_id();
  inline void clear_has_quote_resp_id();
  inline void set_has_received_dept_id();
  inline void clear_has_received_dept_id();
  inline void set_has_start_cash();
  inline void clear_has_start_cash();
  inline void set_has_start_cash_exponent();
  inline void clear_has_start_cash_exponent();
  inline void set_has_target_strategy();
  inline void clear_has_target_strategy();
  inline void set_has_target_strategy_parameters();
  inline void clear_has_target_strategy_parameters();
  inline void set_has_target_strategy_performance();
  inline void clear_has_target_strategy_performance();
  inline void set_has_time_bracket();
  inline void clear_has_time_bracket();
  inline void set_has_tot_num_reports();
  inline void clear_has_tot_num_reports();
  inline void set_has_triggering_instruction();
  inline void clear_has_triggering_instruction();
  inline void set_has_alloc_id();
  inline void clear_has_alloc_id();
  inline void set_has_application_sequence_control();
  inline void clear_has_application_sequence_control();
  inline void set_has_dividend_yield();
  inline void clear_has_dividend_yield();
  inline void set_has_dividend_yield_exponent();
  inline void clear_has_dividend_yield_exponent();
  inline void set_has_last_fragment();
  inline void clear_has_last_fragment();
  inline void set_has_price_delta();
  inline void clear_has_price_delta();
  inline void set_has_risk_free_rate();
  inline void clear_has_risk_free_rate();
  inline void set_has_time_to_expiration();
  inline void clear_has_time_to_expiration();
  inline void set_has_tot_no_fills();
  inline void clear_has_tot_no_fills();
  inline void set_has_trd_match_id();
  inline void clear_has_trd_match_id();
  inline void set_has_volatility();
  inline void clear_has_volatility();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::google::protobuf::int64 avg_px_;
  ::std::string* cl_ord_id_;
  ::google::protobuf::int64 cum_qty_;
  ::std::string* currency_;
  ::std::string* exec_id_;
  ::google::protobuf::int32 cum_qty_exponent_;
  int last_capacity_;
  ::google::protobuf::RepeatedField<int> exec_inst_;
  mutable int _exec_inst_cached_byte_size_;
  ::std::string* exec_ref_id_;
  ::std::string* last_mkt_;
  double last_px_;
  ::google::protobuf::int64 last_qty_;
  ::std::string* list_id_;
  ::google::protobuf::int32 last_qty_exponent_;
  int ord_rej_reason_;
  int ord_status_;
  int ord_type_;
  ::std::string* order_id_;
  ::google::protobuf::int64 price_;
  ::google::protobuf::int32 price_exponent_;
  ::google::protobuf::int32 settl_date_;
  int settl_type_;
  int side_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::google::protobuf::int64 stop_px_;
  ::google::protobuf::int32 stop_px_exponent_;
  int time_in_force_;
  ::std::string* text_;
  ::google::protobuf::int64 transact_time_;
  ::google::protobuf::int32 trade_date_;
  ::google::protobuf::int32 net_money_exponent_;
  ::google::protobuf::int64 expire_time_;
  ::google::protobuf::int64 net_money_;
  ::google::protobuf::int64 settl_curr_amt_;
  ::google::protobuf::int32 settl_curr_amt_exponent_;
  int exec_type_;
  ::std::string* settl_currency_;
  ::google::protobuf::int64 last_forward_points_;
  ::google::protobuf::int32 last_forward_points_exponent_;
  ::google::protobuf::int32 last_spot_rate_exponent_;
  ::google::protobuf::int64 last_spot_rate_;
  ::google::protobuf::int64 leaves_qty_;
  ::std::string* orig_cl_ord_id_;
  ::google::protobuf::int32 leaves_qty_exponent_;
  int settl_curr_fx_rate_calc_;
  ::std::string* secondary_order_id_;
  double settl_curr_fx_rate_;
  ::std::string* compliance_id_;
  ::google::protobuf::int64 day_avg_px_;
  ::google::protobuf::int32 day_avg_px_exponent_;
  ::google::protobuf::int32 day_cum_qty_exponent_;
  ::google::protobuf::int64 day_cum_qty_;
  ::google::protobuf::int64 day_order_qty_;
  ::google::protobuf::int64 effective_time_;
  ::google::protobuf::int32 day_order_qty_exponent_;
  ::google::protobuf::uint32 encoded_text_len_;
  ::std::string* encoded_text_;
  int exec_restatement_reason_;
  ::google::protobuf::int32 expire_date_;
  int gt_booking_inst_;
  ::google::protobuf::int32 gross_trade_amt_exponent_;
  ::google::protobuf::int64 gross_trade_amt_;
  int handl_inst_;
  ::google::protobuf::int32 max_floor_exponent_;
  ::google::protobuf::int64 max_floor_;
  ::google::protobuf::int64 max_show_;
  ::google::protobuf::int32 max_show_exponent_;
  ::google::protobuf::int32 min_qty_exponent_;
  ::google::protobuf::int64 min_qty_;
  int multi_leg_reporting_type_;
  ::google::protobuf::int32 order_qty2_exponent_;
  ::google::protobuf::int64 order_qty2_;
  int position_effect_;
  ::google::protobuf::int32 settl_date2_;
  int trading_session_id_;
  int account_type_;
  ::google::protobuf::int64 accrued_interest_amt_;
  ::google::protobuf::int64 accrued_interest_rate_;
  ::google::protobuf::int32 accrued_interest_amt_exponent_;
  ::google::protobuf::int32 accrued_interest_rate_exponent_;
  ::google::protobuf::int32 basis_feature_date_;
  ::google::protobuf::int32 basis_feature_price_exponent_;
  ::google::protobuf::int64 basis_feature_price_;
  int booking_unit_;
  int cancellation_rights_;
  int cash_margin_;
  int clearing_fee_indicator_;
  ::std::string* cl_ord_link_id_;
  ::Common::CommissionData* commission_data_;
  bool report_to_exch_;
  bool solicited_flag_;
  bool traded_flat_switch_;
  bool working_indicator_;
  ::google::protobuf::int32 concession_exponent_;
  ::google::protobuf::int64 concession_;
  ::std::string* cross_id_;
  int cross_type_;
  int cust_order_capacity_;
  int day_booking_inst_;
  ::google::protobuf::int32 ex_date_;
  ::std::string* designation_;
  double exec_price_adjustment_;
  ::google::protobuf::int64 exec_valuation_point_;
  ::Common::Instrument* instrument_;
  int exec_price_type_;
  ::google::protobuf::int32 last_forward_points2_exponent_;
  ::google::protobuf::int64 last_forward_points2_;
  int money_laundering_status_;
  int order_capacity_;
  ::google::protobuf::int64 num_days_interest_;
  ::Common::OrderQtyData* order_qty_data_;
  ::google::protobuf::RepeatedField<int> order_restrictions_;
  mutable int _order_restrictions_cached_byte_size_;
  ::std::string* orig_cross_id_;
  ::google::protobuf::RepeatedPtrField< ::Common::Parties > parties_;
  int prealloc_method_;
  ::google::protobuf::int32 price_improvement_exponent_;
  ::google::protobuf::int64 price_improvement_;
  int price_type_;
  int priority_indicator_;
  ::std::string* regist_id_;
  ::std::string* secondary_cl_ord_id_;
  ::std::string* secondary_exec_id_;
  ::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data_;
  ::google::protobuf::RepeatedPtrField< ::Common::Stipulations > stipulations_;
  ::google::protobuf::int64 total_takedown_;
  ::google::protobuf::int32 total_takedown_exponent_;
  ::google::protobuf::int32 trade_origination_date_;
  ::google::protobuf::int64 trans_bkd_time_;
  int trading_session_sub_id_;
  ::google::protobuf::int32 underlying_last_px_exponent_;
  ::google::protobuf::int64 underlying_last_px_;
  ::google::protobuf::int64 underlying_last_qty_;
  ::google::protobuf::int32 underlying_last_qty_exponent_;
  int acct_id_source_;
  ::Common::YieldData* yield_data_;
  int booking_type_;
  ::google::protobuf::int32 calculated_ccy_last_qty_exponent_;
  ::google::protobuf::int64 calculated_ccy_last_qty_;
  ::google::protobuf::RepeatedPtrField< ::Common::ContAmtGrp > cont_amt_grp_;
  ::google::protobuf::RepeatedPtrField< ::Common::ContraGrp > contra_grp_;
  ::Common::DiscretionInstructions* discretion_instructions_;
  int cust_order_handling_inst_;
  bool aggressor_indicator_;
  bool copy_msg_indicator_;
  bool cust_directed_order_;
  bool last_rpt_requested_;
  ::google::protobuf::int64 discretion_price_;
  ::Common::DisplayInstruction* display_instruction_;
  ::google::protobuf::int32 discretion_price_exponent_;
  ::google::protobuf::int32 end_accrued_interest_amt_exponent_;
  ::google::protobuf::int64 end_accrued_interest_amt_;
  ::google::protobuf::int64 end_cash_;
  ::Common::FinancingDetails* financing_details_;
  ::std::string* host_cross_id_;
  ::google::protobuf::int32 end_cash_exponent_;
  ::google::protobuf::int32 interest_at_maturity_exponent_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegExecGrp > instrmt_leg_exec_grp_;
  ::google::protobuf::int64 interest_at_maturity_;
  int last_liquidity_ind_;
  ::google::protobuf::int32 last_par_px_exponent_;
  ::google::protobuf::int64 last_par_px_;
  ::google::protobuf::int64 last_swap_points_;
  ::google::protobuf::int32 last_swap_points_exponent_;
  int lot_type_;
  ::std::string* mass_status_req_id_;
  ::google::protobuf::int64 match_increment_;
  ::google::protobuf::int32 match_increment_exponent_;
  int match_type_;
  ::google::protobuf::int64 max_price_levels_;
  ::google::protobuf::RepeatedPtrField< ::Common::MiscFeesGrp > misc_fees_grp_;
  ::std::string* ord_status_req_id_;
  int order_category_;
  int order_handling_inst_source_;
  ::google::protobuf::int64 participation_rate_;
  ::Common::PegInstructions* peg_instructions_;
  ::google::protobuf::int32 participation_rate_exponent_;
  ::google::protobuf::int32 pegged_price_exponent_;
  ::google::protobuf::int64 pegged_price_;
  ::google::protobuf::int64 pegged_ref_price_;
  ::google::protobuf::int32 pegged_ref_price_exponent_;
  int price_protection_scope_;
  bool manual_order_indicator_;
  bool pre_trade_anonymity_;
  bool last_fragment_;
  int qty_type_;
  ::std::string* quote_resp_id_;
  ::std::string* received_dept_id_;
  ::google::protobuf::int64 start_cash_;
  ::google::protobuf::int32 start_cash_exponent_;
  int target_strategy_;
  ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp > strategy_parameters_grp_;
  ::std::string* target_strategy_parameters_;
  double target_strategy_performance_;
  ::std::string* time_bracket_;
  ::google::protobuf::int64 tot_num_reports_;
  ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps > trd_reg_timestamps_;
  ::Common::TriggeringInstruction* triggering_instruction_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;
  ::std::string* alloc_id_;
  ::Common::ApplicationSequenceControl* application_sequence_control_;
  ::google::protobuf::int64 dividend_yield_;
  ::google::protobuf::RepeatedPtrField< ::SingleGeneralOrderHandling::FillsGrp > fills_grp_;
  ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp > pre_alloc_grp_;
  double price_delta_;
  double risk_free_rate_;
  double time_to_expiration_;
  ::google::protobuf::int64 tot_no_fills_;
  ::std::string* trd_match_id_;
  double volatility_;
  ::google::protobuf::RepeatedPtrField< ::Common::RateSource > rate_source_;
  ::google::protobuf::int32 dividend_yield_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(213 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static ExecutionReport* default_instance_;
};
// -------------------------------------------------------------------

class OrderStatusRequest : public ::google::protobuf::Message {
 public:
  OrderStatusRequest();
  virtual ~OrderStatusRequest();

  OrderStatusRequest(const OrderStatusRequest& from);

  inline OrderStatusRequest& operator=(const OrderStatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderStatusRequest& default_instance();

  void Swap(OrderStatusRequest* other);

  // implements Message ----------------------------------------------

  OrderStatusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderStatusRequest& from);
  void MergeFrom(const OrderStatusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cl_ord_id = 1;
  inline bool has_cl_ord_id() const;
  inline void clear_cl_ord_id();
  static const int kClOrdIdFieldNumber = 1;
  inline const ::std::string& cl_ord_id() const;
  inline void set_cl_ord_id(const ::std::string& value);
  inline void set_cl_ord_id(const char* value);
  inline void set_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_id();
  inline ::std::string* release_cl_ord_id();
  inline void set_allocated_cl_ord_id(::std::string* cl_ord_id);

  // optional string order_id = 2;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 2;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional .SingleGeneralOrderHandling.SideEnum side = 3;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 3;
  inline ::SingleGeneralOrderHandling::SideEnum side() const;
  inline void set_side(::SingleGeneralOrderHandling::SideEnum value);

  // optional .Session.StandardHeader standard_header = 4;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 4;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 5;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 5;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional string account = 6;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 6;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string cl_ord_link_id = 7;
  inline bool has_cl_ord_link_id() const;
  inline void clear_cl_ord_link_id();
  static const int kClOrdLinkIdFieldNumber = 7;
  inline const ::std::string& cl_ord_link_id() const;
  inline void set_cl_ord_link_id(const ::std::string& value);
  inline void set_cl_ord_link_id(const char* value);
  inline void set_cl_ord_link_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_link_id();
  inline ::std::string* release_cl_ord_link_id();
  inline void set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id);

  // optional .Common.Instrument instrument = 8;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 8;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // repeated .Common.Parties parties = 9;
  inline int parties_size() const;
  inline void clear_parties();
  static const int kPartiesFieldNumber = 9;
  inline const ::Common::Parties& parties(int index) const;
  inline ::Common::Parties* mutable_parties(int index);
  inline ::Common::Parties* add_parties();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
      parties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
      mutable_parties();

  // optional string secondary_cl_ord_id = 10;
  inline bool has_secondary_cl_ord_id() const;
  inline void clear_secondary_cl_ord_id();
  static const int kSecondaryClOrdIdFieldNumber = 10;
  inline const ::std::string& secondary_cl_ord_id() const;
  inline void set_secondary_cl_ord_id(const ::std::string& value);
  inline void set_secondary_cl_ord_id(const char* value);
  inline void set_secondary_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_cl_ord_id();
  inline ::std::string* release_secondary_cl_ord_id();
  inline void set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id);

  // optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 11;
  inline bool has_acct_id_source() const;
  inline void clear_acct_id_source();
  static const int kAcctIdSourceFieldNumber = 11;
  inline ::SingleGeneralOrderHandling::AcctIdSourceEnum acct_id_source() const;
  inline void set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value);

  // optional .Common.FinancingDetails financing_details = 12;
  inline bool has_financing_details() const;
  inline void clear_financing_details();
  static const int kFinancingDetailsFieldNumber = 12;
  inline const ::Common::FinancingDetails& financing_details() const;
  inline ::Common::FinancingDetails* mutable_financing_details();
  inline ::Common::FinancingDetails* release_financing_details();
  inline void set_allocated_financing_details(::Common::FinancingDetails* financing_details);

  // optional string ord_status_req_id = 13;
  inline bool has_ord_status_req_id() const;
  inline void clear_ord_status_req_id();
  static const int kOrdStatusReqIdFieldNumber = 13;
  inline const ::std::string& ord_status_req_id() const;
  inline void set_ord_status_req_id(const ::std::string& value);
  inline void set_ord_status_req_id(const char* value);
  inline void set_ord_status_req_id(const char* value, size_t size);
  inline ::std::string* mutable_ord_status_req_id();
  inline ::std::string* release_ord_status_req_id();
  inline void set_allocated_ord_status_req_id(::std::string* ord_status_req_id);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 14;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 14;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.OrderStatusRequest)
 private:
  inline void set_has_cl_ord_id();
  inline void clear_has_cl_ord_id();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_cl_ord_link_id();
  inline void clear_has_cl_ord_link_id();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_secondary_cl_ord_id();
  inline void clear_has_secondary_cl_ord_id();
  inline void set_has_acct_id_source();
  inline void clear_has_acct_id_source();
  inline void set_has_financing_details();
  inline void clear_has_financing_details();
  inline void set_has_ord_status_req_id();
  inline void clear_has_ord_status_req_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cl_ord_id_;
  ::std::string* order_id_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::std::string* account_;
  ::std::string* cl_ord_link_id_;
  int side_;
  int acct_id_source_;
  ::Common::Instrument* instrument_;
  ::google::protobuf::RepeatedPtrField< ::Common::Parties > parties_;
  ::std::string* secondary_cl_ord_id_;
  ::Common::FinancingDetails* financing_details_;
  ::std::string* ord_status_req_id_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static OrderStatusRequest* default_instance_;
};
// -------------------------------------------------------------------

class ExecutionAcknowledgement : public ::google::protobuf::Message {
 public:
  ExecutionAcknowledgement();
  virtual ~ExecutionAcknowledgement();

  ExecutionAcknowledgement(const ExecutionAcknowledgement& from);

  inline ExecutionAcknowledgement& operator=(const ExecutionAcknowledgement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecutionAcknowledgement& default_instance();

  void Swap(ExecutionAcknowledgement* other);

  // implements Message ----------------------------------------------

  ExecutionAcknowledgement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecutionAcknowledgement& from);
  void MergeFrom(const ExecutionAcknowledgement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 avg_px = 1;
  inline bool has_avg_px() const;
  inline void clear_avg_px();
  static const int kAvgPxFieldNumber = 1;
  inline ::google::protobuf::int64 avg_px() const;
  inline void set_avg_px(::google::protobuf::int64 value);

  // optional string cl_ord_id = 2;
  inline bool has_cl_ord_id() const;
  inline void clear_cl_ord_id();
  static const int kClOrdIdFieldNumber = 2;
  inline const ::std::string& cl_ord_id() const;
  inline void set_cl_ord_id(const ::std::string& value);
  inline void set_cl_ord_id(const char* value);
  inline void set_cl_ord_id(const char* value, size_t size);
  inline ::std::string* mutable_cl_ord_id();
  inline ::std::string* release_cl_ord_id();
  inline void set_allocated_cl_ord_id(::std::string* cl_ord_id);

  // optional sfixed64 cum_qty = 3;
  inline bool has_cum_qty() const;
  inline void clear_cum_qty();
  static const int kCumQtyFieldNumber = 3;
  inline ::google::protobuf::int64 cum_qty() const;
  inline void set_cum_qty(::google::protobuf::int64 value);

  // optional sfixed32 cum_qty_exponent = 4;
  inline bool has_cum_qty_exponent() const;
  inline void clear_cum_qty_exponent();
  static const int kCumQtyExponentFieldNumber = 4;
  inline ::google::protobuf::int32 cum_qty_exponent() const;
  inline void set_cum_qty_exponent(::google::protobuf::int32 value);

  // optional .SingleGeneralOrderHandling.DKReasonEnum dkreason = 5;
  inline bool has_dkreason() const;
  inline void clear_dkreason();
  static const int kDkreasonFieldNumber = 5;
  inline ::SingleGeneralOrderHandling::DKReasonEnum dkreason() const;
  inline void set_dkreason(::SingleGeneralOrderHandling::DKReasonEnum value);

  // optional bytes encoded_text = 6;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 6;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 7;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 7;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional .SingleGeneralOrderHandling.ExecAckStatusEnum exec_ack_status = 8;
  inline bool has_exec_ack_status() const;
  inline void clear_exec_ack_status();
  static const int kExecAckStatusFieldNumber = 8;
  inline ::SingleGeneralOrderHandling::ExecAckStatusEnum exec_ack_status() const;
  inline void set_exec_ack_status(::SingleGeneralOrderHandling::ExecAckStatusEnum value);

  // optional string exec_id = 9;
  inline bool has_exec_id() const;
  inline void clear_exec_id();
  static const int kExecIdFieldNumber = 9;
  inline const ::std::string& exec_id() const;
  inline void set_exec_id(const ::std::string& value);
  inline void set_exec_id(const char* value);
  inline void set_exec_id(const char* value, size_t size);
  inline ::std::string* mutable_exec_id();
  inline ::std::string* release_exec_id();
  inline void set_allocated_exec_id(::std::string* exec_id);

  // repeated .Common.InstrmtLegGrp instrmt_leg_grp = 10;
  inline int instrmt_leg_grp_size() const;
  inline void clear_instrmt_leg_grp();
  static const int kInstrmtLegGrpFieldNumber = 10;
  inline const ::Common::InstrmtLegGrp& instrmt_leg_grp(int index) const;
  inline ::Common::InstrmtLegGrp* mutable_instrmt_leg_grp(int index);
  inline ::Common::InstrmtLegGrp* add_instrmt_leg_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
      instrmt_leg_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
      mutable_instrmt_leg_grp();

  // optional .Common.Instrument instrument = 11;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 11;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional sfixed64 last_par_px = 12;
  inline bool has_last_par_px() const;
  inline void clear_last_par_px();
  static const int kLastParPxFieldNumber = 12;
  inline ::google::protobuf::int64 last_par_px() const;
  inline void set_last_par_px(::google::protobuf::int64 value);

  // optional sfixed32 last_par_px_exponent = 13;
  inline bool has_last_par_px_exponent() const;
  inline void clear_last_par_px_exponent();
  static const int kLastParPxExponentFieldNumber = 13;
  inline ::google::protobuf::int32 last_par_px_exponent() const;
  inline void set_last_par_px_exponent(::google::protobuf::int32 value);

  // optional double last_px = 14;
  inline bool has_last_px() const;
  inline void clear_last_px();
  static const int kLastPxFieldNumber = 14;
  inline double last_px() const;
  inline void set_last_px(double value);

  // optional sfixed64 last_qty = 15;
  inline bool has_last_qty() const;
  inline void clear_last_qty();
  static const int kLastQtyFieldNumber = 15;
  inline ::google::protobuf::int64 last_qty() const;
  inline void set_last_qty(::google::protobuf::int64 value);

  // optional sfixed32 last_qty_exponent = 16;
  inline bool has_last_qty_exponent() const;
  inline void clear_last_qty_exponent();
  static const int kLastQtyExponentFieldNumber = 16;
  inline ::google::protobuf::int32 last_qty_exponent() const;
  inline void set_last_qty_exponent(::google::protobuf::int32 value);

  // optional string order_id = 17;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 17;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional .Common.OrderQtyData order_qty_data = 18;
  inline bool has_order_qty_data() const;
  inline void clear_order_qty_data();
  static const int kOrderQtyDataFieldNumber = 18;
  inline const ::Common::OrderQtyData& order_qty_data() const;
  inline ::Common::OrderQtyData* mutable_order_qty_data();
  inline ::Common::OrderQtyData* release_order_qty_data();
  inline void set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data);

  // optional .SingleGeneralOrderHandling.PriceTypeEnum price_type = 19;
  inline bool has_price_type() const;
  inline void clear_price_type();
  static const int kPriceTypeFieldNumber = 19;
  inline ::SingleGeneralOrderHandling::PriceTypeEnum price_type() const;
  inline void set_price_type(::SingleGeneralOrderHandling::PriceTypeEnum value);

  // optional string secondary_order_id = 20;
  inline bool has_secondary_order_id() const;
  inline void clear_secondary_order_id();
  static const int kSecondaryOrderIdFieldNumber = 20;
  inline const ::std::string& secondary_order_id() const;
  inline void set_secondary_order_id(const ::std::string& value);
  inline void set_secondary_order_id(const char* value);
  inline void set_secondary_order_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_order_id();
  inline ::std::string* release_secondary_order_id();
  inline void set_allocated_secondary_order_id(::std::string* secondary_order_id);

  // optional .SingleGeneralOrderHandling.SideEnum side = 21;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 21;
  inline ::SingleGeneralOrderHandling::SideEnum side() const;
  inline void set_side(::SingleGeneralOrderHandling::SideEnum value);

  // optional .Session.StandardHeader standard_header = 22;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 22;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 23;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 23;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional string text = 24;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 24;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 25;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 25;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.ExecutionAcknowledgement)
 private:
  inline void set_has_avg_px();
  inline void clear_has_avg_px();
  inline void set_has_cl_ord_id();
  inline void clear_has_cl_ord_id();
  inline void set_has_cum_qty();
  inline void clear_has_cum_qty();
  inline void set_has_cum_qty_exponent();
  inline void clear_has_cum_qty_exponent();
  inline void set_has_dkreason();
  inline void clear_has_dkreason();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_exec_ack_status();
  inline void clear_has_exec_ack_status();
  inline void set_has_exec_id();
  inline void clear_has_exec_id();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_last_par_px();
  inline void clear_has_last_par_px();
  inline void set_has_last_par_px_exponent();
  inline void clear_has_last_par_px_exponent();
  inline void set_has_last_px();
  inline void clear_has_last_px();
  inline void set_has_last_qty();
  inline void clear_has_last_qty();
  inline void set_has_last_qty_exponent();
  inline void clear_has_last_qty_exponent();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_order_qty_data();
  inline void clear_has_order_qty_data();
  inline void set_has_price_type();
  inline void clear_has_price_type();
  inline void set_has_secondary_order_id();
  inline void clear_has_secondary_order_id();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 avg_px_;
  ::std::string* cl_ord_id_;
  ::google::protobuf::int64 cum_qty_;
  ::google::protobuf::int32 cum_qty_exponent_;
  int dkreason_;
  ::std::string* encoded_text_;
  ::google::protobuf::uint32 encoded_text_len_;
  int exec_ack_status_;
  ::std::string* exec_id_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp > instrmt_leg_grp_;
  ::Common::Instrument* instrument_;
  ::google::protobuf::int64 last_par_px_;
  double last_px_;
  ::google::protobuf::int32 last_par_px_exponent_;
  ::google::protobuf::int32 last_qty_exponent_;
  ::google::protobuf::int64 last_qty_;
  ::std::string* order_id_;
  ::Common::OrderQtyData* order_qty_data_;
  ::std::string* secondary_order_id_;
  int price_type_;
  int side_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::std::string* text_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static ExecutionAcknowledgement* default_instance_;
};
// -------------------------------------------------------------------

class DontKnowTrade : public ::google::protobuf::Message {
 public:
  DontKnowTrade();
  virtual ~DontKnowTrade();

  DontKnowTrade(const DontKnowTrade& from);

  inline DontKnowTrade& operator=(const DontKnowTrade& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DontKnowTrade& default_instance();

  void Swap(DontKnowTrade* other);

  // implements Message ----------------------------------------------

  DontKnowTrade* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DontKnowTrade& from);
  void MergeFrom(const DontKnowTrade& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SingleGeneralOrderHandling.DKReasonEnum dkreason = 1;
  inline bool has_dkreason() const;
  inline void clear_dkreason();
  static const int kDkreasonFieldNumber = 1;
  inline ::SingleGeneralOrderHandling::DKReasonEnum dkreason() const;
  inline void set_dkreason(::SingleGeneralOrderHandling::DKReasonEnum value);

  // optional string exec_id = 2;
  inline bool has_exec_id() const;
  inline void clear_exec_id();
  static const int kExecIdFieldNumber = 2;
  inline const ::std::string& exec_id() const;
  inline void set_exec_id(const ::std::string& value);
  inline void set_exec_id(const char* value);
  inline void set_exec_id(const char* value, size_t size);
  inline ::std::string* mutable_exec_id();
  inline ::std::string* release_exec_id();
  inline void set_allocated_exec_id(::std::string* exec_id);

  // optional double last_px = 3;
  inline bool has_last_px() const;
  inline void clear_last_px();
  static const int kLastPxFieldNumber = 3;
  inline double last_px() const;
  inline void set_last_px(double value);

  // optional sfixed64 last_qty = 4;
  inline bool has_last_qty() const;
  inline void clear_last_qty();
  static const int kLastQtyFieldNumber = 4;
  inline ::google::protobuf::int64 last_qty() const;
  inline void set_last_qty(::google::protobuf::int64 value);

  // optional sfixed32 last_qty_exponent = 5;
  inline bool has_last_qty_exponent() const;
  inline void clear_last_qty_exponent();
  static const int kLastQtyExponentFieldNumber = 5;
  inline ::google::protobuf::int32 last_qty_exponent() const;
  inline void set_last_qty_exponent(::google::protobuf::int32 value);

  // optional string order_id = 6;
  inline bool has_order_id() const;
  inline void clear_order_id();
  static const int kOrderIdFieldNumber = 6;
  inline const ::std::string& order_id() const;
  inline void set_order_id(const ::std::string& value);
  inline void set_order_id(const char* value);
  inline void set_order_id(const char* value, size_t size);
  inline ::std::string* mutable_order_id();
  inline ::std::string* release_order_id();
  inline void set_allocated_order_id(::std::string* order_id);

  // optional .SingleGeneralOrderHandling.SideEnum side = 7;
  inline bool has_side() const;
  inline void clear_side();
  static const int kSideFieldNumber = 7;
  inline ::SingleGeneralOrderHandling::SideEnum side() const;
  inline void set_side(::SingleGeneralOrderHandling::SideEnum value);

  // optional .Session.StandardHeader standard_header = 8;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 8;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 9;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 9;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional string text = 10;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 10;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bytes encoded_text = 11;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 11;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 12;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 12;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional .Common.Instrument instrument = 13;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 13;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional .Common.OrderQtyData order_qty_data = 14;
  inline bool has_order_qty_data() const;
  inline void clear_order_qty_data();
  static const int kOrderQtyDataFieldNumber = 14;
  inline const ::Common::OrderQtyData& order_qty_data() const;
  inline ::Common::OrderQtyData* mutable_order_qty_data();
  inline ::Common::OrderQtyData* release_order_qty_data();
  inline void set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data);

  // repeated .Common.InstrmtLegGrp instrmt_leg_grp = 15;
  inline int instrmt_leg_grp_size() const;
  inline void clear_instrmt_leg_grp();
  static const int kInstrmtLegGrpFieldNumber = 15;
  inline const ::Common::InstrmtLegGrp& instrmt_leg_grp(int index) const;
  inline ::Common::InstrmtLegGrp* mutable_instrmt_leg_grp(int index);
  inline ::Common::InstrmtLegGrp* add_instrmt_leg_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
      instrmt_leg_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
      mutable_instrmt_leg_grp();

  // optional string secondary_order_id = 16;
  inline bool has_secondary_order_id() const;
  inline void clear_secondary_order_id();
  static const int kSecondaryOrderIdFieldNumber = 16;
  inline const ::std::string& secondary_order_id() const;
  inline void set_secondary_order_id(const ::std::string& value);
  inline void set_secondary_order_id(const char* value);
  inline void set_secondary_order_id(const char* value, size_t size);
  inline ::std::string* mutable_secondary_order_id();
  inline ::std::string* release_secondary_order_id();
  inline void set_allocated_secondary_order_id(::std::string* secondary_order_id);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 17;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 17;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // @@protoc_insertion_point(class_scope:SingleGeneralOrderHandling.DontKnowTrade)
 private:
  inline void set_has_dkreason();
  inline void clear_has_dkreason();
  inline void set_has_exec_id();
  inline void clear_has_exec_id();
  inline void set_has_last_px();
  inline void clear_has_last_px();
  inline void set_has_last_qty();
  inline void clear_has_last_qty();
  inline void set_has_last_qty_exponent();
  inline void clear_has_last_qty_exponent();
  inline void set_has_order_id();
  inline void clear_has_order_id();
  inline void set_has_side();
  inline void clear_has_side();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_order_qty_data();
  inline void clear_has_order_qty_data();
  inline void set_has_secondary_order_id();
  inline void clear_has_secondary_order_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* exec_id_;
  double last_px_;
  int dkreason_;
  ::google::protobuf::int32 last_qty_exponent_;
  ::google::protobuf::int64 last_qty_;
  ::std::string* order_id_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  int side_;
  ::google::protobuf::uint32 encoded_text_len_;
  ::std::string* text_;
  ::std::string* encoded_text_;
  ::Common::Instrument* instrument_;
  ::Common::OrderQtyData* order_qty_data_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp > instrmt_leg_grp_;
  ::std::string* secondary_order_id_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_AssignDesc_singlegeneralorderhandling_2eproto();
  friend void protobuf_ShutdownFile_singlegeneralorderhandling_2eproto();

  void InitAsDefaultInstance();
  static DontKnowTrade* default_instance_;
};
// ===================================================================


// ===================================================================

// AcctIdSourceUnion

// optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 1;
inline bool AcctIdSourceUnion::has_acct_id_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AcctIdSourceUnion::set_has_acct_id_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AcctIdSourceUnion::clear_has_acct_id_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AcctIdSourceUnion::clear_acct_id_source() {
  acct_id_source_ = 0;
  clear_has_acct_id_source();
}
inline ::SingleGeneralOrderHandling::AcctIdSourceEnum AcctIdSourceUnion::acct_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::AcctIdSourceEnum >(acct_id_source_);
}
inline void AcctIdSourceUnion::set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::AcctIdSourceEnum_IsValid(value));
  set_has_acct_id_source();
  acct_id_source_ = value;
}

// optional sfixed64 acct_id_source_sfixed64 = 2;
inline bool AcctIdSourceUnion::has_acct_id_source_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AcctIdSourceUnion::set_has_acct_id_source_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AcctIdSourceUnion::clear_has_acct_id_source_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AcctIdSourceUnion::clear_acct_id_source_sfixed64() {
  acct_id_source_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_acct_id_source_sfixed64();
}
inline ::google::protobuf::int64 AcctIdSourceUnion::acct_id_source_sfixed64() const {
  return acct_id_source_sfixed64_;
}
inline void AcctIdSourceUnion::set_acct_id_source_sfixed64(::google::protobuf::int64 value) {
  set_has_acct_id_source_sfixed64();
  acct_id_source_sfixed64_ = value;
}

// -------------------------------------------------------------------

// SettlTypeUnion

// optional .SingleGeneralOrderHandling.SettlTypeEnum settl_type = 1;
inline bool SettlTypeUnion::has_settl_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SettlTypeUnion::set_has_settl_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SettlTypeUnion::clear_has_settl_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SettlTypeUnion::clear_settl_type() {
  settl_type_ = 0;
  clear_has_settl_type();
}
inline ::SingleGeneralOrderHandling::SettlTypeEnum SettlTypeUnion::settl_type() const {
  return static_cast< ::SingleGeneralOrderHandling::SettlTypeEnum >(settl_type_);
}
inline void SettlTypeUnion::set_settl_type(::SingleGeneralOrderHandling::SettlTypeEnum value) {
  assert(::SingleGeneralOrderHandling::SettlTypeEnum_IsValid(value));
  set_has_settl_type();
  settl_type_ = value;
}

// optional .fix.Tenor settl_type_tenor = 2;
inline bool SettlTypeUnion::has_settl_type_tenor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SettlTypeUnion::set_has_settl_type_tenor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SettlTypeUnion::clear_has_settl_type_tenor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SettlTypeUnion::clear_settl_type_tenor() {
  if (settl_type_tenor_ != NULL) settl_type_tenor_->::fix::Tenor::Clear();
  clear_has_settl_type_tenor();
}
inline const ::fix::Tenor& SettlTypeUnion::settl_type_tenor() const {
  return settl_type_tenor_ != NULL ? *settl_type_tenor_ : *default_instance_->settl_type_tenor_;
}
inline ::fix::Tenor* SettlTypeUnion::mutable_settl_type_tenor() {
  set_has_settl_type_tenor();
  if (settl_type_tenor_ == NULL) settl_type_tenor_ = new ::fix::Tenor;
  return settl_type_tenor_;
}
inline ::fix::Tenor* SettlTypeUnion::release_settl_type_tenor() {
  clear_has_settl_type_tenor();
  ::fix::Tenor* temp = settl_type_tenor_;
  settl_type_tenor_ = NULL;
  return temp;
}
inline void SettlTypeUnion::set_allocated_settl_type_tenor(::fix::Tenor* settl_type_tenor) {
  delete settl_type_tenor_;
  settl_type_tenor_ = settl_type_tenor;
  if (settl_type_tenor) {
    set_has_settl_type_tenor();
  } else {
    clear_has_settl_type_tenor();
  }
}

// -------------------------------------------------------------------

// TargetStrategyUnion

// optional .SingleGeneralOrderHandling.TargetStrategyEnum target_strategy = 1;
inline bool TargetStrategyUnion::has_target_strategy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TargetStrategyUnion::set_has_target_strategy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TargetStrategyUnion::clear_has_target_strategy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TargetStrategyUnion::clear_target_strategy() {
  target_strategy_ = 0;
  clear_has_target_strategy();
}
inline ::SingleGeneralOrderHandling::TargetStrategyEnum TargetStrategyUnion::target_strategy() const {
  return static_cast< ::SingleGeneralOrderHandling::TargetStrategyEnum >(target_strategy_);
}
inline void TargetStrategyUnion::set_target_strategy(::SingleGeneralOrderHandling::TargetStrategyEnum value) {
  assert(::SingleGeneralOrderHandling::TargetStrategyEnum_IsValid(value));
  set_has_target_strategy();
  target_strategy_ = value;
}

// optional sfixed64 target_strategy_sfixed64 = 2;
inline bool TargetStrategyUnion::has_target_strategy_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TargetStrategyUnion::set_has_target_strategy_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TargetStrategyUnion::clear_has_target_strategy_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TargetStrategyUnion::clear_target_strategy_sfixed64() {
  target_strategy_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_target_strategy_sfixed64();
}
inline ::google::protobuf::int64 TargetStrategyUnion::target_strategy_sfixed64() const {
  return target_strategy_sfixed64_;
}
inline void TargetStrategyUnion::set_target_strategy_sfixed64(::google::protobuf::int64 value) {
  set_has_target_strategy_sfixed64();
  target_strategy_sfixed64_ = value;
}

// -------------------------------------------------------------------

// NewOrderSingle

// optional string account = 1;
inline bool NewOrderSingle::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewOrderSingle::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewOrderSingle::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewOrderSingle::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& NewOrderSingle::account() const {
  return *account_;
}
inline void NewOrderSingle::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void NewOrderSingle::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void NewOrderSingle::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* NewOrderSingle::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cl_ord_id = 2;
inline bool NewOrderSingle::has_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewOrderSingle::set_has_cl_ord_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewOrderSingle::clear_has_cl_ord_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewOrderSingle::clear_cl_ord_id() {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_->clear();
  }
  clear_has_cl_ord_id();
}
inline const ::std::string& NewOrderSingle::cl_ord_id() const {
  return *cl_ord_id_;
}
inline void NewOrderSingle::set_cl_ord_id(const ::std::string& value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void NewOrderSingle::set_cl_ord_id(const char* value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void NewOrderSingle::set_cl_ord_id(const char* value, size_t size) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_cl_ord_id() {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  return cl_ord_id_;
}
inline ::std::string* NewOrderSingle::release_cl_ord_id() {
  clear_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_id_;
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_cl_ord_id(::std::string* cl_ord_id) {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_id_;
  }
  if (cl_ord_id) {
    set_has_cl_ord_id();
    cl_ord_id_ = cl_ord_id;
  } else {
    clear_has_cl_ord_id();
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string currency = 3;
inline bool NewOrderSingle::has_currency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NewOrderSingle::set_has_currency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NewOrderSingle::clear_has_currency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NewOrderSingle::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& NewOrderSingle::currency() const {
  return *currency_;
}
inline void NewOrderSingle::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void NewOrderSingle::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void NewOrderSingle::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* NewOrderSingle::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ex_destination = 4;
inline bool NewOrderSingle::has_ex_destination() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NewOrderSingle::set_has_ex_destination() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NewOrderSingle::clear_has_ex_destination() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NewOrderSingle::clear_ex_destination() {
  if (ex_destination_ != &::google::protobuf::internal::kEmptyString) {
    ex_destination_->clear();
  }
  clear_has_ex_destination();
}
inline const ::std::string& NewOrderSingle::ex_destination() const {
  return *ex_destination_;
}
inline void NewOrderSingle::set_ex_destination(const ::std::string& value) {
  set_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    ex_destination_ = new ::std::string;
  }
  ex_destination_->assign(value);
}
inline void NewOrderSingle::set_ex_destination(const char* value) {
  set_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    ex_destination_ = new ::std::string;
  }
  ex_destination_->assign(value);
}
inline void NewOrderSingle::set_ex_destination(const char* value, size_t size) {
  set_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    ex_destination_ = new ::std::string;
  }
  ex_destination_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_ex_destination() {
  set_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    ex_destination_ = new ::std::string;
  }
  return ex_destination_;
}
inline ::std::string* NewOrderSingle::release_ex_destination() {
  clear_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ex_destination_;
    ex_destination_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_ex_destination(::std::string* ex_destination) {
  if (ex_destination_ != &::google::protobuf::internal::kEmptyString) {
    delete ex_destination_;
  }
  if (ex_destination) {
    set_has_ex_destination();
    ex_destination_ = ex_destination;
  } else {
    clear_has_ex_destination();
    ex_destination_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .SingleGeneralOrderHandling.ExecInstEnum exec_inst = 5 [packed = true];
inline int NewOrderSingle::exec_inst_size() const {
  return exec_inst_.size();
}
inline void NewOrderSingle::clear_exec_inst() {
  exec_inst_.Clear();
}
inline ::SingleGeneralOrderHandling::ExecInstEnum NewOrderSingle::exec_inst(int index) const {
  return static_cast< ::SingleGeneralOrderHandling::ExecInstEnum >(exec_inst_.Get(index));
}
inline void NewOrderSingle::set_exec_inst(int index, ::SingleGeneralOrderHandling::ExecInstEnum value) {
  assert(::SingleGeneralOrderHandling::ExecInstEnum_IsValid(value));
  exec_inst_.Set(index, value);
}
inline void NewOrderSingle::add_exec_inst(::SingleGeneralOrderHandling::ExecInstEnum value) {
  assert(::SingleGeneralOrderHandling::ExecInstEnum_IsValid(value));
  exec_inst_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
NewOrderSingle::exec_inst() const {
  return exec_inst_;
}
inline ::google::protobuf::RepeatedField<int>*
NewOrderSingle::mutable_exec_inst() {
  return &exec_inst_;
}

// optional .SingleGeneralOrderHandling.HandlInstEnum handl_inst = 6;
inline bool NewOrderSingle::has_handl_inst() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NewOrderSingle::set_has_handl_inst() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NewOrderSingle::clear_has_handl_inst() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NewOrderSingle::clear_handl_inst() {
  handl_inst_ = 0;
  clear_has_handl_inst();
}
inline ::SingleGeneralOrderHandling::HandlInstEnum NewOrderSingle::handl_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::HandlInstEnum >(handl_inst_);
}
inline void NewOrderSingle::set_handl_inst(::SingleGeneralOrderHandling::HandlInstEnum value) {
  assert(::SingleGeneralOrderHandling::HandlInstEnum_IsValid(value));
  set_has_handl_inst();
  handl_inst_ = value;
}

// optional string ioi_id = 7;
inline bool NewOrderSingle::has_ioi_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NewOrderSingle::set_has_ioi_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NewOrderSingle::clear_has_ioi_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NewOrderSingle::clear_ioi_id() {
  if (ioi_id_ != &::google::protobuf::internal::kEmptyString) {
    ioi_id_->clear();
  }
  clear_has_ioi_id();
}
inline const ::std::string& NewOrderSingle::ioi_id() const {
  return *ioi_id_;
}
inline void NewOrderSingle::set_ioi_id(const ::std::string& value) {
  set_has_ioi_id();
  if (ioi_id_ == &::google::protobuf::internal::kEmptyString) {
    ioi_id_ = new ::std::string;
  }
  ioi_id_->assign(value);
}
inline void NewOrderSingle::set_ioi_id(const char* value) {
  set_has_ioi_id();
  if (ioi_id_ == &::google::protobuf::internal::kEmptyString) {
    ioi_id_ = new ::std::string;
  }
  ioi_id_->assign(value);
}
inline void NewOrderSingle::set_ioi_id(const char* value, size_t size) {
  set_has_ioi_id();
  if (ioi_id_ == &::google::protobuf::internal::kEmptyString) {
    ioi_id_ = new ::std::string;
  }
  ioi_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_ioi_id() {
  set_has_ioi_id();
  if (ioi_id_ == &::google::protobuf::internal::kEmptyString) {
    ioi_id_ = new ::std::string;
  }
  return ioi_id_;
}
inline ::std::string* NewOrderSingle::release_ioi_id() {
  clear_has_ioi_id();
  if (ioi_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ioi_id_;
    ioi_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_ioi_id(::std::string* ioi_id) {
  if (ioi_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ioi_id_;
  }
  if (ioi_id) {
    set_has_ioi_id();
    ioi_id_ = ioi_id;
  } else {
    clear_has_ioi_id();
    ioi_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 max_floor = 8;
inline bool NewOrderSingle::has_max_floor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NewOrderSingle::set_has_max_floor() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NewOrderSingle::clear_has_max_floor() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NewOrderSingle::clear_max_floor() {
  max_floor_ = GOOGLE_LONGLONG(0);
  clear_has_max_floor();
}
inline ::google::protobuf::int64 NewOrderSingle::max_floor() const {
  return max_floor_;
}
inline void NewOrderSingle::set_max_floor(::google::protobuf::int64 value) {
  set_has_max_floor();
  max_floor_ = value;
}

// optional sfixed32 max_floor_exponent = 9;
inline bool NewOrderSingle::has_max_floor_exponent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NewOrderSingle::set_has_max_floor_exponent() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NewOrderSingle::clear_has_max_floor_exponent() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NewOrderSingle::clear_max_floor_exponent() {
  max_floor_exponent_ = 0;
  clear_has_max_floor_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::max_floor_exponent() const {
  return max_floor_exponent_;
}
inline void NewOrderSingle::set_max_floor_exponent(::google::protobuf::int32 value) {
  set_has_max_floor_exponent();
  max_floor_exponent_ = value;
}

// optional sfixed64 min_qty = 10;
inline bool NewOrderSingle::has_min_qty() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NewOrderSingle::set_has_min_qty() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NewOrderSingle::clear_has_min_qty() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NewOrderSingle::clear_min_qty() {
  min_qty_ = GOOGLE_LONGLONG(0);
  clear_has_min_qty();
}
inline ::google::protobuf::int64 NewOrderSingle::min_qty() const {
  return min_qty_;
}
inline void NewOrderSingle::set_min_qty(::google::protobuf::int64 value) {
  set_has_min_qty();
  min_qty_ = value;
}

// optional sfixed32 min_qty_exponent = 11;
inline bool NewOrderSingle::has_min_qty_exponent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NewOrderSingle::set_has_min_qty_exponent() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NewOrderSingle::clear_has_min_qty_exponent() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NewOrderSingle::clear_min_qty_exponent() {
  min_qty_exponent_ = 0;
  clear_has_min_qty_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::min_qty_exponent() const {
  return min_qty_exponent_;
}
inline void NewOrderSingle::set_min_qty_exponent(::google::protobuf::int32 value) {
  set_has_min_qty_exponent();
  min_qty_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.OrdTypeEnum ord_type = 12;
inline bool NewOrderSingle::has_ord_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NewOrderSingle::set_has_ord_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NewOrderSingle::clear_has_ord_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NewOrderSingle::clear_ord_type() {
  ord_type_ = 0;
  clear_has_ord_type();
}
inline ::SingleGeneralOrderHandling::OrdTypeEnum NewOrderSingle::ord_type() const {
  return static_cast< ::SingleGeneralOrderHandling::OrdTypeEnum >(ord_type_);
}
inline void NewOrderSingle::set_ord_type(::SingleGeneralOrderHandling::OrdTypeEnum value) {
  assert(::SingleGeneralOrderHandling::OrdTypeEnum_IsValid(value));
  set_has_ord_type();
  ord_type_ = value;
}

// optional sfixed64 price = 13;
inline bool NewOrderSingle::has_price() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NewOrderSingle::set_has_price() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NewOrderSingle::clear_has_price() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NewOrderSingle::clear_price() {
  price_ = GOOGLE_LONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::int64 NewOrderSingle::price() const {
  return price_;
}
inline void NewOrderSingle::set_price(::google::protobuf::int64 value) {
  set_has_price();
  price_ = value;
}

// optional sfixed32 price_exponent = 14;
inline bool NewOrderSingle::has_price_exponent() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NewOrderSingle::set_has_price_exponent() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NewOrderSingle::clear_has_price_exponent() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NewOrderSingle::clear_price_exponent() {
  price_exponent_ = 0;
  clear_has_price_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::price_exponent() const {
  return price_exponent_;
}
inline void NewOrderSingle::set_price_exponent(::google::protobuf::int32 value) {
  set_has_price_exponent();
  price_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.ProcessCodeEnum process_code = 15;
inline bool NewOrderSingle::has_process_code() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NewOrderSingle::set_has_process_code() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NewOrderSingle::clear_has_process_code() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NewOrderSingle::clear_process_code() {
  process_code_ = 0;
  clear_has_process_code();
}
inline ::SingleGeneralOrderHandling::ProcessCodeEnum NewOrderSingle::process_code() const {
  return static_cast< ::SingleGeneralOrderHandling::ProcessCodeEnum >(process_code_);
}
inline void NewOrderSingle::set_process_code(::SingleGeneralOrderHandling::ProcessCodeEnum value) {
  assert(::SingleGeneralOrderHandling::ProcessCodeEnum_IsValid(value));
  set_has_process_code();
  process_code_ = value;
}

// optional sfixed32 settl_date = 16;
inline bool NewOrderSingle::has_settl_date() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NewOrderSingle::set_has_settl_date() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NewOrderSingle::clear_has_settl_date() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NewOrderSingle::clear_settl_date() {
  settl_date_ = 0;
  clear_has_settl_date();
}
inline ::google::protobuf::int32 NewOrderSingle::settl_date() const {
  return settl_date_;
}
inline void NewOrderSingle::set_settl_date(::google::protobuf::int32 value) {
  set_has_settl_date();
  settl_date_ = value;
}

// optional .SingleGeneralOrderHandling.SettlTypeEnum settl_type = 17;
inline bool NewOrderSingle::has_settl_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NewOrderSingle::set_has_settl_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NewOrderSingle::clear_has_settl_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NewOrderSingle::clear_settl_type() {
  settl_type_ = 0;
  clear_has_settl_type();
}
inline ::SingleGeneralOrderHandling::SettlTypeEnum NewOrderSingle::settl_type() const {
  return static_cast< ::SingleGeneralOrderHandling::SettlTypeEnum >(settl_type_);
}
inline void NewOrderSingle::set_settl_type(::SingleGeneralOrderHandling::SettlTypeEnum value) {
  assert(::SingleGeneralOrderHandling::SettlTypeEnum_IsValid(value));
  set_has_settl_type();
  settl_type_ = value;
}

// optional .SingleGeneralOrderHandling.SideEnum side = 18;
inline bool NewOrderSingle::has_side() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NewOrderSingle::set_has_side() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NewOrderSingle::clear_has_side() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NewOrderSingle::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::SingleGeneralOrderHandling::SideEnum NewOrderSingle::side() const {
  return static_cast< ::SingleGeneralOrderHandling::SideEnum >(side_);
}
inline void NewOrderSingle::set_side(::SingleGeneralOrderHandling::SideEnum value) {
  assert(::SingleGeneralOrderHandling::SideEnum_IsValid(value));
  set_has_side();
  side_ = value;
}

// optional .Session.StandardHeader standard_header = 19;
inline bool NewOrderSingle::has_standard_header() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NewOrderSingle::set_has_standard_header() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NewOrderSingle::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NewOrderSingle::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& NewOrderSingle::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* NewOrderSingle::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* NewOrderSingle::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 20;
inline bool NewOrderSingle::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NewOrderSingle::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NewOrderSingle::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NewOrderSingle::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& NewOrderSingle::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* NewOrderSingle::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* NewOrderSingle::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional sfixed64 stop_px = 21;
inline bool NewOrderSingle::has_stop_px() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NewOrderSingle::set_has_stop_px() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NewOrderSingle::clear_has_stop_px() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NewOrderSingle::clear_stop_px() {
  stop_px_ = GOOGLE_LONGLONG(0);
  clear_has_stop_px();
}
inline ::google::protobuf::int64 NewOrderSingle::stop_px() const {
  return stop_px_;
}
inline void NewOrderSingle::set_stop_px(::google::protobuf::int64 value) {
  set_has_stop_px();
  stop_px_ = value;
}

// optional sfixed32 stop_px_exponent = 22;
inline bool NewOrderSingle::has_stop_px_exponent() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NewOrderSingle::set_has_stop_px_exponent() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NewOrderSingle::clear_has_stop_px_exponent() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NewOrderSingle::clear_stop_px_exponent() {
  stop_px_exponent_ = 0;
  clear_has_stop_px_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::stop_px_exponent() const {
  return stop_px_exponent_;
}
inline void NewOrderSingle::set_stop_px_exponent(::google::protobuf::int32 value) {
  set_has_stop_px_exponent();
  stop_px_exponent_ = value;
}

// optional string text = 23;
inline bool NewOrderSingle::has_text() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NewOrderSingle::set_has_text() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NewOrderSingle::clear_has_text() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NewOrderSingle::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& NewOrderSingle::text() const {
  return *text_;
}
inline void NewOrderSingle::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void NewOrderSingle::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void NewOrderSingle::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* NewOrderSingle::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.TimeInForceEnum time_in_force = 24;
inline bool NewOrderSingle::has_time_in_force() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void NewOrderSingle::set_has_time_in_force() {
  _has_bits_[0] |= 0x00800000u;
}
inline void NewOrderSingle::clear_has_time_in_force() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void NewOrderSingle::clear_time_in_force() {
  time_in_force_ = 0;
  clear_has_time_in_force();
}
inline ::SingleGeneralOrderHandling::TimeInForceEnum NewOrderSingle::time_in_force() const {
  return static_cast< ::SingleGeneralOrderHandling::TimeInForceEnum >(time_in_force_);
}
inline void NewOrderSingle::set_time_in_force(::SingleGeneralOrderHandling::TimeInForceEnum value) {
  assert(::SingleGeneralOrderHandling::TimeInForceEnum_IsValid(value));
  set_has_time_in_force();
  time_in_force_ = value;
}

// optional sfixed64 expire_time = 25;
inline bool NewOrderSingle::has_expire_time() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void NewOrderSingle::set_has_expire_time() {
  _has_bits_[0] |= 0x01000000u;
}
inline void NewOrderSingle::clear_has_expire_time() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void NewOrderSingle::clear_expire_time() {
  expire_time_ = GOOGLE_LONGLONG(0);
  clear_has_expire_time();
}
inline ::google::protobuf::int64 NewOrderSingle::expire_time() const {
  return expire_time_;
}
inline void NewOrderSingle::set_expire_time(::google::protobuf::int64 value) {
  set_has_expire_time();
  expire_time_ = value;
}

// optional bool forex_req = 26;
inline bool NewOrderSingle::has_forex_req() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void NewOrderSingle::set_has_forex_req() {
  _has_bits_[0] |= 0x02000000u;
}
inline void NewOrderSingle::clear_has_forex_req() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void NewOrderSingle::clear_forex_req() {
  forex_req_ = false;
  clear_has_forex_req();
}
inline bool NewOrderSingle::forex_req() const {
  return forex_req_;
}
inline void NewOrderSingle::set_forex_req(bool value) {
  set_has_forex_req();
  forex_req_ = value;
}

// optional bool locate_reqd = 27;
inline bool NewOrderSingle::has_locate_reqd() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void NewOrderSingle::set_has_locate_reqd() {
  _has_bits_[0] |= 0x04000000u;
}
inline void NewOrderSingle::clear_has_locate_reqd() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void NewOrderSingle::clear_locate_reqd() {
  locate_reqd_ = false;
  clear_has_locate_reqd();
}
inline bool NewOrderSingle::locate_reqd() const {
  return locate_reqd_;
}
inline void NewOrderSingle::set_locate_reqd(bool value) {
  set_has_locate_reqd();
  locate_reqd_ = value;
}

// optional sfixed64 prev_close_px = 28;
inline bool NewOrderSingle::has_prev_close_px() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void NewOrderSingle::set_has_prev_close_px() {
  _has_bits_[0] |= 0x08000000u;
}
inline void NewOrderSingle::clear_has_prev_close_px() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void NewOrderSingle::clear_prev_close_px() {
  prev_close_px_ = GOOGLE_LONGLONG(0);
  clear_has_prev_close_px();
}
inline ::google::protobuf::int64 NewOrderSingle::prev_close_px() const {
  return prev_close_px_;
}
inline void NewOrderSingle::set_prev_close_px(::google::protobuf::int64 value) {
  set_has_prev_close_px();
  prev_close_px_ = value;
}

// optional sfixed32 prev_close_px_exponent = 29;
inline bool NewOrderSingle::has_prev_close_px_exponent() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void NewOrderSingle::set_has_prev_close_px_exponent() {
  _has_bits_[0] |= 0x10000000u;
}
inline void NewOrderSingle::clear_has_prev_close_px_exponent() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void NewOrderSingle::clear_prev_close_px_exponent() {
  prev_close_px_exponent_ = 0;
  clear_has_prev_close_px_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::prev_close_px_exponent() const {
  return prev_close_px_exponent_;
}
inline void NewOrderSingle::set_prev_close_px_exponent(::google::protobuf::int32 value) {
  set_has_prev_close_px_exponent();
  prev_close_px_exponent_ = value;
}

// optional string quote_id = 30;
inline bool NewOrderSingle::has_quote_id() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void NewOrderSingle::set_has_quote_id() {
  _has_bits_[0] |= 0x20000000u;
}
inline void NewOrderSingle::clear_has_quote_id() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void NewOrderSingle::clear_quote_id() {
  if (quote_id_ != &::google::protobuf::internal::kEmptyString) {
    quote_id_->clear();
  }
  clear_has_quote_id();
}
inline const ::std::string& NewOrderSingle::quote_id() const {
  return *quote_id_;
}
inline void NewOrderSingle::set_quote_id(const ::std::string& value) {
  set_has_quote_id();
  if (quote_id_ == &::google::protobuf::internal::kEmptyString) {
    quote_id_ = new ::std::string;
  }
  quote_id_->assign(value);
}
inline void NewOrderSingle::set_quote_id(const char* value) {
  set_has_quote_id();
  if (quote_id_ == &::google::protobuf::internal::kEmptyString) {
    quote_id_ = new ::std::string;
  }
  quote_id_->assign(value);
}
inline void NewOrderSingle::set_quote_id(const char* value, size_t size) {
  set_has_quote_id();
  if (quote_id_ == &::google::protobuf::internal::kEmptyString) {
    quote_id_ = new ::std::string;
  }
  quote_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_quote_id() {
  set_has_quote_id();
  if (quote_id_ == &::google::protobuf::internal::kEmptyString) {
    quote_id_ = new ::std::string;
  }
  return quote_id_;
}
inline ::std::string* NewOrderSingle::release_quote_id() {
  clear_has_quote_id();
  if (quote_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quote_id_;
    quote_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_quote_id(::std::string* quote_id) {
  if (quote_id_ != &::google::protobuf::internal::kEmptyString) {
    delete quote_id_;
  }
  if (quote_id) {
    set_has_quote_id();
    quote_id_ = quote_id;
  } else {
    clear_has_quote_id();
    quote_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string settl_currency = 31;
inline bool NewOrderSingle::has_settl_currency() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void NewOrderSingle::set_has_settl_currency() {
  _has_bits_[0] |= 0x40000000u;
}
inline void NewOrderSingle::clear_has_settl_currency() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void NewOrderSingle::clear_settl_currency() {
  if (settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    settl_currency_->clear();
  }
  clear_has_settl_currency();
}
inline const ::std::string& NewOrderSingle::settl_currency() const {
  return *settl_currency_;
}
inline void NewOrderSingle::set_settl_currency(const ::std::string& value) {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  settl_currency_->assign(value);
}
inline void NewOrderSingle::set_settl_currency(const char* value) {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  settl_currency_->assign(value);
}
inline void NewOrderSingle::set_settl_currency(const char* value, size_t size) {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  settl_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_settl_currency() {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  return settl_currency_;
}
inline ::std::string* NewOrderSingle::release_settl_currency() {
  clear_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = settl_currency_;
    settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_settl_currency(::std::string* settl_currency) {
  if (settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete settl_currency_;
  }
  if (settl_currency) {
    set_has_settl_currency();
    settl_currency_ = settl_currency;
  } else {
    clear_has_settl_currency();
    settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.CoveredOrUncoveredEnum covered_or_uncovered = 32;
inline bool NewOrderSingle::has_covered_or_uncovered() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void NewOrderSingle::set_has_covered_or_uncovered() {
  _has_bits_[0] |= 0x80000000u;
}
inline void NewOrderSingle::clear_has_covered_or_uncovered() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void NewOrderSingle::clear_covered_or_uncovered() {
  covered_or_uncovered_ = 0;
  clear_has_covered_or_uncovered();
}
inline ::SingleGeneralOrderHandling::CoveredOrUncoveredEnum NewOrderSingle::covered_or_uncovered() const {
  return static_cast< ::SingleGeneralOrderHandling::CoveredOrUncoveredEnum >(covered_or_uncovered_);
}
inline void NewOrderSingle::set_covered_or_uncovered(::SingleGeneralOrderHandling::CoveredOrUncoveredEnum value) {
  assert(::SingleGeneralOrderHandling::CoveredOrUncoveredEnum_IsValid(value));
  set_has_covered_or_uncovered();
  covered_or_uncovered_ = value;
}

// optional sfixed64 max_show = 33;
inline bool NewOrderSingle::has_max_show() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void NewOrderSingle::set_has_max_show() {
  _has_bits_[1] |= 0x00000001u;
}
inline void NewOrderSingle::clear_has_max_show() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void NewOrderSingle::clear_max_show() {
  max_show_ = GOOGLE_LONGLONG(0);
  clear_has_max_show();
}
inline ::google::protobuf::int64 NewOrderSingle::max_show() const {
  return max_show_;
}
inline void NewOrderSingle::set_max_show(::google::protobuf::int64 value) {
  set_has_max_show();
  max_show_ = value;
}

// optional sfixed32 max_show_exponent = 34;
inline bool NewOrderSingle::has_max_show_exponent() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void NewOrderSingle::set_has_max_show_exponent() {
  _has_bits_[1] |= 0x00000002u;
}
inline void NewOrderSingle::clear_has_max_show_exponent() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void NewOrderSingle::clear_max_show_exponent() {
  max_show_exponent_ = 0;
  clear_has_max_show_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::max_show_exponent() const {
  return max_show_exponent_;
}
inline void NewOrderSingle::set_max_show_exponent(::google::protobuf::int32 value) {
  set_has_max_show_exponent();
  max_show_exponent_ = value;
}

// optional sfixed64 order_qty2 = 35;
inline bool NewOrderSingle::has_order_qty2() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void NewOrderSingle::set_has_order_qty2() {
  _has_bits_[1] |= 0x00000004u;
}
inline void NewOrderSingle::clear_has_order_qty2() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void NewOrderSingle::clear_order_qty2() {
  order_qty2_ = GOOGLE_LONGLONG(0);
  clear_has_order_qty2();
}
inline ::google::protobuf::int64 NewOrderSingle::order_qty2() const {
  return order_qty2_;
}
inline void NewOrderSingle::set_order_qty2(::google::protobuf::int64 value) {
  set_has_order_qty2();
  order_qty2_ = value;
}

// optional sfixed32 order_qty2_exponent = 36;
inline bool NewOrderSingle::has_order_qty2_exponent() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void NewOrderSingle::set_has_order_qty2_exponent() {
  _has_bits_[1] |= 0x00000008u;
}
inline void NewOrderSingle::clear_has_order_qty2_exponent() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void NewOrderSingle::clear_order_qty2_exponent() {
  order_qty2_exponent_ = 0;
  clear_has_order_qty2_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::order_qty2_exponent() const {
  return order_qty2_exponent_;
}
inline void NewOrderSingle::set_order_qty2_exponent(::google::protobuf::int32 value) {
  set_has_order_qty2_exponent();
  order_qty2_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.PositionEffectEnum position_effect = 37;
inline bool NewOrderSingle::has_position_effect() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void NewOrderSingle::set_has_position_effect() {
  _has_bits_[1] |= 0x00000010u;
}
inline void NewOrderSingle::clear_has_position_effect() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void NewOrderSingle::clear_position_effect() {
  position_effect_ = 0;
  clear_has_position_effect();
}
inline ::SingleGeneralOrderHandling::PositionEffectEnum NewOrderSingle::position_effect() const {
  return static_cast< ::SingleGeneralOrderHandling::PositionEffectEnum >(position_effect_);
}
inline void NewOrderSingle::set_position_effect(::SingleGeneralOrderHandling::PositionEffectEnum value) {
  assert(::SingleGeneralOrderHandling::PositionEffectEnum_IsValid(value));
  set_has_position_effect();
  position_effect_ = value;
}

// optional sfixed32 settl_date2 = 38;
inline bool NewOrderSingle::has_settl_date2() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void NewOrderSingle::set_has_settl_date2() {
  _has_bits_[1] |= 0x00000020u;
}
inline void NewOrderSingle::clear_has_settl_date2() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void NewOrderSingle::clear_settl_date2() {
  settl_date2_ = 0;
  clear_has_settl_date2();
}
inline ::google::protobuf::int32 NewOrderSingle::settl_date2() const {
  return settl_date2_;
}
inline void NewOrderSingle::set_settl_date2(::google::protobuf::int32 value) {
  set_has_settl_date2();
  settl_date2_ = value;
}

// optional string compliance_id = 39;
inline bool NewOrderSingle::has_compliance_id() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void NewOrderSingle::set_has_compliance_id() {
  _has_bits_[1] |= 0x00000040u;
}
inline void NewOrderSingle::clear_has_compliance_id() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void NewOrderSingle::clear_compliance_id() {
  if (compliance_id_ != &::google::protobuf::internal::kEmptyString) {
    compliance_id_->clear();
  }
  clear_has_compliance_id();
}
inline const ::std::string& NewOrderSingle::compliance_id() const {
  return *compliance_id_;
}
inline void NewOrderSingle::set_compliance_id(const ::std::string& value) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(value);
}
inline void NewOrderSingle::set_compliance_id(const char* value) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(value);
}
inline void NewOrderSingle::set_compliance_id(const char* value, size_t size) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_compliance_id() {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  return compliance_id_;
}
inline ::std::string* NewOrderSingle::release_compliance_id() {
  clear_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compliance_id_;
    compliance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_compliance_id(::std::string* compliance_id) {
  if (compliance_id_ != &::google::protobuf::internal::kEmptyString) {
    delete compliance_id_;
  }
  if (compliance_id) {
    set_has_compliance_id();
    compliance_id_ = compliance_id;
  } else {
    clear_has_compliance_id();
    compliance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 effective_time = 40;
inline bool NewOrderSingle::has_effective_time() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void NewOrderSingle::set_has_effective_time() {
  _has_bits_[1] |= 0x00000080u;
}
inline void NewOrderSingle::clear_has_effective_time() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void NewOrderSingle::clear_effective_time() {
  effective_time_ = GOOGLE_LONGLONG(0);
  clear_has_effective_time();
}
inline ::google::protobuf::int64 NewOrderSingle::effective_time() const {
  return effective_time_;
}
inline void NewOrderSingle::set_effective_time(::google::protobuf::int64 value) {
  set_has_effective_time();
  effective_time_ = value;
}

// optional bytes encoded_text = 41;
inline bool NewOrderSingle::has_encoded_text() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void NewOrderSingle::set_has_encoded_text() {
  _has_bits_[1] |= 0x00000100u;
}
inline void NewOrderSingle::clear_has_encoded_text() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void NewOrderSingle::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& NewOrderSingle::encoded_text() const {
  return *encoded_text_;
}
inline void NewOrderSingle::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void NewOrderSingle::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void NewOrderSingle::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* NewOrderSingle::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 42;
inline bool NewOrderSingle::has_encoded_text_len() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void NewOrderSingle::set_has_encoded_text_len() {
  _has_bits_[1] |= 0x00000200u;
}
inline void NewOrderSingle::clear_has_encoded_text_len() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void NewOrderSingle::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 NewOrderSingle::encoded_text_len() const {
  return encoded_text_len_;
}
inline void NewOrderSingle::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional sfixed32 expire_date = 43;
inline bool NewOrderSingle::has_expire_date() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void NewOrderSingle::set_has_expire_date() {
  _has_bits_[1] |= 0x00000400u;
}
inline void NewOrderSingle::clear_has_expire_date() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void NewOrderSingle::clear_expire_date() {
  expire_date_ = 0;
  clear_has_expire_date();
}
inline ::google::protobuf::int32 NewOrderSingle::expire_date() const {
  return expire_date_;
}
inline void NewOrderSingle::set_expire_date(::google::protobuf::int32 value) {
  set_has_expire_date();
  expire_date_ = value;
}

// optional .SingleGeneralOrderHandling.GtBookingInstEnum gt_booking_inst = 44;
inline bool NewOrderSingle::has_gt_booking_inst() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void NewOrderSingle::set_has_gt_booking_inst() {
  _has_bits_[1] |= 0x00000800u;
}
inline void NewOrderSingle::clear_has_gt_booking_inst() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void NewOrderSingle::clear_gt_booking_inst() {
  gt_booking_inst_ = 0;
  clear_has_gt_booking_inst();
}
inline ::SingleGeneralOrderHandling::GtBookingInstEnum NewOrderSingle::gt_booking_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::GtBookingInstEnum >(gt_booking_inst_);
}
inline void NewOrderSingle::set_gt_booking_inst(::SingleGeneralOrderHandling::GtBookingInstEnum value) {
  assert(::SingleGeneralOrderHandling::GtBookingInstEnum_IsValid(value));
  set_has_gt_booking_inst();
  gt_booking_inst_ = value;
}

// optional bool solicited_flag = 45;
inline bool NewOrderSingle::has_solicited_flag() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void NewOrderSingle::set_has_solicited_flag() {
  _has_bits_[1] |= 0x00001000u;
}
inline void NewOrderSingle::clear_has_solicited_flag() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void NewOrderSingle::clear_solicited_flag() {
  solicited_flag_ = false;
  clear_has_solicited_flag();
}
inline bool NewOrderSingle::solicited_flag() const {
  return solicited_flag_;
}
inline void NewOrderSingle::set_solicited_flag(bool value) {
  set_has_solicited_flag();
  solicited_flag_ = value;
}

// optional sfixed64 transact_time = 46;
inline bool NewOrderSingle::has_transact_time() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void NewOrderSingle::set_has_transact_time() {
  _has_bits_[1] |= 0x00002000u;
}
inline void NewOrderSingle::clear_has_transact_time() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void NewOrderSingle::clear_transact_time() {
  transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_transact_time();
}
inline ::google::protobuf::int64 NewOrderSingle::transact_time() const {
  return transact_time_;
}
inline void NewOrderSingle::set_transact_time(::google::protobuf::int64 value) {
  set_has_transact_time();
  transact_time_ = value;
}

// optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 47;
inline bool NewOrderSingle::has_account_type() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void NewOrderSingle::set_has_account_type() {
  _has_bits_[1] |= 0x00004000u;
}
inline void NewOrderSingle::clear_has_account_type() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void NewOrderSingle::clear_account_type() {
  account_type_ = 0;
  clear_has_account_type();
}
inline ::SingleGeneralOrderHandling::AccountTypeEnum NewOrderSingle::account_type() const {
  return static_cast< ::SingleGeneralOrderHandling::AccountTypeEnum >(account_type_);
}
inline void NewOrderSingle::set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value) {
  assert(::SingleGeneralOrderHandling::AccountTypeEnum_IsValid(value));
  set_has_account_type();
  account_type_ = value;
}

// optional .SingleGeneralOrderHandling.BookingUnitEnum booking_unit = 48;
inline bool NewOrderSingle::has_booking_unit() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void NewOrderSingle::set_has_booking_unit() {
  _has_bits_[1] |= 0x00008000u;
}
inline void NewOrderSingle::clear_has_booking_unit() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void NewOrderSingle::clear_booking_unit() {
  booking_unit_ = 0;
  clear_has_booking_unit();
}
inline ::SingleGeneralOrderHandling::BookingUnitEnum NewOrderSingle::booking_unit() const {
  return static_cast< ::SingleGeneralOrderHandling::BookingUnitEnum >(booking_unit_);
}
inline void NewOrderSingle::set_booking_unit(::SingleGeneralOrderHandling::BookingUnitEnum value) {
  assert(::SingleGeneralOrderHandling::BookingUnitEnum_IsValid(value));
  set_has_booking_unit();
  booking_unit_ = value;
}

// optional .SingleGeneralOrderHandling.CancellationRightsEnum cancellation_rights = 49;
inline bool NewOrderSingle::has_cancellation_rights() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void NewOrderSingle::set_has_cancellation_rights() {
  _has_bits_[1] |= 0x00010000u;
}
inline void NewOrderSingle::clear_has_cancellation_rights() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void NewOrderSingle::clear_cancellation_rights() {
  cancellation_rights_ = 0;
  clear_has_cancellation_rights();
}
inline ::SingleGeneralOrderHandling::CancellationRightsEnum NewOrderSingle::cancellation_rights() const {
  return static_cast< ::SingleGeneralOrderHandling::CancellationRightsEnum >(cancellation_rights_);
}
inline void NewOrderSingle::set_cancellation_rights(::SingleGeneralOrderHandling::CancellationRightsEnum value) {
  assert(::SingleGeneralOrderHandling::CancellationRightsEnum_IsValid(value));
  set_has_cancellation_rights();
  cancellation_rights_ = value;
}

// optional .SingleGeneralOrderHandling.CashMarginEnum cash_margin = 50;
inline bool NewOrderSingle::has_cash_margin() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void NewOrderSingle::set_has_cash_margin() {
  _has_bits_[1] |= 0x00020000u;
}
inline void NewOrderSingle::clear_has_cash_margin() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void NewOrderSingle::clear_cash_margin() {
  cash_margin_ = 0;
  clear_has_cash_margin();
}
inline ::SingleGeneralOrderHandling::CashMarginEnum NewOrderSingle::cash_margin() const {
  return static_cast< ::SingleGeneralOrderHandling::CashMarginEnum >(cash_margin_);
}
inline void NewOrderSingle::set_cash_margin(::SingleGeneralOrderHandling::CashMarginEnum value) {
  assert(::SingleGeneralOrderHandling::CashMarginEnum_IsValid(value));
  set_has_cash_margin();
  cash_margin_ = value;
}

// optional string cl_ord_link_id = 51;
inline bool NewOrderSingle::has_cl_ord_link_id() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void NewOrderSingle::set_has_cl_ord_link_id() {
  _has_bits_[1] |= 0x00040000u;
}
inline void NewOrderSingle::clear_has_cl_ord_link_id() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void NewOrderSingle::clear_cl_ord_link_id() {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_->clear();
  }
  clear_has_cl_ord_link_id();
}
inline const ::std::string& NewOrderSingle::cl_ord_link_id() const {
  return *cl_ord_link_id_;
}
inline void NewOrderSingle::set_cl_ord_link_id(const ::std::string& value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void NewOrderSingle::set_cl_ord_link_id(const char* value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void NewOrderSingle::set_cl_ord_link_id(const char* value, size_t size) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_cl_ord_link_id() {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  return cl_ord_link_id_;
}
inline ::std::string* NewOrderSingle::release_cl_ord_link_id() {
  clear_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_link_id_;
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id) {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_link_id_;
  }
  if (cl_ord_link_id) {
    set_has_cl_ord_link_id();
    cl_ord_link_id_ = cl_ord_link_id;
  } else {
    clear_has_cl_ord_link_id();
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.ClearingFeeIndicatorEnum clearing_fee_indicator = 52;
inline bool NewOrderSingle::has_clearing_fee_indicator() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void NewOrderSingle::set_has_clearing_fee_indicator() {
  _has_bits_[1] |= 0x00080000u;
}
inline void NewOrderSingle::clear_has_clearing_fee_indicator() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void NewOrderSingle::clear_clearing_fee_indicator() {
  clearing_fee_indicator_ = 0;
  clear_has_clearing_fee_indicator();
}
inline ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum NewOrderSingle::clearing_fee_indicator() const {
  return static_cast< ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum >(clearing_fee_indicator_);
}
inline void NewOrderSingle::set_clearing_fee_indicator(::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum value) {
  assert(::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum_IsValid(value));
  set_has_clearing_fee_indicator();
  clearing_fee_indicator_ = value;
}

// optional .Common.CommissionData commission_data = 53;
inline bool NewOrderSingle::has_commission_data() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void NewOrderSingle::set_has_commission_data() {
  _has_bits_[1] |= 0x00100000u;
}
inline void NewOrderSingle::clear_has_commission_data() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void NewOrderSingle::clear_commission_data() {
  if (commission_data_ != NULL) commission_data_->::Common::CommissionData::Clear();
  clear_has_commission_data();
}
inline const ::Common::CommissionData& NewOrderSingle::commission_data() const {
  return commission_data_ != NULL ? *commission_data_ : *default_instance_->commission_data_;
}
inline ::Common::CommissionData* NewOrderSingle::mutable_commission_data() {
  set_has_commission_data();
  if (commission_data_ == NULL) commission_data_ = new ::Common::CommissionData;
  return commission_data_;
}
inline ::Common::CommissionData* NewOrderSingle::release_commission_data() {
  clear_has_commission_data();
  ::Common::CommissionData* temp = commission_data_;
  commission_data_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_commission_data(::Common::CommissionData* commission_data) {
  delete commission_data_;
  commission_data_ = commission_data;
  if (commission_data) {
    set_has_commission_data();
  } else {
    clear_has_commission_data();
  }
}

// optional .SingleGeneralOrderHandling.CustOrderCapacityEnum cust_order_capacity = 54;
inline bool NewOrderSingle::has_cust_order_capacity() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void NewOrderSingle::set_has_cust_order_capacity() {
  _has_bits_[1] |= 0x00200000u;
}
inline void NewOrderSingle::clear_has_cust_order_capacity() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void NewOrderSingle::clear_cust_order_capacity() {
  cust_order_capacity_ = 0;
  clear_has_cust_order_capacity();
}
inline ::SingleGeneralOrderHandling::CustOrderCapacityEnum NewOrderSingle::cust_order_capacity() const {
  return static_cast< ::SingleGeneralOrderHandling::CustOrderCapacityEnum >(cust_order_capacity_);
}
inline void NewOrderSingle::set_cust_order_capacity(::SingleGeneralOrderHandling::CustOrderCapacityEnum value) {
  assert(::SingleGeneralOrderHandling::CustOrderCapacityEnum_IsValid(value));
  set_has_cust_order_capacity();
  cust_order_capacity_ = value;
}

// optional .SingleGeneralOrderHandling.DayBookingInstEnum day_booking_inst = 55;
inline bool NewOrderSingle::has_day_booking_inst() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void NewOrderSingle::set_has_day_booking_inst() {
  _has_bits_[1] |= 0x00400000u;
}
inline void NewOrderSingle::clear_has_day_booking_inst() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void NewOrderSingle::clear_day_booking_inst() {
  day_booking_inst_ = 0;
  clear_has_day_booking_inst();
}
inline ::SingleGeneralOrderHandling::DayBookingInstEnum NewOrderSingle::day_booking_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::DayBookingInstEnum >(day_booking_inst_);
}
inline void NewOrderSingle::set_day_booking_inst(::SingleGeneralOrderHandling::DayBookingInstEnum value) {
  assert(::SingleGeneralOrderHandling::DayBookingInstEnum_IsValid(value));
  set_has_day_booking_inst();
  day_booking_inst_ = value;
}

// optional string designation = 56;
inline bool NewOrderSingle::has_designation() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void NewOrderSingle::set_has_designation() {
  _has_bits_[1] |= 0x00800000u;
}
inline void NewOrderSingle::clear_has_designation() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void NewOrderSingle::clear_designation() {
  if (designation_ != &::google::protobuf::internal::kEmptyString) {
    designation_->clear();
  }
  clear_has_designation();
}
inline const ::std::string& NewOrderSingle::designation() const {
  return *designation_;
}
inline void NewOrderSingle::set_designation(const ::std::string& value) {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  designation_->assign(value);
}
inline void NewOrderSingle::set_designation(const char* value) {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  designation_->assign(value);
}
inline void NewOrderSingle::set_designation(const char* value, size_t size) {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  designation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_designation() {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  return designation_;
}
inline ::std::string* NewOrderSingle::release_designation() {
  clear_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = designation_;
    designation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_designation(::std::string* designation) {
  if (designation_ != &::google::protobuf::internal::kEmptyString) {
    delete designation_;
  }
  if (designation) {
    set_has_designation();
    designation_ = designation;
  } else {
    clear_has_designation();
    designation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.Instrument instrument = 57;
inline bool NewOrderSingle::has_instrument() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void NewOrderSingle::set_has_instrument() {
  _has_bits_[1] |= 0x01000000u;
}
inline void NewOrderSingle::clear_has_instrument() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void NewOrderSingle::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& NewOrderSingle::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* NewOrderSingle::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* NewOrderSingle::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional .SingleGeneralOrderHandling.MoneyLaunderingStatusEnum money_laundering_status = 58;
inline bool NewOrderSingle::has_money_laundering_status() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void NewOrderSingle::set_has_money_laundering_status() {
  _has_bits_[1] |= 0x02000000u;
}
inline void NewOrderSingle::clear_has_money_laundering_status() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void NewOrderSingle::clear_money_laundering_status() {
  money_laundering_status_ = 0;
  clear_has_money_laundering_status();
}
inline ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum NewOrderSingle::money_laundering_status() const {
  return static_cast< ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum >(money_laundering_status_);
}
inline void NewOrderSingle::set_money_laundering_status(::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum value) {
  assert(::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum_IsValid(value));
  set_has_money_laundering_status();
  money_laundering_status_ = value;
}

// optional .SingleGeneralOrderHandling.OrderCapacityEnum order_capacity = 59;
inline bool NewOrderSingle::has_order_capacity() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void NewOrderSingle::set_has_order_capacity() {
  _has_bits_[1] |= 0x04000000u;
}
inline void NewOrderSingle::clear_has_order_capacity() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void NewOrderSingle::clear_order_capacity() {
  order_capacity_ = 0;
  clear_has_order_capacity();
}
inline ::SingleGeneralOrderHandling::OrderCapacityEnum NewOrderSingle::order_capacity() const {
  return static_cast< ::SingleGeneralOrderHandling::OrderCapacityEnum >(order_capacity_);
}
inline void NewOrderSingle::set_order_capacity(::SingleGeneralOrderHandling::OrderCapacityEnum value) {
  assert(::SingleGeneralOrderHandling::OrderCapacityEnum_IsValid(value));
  set_has_order_capacity();
  order_capacity_ = value;
}

// optional .Common.OrderQtyData order_qty_data = 60;
inline bool NewOrderSingle::has_order_qty_data() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void NewOrderSingle::set_has_order_qty_data() {
  _has_bits_[1] |= 0x08000000u;
}
inline void NewOrderSingle::clear_has_order_qty_data() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void NewOrderSingle::clear_order_qty_data() {
  if (order_qty_data_ != NULL) order_qty_data_->::Common::OrderQtyData::Clear();
  clear_has_order_qty_data();
}
inline const ::Common::OrderQtyData& NewOrderSingle::order_qty_data() const {
  return order_qty_data_ != NULL ? *order_qty_data_ : *default_instance_->order_qty_data_;
}
inline ::Common::OrderQtyData* NewOrderSingle::mutable_order_qty_data() {
  set_has_order_qty_data();
  if (order_qty_data_ == NULL) order_qty_data_ = new ::Common::OrderQtyData;
  return order_qty_data_;
}
inline ::Common::OrderQtyData* NewOrderSingle::release_order_qty_data() {
  clear_has_order_qty_data();
  ::Common::OrderQtyData* temp = order_qty_data_;
  order_qty_data_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data) {
  delete order_qty_data_;
  order_qty_data_ = order_qty_data;
  if (order_qty_data) {
    set_has_order_qty_data();
  } else {
    clear_has_order_qty_data();
  }
}

// repeated .SingleGeneralOrderHandling.OrderRestrictionsEnum order_restrictions = 61 [packed = true];
inline int NewOrderSingle::order_restrictions_size() const {
  return order_restrictions_.size();
}
inline void NewOrderSingle::clear_order_restrictions() {
  order_restrictions_.Clear();
}
inline ::SingleGeneralOrderHandling::OrderRestrictionsEnum NewOrderSingle::order_restrictions(int index) const {
  return static_cast< ::SingleGeneralOrderHandling::OrderRestrictionsEnum >(order_restrictions_.Get(index));
}
inline void NewOrderSingle::set_order_restrictions(int index, ::SingleGeneralOrderHandling::OrderRestrictionsEnum value) {
  assert(::SingleGeneralOrderHandling::OrderRestrictionsEnum_IsValid(value));
  order_restrictions_.Set(index, value);
}
inline void NewOrderSingle::add_order_restrictions(::SingleGeneralOrderHandling::OrderRestrictionsEnum value) {
  assert(::SingleGeneralOrderHandling::OrderRestrictionsEnum_IsValid(value));
  order_restrictions_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
NewOrderSingle::order_restrictions() const {
  return order_restrictions_;
}
inline ::google::protobuf::RepeatedField<int>*
NewOrderSingle::mutable_order_restrictions() {
  return &order_restrictions_;
}

// repeated .Common.Parties parties = 62;
inline int NewOrderSingle::parties_size() const {
  return parties_.size();
}
inline void NewOrderSingle::clear_parties() {
  parties_.Clear();
}
inline const ::Common::Parties& NewOrderSingle::parties(int index) const {
  return parties_.Get(index);
}
inline ::Common::Parties* NewOrderSingle::mutable_parties(int index) {
  return parties_.Mutable(index);
}
inline ::Common::Parties* NewOrderSingle::add_parties() {
  return parties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
NewOrderSingle::parties() const {
  return parties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
NewOrderSingle::mutable_parties() {
  return &parties_;
}

// optional .SingleGeneralOrderHandling.PreallocMethodEnum prealloc_method = 63;
inline bool NewOrderSingle::has_prealloc_method() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void NewOrderSingle::set_has_prealloc_method() {
  _has_bits_[1] |= 0x40000000u;
}
inline void NewOrderSingle::clear_has_prealloc_method() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void NewOrderSingle::clear_prealloc_method() {
  prealloc_method_ = 0;
  clear_has_prealloc_method();
}
inline ::SingleGeneralOrderHandling::PreallocMethodEnum NewOrderSingle::prealloc_method() const {
  return static_cast< ::SingleGeneralOrderHandling::PreallocMethodEnum >(prealloc_method_);
}
inline void NewOrderSingle::set_prealloc_method(::SingleGeneralOrderHandling::PreallocMethodEnum value) {
  assert(::SingleGeneralOrderHandling::PreallocMethodEnum_IsValid(value));
  set_has_prealloc_method();
  prealloc_method_ = value;
}

// optional sfixed64 price2 = 64;
inline bool NewOrderSingle::has_price2() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void NewOrderSingle::set_has_price2() {
  _has_bits_[1] |= 0x80000000u;
}
inline void NewOrderSingle::clear_has_price2() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void NewOrderSingle::clear_price2() {
  price2_ = GOOGLE_LONGLONG(0);
  clear_has_price2();
}
inline ::google::protobuf::int64 NewOrderSingle::price2() const {
  return price2_;
}
inline void NewOrderSingle::set_price2(::google::protobuf::int64 value) {
  set_has_price2();
  price2_ = value;
}

// optional sfixed32 price2_exponent = 65;
inline bool NewOrderSingle::has_price2_exponent() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void NewOrderSingle::set_has_price2_exponent() {
  _has_bits_[2] |= 0x00000001u;
}
inline void NewOrderSingle::clear_has_price2_exponent() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void NewOrderSingle::clear_price2_exponent() {
  price2_exponent_ = 0;
  clear_has_price2_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::price2_exponent() const {
  return price2_exponent_;
}
inline void NewOrderSingle::set_price2_exponent(::google::protobuf::int32 value) {
  set_has_price2_exponent();
  price2_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.PriceTypeEnum price_type = 66;
inline bool NewOrderSingle::has_price_type() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void NewOrderSingle::set_has_price_type() {
  _has_bits_[2] |= 0x00000002u;
}
inline void NewOrderSingle::clear_has_price_type() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void NewOrderSingle::clear_price_type() {
  price_type_ = 0;
  clear_has_price_type();
}
inline ::SingleGeneralOrderHandling::PriceTypeEnum NewOrderSingle::price_type() const {
  return static_cast< ::SingleGeneralOrderHandling::PriceTypeEnum >(price_type_);
}
inline void NewOrderSingle::set_price_type(::SingleGeneralOrderHandling::PriceTypeEnum value) {
  assert(::SingleGeneralOrderHandling::PriceTypeEnum_IsValid(value));
  set_has_price_type();
  price_type_ = value;
}

// optional string regist_id = 67;
inline bool NewOrderSingle::has_regist_id() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void NewOrderSingle::set_has_regist_id() {
  _has_bits_[2] |= 0x00000004u;
}
inline void NewOrderSingle::clear_has_regist_id() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void NewOrderSingle::clear_regist_id() {
  if (regist_id_ != &::google::protobuf::internal::kEmptyString) {
    regist_id_->clear();
  }
  clear_has_regist_id();
}
inline const ::std::string& NewOrderSingle::regist_id() const {
  return *regist_id_;
}
inline void NewOrderSingle::set_regist_id(const ::std::string& value) {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  regist_id_->assign(value);
}
inline void NewOrderSingle::set_regist_id(const char* value) {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  regist_id_->assign(value);
}
inline void NewOrderSingle::set_regist_id(const char* value, size_t size) {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  regist_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_regist_id() {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  return regist_id_;
}
inline ::std::string* NewOrderSingle::release_regist_id() {
  clear_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = regist_id_;
    regist_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_regist_id(::std::string* regist_id) {
  if (regist_id_ != &::google::protobuf::internal::kEmptyString) {
    delete regist_id_;
  }
  if (regist_id) {
    set_has_regist_id();
    regist_id_ = regist_id;
  } else {
    clear_has_regist_id();
    regist_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string secondary_cl_ord_id = 68;
inline bool NewOrderSingle::has_secondary_cl_ord_id() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void NewOrderSingle::set_has_secondary_cl_ord_id() {
  _has_bits_[2] |= 0x00000008u;
}
inline void NewOrderSingle::clear_has_secondary_cl_ord_id() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void NewOrderSingle::clear_secondary_cl_ord_id() {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_->clear();
  }
  clear_has_secondary_cl_ord_id();
}
inline const ::std::string& NewOrderSingle::secondary_cl_ord_id() const {
  return *secondary_cl_ord_id_;
}
inline void NewOrderSingle::set_secondary_cl_ord_id(const ::std::string& value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void NewOrderSingle::set_secondary_cl_ord_id(const char* value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void NewOrderSingle::set_secondary_cl_ord_id(const char* value, size_t size) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_secondary_cl_ord_id() {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  return secondary_cl_ord_id_;
}
inline ::std::string* NewOrderSingle::release_secondary_cl_ord_id() {
  clear_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_cl_ord_id_;
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id) {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_cl_ord_id_;
  }
  if (secondary_cl_ord_id) {
    set_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = secondary_cl_ord_id;
  } else {
    clear_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 69;
inline bool NewOrderSingle::has_spread_or_benchmark_curve_data() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void NewOrderSingle::set_has_spread_or_benchmark_curve_data() {
  _has_bits_[2] |= 0x00000010u;
}
inline void NewOrderSingle::clear_has_spread_or_benchmark_curve_data() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void NewOrderSingle::clear_spread_or_benchmark_curve_data() {
  if (spread_or_benchmark_curve_data_ != NULL) spread_or_benchmark_curve_data_->::Common::SpreadOrBenchmarkCurveData::Clear();
  clear_has_spread_or_benchmark_curve_data();
}
inline const ::Common::SpreadOrBenchmarkCurveData& NewOrderSingle::spread_or_benchmark_curve_data() const {
  return spread_or_benchmark_curve_data_ != NULL ? *spread_or_benchmark_curve_data_ : *default_instance_->spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* NewOrderSingle::mutable_spread_or_benchmark_curve_data() {
  set_has_spread_or_benchmark_curve_data();
  if (spread_or_benchmark_curve_data_ == NULL) spread_or_benchmark_curve_data_ = new ::Common::SpreadOrBenchmarkCurveData;
  return spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* NewOrderSingle::release_spread_or_benchmark_curve_data() {
  clear_has_spread_or_benchmark_curve_data();
  ::Common::SpreadOrBenchmarkCurveData* temp = spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data) {
  delete spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = spread_or_benchmark_curve_data;
  if (spread_or_benchmark_curve_data) {
    set_has_spread_or_benchmark_curve_data();
  } else {
    clear_has_spread_or_benchmark_curve_data();
  }
}

// repeated .Common.Stipulations stipulations = 70;
inline int NewOrderSingle::stipulations_size() const {
  return stipulations_.size();
}
inline void NewOrderSingle::clear_stipulations() {
  stipulations_.Clear();
}
inline const ::Common::Stipulations& NewOrderSingle::stipulations(int index) const {
  return stipulations_.Get(index);
}
inline ::Common::Stipulations* NewOrderSingle::mutable_stipulations(int index) {
  return stipulations_.Mutable(index);
}
inline ::Common::Stipulations* NewOrderSingle::add_stipulations() {
  return stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
NewOrderSingle::stipulations() const {
  return stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
NewOrderSingle::mutable_stipulations() {
  return &stipulations_;
}

// optional sfixed32 trade_origination_date = 71;
inline bool NewOrderSingle::has_trade_origination_date() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void NewOrderSingle::set_has_trade_origination_date() {
  _has_bits_[2] |= 0x00000040u;
}
inline void NewOrderSingle::clear_has_trade_origination_date() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void NewOrderSingle::clear_trade_origination_date() {
  trade_origination_date_ = 0;
  clear_has_trade_origination_date();
}
inline ::google::protobuf::int32 NewOrderSingle::trade_origination_date() const {
  return trade_origination_date_;
}
inline void NewOrderSingle::set_trade_origination_date(::google::protobuf::int32 value) {
  set_has_trade_origination_date();
  trade_origination_date_ = value;
}

// optional .Common.YieldData yield_data = 72;
inline bool NewOrderSingle::has_yield_data() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void NewOrderSingle::set_has_yield_data() {
  _has_bits_[2] |= 0x00000080u;
}
inline void NewOrderSingle::clear_has_yield_data() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void NewOrderSingle::clear_yield_data() {
  if (yield_data_ != NULL) yield_data_->::Common::YieldData::Clear();
  clear_has_yield_data();
}
inline const ::Common::YieldData& NewOrderSingle::yield_data() const {
  return yield_data_ != NULL ? *yield_data_ : *default_instance_->yield_data_;
}
inline ::Common::YieldData* NewOrderSingle::mutable_yield_data() {
  set_has_yield_data();
  if (yield_data_ == NULL) yield_data_ = new ::Common::YieldData;
  return yield_data_;
}
inline ::Common::YieldData* NewOrderSingle::release_yield_data() {
  clear_has_yield_data();
  ::Common::YieldData* temp = yield_data_;
  yield_data_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_yield_data(::Common::YieldData* yield_data) {
  delete yield_data_;
  yield_data_ = yield_data;
  if (yield_data) {
    set_has_yield_data();
  } else {
    clear_has_yield_data();
  }
}

// optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 73;
inline bool NewOrderSingle::has_acct_id_source() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void NewOrderSingle::set_has_acct_id_source() {
  _has_bits_[2] |= 0x00000100u;
}
inline void NewOrderSingle::clear_has_acct_id_source() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void NewOrderSingle::clear_acct_id_source() {
  acct_id_source_ = 0;
  clear_has_acct_id_source();
}
inline ::SingleGeneralOrderHandling::AcctIdSourceEnum NewOrderSingle::acct_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::AcctIdSourceEnum >(acct_id_source_);
}
inline void NewOrderSingle::set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::AcctIdSourceEnum_IsValid(value));
  set_has_acct_id_source();
  acct_id_source_ = value;
}

// optional string alloc_id = 74;
inline bool NewOrderSingle::has_alloc_id() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void NewOrderSingle::set_has_alloc_id() {
  _has_bits_[2] |= 0x00000200u;
}
inline void NewOrderSingle::clear_has_alloc_id() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void NewOrderSingle::clear_alloc_id() {
  if (alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    alloc_id_->clear();
  }
  clear_has_alloc_id();
}
inline const ::std::string& NewOrderSingle::alloc_id() const {
  return *alloc_id_;
}
inline void NewOrderSingle::set_alloc_id(const ::std::string& value) {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  alloc_id_->assign(value);
}
inline void NewOrderSingle::set_alloc_id(const char* value) {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  alloc_id_->assign(value);
}
inline void NewOrderSingle::set_alloc_id(const char* value, size_t size) {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  alloc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_alloc_id() {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  return alloc_id_;
}
inline ::std::string* NewOrderSingle::release_alloc_id() {
  clear_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alloc_id_;
    alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_alloc_id(::std::string* alloc_id) {
  if (alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    delete alloc_id_;
  }
  if (alloc_id) {
    set_has_alloc_id();
    alloc_id_ = alloc_id;
  } else {
    clear_has_alloc_id();
    alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.BookingTypeEnum booking_type = 75;
inline bool NewOrderSingle::has_booking_type() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void NewOrderSingle::set_has_booking_type() {
  _has_bits_[2] |= 0x00000400u;
}
inline void NewOrderSingle::clear_has_booking_type() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void NewOrderSingle::clear_booking_type() {
  booking_type_ = 0;
  clear_has_booking_type();
}
inline ::SingleGeneralOrderHandling::BookingTypeEnum NewOrderSingle::booking_type() const {
  return static_cast< ::SingleGeneralOrderHandling::BookingTypeEnum >(booking_type_);
}
inline void NewOrderSingle::set_booking_type(::SingleGeneralOrderHandling::BookingTypeEnum value) {
  assert(::SingleGeneralOrderHandling::BookingTypeEnum_IsValid(value));
  set_has_booking_type();
  booking_type_ = value;
}

// optional bool cust_directed_order = 76;
inline bool NewOrderSingle::has_cust_directed_order() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void NewOrderSingle::set_has_cust_directed_order() {
  _has_bits_[2] |= 0x00000800u;
}
inline void NewOrderSingle::clear_has_cust_directed_order() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void NewOrderSingle::clear_cust_directed_order() {
  cust_directed_order_ = false;
  clear_has_cust_directed_order();
}
inline bool NewOrderSingle::cust_directed_order() const {
  return cust_directed_order_;
}
inline void NewOrderSingle::set_cust_directed_order(bool value) {
  set_has_cust_directed_order();
  cust_directed_order_ = value;
}

// optional .SingleGeneralOrderHandling.CustOrderHandlingInstEnum cust_order_handling_inst = 77;
inline bool NewOrderSingle::has_cust_order_handling_inst() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void NewOrderSingle::set_has_cust_order_handling_inst() {
  _has_bits_[2] |= 0x00001000u;
}
inline void NewOrderSingle::clear_has_cust_order_handling_inst() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void NewOrderSingle::clear_cust_order_handling_inst() {
  cust_order_handling_inst_ = 0;
  clear_has_cust_order_handling_inst();
}
inline ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum NewOrderSingle::cust_order_handling_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum >(cust_order_handling_inst_);
}
inline void NewOrderSingle::set_cust_order_handling_inst(::SingleGeneralOrderHandling::CustOrderHandlingInstEnum value) {
  assert(::SingleGeneralOrderHandling::CustOrderHandlingInstEnum_IsValid(value));
  set_has_cust_order_handling_inst();
  cust_order_handling_inst_ = value;
}

// optional .Common.DiscretionInstructions discretion_instructions = 78;
inline bool NewOrderSingle::has_discretion_instructions() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void NewOrderSingle::set_has_discretion_instructions() {
  _has_bits_[2] |= 0x00002000u;
}
inline void NewOrderSingle::clear_has_discretion_instructions() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void NewOrderSingle::clear_discretion_instructions() {
  if (discretion_instructions_ != NULL) discretion_instructions_->::Common::DiscretionInstructions::Clear();
  clear_has_discretion_instructions();
}
inline const ::Common::DiscretionInstructions& NewOrderSingle::discretion_instructions() const {
  return discretion_instructions_ != NULL ? *discretion_instructions_ : *default_instance_->discretion_instructions_;
}
inline ::Common::DiscretionInstructions* NewOrderSingle::mutable_discretion_instructions() {
  set_has_discretion_instructions();
  if (discretion_instructions_ == NULL) discretion_instructions_ = new ::Common::DiscretionInstructions;
  return discretion_instructions_;
}
inline ::Common::DiscretionInstructions* NewOrderSingle::release_discretion_instructions() {
  clear_has_discretion_instructions();
  ::Common::DiscretionInstructions* temp = discretion_instructions_;
  discretion_instructions_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_discretion_instructions(::Common::DiscretionInstructions* discretion_instructions) {
  delete discretion_instructions_;
  discretion_instructions_ = discretion_instructions;
  if (discretion_instructions) {
    set_has_discretion_instructions();
  } else {
    clear_has_discretion_instructions();
  }
}

// optional .Common.DisplayInstruction display_instruction = 79;
inline bool NewOrderSingle::has_display_instruction() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void NewOrderSingle::set_has_display_instruction() {
  _has_bits_[2] |= 0x00004000u;
}
inline void NewOrderSingle::clear_has_display_instruction() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void NewOrderSingle::clear_display_instruction() {
  if (display_instruction_ != NULL) display_instruction_->::Common::DisplayInstruction::Clear();
  clear_has_display_instruction();
}
inline const ::Common::DisplayInstruction& NewOrderSingle::display_instruction() const {
  return display_instruction_ != NULL ? *display_instruction_ : *default_instance_->display_instruction_;
}
inline ::Common::DisplayInstruction* NewOrderSingle::mutable_display_instruction() {
  set_has_display_instruction();
  if (display_instruction_ == NULL) display_instruction_ = new ::Common::DisplayInstruction;
  return display_instruction_;
}
inline ::Common::DisplayInstruction* NewOrderSingle::release_display_instruction() {
  clear_has_display_instruction();
  ::Common::DisplayInstruction* temp = display_instruction_;
  display_instruction_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_display_instruction(::Common::DisplayInstruction* display_instruction) {
  delete display_instruction_;
  display_instruction_ = display_instruction;
  if (display_instruction) {
    set_has_display_instruction();
  } else {
    clear_has_display_instruction();
  }
}

// optional .SingleGeneralOrderHandling.ExDestinationIdSourceEnum ex_destination_id_source = 80;
inline bool NewOrderSingle::has_ex_destination_id_source() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void NewOrderSingle::set_has_ex_destination_id_source() {
  _has_bits_[2] |= 0x00008000u;
}
inline void NewOrderSingle::clear_has_ex_destination_id_source() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void NewOrderSingle::clear_ex_destination_id_source() {
  ex_destination_id_source_ = 0;
  clear_has_ex_destination_id_source();
}
inline ::SingleGeneralOrderHandling::ExDestinationIdSourceEnum NewOrderSingle::ex_destination_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::ExDestinationIdSourceEnum >(ex_destination_id_source_);
}
inline void NewOrderSingle::set_ex_destination_id_source(::SingleGeneralOrderHandling::ExDestinationIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::ExDestinationIdSourceEnum_IsValid(value));
  set_has_ex_destination_id_source();
  ex_destination_id_source_ = value;
}

// optional .Common.FinancingDetails financing_details = 81;
inline bool NewOrderSingle::has_financing_details() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void NewOrderSingle::set_has_financing_details() {
  _has_bits_[2] |= 0x00010000u;
}
inline void NewOrderSingle::clear_has_financing_details() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void NewOrderSingle::clear_financing_details() {
  if (financing_details_ != NULL) financing_details_->::Common::FinancingDetails::Clear();
  clear_has_financing_details();
}
inline const ::Common::FinancingDetails& NewOrderSingle::financing_details() const {
  return financing_details_ != NULL ? *financing_details_ : *default_instance_->financing_details_;
}
inline ::Common::FinancingDetails* NewOrderSingle::mutable_financing_details() {
  set_has_financing_details();
  if (financing_details_ == NULL) financing_details_ = new ::Common::FinancingDetails;
  return financing_details_;
}
inline ::Common::FinancingDetails* NewOrderSingle::release_financing_details() {
  clear_has_financing_details();
  ::Common::FinancingDetails* temp = financing_details_;
  financing_details_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_financing_details(::Common::FinancingDetails* financing_details) {
  delete financing_details_;
  financing_details_ = financing_details;
  if (financing_details) {
    set_has_financing_details();
  } else {
    clear_has_financing_details();
  }
}

// optional bool manual_order_indicator = 82;
inline bool NewOrderSingle::has_manual_order_indicator() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void NewOrderSingle::set_has_manual_order_indicator() {
  _has_bits_[2] |= 0x00020000u;
}
inline void NewOrderSingle::clear_has_manual_order_indicator() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void NewOrderSingle::clear_manual_order_indicator() {
  manual_order_indicator_ = false;
  clear_has_manual_order_indicator();
}
inline bool NewOrderSingle::manual_order_indicator() const {
  return manual_order_indicator_;
}
inline void NewOrderSingle::set_manual_order_indicator(bool value) {
  set_has_manual_order_indicator();
  manual_order_indicator_ = value;
}

// optional sfixed64 match_increment = 83;
inline bool NewOrderSingle::has_match_increment() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void NewOrderSingle::set_has_match_increment() {
  _has_bits_[2] |= 0x00040000u;
}
inline void NewOrderSingle::clear_has_match_increment() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void NewOrderSingle::clear_match_increment() {
  match_increment_ = GOOGLE_LONGLONG(0);
  clear_has_match_increment();
}
inline ::google::protobuf::int64 NewOrderSingle::match_increment() const {
  return match_increment_;
}
inline void NewOrderSingle::set_match_increment(::google::protobuf::int64 value) {
  set_has_match_increment();
  match_increment_ = value;
}

// optional sfixed32 match_increment_exponent = 84;
inline bool NewOrderSingle::has_match_increment_exponent() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void NewOrderSingle::set_has_match_increment_exponent() {
  _has_bits_[2] |= 0x00080000u;
}
inline void NewOrderSingle::clear_has_match_increment_exponent() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void NewOrderSingle::clear_match_increment_exponent() {
  match_increment_exponent_ = 0;
  clear_has_match_increment_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::match_increment_exponent() const {
  return match_increment_exponent_;
}
inline void NewOrderSingle::set_match_increment_exponent(::google::protobuf::int32 value) {
  set_has_match_increment_exponent();
  match_increment_exponent_ = value;
}

// optional sfixed64 max_price_levels = 85;
inline bool NewOrderSingle::has_max_price_levels() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void NewOrderSingle::set_has_max_price_levels() {
  _has_bits_[2] |= 0x00100000u;
}
inline void NewOrderSingle::clear_has_max_price_levels() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void NewOrderSingle::clear_max_price_levels() {
  max_price_levels_ = GOOGLE_LONGLONG(0);
  clear_has_max_price_levels();
}
inline ::google::protobuf::int64 NewOrderSingle::max_price_levels() const {
  return max_price_levels_;
}
inline void NewOrderSingle::set_max_price_levels(::google::protobuf::int64 value) {
  set_has_max_price_levels();
  max_price_levels_ = value;
}

// optional .SingleGeneralOrderHandling.OrderHandlingInstSourceEnum order_handling_inst_source = 86;
inline bool NewOrderSingle::has_order_handling_inst_source() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void NewOrderSingle::set_has_order_handling_inst_source() {
  _has_bits_[2] |= 0x00200000u;
}
inline void NewOrderSingle::clear_has_order_handling_inst_source() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void NewOrderSingle::clear_order_handling_inst_source() {
  order_handling_inst_source_ = 0;
  clear_has_order_handling_inst_source();
}
inline ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum NewOrderSingle::order_handling_inst_source() const {
  return static_cast< ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum >(order_handling_inst_source_);
}
inline void NewOrderSingle::set_order_handling_inst_source(::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum value) {
  assert(::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum_IsValid(value));
  set_has_order_handling_inst_source();
  order_handling_inst_source_ = value;
}

// optional sfixed64 participation_rate = 87;
inline bool NewOrderSingle::has_participation_rate() const {
  return (_has_bits_[2] & 0x00400000u) != 0;
}
inline void NewOrderSingle::set_has_participation_rate() {
  _has_bits_[2] |= 0x00400000u;
}
inline void NewOrderSingle::clear_has_participation_rate() {
  _has_bits_[2] &= ~0x00400000u;
}
inline void NewOrderSingle::clear_participation_rate() {
  participation_rate_ = GOOGLE_LONGLONG(0);
  clear_has_participation_rate();
}
inline ::google::protobuf::int64 NewOrderSingle::participation_rate() const {
  return participation_rate_;
}
inline void NewOrderSingle::set_participation_rate(::google::protobuf::int64 value) {
  set_has_participation_rate();
  participation_rate_ = value;
}

// optional sfixed32 participation_rate_exponent = 88;
inline bool NewOrderSingle::has_participation_rate_exponent() const {
  return (_has_bits_[2] & 0x00800000u) != 0;
}
inline void NewOrderSingle::set_has_participation_rate_exponent() {
  _has_bits_[2] |= 0x00800000u;
}
inline void NewOrderSingle::clear_has_participation_rate_exponent() {
  _has_bits_[2] &= ~0x00800000u;
}
inline void NewOrderSingle::clear_participation_rate_exponent() {
  participation_rate_exponent_ = 0;
  clear_has_participation_rate_exponent();
}
inline ::google::protobuf::int32 NewOrderSingle::participation_rate_exponent() const {
  return participation_rate_exponent_;
}
inline void NewOrderSingle::set_participation_rate_exponent(::google::protobuf::int32 value) {
  set_has_participation_rate_exponent();
  participation_rate_exponent_ = value;
}

// optional .Common.PegInstructions peg_instructions = 89;
inline bool NewOrderSingle::has_peg_instructions() const {
  return (_has_bits_[2] & 0x01000000u) != 0;
}
inline void NewOrderSingle::set_has_peg_instructions() {
  _has_bits_[2] |= 0x01000000u;
}
inline void NewOrderSingle::clear_has_peg_instructions() {
  _has_bits_[2] &= ~0x01000000u;
}
inline void NewOrderSingle::clear_peg_instructions() {
  if (peg_instructions_ != NULL) peg_instructions_->::Common::PegInstructions::Clear();
  clear_has_peg_instructions();
}
inline const ::Common::PegInstructions& NewOrderSingle::peg_instructions() const {
  return peg_instructions_ != NULL ? *peg_instructions_ : *default_instance_->peg_instructions_;
}
inline ::Common::PegInstructions* NewOrderSingle::mutable_peg_instructions() {
  set_has_peg_instructions();
  if (peg_instructions_ == NULL) peg_instructions_ = new ::Common::PegInstructions;
  return peg_instructions_;
}
inline ::Common::PegInstructions* NewOrderSingle::release_peg_instructions() {
  clear_has_peg_instructions();
  ::Common::PegInstructions* temp = peg_instructions_;
  peg_instructions_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_peg_instructions(::Common::PegInstructions* peg_instructions) {
  delete peg_instructions_;
  peg_instructions_ = peg_instructions;
  if (peg_instructions) {
    set_has_peg_instructions();
  } else {
    clear_has_peg_instructions();
  }
}

// repeated .Common.PreAllocGrp pre_alloc_grp = 90;
inline int NewOrderSingle::pre_alloc_grp_size() const {
  return pre_alloc_grp_.size();
}
inline void NewOrderSingle::clear_pre_alloc_grp() {
  pre_alloc_grp_.Clear();
}
inline const ::Common::PreAllocGrp& NewOrderSingle::pre_alloc_grp(int index) const {
  return pre_alloc_grp_.Get(index);
}
inline ::Common::PreAllocGrp* NewOrderSingle::mutable_pre_alloc_grp(int index) {
  return pre_alloc_grp_.Mutable(index);
}
inline ::Common::PreAllocGrp* NewOrderSingle::add_pre_alloc_grp() {
  return pre_alloc_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >&
NewOrderSingle::pre_alloc_grp() const {
  return pre_alloc_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >*
NewOrderSingle::mutable_pre_alloc_grp() {
  return &pre_alloc_grp_;
}

// optional bool pre_trade_anonymity = 91;
inline bool NewOrderSingle::has_pre_trade_anonymity() const {
  return (_has_bits_[2] & 0x04000000u) != 0;
}
inline void NewOrderSingle::set_has_pre_trade_anonymity() {
  _has_bits_[2] |= 0x04000000u;
}
inline void NewOrderSingle::clear_has_pre_trade_anonymity() {
  _has_bits_[2] &= ~0x04000000u;
}
inline void NewOrderSingle::clear_pre_trade_anonymity() {
  pre_trade_anonymity_ = false;
  clear_has_pre_trade_anonymity();
}
inline bool NewOrderSingle::pre_trade_anonymity() const {
  return pre_trade_anonymity_;
}
inline void NewOrderSingle::set_pre_trade_anonymity(bool value) {
  set_has_pre_trade_anonymity();
  pre_trade_anonymity_ = value;
}

// optional .SingleGeneralOrderHandling.PriceProtectionScopeEnum price_protection_scope = 92;
inline bool NewOrderSingle::has_price_protection_scope() const {
  return (_has_bits_[2] & 0x08000000u) != 0;
}
inline void NewOrderSingle::set_has_price_protection_scope() {
  _has_bits_[2] |= 0x08000000u;
}
inline void NewOrderSingle::clear_has_price_protection_scope() {
  _has_bits_[2] &= ~0x08000000u;
}
inline void NewOrderSingle::clear_price_protection_scope() {
  price_protection_scope_ = 0;
  clear_has_price_protection_scope();
}
inline ::SingleGeneralOrderHandling::PriceProtectionScopeEnum NewOrderSingle::price_protection_scope() const {
  return static_cast< ::SingleGeneralOrderHandling::PriceProtectionScopeEnum >(price_protection_scope_);
}
inline void NewOrderSingle::set_price_protection_scope(::SingleGeneralOrderHandling::PriceProtectionScopeEnum value) {
  assert(::SingleGeneralOrderHandling::PriceProtectionScopeEnum_IsValid(value));
  set_has_price_protection_scope();
  price_protection_scope_ = value;
}

// optional .SingleGeneralOrderHandling.QtyTypeEnum qty_type = 93;
inline bool NewOrderSingle::has_qty_type() const {
  return (_has_bits_[2] & 0x10000000u) != 0;
}
inline void NewOrderSingle::set_has_qty_type() {
  _has_bits_[2] |= 0x10000000u;
}
inline void NewOrderSingle::clear_has_qty_type() {
  _has_bits_[2] &= ~0x10000000u;
}
inline void NewOrderSingle::clear_qty_type() {
  qty_type_ = 0;
  clear_has_qty_type();
}
inline ::SingleGeneralOrderHandling::QtyTypeEnum NewOrderSingle::qty_type() const {
  return static_cast< ::SingleGeneralOrderHandling::QtyTypeEnum >(qty_type_);
}
inline void NewOrderSingle::set_qty_type(::SingleGeneralOrderHandling::QtyTypeEnum value) {
  assert(::SingleGeneralOrderHandling::QtyTypeEnum_IsValid(value));
  set_has_qty_type();
  qty_type_ = value;
}

// optional string received_dept_id = 94;
inline bool NewOrderSingle::has_received_dept_id() const {
  return (_has_bits_[2] & 0x20000000u) != 0;
}
inline void NewOrderSingle::set_has_received_dept_id() {
  _has_bits_[2] |= 0x20000000u;
}
inline void NewOrderSingle::clear_has_received_dept_id() {
  _has_bits_[2] &= ~0x20000000u;
}
inline void NewOrderSingle::clear_received_dept_id() {
  if (received_dept_id_ != &::google::protobuf::internal::kEmptyString) {
    received_dept_id_->clear();
  }
  clear_has_received_dept_id();
}
inline const ::std::string& NewOrderSingle::received_dept_id() const {
  return *received_dept_id_;
}
inline void NewOrderSingle::set_received_dept_id(const ::std::string& value) {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  received_dept_id_->assign(value);
}
inline void NewOrderSingle::set_received_dept_id(const char* value) {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  received_dept_id_->assign(value);
}
inline void NewOrderSingle::set_received_dept_id(const char* value, size_t size) {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  received_dept_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_received_dept_id() {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  return received_dept_id_;
}
inline ::std::string* NewOrderSingle::release_received_dept_id() {
  clear_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = received_dept_id_;
    received_dept_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_received_dept_id(::std::string* received_dept_id) {
  if (received_dept_id_ != &::google::protobuf::internal::kEmptyString) {
    delete received_dept_id_;
  }
  if (received_dept_id) {
    set_has_received_dept_id();
    received_dept_id_ = received_dept_id;
  } else {
    clear_has_received_dept_id();
    received_dept_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ref_order_id = 95;
inline bool NewOrderSingle::has_ref_order_id() const {
  return (_has_bits_[2] & 0x40000000u) != 0;
}
inline void NewOrderSingle::set_has_ref_order_id() {
  _has_bits_[2] |= 0x40000000u;
}
inline void NewOrderSingle::clear_has_ref_order_id() {
  _has_bits_[2] &= ~0x40000000u;
}
inline void NewOrderSingle::clear_ref_order_id() {
  if (ref_order_id_ != &::google::protobuf::internal::kEmptyString) {
    ref_order_id_->clear();
  }
  clear_has_ref_order_id();
}
inline const ::std::string& NewOrderSingle::ref_order_id() const {
  return *ref_order_id_;
}
inline void NewOrderSingle::set_ref_order_id(const ::std::string& value) {
  set_has_ref_order_id();
  if (ref_order_id_ == &::google::protobuf::internal::kEmptyString) {
    ref_order_id_ = new ::std::string;
  }
  ref_order_id_->assign(value);
}
inline void NewOrderSingle::set_ref_order_id(const char* value) {
  set_has_ref_order_id();
  if (ref_order_id_ == &::google::protobuf::internal::kEmptyString) {
    ref_order_id_ = new ::std::string;
  }
  ref_order_id_->assign(value);
}
inline void NewOrderSingle::set_ref_order_id(const char* value, size_t size) {
  set_has_ref_order_id();
  if (ref_order_id_ == &::google::protobuf::internal::kEmptyString) {
    ref_order_id_ = new ::std::string;
  }
  ref_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_ref_order_id() {
  set_has_ref_order_id();
  if (ref_order_id_ == &::google::protobuf::internal::kEmptyString) {
    ref_order_id_ = new ::std::string;
  }
  return ref_order_id_;
}
inline ::std::string* NewOrderSingle::release_ref_order_id() {
  clear_has_ref_order_id();
  if (ref_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ref_order_id_;
    ref_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_ref_order_id(::std::string* ref_order_id) {
  if (ref_order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ref_order_id_;
  }
  if (ref_order_id) {
    set_has_ref_order_id();
    ref_order_id_ = ref_order_id;
  } else {
    clear_has_ref_order_id();
    ref_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.RefOrderIdSourceEnum ref_order_id_source = 96;
inline bool NewOrderSingle::has_ref_order_id_source() const {
  return (_has_bits_[2] & 0x80000000u) != 0;
}
inline void NewOrderSingle::set_has_ref_order_id_source() {
  _has_bits_[2] |= 0x80000000u;
}
inline void NewOrderSingle::clear_has_ref_order_id_source() {
  _has_bits_[2] &= ~0x80000000u;
}
inline void NewOrderSingle::clear_ref_order_id_source() {
  ref_order_id_source_ = 0;
  clear_has_ref_order_id_source();
}
inline ::SingleGeneralOrderHandling::RefOrderIdSourceEnum NewOrderSingle::ref_order_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::RefOrderIdSourceEnum >(ref_order_id_source_);
}
inline void NewOrderSingle::set_ref_order_id_source(::SingleGeneralOrderHandling::RefOrderIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::RefOrderIdSourceEnum_IsValid(value));
  set_has_ref_order_id_source();
  ref_order_id_source_ = value;
}

// repeated .Common.StrategyParametersGrp strategy_parameters_grp = 97;
inline int NewOrderSingle::strategy_parameters_grp_size() const {
  return strategy_parameters_grp_.size();
}
inline void NewOrderSingle::clear_strategy_parameters_grp() {
  strategy_parameters_grp_.Clear();
}
inline const ::Common::StrategyParametersGrp& NewOrderSingle::strategy_parameters_grp(int index) const {
  return strategy_parameters_grp_.Get(index);
}
inline ::Common::StrategyParametersGrp* NewOrderSingle::mutable_strategy_parameters_grp(int index) {
  return strategy_parameters_grp_.Mutable(index);
}
inline ::Common::StrategyParametersGrp* NewOrderSingle::add_strategy_parameters_grp() {
  return strategy_parameters_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >&
NewOrderSingle::strategy_parameters_grp() const {
  return strategy_parameters_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >*
NewOrderSingle::mutable_strategy_parameters_grp() {
  return &strategy_parameters_grp_;
}

// optional .SingleGeneralOrderHandling.TargetStrategyEnum target_strategy = 98;
inline bool NewOrderSingle::has_target_strategy() const {
  return (_has_bits_[3] & 0x00000002u) != 0;
}
inline void NewOrderSingle::set_has_target_strategy() {
  _has_bits_[3] |= 0x00000002u;
}
inline void NewOrderSingle::clear_has_target_strategy() {
  _has_bits_[3] &= ~0x00000002u;
}
inline void NewOrderSingle::clear_target_strategy() {
  target_strategy_ = 0;
  clear_has_target_strategy();
}
inline ::SingleGeneralOrderHandling::TargetStrategyEnum NewOrderSingle::target_strategy() const {
  return static_cast< ::SingleGeneralOrderHandling::TargetStrategyEnum >(target_strategy_);
}
inline void NewOrderSingle::set_target_strategy(::SingleGeneralOrderHandling::TargetStrategyEnum value) {
  assert(::SingleGeneralOrderHandling::TargetStrategyEnum_IsValid(value));
  set_has_target_strategy();
  target_strategy_ = value;
}

// optional string target_strategy_parameters = 99;
inline bool NewOrderSingle::has_target_strategy_parameters() const {
  return (_has_bits_[3] & 0x00000004u) != 0;
}
inline void NewOrderSingle::set_has_target_strategy_parameters() {
  _has_bits_[3] |= 0x00000004u;
}
inline void NewOrderSingle::clear_has_target_strategy_parameters() {
  _has_bits_[3] &= ~0x00000004u;
}
inline void NewOrderSingle::clear_target_strategy_parameters() {
  if (target_strategy_parameters_ != &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_->clear();
  }
  clear_has_target_strategy_parameters();
}
inline const ::std::string& NewOrderSingle::target_strategy_parameters() const {
  return *target_strategy_parameters_;
}
inline void NewOrderSingle::set_target_strategy_parameters(const ::std::string& value) {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  target_strategy_parameters_->assign(value);
}
inline void NewOrderSingle::set_target_strategy_parameters(const char* value) {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  target_strategy_parameters_->assign(value);
}
inline void NewOrderSingle::set_target_strategy_parameters(const char* value, size_t size) {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  target_strategy_parameters_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NewOrderSingle::mutable_target_strategy_parameters() {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  return target_strategy_parameters_;
}
inline ::std::string* NewOrderSingle::release_target_strategy_parameters() {
  clear_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_strategy_parameters_;
    target_strategy_parameters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NewOrderSingle::set_allocated_target_strategy_parameters(::std::string* target_strategy_parameters) {
  if (target_strategy_parameters_ != &::google::protobuf::internal::kEmptyString) {
    delete target_strategy_parameters_;
  }
  if (target_strategy_parameters) {
    set_has_target_strategy_parameters();
    target_strategy_parameters_ = target_strategy_parameters;
  } else {
    clear_has_target_strategy_parameters();
    target_strategy_parameters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 trade_date = 100;
inline bool NewOrderSingle::has_trade_date() const {
  return (_has_bits_[3] & 0x00000008u) != 0;
}
inline void NewOrderSingle::set_has_trade_date() {
  _has_bits_[3] |= 0x00000008u;
}
inline void NewOrderSingle::clear_has_trade_date() {
  _has_bits_[3] &= ~0x00000008u;
}
inline void NewOrderSingle::clear_trade_date() {
  trade_date_ = 0;
  clear_has_trade_date();
}
inline ::google::protobuf::int32 NewOrderSingle::trade_date() const {
  return trade_date_;
}
inline void NewOrderSingle::set_trade_date(::google::protobuf::int32 value) {
  set_has_trade_date();
  trade_date_ = value;
}

// repeated .Common.TrdRegTimestamps trd_reg_timestamps = 101;
inline int NewOrderSingle::trd_reg_timestamps_size() const {
  return trd_reg_timestamps_.size();
}
inline void NewOrderSingle::clear_trd_reg_timestamps() {
  trd_reg_timestamps_.Clear();
}
inline const ::Common::TrdRegTimestamps& NewOrderSingle::trd_reg_timestamps(int index) const {
  return trd_reg_timestamps_.Get(index);
}
inline ::Common::TrdRegTimestamps* NewOrderSingle::mutable_trd_reg_timestamps(int index) {
  return trd_reg_timestamps_.Mutable(index);
}
inline ::Common::TrdRegTimestamps* NewOrderSingle::add_trd_reg_timestamps() {
  return trd_reg_timestamps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >&
NewOrderSingle::trd_reg_timestamps() const {
  return trd_reg_timestamps_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >*
NewOrderSingle::mutable_trd_reg_timestamps() {
  return &trd_reg_timestamps_;
}

// repeated .Common.TrdgSesGrp trdg_ses_grp = 102;
inline int NewOrderSingle::trdg_ses_grp_size() const {
  return trdg_ses_grp_.size();
}
inline void NewOrderSingle::clear_trdg_ses_grp() {
  trdg_ses_grp_.Clear();
}
inline const ::Common::TrdgSesGrp& NewOrderSingle::trdg_ses_grp(int index) const {
  return trdg_ses_grp_.Get(index);
}
inline ::Common::TrdgSesGrp* NewOrderSingle::mutable_trdg_ses_grp(int index) {
  return trdg_ses_grp_.Mutable(index);
}
inline ::Common::TrdgSesGrp* NewOrderSingle::add_trdg_ses_grp() {
  return trdg_ses_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp >&
NewOrderSingle::trdg_ses_grp() const {
  return trdg_ses_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp >*
NewOrderSingle::mutable_trdg_ses_grp() {
  return &trdg_ses_grp_;
}

// optional .Common.TriggeringInstruction triggering_instruction = 103;
inline bool NewOrderSingle::has_triggering_instruction() const {
  return (_has_bits_[3] & 0x00000040u) != 0;
}
inline void NewOrderSingle::set_has_triggering_instruction() {
  _has_bits_[3] |= 0x00000040u;
}
inline void NewOrderSingle::clear_has_triggering_instruction() {
  _has_bits_[3] &= ~0x00000040u;
}
inline void NewOrderSingle::clear_triggering_instruction() {
  if (triggering_instruction_ != NULL) triggering_instruction_->::Common::TriggeringInstruction::Clear();
  clear_has_triggering_instruction();
}
inline const ::Common::TriggeringInstruction& NewOrderSingle::triggering_instruction() const {
  return triggering_instruction_ != NULL ? *triggering_instruction_ : *default_instance_->triggering_instruction_;
}
inline ::Common::TriggeringInstruction* NewOrderSingle::mutable_triggering_instruction() {
  set_has_triggering_instruction();
  if (triggering_instruction_ == NULL) triggering_instruction_ = new ::Common::TriggeringInstruction;
  return triggering_instruction_;
}
inline ::Common::TriggeringInstruction* NewOrderSingle::release_triggering_instruction() {
  clear_has_triggering_instruction();
  ::Common::TriggeringInstruction* temp = triggering_instruction_;
  triggering_instruction_ = NULL;
  return temp;
}
inline void NewOrderSingle::set_allocated_triggering_instruction(::Common::TriggeringInstruction* triggering_instruction) {
  delete triggering_instruction_;
  triggering_instruction_ = triggering_instruction;
  if (triggering_instruction) {
    set_has_triggering_instruction();
  } else {
    clear_has_triggering_instruction();
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 104;
inline int NewOrderSingle::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void NewOrderSingle::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& NewOrderSingle::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* NewOrderSingle::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* NewOrderSingle::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
NewOrderSingle::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
NewOrderSingle::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// -------------------------------------------------------------------

// OrderCancelReplaceRequest

// optional string account = 1;
inline bool OrderCancelReplaceRequest::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderCancelReplaceRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderCancelReplaceRequest::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& OrderCancelReplaceRequest::account() const {
  return *account_;
}
inline void OrderCancelReplaceRequest::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void OrderCancelReplaceRequest::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void OrderCancelReplaceRequest::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* OrderCancelReplaceRequest::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cl_ord_id = 2;
inline bool OrderCancelReplaceRequest::has_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_cl_ord_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderCancelReplaceRequest::clear_has_cl_ord_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderCancelReplaceRequest::clear_cl_ord_id() {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_->clear();
  }
  clear_has_cl_ord_id();
}
inline const ::std::string& OrderCancelReplaceRequest::cl_ord_id() const {
  return *cl_ord_id_;
}
inline void OrderCancelReplaceRequest::set_cl_ord_id(const ::std::string& value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_cl_ord_id(const char* value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_cl_ord_id(const char* value, size_t size) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_cl_ord_id() {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  return cl_ord_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_cl_ord_id() {
  clear_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_id_;
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_cl_ord_id(::std::string* cl_ord_id) {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_id_;
  }
  if (cl_ord_id) {
    set_has_cl_ord_id();
    cl_ord_id_ = cl_ord_id;
  } else {
    clear_has_cl_ord_id();
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string currency = 3;
inline bool OrderCancelReplaceRequest::has_currency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_currency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderCancelReplaceRequest::clear_has_currency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderCancelReplaceRequest::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& OrderCancelReplaceRequest::currency() const {
  return *currency_;
}
inline void OrderCancelReplaceRequest::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void OrderCancelReplaceRequest::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void OrderCancelReplaceRequest::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* OrderCancelReplaceRequest::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .SingleGeneralOrderHandling.ExecInstEnum exec_inst = 4 [packed = true];
inline int OrderCancelReplaceRequest::exec_inst_size() const {
  return exec_inst_.size();
}
inline void OrderCancelReplaceRequest::clear_exec_inst() {
  exec_inst_.Clear();
}
inline ::SingleGeneralOrderHandling::ExecInstEnum OrderCancelReplaceRequest::exec_inst(int index) const {
  return static_cast< ::SingleGeneralOrderHandling::ExecInstEnum >(exec_inst_.Get(index));
}
inline void OrderCancelReplaceRequest::set_exec_inst(int index, ::SingleGeneralOrderHandling::ExecInstEnum value) {
  assert(::SingleGeneralOrderHandling::ExecInstEnum_IsValid(value));
  exec_inst_.Set(index, value);
}
inline void OrderCancelReplaceRequest::add_exec_inst(::SingleGeneralOrderHandling::ExecInstEnum value) {
  assert(::SingleGeneralOrderHandling::ExecInstEnum_IsValid(value));
  exec_inst_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
OrderCancelReplaceRequest::exec_inst() const {
  return exec_inst_;
}
inline ::google::protobuf::RepeatedField<int>*
OrderCancelReplaceRequest::mutable_exec_inst() {
  return &exec_inst_;
}

// optional .SingleGeneralOrderHandling.HandlInstEnum handl_inst = 5;
inline bool OrderCancelReplaceRequest::has_handl_inst() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_handl_inst() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderCancelReplaceRequest::clear_has_handl_inst() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderCancelReplaceRequest::clear_handl_inst() {
  handl_inst_ = 0;
  clear_has_handl_inst();
}
inline ::SingleGeneralOrderHandling::HandlInstEnum OrderCancelReplaceRequest::handl_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::HandlInstEnum >(handl_inst_);
}
inline void OrderCancelReplaceRequest::set_handl_inst(::SingleGeneralOrderHandling::HandlInstEnum value) {
  assert(::SingleGeneralOrderHandling::HandlInstEnum_IsValid(value));
  set_has_handl_inst();
  handl_inst_ = value;
}

// optional string list_id = 6;
inline bool OrderCancelReplaceRequest::has_list_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_list_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderCancelReplaceRequest::clear_has_list_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderCancelReplaceRequest::clear_list_id() {
  if (list_id_ != &::google::protobuf::internal::kEmptyString) {
    list_id_->clear();
  }
  clear_has_list_id();
}
inline const ::std::string& OrderCancelReplaceRequest::list_id() const {
  return *list_id_;
}
inline void OrderCancelReplaceRequest::set_list_id(const ::std::string& value) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_list_id(const char* value) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_list_id(const char* value, size_t size) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_list_id() {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  return list_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_list_id() {
  clear_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = list_id_;
    list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_list_id(::std::string* list_id) {
  if (list_id_ != &::google::protobuf::internal::kEmptyString) {
    delete list_id_;
  }
  if (list_id) {
    set_has_list_id();
    list_id_ = list_id;
  } else {
    clear_has_list_id();
    list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.OrdTypeEnum ord_type = 7;
inline bool OrderCancelReplaceRequest::has_ord_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_ord_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderCancelReplaceRequest::clear_has_ord_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderCancelReplaceRequest::clear_ord_type() {
  ord_type_ = 0;
  clear_has_ord_type();
}
inline ::SingleGeneralOrderHandling::OrdTypeEnum OrderCancelReplaceRequest::ord_type() const {
  return static_cast< ::SingleGeneralOrderHandling::OrdTypeEnum >(ord_type_);
}
inline void OrderCancelReplaceRequest::set_ord_type(::SingleGeneralOrderHandling::OrdTypeEnum value) {
  assert(::SingleGeneralOrderHandling::OrdTypeEnum_IsValid(value));
  set_has_ord_type();
  ord_type_ = value;
}

// optional string order_id = 8;
inline bool OrderCancelReplaceRequest::has_order_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_order_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderCancelReplaceRequest::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderCancelReplaceRequest::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& OrderCancelReplaceRequest::order_id() const {
  return *order_id_;
}
inline void OrderCancelReplaceRequest::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string orig_cl_ord_id = 9;
inline bool OrderCancelReplaceRequest::has_orig_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_orig_cl_ord_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderCancelReplaceRequest::clear_has_orig_cl_ord_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderCancelReplaceRequest::clear_orig_cl_ord_id() {
  if (orig_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_->clear();
  }
  clear_has_orig_cl_ord_id();
}
inline const ::std::string& OrderCancelReplaceRequest::orig_cl_ord_id() const {
  return *orig_cl_ord_id_;
}
inline void OrderCancelReplaceRequest::set_orig_cl_ord_id(const ::std::string& value) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_orig_cl_ord_id(const char* value) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_orig_cl_ord_id(const char* value, size_t size) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_orig_cl_ord_id() {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  return orig_cl_ord_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_orig_cl_ord_id() {
  clear_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orig_cl_ord_id_;
    orig_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_orig_cl_ord_id(::std::string* orig_cl_ord_id) {
  if (orig_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete orig_cl_ord_id_;
  }
  if (orig_cl_ord_id) {
    set_has_orig_cl_ord_id();
    orig_cl_ord_id_ = orig_cl_ord_id;
  } else {
    clear_has_orig_cl_ord_id();
    orig_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 price = 10;
inline bool OrderCancelReplaceRequest::has_price() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_price() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderCancelReplaceRequest::clear_has_price() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderCancelReplaceRequest::clear_price() {
  price_ = GOOGLE_LONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::price() const {
  return price_;
}
inline void OrderCancelReplaceRequest::set_price(::google::protobuf::int64 value) {
  set_has_price();
  price_ = value;
}

// optional sfixed32 price_exponent = 11;
inline bool OrderCancelReplaceRequest::has_price_exponent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_price_exponent() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrderCancelReplaceRequest::clear_has_price_exponent() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrderCancelReplaceRequest::clear_price_exponent() {
  price_exponent_ = 0;
  clear_has_price_exponent();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::price_exponent() const {
  return price_exponent_;
}
inline void OrderCancelReplaceRequest::set_price_exponent(::google::protobuf::int32 value) {
  set_has_price_exponent();
  price_exponent_ = value;
}

// optional sfixed32 settl_date = 12;
inline bool OrderCancelReplaceRequest::has_settl_date() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_settl_date() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrderCancelReplaceRequest::clear_has_settl_date() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrderCancelReplaceRequest::clear_settl_date() {
  settl_date_ = 0;
  clear_has_settl_date();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::settl_date() const {
  return settl_date_;
}
inline void OrderCancelReplaceRequest::set_settl_date(::google::protobuf::int32 value) {
  set_has_settl_date();
  settl_date_ = value;
}

// optional .SingleGeneralOrderHandling.SettlTypeEnum settl_type = 13;
inline bool OrderCancelReplaceRequest::has_settl_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_settl_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrderCancelReplaceRequest::clear_has_settl_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrderCancelReplaceRequest::clear_settl_type() {
  settl_type_ = 0;
  clear_has_settl_type();
}
inline ::SingleGeneralOrderHandling::SettlTypeEnum OrderCancelReplaceRequest::settl_type() const {
  return static_cast< ::SingleGeneralOrderHandling::SettlTypeEnum >(settl_type_);
}
inline void OrderCancelReplaceRequest::set_settl_type(::SingleGeneralOrderHandling::SettlTypeEnum value) {
  assert(::SingleGeneralOrderHandling::SettlTypeEnum_IsValid(value));
  set_has_settl_type();
  settl_type_ = value;
}

// optional .SingleGeneralOrderHandling.SideEnum side = 14;
inline bool OrderCancelReplaceRequest::has_side() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_side() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OrderCancelReplaceRequest::clear_has_side() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OrderCancelReplaceRequest::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::SingleGeneralOrderHandling::SideEnum OrderCancelReplaceRequest::side() const {
  return static_cast< ::SingleGeneralOrderHandling::SideEnum >(side_);
}
inline void OrderCancelReplaceRequest::set_side(::SingleGeneralOrderHandling::SideEnum value) {
  assert(::SingleGeneralOrderHandling::SideEnum_IsValid(value));
  set_has_side();
  side_ = value;
}

// optional .Session.StandardHeader standard_header = 15;
inline bool OrderCancelReplaceRequest::has_standard_header() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_standard_header() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OrderCancelReplaceRequest::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OrderCancelReplaceRequest::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& OrderCancelReplaceRequest::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* OrderCancelReplaceRequest::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* OrderCancelReplaceRequest::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 16;
inline bool OrderCancelReplaceRequest::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OrderCancelReplaceRequest::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OrderCancelReplaceRequest::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& OrderCancelReplaceRequest::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* OrderCancelReplaceRequest::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* OrderCancelReplaceRequest::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional sfixed64 stop_px = 17;
inline bool OrderCancelReplaceRequest::has_stop_px() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_stop_px() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OrderCancelReplaceRequest::clear_has_stop_px() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OrderCancelReplaceRequest::clear_stop_px() {
  stop_px_ = GOOGLE_LONGLONG(0);
  clear_has_stop_px();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::stop_px() const {
  return stop_px_;
}
inline void OrderCancelReplaceRequest::set_stop_px(::google::protobuf::int64 value) {
  set_has_stop_px();
  stop_px_ = value;
}

// optional sfixed32 stop_px_exponent = 18;
inline bool OrderCancelReplaceRequest::has_stop_px_exponent() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_stop_px_exponent() {
  _has_bits_[0] |= 0x00020000u;
}
inline void OrderCancelReplaceRequest::clear_has_stop_px_exponent() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void OrderCancelReplaceRequest::clear_stop_px_exponent() {
  stop_px_exponent_ = 0;
  clear_has_stop_px_exponent();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::stop_px_exponent() const {
  return stop_px_exponent_;
}
inline void OrderCancelReplaceRequest::set_stop_px_exponent(::google::protobuf::int32 value) {
  set_has_stop_px_exponent();
  stop_px_exponent_ = value;
}

// optional string text = 19;
inline bool OrderCancelReplaceRequest::has_text() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_text() {
  _has_bits_[0] |= 0x00040000u;
}
inline void OrderCancelReplaceRequest::clear_has_text() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void OrderCancelReplaceRequest::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& OrderCancelReplaceRequest::text() const {
  return *text_;
}
inline void OrderCancelReplaceRequest::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void OrderCancelReplaceRequest::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void OrderCancelReplaceRequest::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* OrderCancelReplaceRequest::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.TimeInForceEnum time_in_force = 20;
inline bool OrderCancelReplaceRequest::has_time_in_force() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_time_in_force() {
  _has_bits_[0] |= 0x00080000u;
}
inline void OrderCancelReplaceRequest::clear_has_time_in_force() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void OrderCancelReplaceRequest::clear_time_in_force() {
  time_in_force_ = 0;
  clear_has_time_in_force();
}
inline ::SingleGeneralOrderHandling::TimeInForceEnum OrderCancelReplaceRequest::time_in_force() const {
  return static_cast< ::SingleGeneralOrderHandling::TimeInForceEnum >(time_in_force_);
}
inline void OrderCancelReplaceRequest::set_time_in_force(::SingleGeneralOrderHandling::TimeInForceEnum value) {
  assert(::SingleGeneralOrderHandling::TimeInForceEnum_IsValid(value));
  set_has_time_in_force();
  time_in_force_ = value;
}

// optional string ex_destination = 21;
inline bool OrderCancelReplaceRequest::has_ex_destination() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_ex_destination() {
  _has_bits_[0] |= 0x00100000u;
}
inline void OrderCancelReplaceRequest::clear_has_ex_destination() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void OrderCancelReplaceRequest::clear_ex_destination() {
  if (ex_destination_ != &::google::protobuf::internal::kEmptyString) {
    ex_destination_->clear();
  }
  clear_has_ex_destination();
}
inline const ::std::string& OrderCancelReplaceRequest::ex_destination() const {
  return *ex_destination_;
}
inline void OrderCancelReplaceRequest::set_ex_destination(const ::std::string& value) {
  set_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    ex_destination_ = new ::std::string;
  }
  ex_destination_->assign(value);
}
inline void OrderCancelReplaceRequest::set_ex_destination(const char* value) {
  set_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    ex_destination_ = new ::std::string;
  }
  ex_destination_->assign(value);
}
inline void OrderCancelReplaceRequest::set_ex_destination(const char* value, size_t size) {
  set_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    ex_destination_ = new ::std::string;
  }
  ex_destination_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_ex_destination() {
  set_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    ex_destination_ = new ::std::string;
  }
  return ex_destination_;
}
inline ::std::string* OrderCancelReplaceRequest::release_ex_destination() {
  clear_has_ex_destination();
  if (ex_destination_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ex_destination_;
    ex_destination_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_ex_destination(::std::string* ex_destination) {
  if (ex_destination_ != &::google::protobuf::internal::kEmptyString) {
    delete ex_destination_;
  }
  if (ex_destination) {
    set_has_ex_destination();
    ex_destination_ = ex_destination;
  } else {
    clear_has_ex_destination();
    ex_destination_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 max_floor = 22;
inline bool OrderCancelReplaceRequest::has_max_floor() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_max_floor() {
  _has_bits_[0] |= 0x00200000u;
}
inline void OrderCancelReplaceRequest::clear_has_max_floor() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void OrderCancelReplaceRequest::clear_max_floor() {
  max_floor_ = GOOGLE_LONGLONG(0);
  clear_has_max_floor();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::max_floor() const {
  return max_floor_;
}
inline void OrderCancelReplaceRequest::set_max_floor(::google::protobuf::int64 value) {
  set_has_max_floor();
  max_floor_ = value;
}

// optional sfixed32 max_floor_exponent = 23;
inline bool OrderCancelReplaceRequest::has_max_floor_exponent() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_max_floor_exponent() {
  _has_bits_[0] |= 0x00400000u;
}
inline void OrderCancelReplaceRequest::clear_has_max_floor_exponent() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void OrderCancelReplaceRequest::clear_max_floor_exponent() {
  max_floor_exponent_ = 0;
  clear_has_max_floor_exponent();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::max_floor_exponent() const {
  return max_floor_exponent_;
}
inline void OrderCancelReplaceRequest::set_max_floor_exponent(::google::protobuf::int32 value) {
  set_has_max_floor_exponent();
  max_floor_exponent_ = value;
}

// optional sfixed64 min_qty = 24;
inline bool OrderCancelReplaceRequest::has_min_qty() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_min_qty() {
  _has_bits_[0] |= 0x00800000u;
}
inline void OrderCancelReplaceRequest::clear_has_min_qty() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void OrderCancelReplaceRequest::clear_min_qty() {
  min_qty_ = GOOGLE_LONGLONG(0);
  clear_has_min_qty();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::min_qty() const {
  return min_qty_;
}
inline void OrderCancelReplaceRequest::set_min_qty(::google::protobuf::int64 value) {
  set_has_min_qty();
  min_qty_ = value;
}

// optional sfixed32 min_qty_exponent = 25;
inline bool OrderCancelReplaceRequest::has_min_qty_exponent() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_min_qty_exponent() {
  _has_bits_[0] |= 0x01000000u;
}
inline void OrderCancelReplaceRequest::clear_has_min_qty_exponent() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void OrderCancelReplaceRequest::clear_min_qty_exponent() {
  min_qty_exponent_ = 0;
  clear_has_min_qty_exponent();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::min_qty_exponent() const {
  return min_qty_exponent_;
}
inline void OrderCancelReplaceRequest::set_min_qty_exponent(::google::protobuf::int32 value) {
  set_has_min_qty_exponent();
  min_qty_exponent_ = value;
}

// optional sfixed64 expire_time = 26;
inline bool OrderCancelReplaceRequest::has_expire_time() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_expire_time() {
  _has_bits_[0] |= 0x02000000u;
}
inline void OrderCancelReplaceRequest::clear_has_expire_time() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void OrderCancelReplaceRequest::clear_expire_time() {
  expire_time_ = GOOGLE_LONGLONG(0);
  clear_has_expire_time();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::expire_time() const {
  return expire_time_;
}
inline void OrderCancelReplaceRequest::set_expire_time(::google::protobuf::int64 value) {
  set_has_expire_time();
  expire_time_ = value;
}

// optional bool forex_req = 27;
inline bool OrderCancelReplaceRequest::has_forex_req() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_forex_req() {
  _has_bits_[0] |= 0x04000000u;
}
inline void OrderCancelReplaceRequest::clear_has_forex_req() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void OrderCancelReplaceRequest::clear_forex_req() {
  forex_req_ = false;
  clear_has_forex_req();
}
inline bool OrderCancelReplaceRequest::forex_req() const {
  return forex_req_;
}
inline void OrderCancelReplaceRequest::set_forex_req(bool value) {
  set_has_forex_req();
  forex_req_ = value;
}

// optional string settl_currency = 28;
inline bool OrderCancelReplaceRequest::has_settl_currency() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_settl_currency() {
  _has_bits_[0] |= 0x08000000u;
}
inline void OrderCancelReplaceRequest::clear_has_settl_currency() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void OrderCancelReplaceRequest::clear_settl_currency() {
  if (settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    settl_currency_->clear();
  }
  clear_has_settl_currency();
}
inline const ::std::string& OrderCancelReplaceRequest::settl_currency() const {
  return *settl_currency_;
}
inline void OrderCancelReplaceRequest::set_settl_currency(const ::std::string& value) {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  settl_currency_->assign(value);
}
inline void OrderCancelReplaceRequest::set_settl_currency(const char* value) {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  settl_currency_->assign(value);
}
inline void OrderCancelReplaceRequest::set_settl_currency(const char* value, size_t size) {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  settl_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_settl_currency() {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  return settl_currency_;
}
inline ::std::string* OrderCancelReplaceRequest::release_settl_currency() {
  clear_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = settl_currency_;
    settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_settl_currency(::std::string* settl_currency) {
  if (settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete settl_currency_;
  }
  if (settl_currency) {
    set_has_settl_currency();
    settl_currency_ = settl_currency;
  } else {
    clear_has_settl_currency();
    settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.CoveredOrUncoveredEnum covered_or_uncovered = 29;
inline bool OrderCancelReplaceRequest::has_covered_or_uncovered() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_covered_or_uncovered() {
  _has_bits_[0] |= 0x10000000u;
}
inline void OrderCancelReplaceRequest::clear_has_covered_or_uncovered() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void OrderCancelReplaceRequest::clear_covered_or_uncovered() {
  covered_or_uncovered_ = 0;
  clear_has_covered_or_uncovered();
}
inline ::SingleGeneralOrderHandling::CoveredOrUncoveredEnum OrderCancelReplaceRequest::covered_or_uncovered() const {
  return static_cast< ::SingleGeneralOrderHandling::CoveredOrUncoveredEnum >(covered_or_uncovered_);
}
inline void OrderCancelReplaceRequest::set_covered_or_uncovered(::SingleGeneralOrderHandling::CoveredOrUncoveredEnum value) {
  assert(::SingleGeneralOrderHandling::CoveredOrUncoveredEnum_IsValid(value));
  set_has_covered_or_uncovered();
  covered_or_uncovered_ = value;
}

// optional bool locate_reqd = 30;
inline bool OrderCancelReplaceRequest::has_locate_reqd() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_locate_reqd() {
  _has_bits_[0] |= 0x20000000u;
}
inline void OrderCancelReplaceRequest::clear_has_locate_reqd() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void OrderCancelReplaceRequest::clear_locate_reqd() {
  locate_reqd_ = false;
  clear_has_locate_reqd();
}
inline bool OrderCancelReplaceRequest::locate_reqd() const {
  return locate_reqd_;
}
inline void OrderCancelReplaceRequest::set_locate_reqd(bool value) {
  set_has_locate_reqd();
  locate_reqd_ = value;
}

// optional sfixed64 max_show = 31;
inline bool OrderCancelReplaceRequest::has_max_show() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_max_show() {
  _has_bits_[0] |= 0x40000000u;
}
inline void OrderCancelReplaceRequest::clear_has_max_show() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void OrderCancelReplaceRequest::clear_max_show() {
  max_show_ = GOOGLE_LONGLONG(0);
  clear_has_max_show();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::max_show() const {
  return max_show_;
}
inline void OrderCancelReplaceRequest::set_max_show(::google::protobuf::int64 value) {
  set_has_max_show();
  max_show_ = value;
}

// optional sfixed32 max_show_exponent = 32;
inline bool OrderCancelReplaceRequest::has_max_show_exponent() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_max_show_exponent() {
  _has_bits_[0] |= 0x80000000u;
}
inline void OrderCancelReplaceRequest::clear_has_max_show_exponent() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void OrderCancelReplaceRequest::clear_max_show_exponent() {
  max_show_exponent_ = 0;
  clear_has_max_show_exponent();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::max_show_exponent() const {
  return max_show_exponent_;
}
inline void OrderCancelReplaceRequest::set_max_show_exponent(::google::protobuf::int32 value) {
  set_has_max_show_exponent();
  max_show_exponent_ = value;
}

// optional sfixed64 order_qty2 = 33;
inline bool OrderCancelReplaceRequest::has_order_qty2() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_order_qty2() {
  _has_bits_[1] |= 0x00000001u;
}
inline void OrderCancelReplaceRequest::clear_has_order_qty2() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void OrderCancelReplaceRequest::clear_order_qty2() {
  order_qty2_ = GOOGLE_LONGLONG(0);
  clear_has_order_qty2();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::order_qty2() const {
  return order_qty2_;
}
inline void OrderCancelReplaceRequest::set_order_qty2(::google::protobuf::int64 value) {
  set_has_order_qty2();
  order_qty2_ = value;
}

// optional sfixed32 order_qty2_exponent = 34;
inline bool OrderCancelReplaceRequest::has_order_qty2_exponent() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_order_qty2_exponent() {
  _has_bits_[1] |= 0x00000002u;
}
inline void OrderCancelReplaceRequest::clear_has_order_qty2_exponent() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void OrderCancelReplaceRequest::clear_order_qty2_exponent() {
  order_qty2_exponent_ = 0;
  clear_has_order_qty2_exponent();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::order_qty2_exponent() const {
  return order_qty2_exponent_;
}
inline void OrderCancelReplaceRequest::set_order_qty2_exponent(::google::protobuf::int32 value) {
  set_has_order_qty2_exponent();
  order_qty2_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.PositionEffectEnum position_effect = 35;
inline bool OrderCancelReplaceRequest::has_position_effect() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_position_effect() {
  _has_bits_[1] |= 0x00000004u;
}
inline void OrderCancelReplaceRequest::clear_has_position_effect() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void OrderCancelReplaceRequest::clear_position_effect() {
  position_effect_ = 0;
  clear_has_position_effect();
}
inline ::SingleGeneralOrderHandling::PositionEffectEnum OrderCancelReplaceRequest::position_effect() const {
  return static_cast< ::SingleGeneralOrderHandling::PositionEffectEnum >(position_effect_);
}
inline void OrderCancelReplaceRequest::set_position_effect(::SingleGeneralOrderHandling::PositionEffectEnum value) {
  assert(::SingleGeneralOrderHandling::PositionEffectEnum_IsValid(value));
  set_has_position_effect();
  position_effect_ = value;
}

// optional sfixed32 settl_date2 = 36;
inline bool OrderCancelReplaceRequest::has_settl_date2() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_settl_date2() {
  _has_bits_[1] |= 0x00000008u;
}
inline void OrderCancelReplaceRequest::clear_has_settl_date2() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void OrderCancelReplaceRequest::clear_settl_date2() {
  settl_date2_ = 0;
  clear_has_settl_date2();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::settl_date2() const {
  return settl_date2_;
}
inline void OrderCancelReplaceRequest::set_settl_date2(::google::protobuf::int32 value) {
  set_has_settl_date2();
  settl_date2_ = value;
}

// optional string compliance_id = 37;
inline bool OrderCancelReplaceRequest::has_compliance_id() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_compliance_id() {
  _has_bits_[1] |= 0x00000010u;
}
inline void OrderCancelReplaceRequest::clear_has_compliance_id() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void OrderCancelReplaceRequest::clear_compliance_id() {
  if (compliance_id_ != &::google::protobuf::internal::kEmptyString) {
    compliance_id_->clear();
  }
  clear_has_compliance_id();
}
inline const ::std::string& OrderCancelReplaceRequest::compliance_id() const {
  return *compliance_id_;
}
inline void OrderCancelReplaceRequest::set_compliance_id(const ::std::string& value) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_compliance_id(const char* value) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_compliance_id(const char* value, size_t size) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_compliance_id() {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  return compliance_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_compliance_id() {
  clear_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compliance_id_;
    compliance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_compliance_id(::std::string* compliance_id) {
  if (compliance_id_ != &::google::protobuf::internal::kEmptyString) {
    delete compliance_id_;
  }
  if (compliance_id) {
    set_has_compliance_id();
    compliance_id_ = compliance_id;
  } else {
    clear_has_compliance_id();
    compliance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 effective_time = 38;
inline bool OrderCancelReplaceRequest::has_effective_time() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_effective_time() {
  _has_bits_[1] |= 0x00000020u;
}
inline void OrderCancelReplaceRequest::clear_has_effective_time() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void OrderCancelReplaceRequest::clear_effective_time() {
  effective_time_ = GOOGLE_LONGLONG(0);
  clear_has_effective_time();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::effective_time() const {
  return effective_time_;
}
inline void OrderCancelReplaceRequest::set_effective_time(::google::protobuf::int64 value) {
  set_has_effective_time();
  effective_time_ = value;
}

// optional bytes encoded_text = 39;
inline bool OrderCancelReplaceRequest::has_encoded_text() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_encoded_text() {
  _has_bits_[1] |= 0x00000040u;
}
inline void OrderCancelReplaceRequest::clear_has_encoded_text() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void OrderCancelReplaceRequest::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& OrderCancelReplaceRequest::encoded_text() const {
  return *encoded_text_;
}
inline void OrderCancelReplaceRequest::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void OrderCancelReplaceRequest::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void OrderCancelReplaceRequest::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* OrderCancelReplaceRequest::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 40;
inline bool OrderCancelReplaceRequest::has_encoded_text_len() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_encoded_text_len() {
  _has_bits_[1] |= 0x00000080u;
}
inline void OrderCancelReplaceRequest::clear_has_encoded_text_len() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void OrderCancelReplaceRequest::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 OrderCancelReplaceRequest::encoded_text_len() const {
  return encoded_text_len_;
}
inline void OrderCancelReplaceRequest::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional sfixed32 expire_date = 41;
inline bool OrderCancelReplaceRequest::has_expire_date() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_expire_date() {
  _has_bits_[1] |= 0x00000100u;
}
inline void OrderCancelReplaceRequest::clear_has_expire_date() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void OrderCancelReplaceRequest::clear_expire_date() {
  expire_date_ = 0;
  clear_has_expire_date();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::expire_date() const {
  return expire_date_;
}
inline void OrderCancelReplaceRequest::set_expire_date(::google::protobuf::int32 value) {
  set_has_expire_date();
  expire_date_ = value;
}

// optional .SingleGeneralOrderHandling.GtBookingInstEnum gt_booking_inst = 42;
inline bool OrderCancelReplaceRequest::has_gt_booking_inst() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_gt_booking_inst() {
  _has_bits_[1] |= 0x00000200u;
}
inline void OrderCancelReplaceRequest::clear_has_gt_booking_inst() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void OrderCancelReplaceRequest::clear_gt_booking_inst() {
  gt_booking_inst_ = 0;
  clear_has_gt_booking_inst();
}
inline ::SingleGeneralOrderHandling::GtBookingInstEnum OrderCancelReplaceRequest::gt_booking_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::GtBookingInstEnum >(gt_booking_inst_);
}
inline void OrderCancelReplaceRequest::set_gt_booking_inst(::SingleGeneralOrderHandling::GtBookingInstEnum value) {
  assert(::SingleGeneralOrderHandling::GtBookingInstEnum_IsValid(value));
  set_has_gt_booking_inst();
  gt_booking_inst_ = value;
}

// optional bool solicited_flag = 43;
inline bool OrderCancelReplaceRequest::has_solicited_flag() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_solicited_flag() {
  _has_bits_[1] |= 0x00000400u;
}
inline void OrderCancelReplaceRequest::clear_has_solicited_flag() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void OrderCancelReplaceRequest::clear_solicited_flag() {
  solicited_flag_ = false;
  clear_has_solicited_flag();
}
inline bool OrderCancelReplaceRequest::solicited_flag() const {
  return solicited_flag_;
}
inline void OrderCancelReplaceRequest::set_solicited_flag(bool value) {
  set_has_solicited_flag();
  solicited_flag_ = value;
}

// optional sfixed64 transact_time = 44;
inline bool OrderCancelReplaceRequest::has_transact_time() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_transact_time() {
  _has_bits_[1] |= 0x00000800u;
}
inline void OrderCancelReplaceRequest::clear_has_transact_time() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void OrderCancelReplaceRequest::clear_transact_time() {
  transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_transact_time();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::transact_time() const {
  return transact_time_;
}
inline void OrderCancelReplaceRequest::set_transact_time(::google::protobuf::int64 value) {
  set_has_transact_time();
  transact_time_ = value;
}

// optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 45;
inline bool OrderCancelReplaceRequest::has_account_type() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_account_type() {
  _has_bits_[1] |= 0x00001000u;
}
inline void OrderCancelReplaceRequest::clear_has_account_type() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void OrderCancelReplaceRequest::clear_account_type() {
  account_type_ = 0;
  clear_has_account_type();
}
inline ::SingleGeneralOrderHandling::AccountTypeEnum OrderCancelReplaceRequest::account_type() const {
  return static_cast< ::SingleGeneralOrderHandling::AccountTypeEnum >(account_type_);
}
inline void OrderCancelReplaceRequest::set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value) {
  assert(::SingleGeneralOrderHandling::AccountTypeEnum_IsValid(value));
  set_has_account_type();
  account_type_ = value;
}

// optional .SingleGeneralOrderHandling.BookingUnitEnum booking_unit = 46;
inline bool OrderCancelReplaceRequest::has_booking_unit() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_booking_unit() {
  _has_bits_[1] |= 0x00002000u;
}
inline void OrderCancelReplaceRequest::clear_has_booking_unit() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void OrderCancelReplaceRequest::clear_booking_unit() {
  booking_unit_ = 0;
  clear_has_booking_unit();
}
inline ::SingleGeneralOrderHandling::BookingUnitEnum OrderCancelReplaceRequest::booking_unit() const {
  return static_cast< ::SingleGeneralOrderHandling::BookingUnitEnum >(booking_unit_);
}
inline void OrderCancelReplaceRequest::set_booking_unit(::SingleGeneralOrderHandling::BookingUnitEnum value) {
  assert(::SingleGeneralOrderHandling::BookingUnitEnum_IsValid(value));
  set_has_booking_unit();
  booking_unit_ = value;
}

// optional .SingleGeneralOrderHandling.CancellationRightsEnum cancellation_rights = 47;
inline bool OrderCancelReplaceRequest::has_cancellation_rights() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_cancellation_rights() {
  _has_bits_[1] |= 0x00004000u;
}
inline void OrderCancelReplaceRequest::clear_has_cancellation_rights() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void OrderCancelReplaceRequest::clear_cancellation_rights() {
  cancellation_rights_ = 0;
  clear_has_cancellation_rights();
}
inline ::SingleGeneralOrderHandling::CancellationRightsEnum OrderCancelReplaceRequest::cancellation_rights() const {
  return static_cast< ::SingleGeneralOrderHandling::CancellationRightsEnum >(cancellation_rights_);
}
inline void OrderCancelReplaceRequest::set_cancellation_rights(::SingleGeneralOrderHandling::CancellationRightsEnum value) {
  assert(::SingleGeneralOrderHandling::CancellationRightsEnum_IsValid(value));
  set_has_cancellation_rights();
  cancellation_rights_ = value;
}

// optional .SingleGeneralOrderHandling.CashMarginEnum cash_margin = 48;
inline bool OrderCancelReplaceRequest::has_cash_margin() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_cash_margin() {
  _has_bits_[1] |= 0x00008000u;
}
inline void OrderCancelReplaceRequest::clear_has_cash_margin() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void OrderCancelReplaceRequest::clear_cash_margin() {
  cash_margin_ = 0;
  clear_has_cash_margin();
}
inline ::SingleGeneralOrderHandling::CashMarginEnum OrderCancelReplaceRequest::cash_margin() const {
  return static_cast< ::SingleGeneralOrderHandling::CashMarginEnum >(cash_margin_);
}
inline void OrderCancelReplaceRequest::set_cash_margin(::SingleGeneralOrderHandling::CashMarginEnum value) {
  assert(::SingleGeneralOrderHandling::CashMarginEnum_IsValid(value));
  set_has_cash_margin();
  cash_margin_ = value;
}

// optional string cl_ord_link_id = 49;
inline bool OrderCancelReplaceRequest::has_cl_ord_link_id() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_cl_ord_link_id() {
  _has_bits_[1] |= 0x00010000u;
}
inline void OrderCancelReplaceRequest::clear_has_cl_ord_link_id() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void OrderCancelReplaceRequest::clear_cl_ord_link_id() {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_->clear();
  }
  clear_has_cl_ord_link_id();
}
inline const ::std::string& OrderCancelReplaceRequest::cl_ord_link_id() const {
  return *cl_ord_link_id_;
}
inline void OrderCancelReplaceRequest::set_cl_ord_link_id(const ::std::string& value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_cl_ord_link_id(const char* value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_cl_ord_link_id(const char* value, size_t size) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_cl_ord_link_id() {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  return cl_ord_link_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_cl_ord_link_id() {
  clear_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_link_id_;
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id) {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_link_id_;
  }
  if (cl_ord_link_id) {
    set_has_cl_ord_link_id();
    cl_ord_link_id_ = cl_ord_link_id;
  } else {
    clear_has_cl_ord_link_id();
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.ClearingFeeIndicatorEnum clearing_fee_indicator = 50;
inline bool OrderCancelReplaceRequest::has_clearing_fee_indicator() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_clearing_fee_indicator() {
  _has_bits_[1] |= 0x00020000u;
}
inline void OrderCancelReplaceRequest::clear_has_clearing_fee_indicator() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void OrderCancelReplaceRequest::clear_clearing_fee_indicator() {
  clearing_fee_indicator_ = 0;
  clear_has_clearing_fee_indicator();
}
inline ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum OrderCancelReplaceRequest::clearing_fee_indicator() const {
  return static_cast< ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum >(clearing_fee_indicator_);
}
inline void OrderCancelReplaceRequest::set_clearing_fee_indicator(::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum value) {
  assert(::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum_IsValid(value));
  set_has_clearing_fee_indicator();
  clearing_fee_indicator_ = value;
}

// optional .Common.CommissionData commission_data = 51;
inline bool OrderCancelReplaceRequest::has_commission_data() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_commission_data() {
  _has_bits_[1] |= 0x00040000u;
}
inline void OrderCancelReplaceRequest::clear_has_commission_data() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void OrderCancelReplaceRequest::clear_commission_data() {
  if (commission_data_ != NULL) commission_data_->::Common::CommissionData::Clear();
  clear_has_commission_data();
}
inline const ::Common::CommissionData& OrderCancelReplaceRequest::commission_data() const {
  return commission_data_ != NULL ? *commission_data_ : *default_instance_->commission_data_;
}
inline ::Common::CommissionData* OrderCancelReplaceRequest::mutable_commission_data() {
  set_has_commission_data();
  if (commission_data_ == NULL) commission_data_ = new ::Common::CommissionData;
  return commission_data_;
}
inline ::Common::CommissionData* OrderCancelReplaceRequest::release_commission_data() {
  clear_has_commission_data();
  ::Common::CommissionData* temp = commission_data_;
  commission_data_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_commission_data(::Common::CommissionData* commission_data) {
  delete commission_data_;
  commission_data_ = commission_data;
  if (commission_data) {
    set_has_commission_data();
  } else {
    clear_has_commission_data();
  }
}

// optional .SingleGeneralOrderHandling.CustOrderCapacityEnum cust_order_capacity = 52;
inline bool OrderCancelReplaceRequest::has_cust_order_capacity() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_cust_order_capacity() {
  _has_bits_[1] |= 0x00080000u;
}
inline void OrderCancelReplaceRequest::clear_has_cust_order_capacity() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void OrderCancelReplaceRequest::clear_cust_order_capacity() {
  cust_order_capacity_ = 0;
  clear_has_cust_order_capacity();
}
inline ::SingleGeneralOrderHandling::CustOrderCapacityEnum OrderCancelReplaceRequest::cust_order_capacity() const {
  return static_cast< ::SingleGeneralOrderHandling::CustOrderCapacityEnum >(cust_order_capacity_);
}
inline void OrderCancelReplaceRequest::set_cust_order_capacity(::SingleGeneralOrderHandling::CustOrderCapacityEnum value) {
  assert(::SingleGeneralOrderHandling::CustOrderCapacityEnum_IsValid(value));
  set_has_cust_order_capacity();
  cust_order_capacity_ = value;
}

// optional .SingleGeneralOrderHandling.DayBookingInstEnum day_booking_inst = 53;
inline bool OrderCancelReplaceRequest::has_day_booking_inst() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_day_booking_inst() {
  _has_bits_[1] |= 0x00100000u;
}
inline void OrderCancelReplaceRequest::clear_has_day_booking_inst() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void OrderCancelReplaceRequest::clear_day_booking_inst() {
  day_booking_inst_ = 0;
  clear_has_day_booking_inst();
}
inline ::SingleGeneralOrderHandling::DayBookingInstEnum OrderCancelReplaceRequest::day_booking_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::DayBookingInstEnum >(day_booking_inst_);
}
inline void OrderCancelReplaceRequest::set_day_booking_inst(::SingleGeneralOrderHandling::DayBookingInstEnum value) {
  assert(::SingleGeneralOrderHandling::DayBookingInstEnum_IsValid(value));
  set_has_day_booking_inst();
  day_booking_inst_ = value;
}

// optional string designation = 54;
inline bool OrderCancelReplaceRequest::has_designation() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_designation() {
  _has_bits_[1] |= 0x00200000u;
}
inline void OrderCancelReplaceRequest::clear_has_designation() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void OrderCancelReplaceRequest::clear_designation() {
  if (designation_ != &::google::protobuf::internal::kEmptyString) {
    designation_->clear();
  }
  clear_has_designation();
}
inline const ::std::string& OrderCancelReplaceRequest::designation() const {
  return *designation_;
}
inline void OrderCancelReplaceRequest::set_designation(const ::std::string& value) {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  designation_->assign(value);
}
inline void OrderCancelReplaceRequest::set_designation(const char* value) {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  designation_->assign(value);
}
inline void OrderCancelReplaceRequest::set_designation(const char* value, size_t size) {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  designation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_designation() {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  return designation_;
}
inline ::std::string* OrderCancelReplaceRequest::release_designation() {
  clear_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = designation_;
    designation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_designation(::std::string* designation) {
  if (designation_ != &::google::protobuf::internal::kEmptyString) {
    delete designation_;
  }
  if (designation) {
    set_has_designation();
    designation_ = designation;
  } else {
    clear_has_designation();
    designation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.Instrument instrument = 55;
inline bool OrderCancelReplaceRequest::has_instrument() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_instrument() {
  _has_bits_[1] |= 0x00400000u;
}
inline void OrderCancelReplaceRequest::clear_has_instrument() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void OrderCancelReplaceRequest::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& OrderCancelReplaceRequest::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* OrderCancelReplaceRequest::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* OrderCancelReplaceRequest::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional .SingleGeneralOrderHandling.MoneyLaunderingStatusEnum money_laundering_status = 56;
inline bool OrderCancelReplaceRequest::has_money_laundering_status() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_money_laundering_status() {
  _has_bits_[1] |= 0x00800000u;
}
inline void OrderCancelReplaceRequest::clear_has_money_laundering_status() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void OrderCancelReplaceRequest::clear_money_laundering_status() {
  money_laundering_status_ = 0;
  clear_has_money_laundering_status();
}
inline ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum OrderCancelReplaceRequest::money_laundering_status() const {
  return static_cast< ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum >(money_laundering_status_);
}
inline void OrderCancelReplaceRequest::set_money_laundering_status(::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum value) {
  assert(::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum_IsValid(value));
  set_has_money_laundering_status();
  money_laundering_status_ = value;
}

// optional .SingleGeneralOrderHandling.OrderCapacityEnum order_capacity = 57;
inline bool OrderCancelReplaceRequest::has_order_capacity() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_order_capacity() {
  _has_bits_[1] |= 0x01000000u;
}
inline void OrderCancelReplaceRequest::clear_has_order_capacity() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void OrderCancelReplaceRequest::clear_order_capacity() {
  order_capacity_ = 0;
  clear_has_order_capacity();
}
inline ::SingleGeneralOrderHandling::OrderCapacityEnum OrderCancelReplaceRequest::order_capacity() const {
  return static_cast< ::SingleGeneralOrderHandling::OrderCapacityEnum >(order_capacity_);
}
inline void OrderCancelReplaceRequest::set_order_capacity(::SingleGeneralOrderHandling::OrderCapacityEnum value) {
  assert(::SingleGeneralOrderHandling::OrderCapacityEnum_IsValid(value));
  set_has_order_capacity();
  order_capacity_ = value;
}

// optional .Common.OrderQtyData order_qty_data = 58;
inline bool OrderCancelReplaceRequest::has_order_qty_data() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_order_qty_data() {
  _has_bits_[1] |= 0x02000000u;
}
inline void OrderCancelReplaceRequest::clear_has_order_qty_data() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void OrderCancelReplaceRequest::clear_order_qty_data() {
  if (order_qty_data_ != NULL) order_qty_data_->::Common::OrderQtyData::Clear();
  clear_has_order_qty_data();
}
inline const ::Common::OrderQtyData& OrderCancelReplaceRequest::order_qty_data() const {
  return order_qty_data_ != NULL ? *order_qty_data_ : *default_instance_->order_qty_data_;
}
inline ::Common::OrderQtyData* OrderCancelReplaceRequest::mutable_order_qty_data() {
  set_has_order_qty_data();
  if (order_qty_data_ == NULL) order_qty_data_ = new ::Common::OrderQtyData;
  return order_qty_data_;
}
inline ::Common::OrderQtyData* OrderCancelReplaceRequest::release_order_qty_data() {
  clear_has_order_qty_data();
  ::Common::OrderQtyData* temp = order_qty_data_;
  order_qty_data_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data) {
  delete order_qty_data_;
  order_qty_data_ = order_qty_data;
  if (order_qty_data) {
    set_has_order_qty_data();
  } else {
    clear_has_order_qty_data();
  }
}

// repeated .SingleGeneralOrderHandling.OrderRestrictionsEnum order_restrictions = 59 [packed = true];
inline int OrderCancelReplaceRequest::order_restrictions_size() const {
  return order_restrictions_.size();
}
inline void OrderCancelReplaceRequest::clear_order_restrictions() {
  order_restrictions_.Clear();
}
inline ::SingleGeneralOrderHandling::OrderRestrictionsEnum OrderCancelReplaceRequest::order_restrictions(int index) const {
  return static_cast< ::SingleGeneralOrderHandling::OrderRestrictionsEnum >(order_restrictions_.Get(index));
}
inline void OrderCancelReplaceRequest::set_order_restrictions(int index, ::SingleGeneralOrderHandling::OrderRestrictionsEnum value) {
  assert(::SingleGeneralOrderHandling::OrderRestrictionsEnum_IsValid(value));
  order_restrictions_.Set(index, value);
}
inline void OrderCancelReplaceRequest::add_order_restrictions(::SingleGeneralOrderHandling::OrderRestrictionsEnum value) {
  assert(::SingleGeneralOrderHandling::OrderRestrictionsEnum_IsValid(value));
  order_restrictions_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
OrderCancelReplaceRequest::order_restrictions() const {
  return order_restrictions_;
}
inline ::google::protobuf::RepeatedField<int>*
OrderCancelReplaceRequest::mutable_order_restrictions() {
  return &order_restrictions_;
}

// optional sfixed64 orig_ord_mod_time = 60;
inline bool OrderCancelReplaceRequest::has_orig_ord_mod_time() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_orig_ord_mod_time() {
  _has_bits_[1] |= 0x08000000u;
}
inline void OrderCancelReplaceRequest::clear_has_orig_ord_mod_time() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void OrderCancelReplaceRequest::clear_orig_ord_mod_time() {
  orig_ord_mod_time_ = GOOGLE_LONGLONG(0);
  clear_has_orig_ord_mod_time();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::orig_ord_mod_time() const {
  return orig_ord_mod_time_;
}
inline void OrderCancelReplaceRequest::set_orig_ord_mod_time(::google::protobuf::int64 value) {
  set_has_orig_ord_mod_time();
  orig_ord_mod_time_ = value;
}

// repeated .Common.Parties parties = 61;
inline int OrderCancelReplaceRequest::parties_size() const {
  return parties_.size();
}
inline void OrderCancelReplaceRequest::clear_parties() {
  parties_.Clear();
}
inline const ::Common::Parties& OrderCancelReplaceRequest::parties(int index) const {
  return parties_.Get(index);
}
inline ::Common::Parties* OrderCancelReplaceRequest::mutable_parties(int index) {
  return parties_.Mutable(index);
}
inline ::Common::Parties* OrderCancelReplaceRequest::add_parties() {
  return parties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
OrderCancelReplaceRequest::parties() const {
  return parties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
OrderCancelReplaceRequest::mutable_parties() {
  return &parties_;
}

// optional .SingleGeneralOrderHandling.PreallocMethodEnum prealloc_method = 62;
inline bool OrderCancelReplaceRequest::has_prealloc_method() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_prealloc_method() {
  _has_bits_[1] |= 0x20000000u;
}
inline void OrderCancelReplaceRequest::clear_has_prealloc_method() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void OrderCancelReplaceRequest::clear_prealloc_method() {
  prealloc_method_ = 0;
  clear_has_prealloc_method();
}
inline ::SingleGeneralOrderHandling::PreallocMethodEnum OrderCancelReplaceRequest::prealloc_method() const {
  return static_cast< ::SingleGeneralOrderHandling::PreallocMethodEnum >(prealloc_method_);
}
inline void OrderCancelReplaceRequest::set_prealloc_method(::SingleGeneralOrderHandling::PreallocMethodEnum value) {
  assert(::SingleGeneralOrderHandling::PreallocMethodEnum_IsValid(value));
  set_has_prealloc_method();
  prealloc_method_ = value;
}

// optional sfixed64 price2 = 63;
inline bool OrderCancelReplaceRequest::has_price2() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_price2() {
  _has_bits_[1] |= 0x40000000u;
}
inline void OrderCancelReplaceRequest::clear_has_price2() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void OrderCancelReplaceRequest::clear_price2() {
  price2_ = GOOGLE_LONGLONG(0);
  clear_has_price2();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::price2() const {
  return price2_;
}
inline void OrderCancelReplaceRequest::set_price2(::google::protobuf::int64 value) {
  set_has_price2();
  price2_ = value;
}

// optional sfixed32 price2_exponent = 64;
inline bool OrderCancelReplaceRequest::has_price2_exponent() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_price2_exponent() {
  _has_bits_[1] |= 0x80000000u;
}
inline void OrderCancelReplaceRequest::clear_has_price2_exponent() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void OrderCancelReplaceRequest::clear_price2_exponent() {
  price2_exponent_ = 0;
  clear_has_price2_exponent();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::price2_exponent() const {
  return price2_exponent_;
}
inline void OrderCancelReplaceRequest::set_price2_exponent(::google::protobuf::int32 value) {
  set_has_price2_exponent();
  price2_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.PriceTypeEnum price_type = 65;
inline bool OrderCancelReplaceRequest::has_price_type() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_price_type() {
  _has_bits_[2] |= 0x00000001u;
}
inline void OrderCancelReplaceRequest::clear_has_price_type() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void OrderCancelReplaceRequest::clear_price_type() {
  price_type_ = 0;
  clear_has_price_type();
}
inline ::SingleGeneralOrderHandling::PriceTypeEnum OrderCancelReplaceRequest::price_type() const {
  return static_cast< ::SingleGeneralOrderHandling::PriceTypeEnum >(price_type_);
}
inline void OrderCancelReplaceRequest::set_price_type(::SingleGeneralOrderHandling::PriceTypeEnum value) {
  assert(::SingleGeneralOrderHandling::PriceTypeEnum_IsValid(value));
  set_has_price_type();
  price_type_ = value;
}

// optional string regist_id = 66;
inline bool OrderCancelReplaceRequest::has_regist_id() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_regist_id() {
  _has_bits_[2] |= 0x00000002u;
}
inline void OrderCancelReplaceRequest::clear_has_regist_id() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void OrderCancelReplaceRequest::clear_regist_id() {
  if (regist_id_ != &::google::protobuf::internal::kEmptyString) {
    regist_id_->clear();
  }
  clear_has_regist_id();
}
inline const ::std::string& OrderCancelReplaceRequest::regist_id() const {
  return *regist_id_;
}
inline void OrderCancelReplaceRequest::set_regist_id(const ::std::string& value) {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  regist_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_regist_id(const char* value) {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  regist_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_regist_id(const char* value, size_t size) {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  regist_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_regist_id() {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  return regist_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_regist_id() {
  clear_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = regist_id_;
    regist_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_regist_id(::std::string* regist_id) {
  if (regist_id_ != &::google::protobuf::internal::kEmptyString) {
    delete regist_id_;
  }
  if (regist_id) {
    set_has_regist_id();
    regist_id_ = regist_id;
  } else {
    clear_has_regist_id();
    regist_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string secondary_cl_ord_id = 67;
inline bool OrderCancelReplaceRequest::has_secondary_cl_ord_id() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_secondary_cl_ord_id() {
  _has_bits_[2] |= 0x00000004u;
}
inline void OrderCancelReplaceRequest::clear_has_secondary_cl_ord_id() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void OrderCancelReplaceRequest::clear_secondary_cl_ord_id() {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_->clear();
  }
  clear_has_secondary_cl_ord_id();
}
inline const ::std::string& OrderCancelReplaceRequest::secondary_cl_ord_id() const {
  return *secondary_cl_ord_id_;
}
inline void OrderCancelReplaceRequest::set_secondary_cl_ord_id(const ::std::string& value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_secondary_cl_ord_id(const char* value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_secondary_cl_ord_id(const char* value, size_t size) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_secondary_cl_ord_id() {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  return secondary_cl_ord_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_secondary_cl_ord_id() {
  clear_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_cl_ord_id_;
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id) {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_cl_ord_id_;
  }
  if (secondary_cl_ord_id) {
    set_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = secondary_cl_ord_id;
  } else {
    clear_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 68;
inline bool OrderCancelReplaceRequest::has_spread_or_benchmark_curve_data() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_spread_or_benchmark_curve_data() {
  _has_bits_[2] |= 0x00000008u;
}
inline void OrderCancelReplaceRequest::clear_has_spread_or_benchmark_curve_data() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void OrderCancelReplaceRequest::clear_spread_or_benchmark_curve_data() {
  if (spread_or_benchmark_curve_data_ != NULL) spread_or_benchmark_curve_data_->::Common::SpreadOrBenchmarkCurveData::Clear();
  clear_has_spread_or_benchmark_curve_data();
}
inline const ::Common::SpreadOrBenchmarkCurveData& OrderCancelReplaceRequest::spread_or_benchmark_curve_data() const {
  return spread_or_benchmark_curve_data_ != NULL ? *spread_or_benchmark_curve_data_ : *default_instance_->spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* OrderCancelReplaceRequest::mutable_spread_or_benchmark_curve_data() {
  set_has_spread_or_benchmark_curve_data();
  if (spread_or_benchmark_curve_data_ == NULL) spread_or_benchmark_curve_data_ = new ::Common::SpreadOrBenchmarkCurveData;
  return spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* OrderCancelReplaceRequest::release_spread_or_benchmark_curve_data() {
  clear_has_spread_or_benchmark_curve_data();
  ::Common::SpreadOrBenchmarkCurveData* temp = spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data) {
  delete spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = spread_or_benchmark_curve_data;
  if (spread_or_benchmark_curve_data) {
    set_has_spread_or_benchmark_curve_data();
  } else {
    clear_has_spread_or_benchmark_curve_data();
  }
}

// optional sfixed32 trade_origination_date = 69;
inline bool OrderCancelReplaceRequest::has_trade_origination_date() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_trade_origination_date() {
  _has_bits_[2] |= 0x00000010u;
}
inline void OrderCancelReplaceRequest::clear_has_trade_origination_date() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void OrderCancelReplaceRequest::clear_trade_origination_date() {
  trade_origination_date_ = 0;
  clear_has_trade_origination_date();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::trade_origination_date() const {
  return trade_origination_date_;
}
inline void OrderCancelReplaceRequest::set_trade_origination_date(::google::protobuf::int32 value) {
  set_has_trade_origination_date();
  trade_origination_date_ = value;
}

// optional .Common.YieldData yield_data = 70;
inline bool OrderCancelReplaceRequest::has_yield_data() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_yield_data() {
  _has_bits_[2] |= 0x00000020u;
}
inline void OrderCancelReplaceRequest::clear_has_yield_data() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void OrderCancelReplaceRequest::clear_yield_data() {
  if (yield_data_ != NULL) yield_data_->::Common::YieldData::Clear();
  clear_has_yield_data();
}
inline const ::Common::YieldData& OrderCancelReplaceRequest::yield_data() const {
  return yield_data_ != NULL ? *yield_data_ : *default_instance_->yield_data_;
}
inline ::Common::YieldData* OrderCancelReplaceRequest::mutable_yield_data() {
  set_has_yield_data();
  if (yield_data_ == NULL) yield_data_ = new ::Common::YieldData;
  return yield_data_;
}
inline ::Common::YieldData* OrderCancelReplaceRequest::release_yield_data() {
  clear_has_yield_data();
  ::Common::YieldData* temp = yield_data_;
  yield_data_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_yield_data(::Common::YieldData* yield_data) {
  delete yield_data_;
  yield_data_ = yield_data;
  if (yield_data) {
    set_has_yield_data();
  } else {
    clear_has_yield_data();
  }
}

// optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 71;
inline bool OrderCancelReplaceRequest::has_acct_id_source() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_acct_id_source() {
  _has_bits_[2] |= 0x00000040u;
}
inline void OrderCancelReplaceRequest::clear_has_acct_id_source() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void OrderCancelReplaceRequest::clear_acct_id_source() {
  acct_id_source_ = 0;
  clear_has_acct_id_source();
}
inline ::SingleGeneralOrderHandling::AcctIdSourceEnum OrderCancelReplaceRequest::acct_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::AcctIdSourceEnum >(acct_id_source_);
}
inline void OrderCancelReplaceRequest::set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::AcctIdSourceEnum_IsValid(value));
  set_has_acct_id_source();
  acct_id_source_ = value;
}

// optional string alloc_id = 72;
inline bool OrderCancelReplaceRequest::has_alloc_id() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_alloc_id() {
  _has_bits_[2] |= 0x00000080u;
}
inline void OrderCancelReplaceRequest::clear_has_alloc_id() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void OrderCancelReplaceRequest::clear_alloc_id() {
  if (alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    alloc_id_->clear();
  }
  clear_has_alloc_id();
}
inline const ::std::string& OrderCancelReplaceRequest::alloc_id() const {
  return *alloc_id_;
}
inline void OrderCancelReplaceRequest::set_alloc_id(const ::std::string& value) {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  alloc_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_alloc_id(const char* value) {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  alloc_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_alloc_id(const char* value, size_t size) {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  alloc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_alloc_id() {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  return alloc_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_alloc_id() {
  clear_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alloc_id_;
    alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_alloc_id(::std::string* alloc_id) {
  if (alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    delete alloc_id_;
  }
  if (alloc_id) {
    set_has_alloc_id();
    alloc_id_ = alloc_id;
  } else {
    clear_has_alloc_id();
    alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.BookingTypeEnum booking_type = 73;
inline bool OrderCancelReplaceRequest::has_booking_type() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_booking_type() {
  _has_bits_[2] |= 0x00000100u;
}
inline void OrderCancelReplaceRequest::clear_has_booking_type() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void OrderCancelReplaceRequest::clear_booking_type() {
  booking_type_ = 0;
  clear_has_booking_type();
}
inline ::SingleGeneralOrderHandling::BookingTypeEnum OrderCancelReplaceRequest::booking_type() const {
  return static_cast< ::SingleGeneralOrderHandling::BookingTypeEnum >(booking_type_);
}
inline void OrderCancelReplaceRequest::set_booking_type(::SingleGeneralOrderHandling::BookingTypeEnum value) {
  assert(::SingleGeneralOrderHandling::BookingTypeEnum_IsValid(value));
  set_has_booking_type();
  booking_type_ = value;
}

// optional bool cust_directed_order = 74;
inline bool OrderCancelReplaceRequest::has_cust_directed_order() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_cust_directed_order() {
  _has_bits_[2] |= 0x00000200u;
}
inline void OrderCancelReplaceRequest::clear_has_cust_directed_order() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void OrderCancelReplaceRequest::clear_cust_directed_order() {
  cust_directed_order_ = false;
  clear_has_cust_directed_order();
}
inline bool OrderCancelReplaceRequest::cust_directed_order() const {
  return cust_directed_order_;
}
inline void OrderCancelReplaceRequest::set_cust_directed_order(bool value) {
  set_has_cust_directed_order();
  cust_directed_order_ = value;
}

// optional .SingleGeneralOrderHandling.CustOrderHandlingInstEnum cust_order_handling_inst = 75;
inline bool OrderCancelReplaceRequest::has_cust_order_handling_inst() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_cust_order_handling_inst() {
  _has_bits_[2] |= 0x00000400u;
}
inline void OrderCancelReplaceRequest::clear_has_cust_order_handling_inst() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void OrderCancelReplaceRequest::clear_cust_order_handling_inst() {
  cust_order_handling_inst_ = 0;
  clear_has_cust_order_handling_inst();
}
inline ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum OrderCancelReplaceRequest::cust_order_handling_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum >(cust_order_handling_inst_);
}
inline void OrderCancelReplaceRequest::set_cust_order_handling_inst(::SingleGeneralOrderHandling::CustOrderHandlingInstEnum value) {
  assert(::SingleGeneralOrderHandling::CustOrderHandlingInstEnum_IsValid(value));
  set_has_cust_order_handling_inst();
  cust_order_handling_inst_ = value;
}

// optional .Common.DiscretionInstructions discretion_instructions = 76;
inline bool OrderCancelReplaceRequest::has_discretion_instructions() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_discretion_instructions() {
  _has_bits_[2] |= 0x00000800u;
}
inline void OrderCancelReplaceRequest::clear_has_discretion_instructions() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void OrderCancelReplaceRequest::clear_discretion_instructions() {
  if (discretion_instructions_ != NULL) discretion_instructions_->::Common::DiscretionInstructions::Clear();
  clear_has_discretion_instructions();
}
inline const ::Common::DiscretionInstructions& OrderCancelReplaceRequest::discretion_instructions() const {
  return discretion_instructions_ != NULL ? *discretion_instructions_ : *default_instance_->discretion_instructions_;
}
inline ::Common::DiscretionInstructions* OrderCancelReplaceRequest::mutable_discretion_instructions() {
  set_has_discretion_instructions();
  if (discretion_instructions_ == NULL) discretion_instructions_ = new ::Common::DiscretionInstructions;
  return discretion_instructions_;
}
inline ::Common::DiscretionInstructions* OrderCancelReplaceRequest::release_discretion_instructions() {
  clear_has_discretion_instructions();
  ::Common::DiscretionInstructions* temp = discretion_instructions_;
  discretion_instructions_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_discretion_instructions(::Common::DiscretionInstructions* discretion_instructions) {
  delete discretion_instructions_;
  discretion_instructions_ = discretion_instructions;
  if (discretion_instructions) {
    set_has_discretion_instructions();
  } else {
    clear_has_discretion_instructions();
  }
}

// optional .Common.DisplayInstruction display_instruction = 77;
inline bool OrderCancelReplaceRequest::has_display_instruction() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_display_instruction() {
  _has_bits_[2] |= 0x00001000u;
}
inline void OrderCancelReplaceRequest::clear_has_display_instruction() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void OrderCancelReplaceRequest::clear_display_instruction() {
  if (display_instruction_ != NULL) display_instruction_->::Common::DisplayInstruction::Clear();
  clear_has_display_instruction();
}
inline const ::Common::DisplayInstruction& OrderCancelReplaceRequest::display_instruction() const {
  return display_instruction_ != NULL ? *display_instruction_ : *default_instance_->display_instruction_;
}
inline ::Common::DisplayInstruction* OrderCancelReplaceRequest::mutable_display_instruction() {
  set_has_display_instruction();
  if (display_instruction_ == NULL) display_instruction_ = new ::Common::DisplayInstruction;
  return display_instruction_;
}
inline ::Common::DisplayInstruction* OrderCancelReplaceRequest::release_display_instruction() {
  clear_has_display_instruction();
  ::Common::DisplayInstruction* temp = display_instruction_;
  display_instruction_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_display_instruction(::Common::DisplayInstruction* display_instruction) {
  delete display_instruction_;
  display_instruction_ = display_instruction;
  if (display_instruction) {
    set_has_display_instruction();
  } else {
    clear_has_display_instruction();
  }
}

// optional .SingleGeneralOrderHandling.ExDestinationIdSourceEnum ex_destination_id_source = 78;
inline bool OrderCancelReplaceRequest::has_ex_destination_id_source() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_ex_destination_id_source() {
  _has_bits_[2] |= 0x00002000u;
}
inline void OrderCancelReplaceRequest::clear_has_ex_destination_id_source() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void OrderCancelReplaceRequest::clear_ex_destination_id_source() {
  ex_destination_id_source_ = 0;
  clear_has_ex_destination_id_source();
}
inline ::SingleGeneralOrderHandling::ExDestinationIdSourceEnum OrderCancelReplaceRequest::ex_destination_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::ExDestinationIdSourceEnum >(ex_destination_id_source_);
}
inline void OrderCancelReplaceRequest::set_ex_destination_id_source(::SingleGeneralOrderHandling::ExDestinationIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::ExDestinationIdSourceEnum_IsValid(value));
  set_has_ex_destination_id_source();
  ex_destination_id_source_ = value;
}

// optional .Common.FinancingDetails financing_details = 79;
inline bool OrderCancelReplaceRequest::has_financing_details() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_financing_details() {
  _has_bits_[2] |= 0x00004000u;
}
inline void OrderCancelReplaceRequest::clear_has_financing_details() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void OrderCancelReplaceRequest::clear_financing_details() {
  if (financing_details_ != NULL) financing_details_->::Common::FinancingDetails::Clear();
  clear_has_financing_details();
}
inline const ::Common::FinancingDetails& OrderCancelReplaceRequest::financing_details() const {
  return financing_details_ != NULL ? *financing_details_ : *default_instance_->financing_details_;
}
inline ::Common::FinancingDetails* OrderCancelReplaceRequest::mutable_financing_details() {
  set_has_financing_details();
  if (financing_details_ == NULL) financing_details_ = new ::Common::FinancingDetails;
  return financing_details_;
}
inline ::Common::FinancingDetails* OrderCancelReplaceRequest::release_financing_details() {
  clear_has_financing_details();
  ::Common::FinancingDetails* temp = financing_details_;
  financing_details_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_financing_details(::Common::FinancingDetails* financing_details) {
  delete financing_details_;
  financing_details_ = financing_details;
  if (financing_details) {
    set_has_financing_details();
  } else {
    clear_has_financing_details();
  }
}

// optional bool manual_order_indicator = 80;
inline bool OrderCancelReplaceRequest::has_manual_order_indicator() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_manual_order_indicator() {
  _has_bits_[2] |= 0x00008000u;
}
inline void OrderCancelReplaceRequest::clear_has_manual_order_indicator() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void OrderCancelReplaceRequest::clear_manual_order_indicator() {
  manual_order_indicator_ = false;
  clear_has_manual_order_indicator();
}
inline bool OrderCancelReplaceRequest::manual_order_indicator() const {
  return manual_order_indicator_;
}
inline void OrderCancelReplaceRequest::set_manual_order_indicator(bool value) {
  set_has_manual_order_indicator();
  manual_order_indicator_ = value;
}

// optional sfixed64 match_increment = 81;
inline bool OrderCancelReplaceRequest::has_match_increment() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_match_increment() {
  _has_bits_[2] |= 0x00010000u;
}
inline void OrderCancelReplaceRequest::clear_has_match_increment() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void OrderCancelReplaceRequest::clear_match_increment() {
  match_increment_ = GOOGLE_LONGLONG(0);
  clear_has_match_increment();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::match_increment() const {
  return match_increment_;
}
inline void OrderCancelReplaceRequest::set_match_increment(::google::protobuf::int64 value) {
  set_has_match_increment();
  match_increment_ = value;
}

// optional sfixed32 match_increment_exponent = 82;
inline bool OrderCancelReplaceRequest::has_match_increment_exponent() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_match_increment_exponent() {
  _has_bits_[2] |= 0x00020000u;
}
inline void OrderCancelReplaceRequest::clear_has_match_increment_exponent() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void OrderCancelReplaceRequest::clear_match_increment_exponent() {
  match_increment_exponent_ = 0;
  clear_has_match_increment_exponent();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::match_increment_exponent() const {
  return match_increment_exponent_;
}
inline void OrderCancelReplaceRequest::set_match_increment_exponent(::google::protobuf::int32 value) {
  set_has_match_increment_exponent();
  match_increment_exponent_ = value;
}

// optional sfixed64 max_price_levels = 83;
inline bool OrderCancelReplaceRequest::has_max_price_levels() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_max_price_levels() {
  _has_bits_[2] |= 0x00040000u;
}
inline void OrderCancelReplaceRequest::clear_has_max_price_levels() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void OrderCancelReplaceRequest::clear_max_price_levels() {
  max_price_levels_ = GOOGLE_LONGLONG(0);
  clear_has_max_price_levels();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::max_price_levels() const {
  return max_price_levels_;
}
inline void OrderCancelReplaceRequest::set_max_price_levels(::google::protobuf::int64 value) {
  set_has_max_price_levels();
  max_price_levels_ = value;
}

// optional .SingleGeneralOrderHandling.OrderHandlingInstSourceEnum order_handling_inst_source = 84;
inline bool OrderCancelReplaceRequest::has_order_handling_inst_source() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_order_handling_inst_source() {
  _has_bits_[2] |= 0x00080000u;
}
inline void OrderCancelReplaceRequest::clear_has_order_handling_inst_source() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void OrderCancelReplaceRequest::clear_order_handling_inst_source() {
  order_handling_inst_source_ = 0;
  clear_has_order_handling_inst_source();
}
inline ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum OrderCancelReplaceRequest::order_handling_inst_source() const {
  return static_cast< ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum >(order_handling_inst_source_);
}
inline void OrderCancelReplaceRequest::set_order_handling_inst_source(::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum value) {
  assert(::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum_IsValid(value));
  set_has_order_handling_inst_source();
  order_handling_inst_source_ = value;
}

// optional sfixed64 participation_rate = 85;
inline bool OrderCancelReplaceRequest::has_participation_rate() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_participation_rate() {
  _has_bits_[2] |= 0x00100000u;
}
inline void OrderCancelReplaceRequest::clear_has_participation_rate() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void OrderCancelReplaceRequest::clear_participation_rate() {
  participation_rate_ = GOOGLE_LONGLONG(0);
  clear_has_participation_rate();
}
inline ::google::protobuf::int64 OrderCancelReplaceRequest::participation_rate() const {
  return participation_rate_;
}
inline void OrderCancelReplaceRequest::set_participation_rate(::google::protobuf::int64 value) {
  set_has_participation_rate();
  participation_rate_ = value;
}

// optional sfixed32 participation_rate_exponent = 86;
inline bool OrderCancelReplaceRequest::has_participation_rate_exponent() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_participation_rate_exponent() {
  _has_bits_[2] |= 0x00200000u;
}
inline void OrderCancelReplaceRequest::clear_has_participation_rate_exponent() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void OrderCancelReplaceRequest::clear_participation_rate_exponent() {
  participation_rate_exponent_ = 0;
  clear_has_participation_rate_exponent();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::participation_rate_exponent() const {
  return participation_rate_exponent_;
}
inline void OrderCancelReplaceRequest::set_participation_rate_exponent(::google::protobuf::int32 value) {
  set_has_participation_rate_exponent();
  participation_rate_exponent_ = value;
}

// optional .Common.PegInstructions peg_instructions = 87;
inline bool OrderCancelReplaceRequest::has_peg_instructions() const {
  return (_has_bits_[2] & 0x00400000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_peg_instructions() {
  _has_bits_[2] |= 0x00400000u;
}
inline void OrderCancelReplaceRequest::clear_has_peg_instructions() {
  _has_bits_[2] &= ~0x00400000u;
}
inline void OrderCancelReplaceRequest::clear_peg_instructions() {
  if (peg_instructions_ != NULL) peg_instructions_->::Common::PegInstructions::Clear();
  clear_has_peg_instructions();
}
inline const ::Common::PegInstructions& OrderCancelReplaceRequest::peg_instructions() const {
  return peg_instructions_ != NULL ? *peg_instructions_ : *default_instance_->peg_instructions_;
}
inline ::Common::PegInstructions* OrderCancelReplaceRequest::mutable_peg_instructions() {
  set_has_peg_instructions();
  if (peg_instructions_ == NULL) peg_instructions_ = new ::Common::PegInstructions;
  return peg_instructions_;
}
inline ::Common::PegInstructions* OrderCancelReplaceRequest::release_peg_instructions() {
  clear_has_peg_instructions();
  ::Common::PegInstructions* temp = peg_instructions_;
  peg_instructions_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_peg_instructions(::Common::PegInstructions* peg_instructions) {
  delete peg_instructions_;
  peg_instructions_ = peg_instructions;
  if (peg_instructions) {
    set_has_peg_instructions();
  } else {
    clear_has_peg_instructions();
  }
}

// repeated .Common.PreAllocGrp pre_alloc_grp = 88;
inline int OrderCancelReplaceRequest::pre_alloc_grp_size() const {
  return pre_alloc_grp_.size();
}
inline void OrderCancelReplaceRequest::clear_pre_alloc_grp() {
  pre_alloc_grp_.Clear();
}
inline const ::Common::PreAllocGrp& OrderCancelReplaceRequest::pre_alloc_grp(int index) const {
  return pre_alloc_grp_.Get(index);
}
inline ::Common::PreAllocGrp* OrderCancelReplaceRequest::mutable_pre_alloc_grp(int index) {
  return pre_alloc_grp_.Mutable(index);
}
inline ::Common::PreAllocGrp* OrderCancelReplaceRequest::add_pre_alloc_grp() {
  return pre_alloc_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >&
OrderCancelReplaceRequest::pre_alloc_grp() const {
  return pre_alloc_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >*
OrderCancelReplaceRequest::mutable_pre_alloc_grp() {
  return &pre_alloc_grp_;
}

// optional bool pre_trade_anonymity = 89;
inline bool OrderCancelReplaceRequest::has_pre_trade_anonymity() const {
  return (_has_bits_[2] & 0x01000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_pre_trade_anonymity() {
  _has_bits_[2] |= 0x01000000u;
}
inline void OrderCancelReplaceRequest::clear_has_pre_trade_anonymity() {
  _has_bits_[2] &= ~0x01000000u;
}
inline void OrderCancelReplaceRequest::clear_pre_trade_anonymity() {
  pre_trade_anonymity_ = false;
  clear_has_pre_trade_anonymity();
}
inline bool OrderCancelReplaceRequest::pre_trade_anonymity() const {
  return pre_trade_anonymity_;
}
inline void OrderCancelReplaceRequest::set_pre_trade_anonymity(bool value) {
  set_has_pre_trade_anonymity();
  pre_trade_anonymity_ = value;
}

// optional .SingleGeneralOrderHandling.PriceProtectionScopeEnum price_protection_scope = 90;
inline bool OrderCancelReplaceRequest::has_price_protection_scope() const {
  return (_has_bits_[2] & 0x02000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_price_protection_scope() {
  _has_bits_[2] |= 0x02000000u;
}
inline void OrderCancelReplaceRequest::clear_has_price_protection_scope() {
  _has_bits_[2] &= ~0x02000000u;
}
inline void OrderCancelReplaceRequest::clear_price_protection_scope() {
  price_protection_scope_ = 0;
  clear_has_price_protection_scope();
}
inline ::SingleGeneralOrderHandling::PriceProtectionScopeEnum OrderCancelReplaceRequest::price_protection_scope() const {
  return static_cast< ::SingleGeneralOrderHandling::PriceProtectionScopeEnum >(price_protection_scope_);
}
inline void OrderCancelReplaceRequest::set_price_protection_scope(::SingleGeneralOrderHandling::PriceProtectionScopeEnum value) {
  assert(::SingleGeneralOrderHandling::PriceProtectionScopeEnum_IsValid(value));
  set_has_price_protection_scope();
  price_protection_scope_ = value;
}

// optional .SingleGeneralOrderHandling.QtyTypeEnum qty_type = 91;
inline bool OrderCancelReplaceRequest::has_qty_type() const {
  return (_has_bits_[2] & 0x04000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_qty_type() {
  _has_bits_[2] |= 0x04000000u;
}
inline void OrderCancelReplaceRequest::clear_has_qty_type() {
  _has_bits_[2] &= ~0x04000000u;
}
inline void OrderCancelReplaceRequest::clear_qty_type() {
  qty_type_ = 0;
  clear_has_qty_type();
}
inline ::SingleGeneralOrderHandling::QtyTypeEnum OrderCancelReplaceRequest::qty_type() const {
  return static_cast< ::SingleGeneralOrderHandling::QtyTypeEnum >(qty_type_);
}
inline void OrderCancelReplaceRequest::set_qty_type(::SingleGeneralOrderHandling::QtyTypeEnum value) {
  assert(::SingleGeneralOrderHandling::QtyTypeEnum_IsValid(value));
  set_has_qty_type();
  qty_type_ = value;
}

// optional string received_dept_id = 92;
inline bool OrderCancelReplaceRequest::has_received_dept_id() const {
  return (_has_bits_[2] & 0x08000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_received_dept_id() {
  _has_bits_[2] |= 0x08000000u;
}
inline void OrderCancelReplaceRequest::clear_has_received_dept_id() {
  _has_bits_[2] &= ~0x08000000u;
}
inline void OrderCancelReplaceRequest::clear_received_dept_id() {
  if (received_dept_id_ != &::google::protobuf::internal::kEmptyString) {
    received_dept_id_->clear();
  }
  clear_has_received_dept_id();
}
inline const ::std::string& OrderCancelReplaceRequest::received_dept_id() const {
  return *received_dept_id_;
}
inline void OrderCancelReplaceRequest::set_received_dept_id(const ::std::string& value) {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  received_dept_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_received_dept_id(const char* value) {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  received_dept_id_->assign(value);
}
inline void OrderCancelReplaceRequest::set_received_dept_id(const char* value, size_t size) {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  received_dept_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_received_dept_id() {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  return received_dept_id_;
}
inline ::std::string* OrderCancelReplaceRequest::release_received_dept_id() {
  clear_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = received_dept_id_;
    received_dept_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_received_dept_id(::std::string* received_dept_id) {
  if (received_dept_id_ != &::google::protobuf::internal::kEmptyString) {
    delete received_dept_id_;
  }
  if (received_dept_id) {
    set_has_received_dept_id();
    received_dept_id_ = received_dept_id;
  } else {
    clear_has_received_dept_id();
    received_dept_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.StrategyParametersGrp strategy_parameters_grp = 93;
inline int OrderCancelReplaceRequest::strategy_parameters_grp_size() const {
  return strategy_parameters_grp_.size();
}
inline void OrderCancelReplaceRequest::clear_strategy_parameters_grp() {
  strategy_parameters_grp_.Clear();
}
inline const ::Common::StrategyParametersGrp& OrderCancelReplaceRequest::strategy_parameters_grp(int index) const {
  return strategy_parameters_grp_.Get(index);
}
inline ::Common::StrategyParametersGrp* OrderCancelReplaceRequest::mutable_strategy_parameters_grp(int index) {
  return strategy_parameters_grp_.Mutable(index);
}
inline ::Common::StrategyParametersGrp* OrderCancelReplaceRequest::add_strategy_parameters_grp() {
  return strategy_parameters_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >&
OrderCancelReplaceRequest::strategy_parameters_grp() const {
  return strategy_parameters_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >*
OrderCancelReplaceRequest::mutable_strategy_parameters_grp() {
  return &strategy_parameters_grp_;
}

// optional .SingleGeneralOrderHandling.TargetStrategyEnum target_strategy = 94;
inline bool OrderCancelReplaceRequest::has_target_strategy() const {
  return (_has_bits_[2] & 0x20000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_target_strategy() {
  _has_bits_[2] |= 0x20000000u;
}
inline void OrderCancelReplaceRequest::clear_has_target_strategy() {
  _has_bits_[2] &= ~0x20000000u;
}
inline void OrderCancelReplaceRequest::clear_target_strategy() {
  target_strategy_ = 0;
  clear_has_target_strategy();
}
inline ::SingleGeneralOrderHandling::TargetStrategyEnum OrderCancelReplaceRequest::target_strategy() const {
  return static_cast< ::SingleGeneralOrderHandling::TargetStrategyEnum >(target_strategy_);
}
inline void OrderCancelReplaceRequest::set_target_strategy(::SingleGeneralOrderHandling::TargetStrategyEnum value) {
  assert(::SingleGeneralOrderHandling::TargetStrategyEnum_IsValid(value));
  set_has_target_strategy();
  target_strategy_ = value;
}

// optional string target_strategy_parameters = 95;
inline bool OrderCancelReplaceRequest::has_target_strategy_parameters() const {
  return (_has_bits_[2] & 0x40000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_target_strategy_parameters() {
  _has_bits_[2] |= 0x40000000u;
}
inline void OrderCancelReplaceRequest::clear_has_target_strategy_parameters() {
  _has_bits_[2] &= ~0x40000000u;
}
inline void OrderCancelReplaceRequest::clear_target_strategy_parameters() {
  if (target_strategy_parameters_ != &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_->clear();
  }
  clear_has_target_strategy_parameters();
}
inline const ::std::string& OrderCancelReplaceRequest::target_strategy_parameters() const {
  return *target_strategy_parameters_;
}
inline void OrderCancelReplaceRequest::set_target_strategy_parameters(const ::std::string& value) {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  target_strategy_parameters_->assign(value);
}
inline void OrderCancelReplaceRequest::set_target_strategy_parameters(const char* value) {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  target_strategy_parameters_->assign(value);
}
inline void OrderCancelReplaceRequest::set_target_strategy_parameters(const char* value, size_t size) {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  target_strategy_parameters_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReplaceRequest::mutable_target_strategy_parameters() {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  return target_strategy_parameters_;
}
inline ::std::string* OrderCancelReplaceRequest::release_target_strategy_parameters() {
  clear_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_strategy_parameters_;
    target_strategy_parameters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReplaceRequest::set_allocated_target_strategy_parameters(::std::string* target_strategy_parameters) {
  if (target_strategy_parameters_ != &::google::protobuf::internal::kEmptyString) {
    delete target_strategy_parameters_;
  }
  if (target_strategy_parameters) {
    set_has_target_strategy_parameters();
    target_strategy_parameters_ = target_strategy_parameters;
  } else {
    clear_has_target_strategy_parameters();
    target_strategy_parameters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 trade_date = 96;
inline bool OrderCancelReplaceRequest::has_trade_date() const {
  return (_has_bits_[2] & 0x80000000u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_trade_date() {
  _has_bits_[2] |= 0x80000000u;
}
inline void OrderCancelReplaceRequest::clear_has_trade_date() {
  _has_bits_[2] &= ~0x80000000u;
}
inline void OrderCancelReplaceRequest::clear_trade_date() {
  trade_date_ = 0;
  clear_has_trade_date();
}
inline ::google::protobuf::int32 OrderCancelReplaceRequest::trade_date() const {
  return trade_date_;
}
inline void OrderCancelReplaceRequest::set_trade_date(::google::protobuf::int32 value) {
  set_has_trade_date();
  trade_date_ = value;
}

// repeated .Common.TrdRegTimestamps trd_reg_timestamps = 97;
inline int OrderCancelReplaceRequest::trd_reg_timestamps_size() const {
  return trd_reg_timestamps_.size();
}
inline void OrderCancelReplaceRequest::clear_trd_reg_timestamps() {
  trd_reg_timestamps_.Clear();
}
inline const ::Common::TrdRegTimestamps& OrderCancelReplaceRequest::trd_reg_timestamps(int index) const {
  return trd_reg_timestamps_.Get(index);
}
inline ::Common::TrdRegTimestamps* OrderCancelReplaceRequest::mutable_trd_reg_timestamps(int index) {
  return trd_reg_timestamps_.Mutable(index);
}
inline ::Common::TrdRegTimestamps* OrderCancelReplaceRequest::add_trd_reg_timestamps() {
  return trd_reg_timestamps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >&
OrderCancelReplaceRequest::trd_reg_timestamps() const {
  return trd_reg_timestamps_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >*
OrderCancelReplaceRequest::mutable_trd_reg_timestamps() {
  return &trd_reg_timestamps_;
}

// repeated .Common.TrdgSesGrp trdg_ses_grp = 98;
inline int OrderCancelReplaceRequest::trdg_ses_grp_size() const {
  return trdg_ses_grp_.size();
}
inline void OrderCancelReplaceRequest::clear_trdg_ses_grp() {
  trdg_ses_grp_.Clear();
}
inline const ::Common::TrdgSesGrp& OrderCancelReplaceRequest::trdg_ses_grp(int index) const {
  return trdg_ses_grp_.Get(index);
}
inline ::Common::TrdgSesGrp* OrderCancelReplaceRequest::mutable_trdg_ses_grp(int index) {
  return trdg_ses_grp_.Mutable(index);
}
inline ::Common::TrdgSesGrp* OrderCancelReplaceRequest::add_trdg_ses_grp() {
  return trdg_ses_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp >&
OrderCancelReplaceRequest::trdg_ses_grp() const {
  return trdg_ses_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::TrdgSesGrp >*
OrderCancelReplaceRequest::mutable_trdg_ses_grp() {
  return &trdg_ses_grp_;
}

// optional .Common.TriggeringInstruction triggering_instruction = 99;
inline bool OrderCancelReplaceRequest::has_triggering_instruction() const {
  return (_has_bits_[3] & 0x00000004u) != 0;
}
inline void OrderCancelReplaceRequest::set_has_triggering_instruction() {
  _has_bits_[3] |= 0x00000004u;
}
inline void OrderCancelReplaceRequest::clear_has_triggering_instruction() {
  _has_bits_[3] &= ~0x00000004u;
}
inline void OrderCancelReplaceRequest::clear_triggering_instruction() {
  if (triggering_instruction_ != NULL) triggering_instruction_->::Common::TriggeringInstruction::Clear();
  clear_has_triggering_instruction();
}
inline const ::Common::TriggeringInstruction& OrderCancelReplaceRequest::triggering_instruction() const {
  return triggering_instruction_ != NULL ? *triggering_instruction_ : *default_instance_->triggering_instruction_;
}
inline ::Common::TriggeringInstruction* OrderCancelReplaceRequest::mutable_triggering_instruction() {
  set_has_triggering_instruction();
  if (triggering_instruction_ == NULL) triggering_instruction_ = new ::Common::TriggeringInstruction;
  return triggering_instruction_;
}
inline ::Common::TriggeringInstruction* OrderCancelReplaceRequest::release_triggering_instruction() {
  clear_has_triggering_instruction();
  ::Common::TriggeringInstruction* temp = triggering_instruction_;
  triggering_instruction_ = NULL;
  return temp;
}
inline void OrderCancelReplaceRequest::set_allocated_triggering_instruction(::Common::TriggeringInstruction* triggering_instruction) {
  delete triggering_instruction_;
  triggering_instruction_ = triggering_instruction;
  if (triggering_instruction) {
    set_has_triggering_instruction();
  } else {
    clear_has_triggering_instruction();
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 100;
inline int OrderCancelReplaceRequest::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void OrderCancelReplaceRequest::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& OrderCancelReplaceRequest::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* OrderCancelReplaceRequest::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* OrderCancelReplaceRequest::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
OrderCancelReplaceRequest::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
OrderCancelReplaceRequest::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// -------------------------------------------------------------------

// OrderCancelRequest

// optional string cl_ord_id = 1;
inline bool OrderCancelRequest::has_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderCancelRequest::set_has_cl_ord_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderCancelRequest::clear_has_cl_ord_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderCancelRequest::clear_cl_ord_id() {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_->clear();
  }
  clear_has_cl_ord_id();
}
inline const ::std::string& OrderCancelRequest::cl_ord_id() const {
  return *cl_ord_id_;
}
inline void OrderCancelRequest::set_cl_ord_id(const ::std::string& value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void OrderCancelRequest::set_cl_ord_id(const char* value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void OrderCancelRequest::set_cl_ord_id(const char* value, size_t size) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_cl_ord_id() {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  return cl_ord_id_;
}
inline ::std::string* OrderCancelRequest::release_cl_ord_id() {
  clear_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_id_;
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_cl_ord_id(::std::string* cl_ord_id) {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_id_;
  }
  if (cl_ord_id) {
    set_has_cl_ord_id();
    cl_ord_id_ = cl_ord_id;
  } else {
    clear_has_cl_ord_id();
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string list_id = 2;
inline bool OrderCancelRequest::has_list_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderCancelRequest::set_has_list_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderCancelRequest::clear_has_list_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderCancelRequest::clear_list_id() {
  if (list_id_ != &::google::protobuf::internal::kEmptyString) {
    list_id_->clear();
  }
  clear_has_list_id();
}
inline const ::std::string& OrderCancelRequest::list_id() const {
  return *list_id_;
}
inline void OrderCancelRequest::set_list_id(const ::std::string& value) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(value);
}
inline void OrderCancelRequest::set_list_id(const char* value) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(value);
}
inline void OrderCancelRequest::set_list_id(const char* value, size_t size) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_list_id() {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  return list_id_;
}
inline ::std::string* OrderCancelRequest::release_list_id() {
  clear_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = list_id_;
    list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_list_id(::std::string* list_id) {
  if (list_id_ != &::google::protobuf::internal::kEmptyString) {
    delete list_id_;
  }
  if (list_id) {
    set_has_list_id();
    list_id_ = list_id;
  } else {
    clear_has_list_id();
    list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string order_id = 3;
inline bool OrderCancelRequest::has_order_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderCancelRequest::set_has_order_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderCancelRequest::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderCancelRequest::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& OrderCancelRequest::order_id() const {
  return *order_id_;
}
inline void OrderCancelRequest::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderCancelRequest::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderCancelRequest::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* OrderCancelRequest::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string orig_cl_ord_id = 4;
inline bool OrderCancelRequest::has_orig_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderCancelRequest::set_has_orig_cl_ord_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderCancelRequest::clear_has_orig_cl_ord_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderCancelRequest::clear_orig_cl_ord_id() {
  if (orig_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_->clear();
  }
  clear_has_orig_cl_ord_id();
}
inline const ::std::string& OrderCancelRequest::orig_cl_ord_id() const {
  return *orig_cl_ord_id_;
}
inline void OrderCancelRequest::set_orig_cl_ord_id(const ::std::string& value) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(value);
}
inline void OrderCancelRequest::set_orig_cl_ord_id(const char* value) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(value);
}
inline void OrderCancelRequest::set_orig_cl_ord_id(const char* value, size_t size) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_orig_cl_ord_id() {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  return orig_cl_ord_id_;
}
inline ::std::string* OrderCancelRequest::release_orig_cl_ord_id() {
  clear_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orig_cl_ord_id_;
    orig_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_orig_cl_ord_id(::std::string* orig_cl_ord_id) {
  if (orig_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete orig_cl_ord_id_;
  }
  if (orig_cl_ord_id) {
    set_has_orig_cl_ord_id();
    orig_cl_ord_id_ = orig_cl_ord_id;
  } else {
    clear_has_orig_cl_ord_id();
    orig_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.SideEnum side = 5;
inline bool OrderCancelRequest::has_side() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderCancelRequest::set_has_side() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderCancelRequest::clear_has_side() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderCancelRequest::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::SingleGeneralOrderHandling::SideEnum OrderCancelRequest::side() const {
  return static_cast< ::SingleGeneralOrderHandling::SideEnum >(side_);
}
inline void OrderCancelRequest::set_side(::SingleGeneralOrderHandling::SideEnum value) {
  assert(::SingleGeneralOrderHandling::SideEnum_IsValid(value));
  set_has_side();
  side_ = value;
}

// optional .Session.StandardHeader standard_header = 6;
inline bool OrderCancelRequest::has_standard_header() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderCancelRequest::set_has_standard_header() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderCancelRequest::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderCancelRequest::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& OrderCancelRequest::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* OrderCancelRequest::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* OrderCancelRequest::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void OrderCancelRequest::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 7;
inline bool OrderCancelRequest::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderCancelRequest::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderCancelRequest::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderCancelRequest::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& OrderCancelRequest::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* OrderCancelRequest::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* OrderCancelRequest::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void OrderCancelRequest::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional string text = 8;
inline bool OrderCancelRequest::has_text() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderCancelRequest::set_has_text() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderCancelRequest::clear_has_text() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderCancelRequest::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& OrderCancelRequest::text() const {
  return *text_;
}
inline void OrderCancelRequest::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void OrderCancelRequest::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void OrderCancelRequest::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* OrderCancelRequest::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 9;
inline bool OrderCancelRequest::has_account() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderCancelRequest::set_has_account() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderCancelRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderCancelRequest::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& OrderCancelRequest::account() const {
  return *account_;
}
inline void OrderCancelRequest::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void OrderCancelRequest::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void OrderCancelRequest::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* OrderCancelRequest::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string compliance_id = 10;
inline bool OrderCancelRequest::has_compliance_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderCancelRequest::set_has_compliance_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderCancelRequest::clear_has_compliance_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderCancelRequest::clear_compliance_id() {
  if (compliance_id_ != &::google::protobuf::internal::kEmptyString) {
    compliance_id_->clear();
  }
  clear_has_compliance_id();
}
inline const ::std::string& OrderCancelRequest::compliance_id() const {
  return *compliance_id_;
}
inline void OrderCancelRequest::set_compliance_id(const ::std::string& value) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(value);
}
inline void OrderCancelRequest::set_compliance_id(const char* value) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(value);
}
inline void OrderCancelRequest::set_compliance_id(const char* value, size_t size) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_compliance_id() {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  return compliance_id_;
}
inline ::std::string* OrderCancelRequest::release_compliance_id() {
  clear_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compliance_id_;
    compliance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_compliance_id(::std::string* compliance_id) {
  if (compliance_id_ != &::google::protobuf::internal::kEmptyString) {
    delete compliance_id_;
  }
  if (compliance_id) {
    set_has_compliance_id();
    compliance_id_ = compliance_id;
  } else {
    clear_has_compliance_id();
    compliance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_text = 11;
inline bool OrderCancelRequest::has_encoded_text() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrderCancelRequest::set_has_encoded_text() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrderCancelRequest::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrderCancelRequest::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& OrderCancelRequest::encoded_text() const {
  return *encoded_text_;
}
inline void OrderCancelRequest::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void OrderCancelRequest::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void OrderCancelRequest::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* OrderCancelRequest::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 12;
inline bool OrderCancelRequest::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrderCancelRequest::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrderCancelRequest::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrderCancelRequest::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 OrderCancelRequest::encoded_text_len() const {
  return encoded_text_len_;
}
inline void OrderCancelRequest::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional sfixed64 transact_time = 13;
inline bool OrderCancelRequest::has_transact_time() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrderCancelRequest::set_has_transact_time() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrderCancelRequest::clear_has_transact_time() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrderCancelRequest::clear_transact_time() {
  transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_transact_time();
}
inline ::google::protobuf::int64 OrderCancelRequest::transact_time() const {
  return transact_time_;
}
inline void OrderCancelRequest::set_transact_time(::google::protobuf::int64 value) {
  set_has_transact_time();
  transact_time_ = value;
}

// optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 14;
inline bool OrderCancelRequest::has_account_type() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OrderCancelRequest::set_has_account_type() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OrderCancelRequest::clear_has_account_type() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OrderCancelRequest::clear_account_type() {
  account_type_ = 0;
  clear_has_account_type();
}
inline ::SingleGeneralOrderHandling::AccountTypeEnum OrderCancelRequest::account_type() const {
  return static_cast< ::SingleGeneralOrderHandling::AccountTypeEnum >(account_type_);
}
inline void OrderCancelRequest::set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value) {
  assert(::SingleGeneralOrderHandling::AccountTypeEnum_IsValid(value));
  set_has_account_type();
  account_type_ = value;
}

// optional string cl_ord_link_id = 15;
inline bool OrderCancelRequest::has_cl_ord_link_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OrderCancelRequest::set_has_cl_ord_link_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OrderCancelRequest::clear_has_cl_ord_link_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OrderCancelRequest::clear_cl_ord_link_id() {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_->clear();
  }
  clear_has_cl_ord_link_id();
}
inline const ::std::string& OrderCancelRequest::cl_ord_link_id() const {
  return *cl_ord_link_id_;
}
inline void OrderCancelRequest::set_cl_ord_link_id(const ::std::string& value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void OrderCancelRequest::set_cl_ord_link_id(const char* value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void OrderCancelRequest::set_cl_ord_link_id(const char* value, size_t size) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_cl_ord_link_id() {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  return cl_ord_link_id_;
}
inline ::std::string* OrderCancelRequest::release_cl_ord_link_id() {
  clear_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_link_id_;
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id) {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_link_id_;
  }
  if (cl_ord_link_id) {
    set_has_cl_ord_link_id();
    cl_ord_link_id_ = cl_ord_link_id;
  } else {
    clear_has_cl_ord_link_id();
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.Instrument instrument = 16;
inline bool OrderCancelRequest::has_instrument() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OrderCancelRequest::set_has_instrument() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OrderCancelRequest::clear_has_instrument() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OrderCancelRequest::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& OrderCancelRequest::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* OrderCancelRequest::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* OrderCancelRequest::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void OrderCancelRequest::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional .Common.OrderQtyData order_qty_data = 17;
inline bool OrderCancelRequest::has_order_qty_data() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OrderCancelRequest::set_has_order_qty_data() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OrderCancelRequest::clear_has_order_qty_data() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OrderCancelRequest::clear_order_qty_data() {
  if (order_qty_data_ != NULL) order_qty_data_->::Common::OrderQtyData::Clear();
  clear_has_order_qty_data();
}
inline const ::Common::OrderQtyData& OrderCancelRequest::order_qty_data() const {
  return order_qty_data_ != NULL ? *order_qty_data_ : *default_instance_->order_qty_data_;
}
inline ::Common::OrderQtyData* OrderCancelRequest::mutable_order_qty_data() {
  set_has_order_qty_data();
  if (order_qty_data_ == NULL) order_qty_data_ = new ::Common::OrderQtyData;
  return order_qty_data_;
}
inline ::Common::OrderQtyData* OrderCancelRequest::release_order_qty_data() {
  clear_has_order_qty_data();
  ::Common::OrderQtyData* temp = order_qty_data_;
  order_qty_data_ = NULL;
  return temp;
}
inline void OrderCancelRequest::set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data) {
  delete order_qty_data_;
  order_qty_data_ = order_qty_data;
  if (order_qty_data) {
    set_has_order_qty_data();
  } else {
    clear_has_order_qty_data();
  }
}

// optional sfixed64 orig_ord_mod_time = 18;
inline bool OrderCancelRequest::has_orig_ord_mod_time() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void OrderCancelRequest::set_has_orig_ord_mod_time() {
  _has_bits_[0] |= 0x00020000u;
}
inline void OrderCancelRequest::clear_has_orig_ord_mod_time() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void OrderCancelRequest::clear_orig_ord_mod_time() {
  orig_ord_mod_time_ = GOOGLE_LONGLONG(0);
  clear_has_orig_ord_mod_time();
}
inline ::google::protobuf::int64 OrderCancelRequest::orig_ord_mod_time() const {
  return orig_ord_mod_time_;
}
inline void OrderCancelRequest::set_orig_ord_mod_time(::google::protobuf::int64 value) {
  set_has_orig_ord_mod_time();
  orig_ord_mod_time_ = value;
}

// repeated .Common.Parties parties = 19;
inline int OrderCancelRequest::parties_size() const {
  return parties_.size();
}
inline void OrderCancelRequest::clear_parties() {
  parties_.Clear();
}
inline const ::Common::Parties& OrderCancelRequest::parties(int index) const {
  return parties_.Get(index);
}
inline ::Common::Parties* OrderCancelRequest::mutable_parties(int index) {
  return parties_.Mutable(index);
}
inline ::Common::Parties* OrderCancelRequest::add_parties() {
  return parties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
OrderCancelRequest::parties() const {
  return parties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
OrderCancelRequest::mutable_parties() {
  return &parties_;
}

// optional string secondary_cl_ord_id = 20;
inline bool OrderCancelRequest::has_secondary_cl_ord_id() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void OrderCancelRequest::set_has_secondary_cl_ord_id() {
  _has_bits_[0] |= 0x00080000u;
}
inline void OrderCancelRequest::clear_has_secondary_cl_ord_id() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void OrderCancelRequest::clear_secondary_cl_ord_id() {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_->clear();
  }
  clear_has_secondary_cl_ord_id();
}
inline const ::std::string& OrderCancelRequest::secondary_cl_ord_id() const {
  return *secondary_cl_ord_id_;
}
inline void OrderCancelRequest::set_secondary_cl_ord_id(const ::std::string& value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void OrderCancelRequest::set_secondary_cl_ord_id(const char* value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void OrderCancelRequest::set_secondary_cl_ord_id(const char* value, size_t size) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelRequest::mutable_secondary_cl_ord_id() {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  return secondary_cl_ord_id_;
}
inline ::std::string* OrderCancelRequest::release_secondary_cl_ord_id() {
  clear_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_cl_ord_id_;
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelRequest::set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id) {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_cl_ord_id_;
  }
  if (secondary_cl_ord_id) {
    set_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = secondary_cl_ord_id;
  } else {
    clear_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 21;
inline bool OrderCancelRequest::has_acct_id_source() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void OrderCancelRequest::set_has_acct_id_source() {
  _has_bits_[0] |= 0x00100000u;
}
inline void OrderCancelRequest::clear_has_acct_id_source() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void OrderCancelRequest::clear_acct_id_source() {
  acct_id_source_ = 0;
  clear_has_acct_id_source();
}
inline ::SingleGeneralOrderHandling::AcctIdSourceEnum OrderCancelRequest::acct_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::AcctIdSourceEnum >(acct_id_source_);
}
inline void OrderCancelRequest::set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::AcctIdSourceEnum_IsValid(value));
  set_has_acct_id_source();
  acct_id_source_ = value;
}

// optional .Common.FinancingDetails financing_details = 22;
inline bool OrderCancelRequest::has_financing_details() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void OrderCancelRequest::set_has_financing_details() {
  _has_bits_[0] |= 0x00200000u;
}
inline void OrderCancelRequest::clear_has_financing_details() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void OrderCancelRequest::clear_financing_details() {
  if (financing_details_ != NULL) financing_details_->::Common::FinancingDetails::Clear();
  clear_has_financing_details();
}
inline const ::Common::FinancingDetails& OrderCancelRequest::financing_details() const {
  return financing_details_ != NULL ? *financing_details_ : *default_instance_->financing_details_;
}
inline ::Common::FinancingDetails* OrderCancelRequest::mutable_financing_details() {
  set_has_financing_details();
  if (financing_details_ == NULL) financing_details_ = new ::Common::FinancingDetails;
  return financing_details_;
}
inline ::Common::FinancingDetails* OrderCancelRequest::release_financing_details() {
  clear_has_financing_details();
  ::Common::FinancingDetails* temp = financing_details_;
  financing_details_ = NULL;
  return temp;
}
inline void OrderCancelRequest::set_allocated_financing_details(::Common::FinancingDetails* financing_details) {
  delete financing_details_;
  financing_details_ = financing_details;
  if (financing_details) {
    set_has_financing_details();
  } else {
    clear_has_financing_details();
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 23;
inline int OrderCancelRequest::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void OrderCancelRequest::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& OrderCancelRequest::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* OrderCancelRequest::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* OrderCancelRequest::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
OrderCancelRequest::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
OrderCancelRequest::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// -------------------------------------------------------------------

// CxlRejReasonUnion

// optional .SingleGeneralOrderHandling.CxlRejReasonEnum cxl_rej_reason = 1;
inline bool CxlRejReasonUnion::has_cxl_rej_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CxlRejReasonUnion::set_has_cxl_rej_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CxlRejReasonUnion::clear_has_cxl_rej_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CxlRejReasonUnion::clear_cxl_rej_reason() {
  cxl_rej_reason_ = 0;
  clear_has_cxl_rej_reason();
}
inline ::SingleGeneralOrderHandling::CxlRejReasonEnum CxlRejReasonUnion::cxl_rej_reason() const {
  return static_cast< ::SingleGeneralOrderHandling::CxlRejReasonEnum >(cxl_rej_reason_);
}
inline void CxlRejReasonUnion::set_cxl_rej_reason(::SingleGeneralOrderHandling::CxlRejReasonEnum value) {
  assert(::SingleGeneralOrderHandling::CxlRejReasonEnum_IsValid(value));
  set_has_cxl_rej_reason();
  cxl_rej_reason_ = value;
}

// optional sfixed64 cxl_rej_reason_sfixed64 = 2;
inline bool CxlRejReasonUnion::has_cxl_rej_reason_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CxlRejReasonUnion::set_has_cxl_rej_reason_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CxlRejReasonUnion::clear_has_cxl_rej_reason_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CxlRejReasonUnion::clear_cxl_rej_reason_sfixed64() {
  cxl_rej_reason_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_cxl_rej_reason_sfixed64();
}
inline ::google::protobuf::int64 CxlRejReasonUnion::cxl_rej_reason_sfixed64() const {
  return cxl_rej_reason_sfixed64_;
}
inline void CxlRejReasonUnion::set_cxl_rej_reason_sfixed64(::google::protobuf::int64 value) {
  set_has_cxl_rej_reason_sfixed64();
  cxl_rej_reason_sfixed64_ = value;
}

// -------------------------------------------------------------------

// OrderCancelReject

// optional string cl_ord_id = 1;
inline bool OrderCancelReject::has_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderCancelReject::set_has_cl_ord_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderCancelReject::clear_has_cl_ord_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderCancelReject::clear_cl_ord_id() {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_->clear();
  }
  clear_has_cl_ord_id();
}
inline const ::std::string& OrderCancelReject::cl_ord_id() const {
  return *cl_ord_id_;
}
inline void OrderCancelReject::set_cl_ord_id(const ::std::string& value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void OrderCancelReject::set_cl_ord_id(const char* value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void OrderCancelReject::set_cl_ord_id(const char* value, size_t size) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_cl_ord_id() {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  return cl_ord_id_;
}
inline ::std::string* OrderCancelReject::release_cl_ord_id() {
  clear_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_id_;
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_cl_ord_id(::std::string* cl_ord_id) {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_id_;
  }
  if (cl_ord_id) {
    set_has_cl_ord_id();
    cl_ord_id_ = cl_ord_id;
  } else {
    clear_has_cl_ord_id();
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.CxlRejReasonEnum cxl_rej_reason = 2;
inline bool OrderCancelReject::has_cxl_rej_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderCancelReject::set_has_cxl_rej_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderCancelReject::clear_has_cxl_rej_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderCancelReject::clear_cxl_rej_reason() {
  cxl_rej_reason_ = 0;
  clear_has_cxl_rej_reason();
}
inline ::SingleGeneralOrderHandling::CxlRejReasonEnum OrderCancelReject::cxl_rej_reason() const {
  return static_cast< ::SingleGeneralOrderHandling::CxlRejReasonEnum >(cxl_rej_reason_);
}
inline void OrderCancelReject::set_cxl_rej_reason(::SingleGeneralOrderHandling::CxlRejReasonEnum value) {
  assert(::SingleGeneralOrderHandling::CxlRejReasonEnum_IsValid(value));
  set_has_cxl_rej_reason();
  cxl_rej_reason_ = value;
}

// optional string list_id = 3;
inline bool OrderCancelReject::has_list_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderCancelReject::set_has_list_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderCancelReject::clear_has_list_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderCancelReject::clear_list_id() {
  if (list_id_ != &::google::protobuf::internal::kEmptyString) {
    list_id_->clear();
  }
  clear_has_list_id();
}
inline const ::std::string& OrderCancelReject::list_id() const {
  return *list_id_;
}
inline void OrderCancelReject::set_list_id(const ::std::string& value) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(value);
}
inline void OrderCancelReject::set_list_id(const char* value) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(value);
}
inline void OrderCancelReject::set_list_id(const char* value, size_t size) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_list_id() {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  return list_id_;
}
inline ::std::string* OrderCancelReject::release_list_id() {
  clear_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = list_id_;
    list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_list_id(::std::string* list_id) {
  if (list_id_ != &::google::protobuf::internal::kEmptyString) {
    delete list_id_;
  }
  if (list_id) {
    set_has_list_id();
    list_id_ = list_id;
  } else {
    clear_has_list_id();
    list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string order_id = 4;
inline bool OrderCancelReject::has_order_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderCancelReject::set_has_order_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderCancelReject::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderCancelReject::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& OrderCancelReject::order_id() const {
  return *order_id_;
}
inline void OrderCancelReject::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderCancelReject::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderCancelReject::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* OrderCancelReject::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Session.StandardHeader standard_header = 5;
inline bool OrderCancelReject::has_standard_header() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderCancelReject::set_has_standard_header() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderCancelReject::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderCancelReject::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& OrderCancelReject::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* OrderCancelReject::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* OrderCancelReject::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void OrderCancelReject::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 6;
inline bool OrderCancelReject::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderCancelReject::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderCancelReject::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderCancelReject::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& OrderCancelReject::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* OrderCancelReject::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* OrderCancelReject::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void OrderCancelReject::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional string text = 7;
inline bool OrderCancelReject::has_text() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderCancelReject::set_has_text() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderCancelReject::clear_has_text() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderCancelReject::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& OrderCancelReject::text() const {
  return *text_;
}
inline void OrderCancelReject::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void OrderCancelReject::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void OrderCancelReject::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* OrderCancelReject::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.OrdStatusEnum ord_status = 8;
inline bool OrderCancelReject::has_ord_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderCancelReject::set_has_ord_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderCancelReject::clear_has_ord_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderCancelReject::clear_ord_status() {
  ord_status_ = 0;
  clear_has_ord_status();
}
inline ::SingleGeneralOrderHandling::OrdStatusEnum OrderCancelReject::ord_status() const {
  return static_cast< ::SingleGeneralOrderHandling::OrdStatusEnum >(ord_status_);
}
inline void OrderCancelReject::set_ord_status(::SingleGeneralOrderHandling::OrdStatusEnum value) {
  assert(::SingleGeneralOrderHandling::OrdStatusEnum_IsValid(value));
  set_has_ord_status();
  ord_status_ = value;
}

// optional string orig_cl_ord_id = 9;
inline bool OrderCancelReject::has_orig_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OrderCancelReject::set_has_orig_cl_ord_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OrderCancelReject::clear_has_orig_cl_ord_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OrderCancelReject::clear_orig_cl_ord_id() {
  if (orig_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_->clear();
  }
  clear_has_orig_cl_ord_id();
}
inline const ::std::string& OrderCancelReject::orig_cl_ord_id() const {
  return *orig_cl_ord_id_;
}
inline void OrderCancelReject::set_orig_cl_ord_id(const ::std::string& value) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(value);
}
inline void OrderCancelReject::set_orig_cl_ord_id(const char* value) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(value);
}
inline void OrderCancelReject::set_orig_cl_ord_id(const char* value, size_t size) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_orig_cl_ord_id() {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  return orig_cl_ord_id_;
}
inline ::std::string* OrderCancelReject::release_orig_cl_ord_id() {
  clear_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orig_cl_ord_id_;
    orig_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_orig_cl_ord_id(::std::string* orig_cl_ord_id) {
  if (orig_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete orig_cl_ord_id_;
  }
  if (orig_cl_ord_id) {
    set_has_orig_cl_ord_id();
    orig_cl_ord_id_ = orig_cl_ord_id;
  } else {
    clear_has_orig_cl_ord_id();
    orig_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string secondary_order_id = 10;
inline bool OrderCancelReject::has_secondary_order_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderCancelReject::set_has_secondary_order_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderCancelReject::clear_has_secondary_order_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderCancelReject::clear_secondary_order_id() {
  if (secondary_order_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_->clear();
  }
  clear_has_secondary_order_id();
}
inline const ::std::string& OrderCancelReject::secondary_order_id() const {
  return *secondary_order_id_;
}
inline void OrderCancelReject::set_secondary_order_id(const ::std::string& value) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(value);
}
inline void OrderCancelReject::set_secondary_order_id(const char* value) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(value);
}
inline void OrderCancelReject::set_secondary_order_id(const char* value, size_t size) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_secondary_order_id() {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  return secondary_order_id_;
}
inline ::std::string* OrderCancelReject::release_secondary_order_id() {
  clear_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_order_id_;
    secondary_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_secondary_order_id(::std::string* secondary_order_id) {
  if (secondary_order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_order_id_;
  }
  if (secondary_order_id) {
    set_has_secondary_order_id();
    secondary_order_id_ = secondary_order_id;
  } else {
    clear_has_secondary_order_id();
    secondary_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string account = 11;
inline bool OrderCancelReject::has_account() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrderCancelReject::set_has_account() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrderCancelReject::clear_has_account() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrderCancelReject::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& OrderCancelReject::account() const {
  return *account_;
}
inline void OrderCancelReject::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void OrderCancelReject::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void OrderCancelReject::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* OrderCancelReject::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.CxlRejResponseToEnum cxl_rej_response_to = 12;
inline bool OrderCancelReject::has_cxl_rej_response_to() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrderCancelReject::set_has_cxl_rej_response_to() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrderCancelReject::clear_has_cxl_rej_response_to() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrderCancelReject::clear_cxl_rej_response_to() {
  cxl_rej_response_to_ = 0;
  clear_has_cxl_rej_response_to();
}
inline ::SingleGeneralOrderHandling::CxlRejResponseToEnum OrderCancelReject::cxl_rej_response_to() const {
  return static_cast< ::SingleGeneralOrderHandling::CxlRejResponseToEnum >(cxl_rej_response_to_);
}
inline void OrderCancelReject::set_cxl_rej_response_to(::SingleGeneralOrderHandling::CxlRejResponseToEnum value) {
  assert(::SingleGeneralOrderHandling::CxlRejResponseToEnum_IsValid(value));
  set_has_cxl_rej_response_to();
  cxl_rej_response_to_ = value;
}

// optional bytes encoded_text = 13;
inline bool OrderCancelReject::has_encoded_text() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrderCancelReject::set_has_encoded_text() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrderCancelReject::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrderCancelReject::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& OrderCancelReject::encoded_text() const {
  return *encoded_text_;
}
inline void OrderCancelReject::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void OrderCancelReject::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void OrderCancelReject::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* OrderCancelReject::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 14;
inline bool OrderCancelReject::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void OrderCancelReject::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00002000u;
}
inline void OrderCancelReject::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void OrderCancelReject::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 OrderCancelReject::encoded_text_len() const {
  return encoded_text_len_;
}
inline void OrderCancelReject::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional sfixed64 transact_time = 15;
inline bool OrderCancelReject::has_transact_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void OrderCancelReject::set_has_transact_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void OrderCancelReject::clear_has_transact_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void OrderCancelReject::clear_transact_time() {
  transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_transact_time();
}
inline ::google::protobuf::int64 OrderCancelReject::transact_time() const {
  return transact_time_;
}
inline void OrderCancelReject::set_transact_time(::google::protobuf::int64 value) {
  set_has_transact_time();
  transact_time_ = value;
}

// optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 16;
inline bool OrderCancelReject::has_account_type() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void OrderCancelReject::set_has_account_type() {
  _has_bits_[0] |= 0x00008000u;
}
inline void OrderCancelReject::clear_has_account_type() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void OrderCancelReject::clear_account_type() {
  account_type_ = 0;
  clear_has_account_type();
}
inline ::SingleGeneralOrderHandling::AccountTypeEnum OrderCancelReject::account_type() const {
  return static_cast< ::SingleGeneralOrderHandling::AccountTypeEnum >(account_type_);
}
inline void OrderCancelReject::set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value) {
  assert(::SingleGeneralOrderHandling::AccountTypeEnum_IsValid(value));
  set_has_account_type();
  account_type_ = value;
}

// optional string cl_ord_link_id = 17;
inline bool OrderCancelReject::has_cl_ord_link_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void OrderCancelReject::set_has_cl_ord_link_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void OrderCancelReject::clear_has_cl_ord_link_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void OrderCancelReject::clear_cl_ord_link_id() {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_->clear();
  }
  clear_has_cl_ord_link_id();
}
inline const ::std::string& OrderCancelReject::cl_ord_link_id() const {
  return *cl_ord_link_id_;
}
inline void OrderCancelReject::set_cl_ord_link_id(const ::std::string& value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void OrderCancelReject::set_cl_ord_link_id(const char* value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void OrderCancelReject::set_cl_ord_link_id(const char* value, size_t size) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_cl_ord_link_id() {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  return cl_ord_link_id_;
}
inline ::std::string* OrderCancelReject::release_cl_ord_link_id() {
  clear_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_link_id_;
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id) {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_link_id_;
  }
  if (cl_ord_link_id) {
    set_has_cl_ord_link_id();
    cl_ord_link_id_ = cl_ord_link_id;
  } else {
    clear_has_cl_ord_link_id();
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 orig_ord_mod_time = 18;
inline bool OrderCancelReject::has_orig_ord_mod_time() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void OrderCancelReject::set_has_orig_ord_mod_time() {
  _has_bits_[0] |= 0x00020000u;
}
inline void OrderCancelReject::clear_has_orig_ord_mod_time() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void OrderCancelReject::clear_orig_ord_mod_time() {
  orig_ord_mod_time_ = GOOGLE_LONGLONG(0);
  clear_has_orig_ord_mod_time();
}
inline ::google::protobuf::int64 OrderCancelReject::orig_ord_mod_time() const {
  return orig_ord_mod_time_;
}
inline void OrderCancelReject::set_orig_ord_mod_time(::google::protobuf::int64 value) {
  set_has_orig_ord_mod_time();
  orig_ord_mod_time_ = value;
}

// optional string secondary_cl_ord_id = 19;
inline bool OrderCancelReject::has_secondary_cl_ord_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void OrderCancelReject::set_has_secondary_cl_ord_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void OrderCancelReject::clear_has_secondary_cl_ord_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void OrderCancelReject::clear_secondary_cl_ord_id() {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_->clear();
  }
  clear_has_secondary_cl_ord_id();
}
inline const ::std::string& OrderCancelReject::secondary_cl_ord_id() const {
  return *secondary_cl_ord_id_;
}
inline void OrderCancelReject::set_secondary_cl_ord_id(const ::std::string& value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void OrderCancelReject::set_secondary_cl_ord_id(const char* value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void OrderCancelReject::set_secondary_cl_ord_id(const char* value, size_t size) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderCancelReject::mutable_secondary_cl_ord_id() {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  return secondary_cl_ord_id_;
}
inline ::std::string* OrderCancelReject::release_secondary_cl_ord_id() {
  clear_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_cl_ord_id_;
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderCancelReject::set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id) {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_cl_ord_id_;
  }
  if (secondary_cl_ord_id) {
    set_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = secondary_cl_ord_id;
  } else {
    clear_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 trade_origination_date = 20;
inline bool OrderCancelReject::has_trade_origination_date() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void OrderCancelReject::set_has_trade_origination_date() {
  _has_bits_[0] |= 0x00080000u;
}
inline void OrderCancelReject::clear_has_trade_origination_date() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void OrderCancelReject::clear_trade_origination_date() {
  trade_origination_date_ = 0;
  clear_has_trade_origination_date();
}
inline ::google::protobuf::int32 OrderCancelReject::trade_origination_date() const {
  return trade_origination_date_;
}
inline void OrderCancelReject::set_trade_origination_date(::google::protobuf::int32 value) {
  set_has_trade_origination_date();
  trade_origination_date_ = value;
}

// optional bool working_indicator = 21;
inline bool OrderCancelReject::has_working_indicator() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void OrderCancelReject::set_has_working_indicator() {
  _has_bits_[0] |= 0x00100000u;
}
inline void OrderCancelReject::clear_has_working_indicator() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void OrderCancelReject::clear_working_indicator() {
  working_indicator_ = false;
  clear_has_working_indicator();
}
inline bool OrderCancelReject::working_indicator() const {
  return working_indicator_;
}
inline void OrderCancelReject::set_working_indicator(bool value) {
  set_has_working_indicator();
  working_indicator_ = value;
}

// optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 22;
inline bool OrderCancelReject::has_acct_id_source() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void OrderCancelReject::set_has_acct_id_source() {
  _has_bits_[0] |= 0x00200000u;
}
inline void OrderCancelReject::clear_has_acct_id_source() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void OrderCancelReject::clear_acct_id_source() {
  acct_id_source_ = 0;
  clear_has_acct_id_source();
}
inline ::SingleGeneralOrderHandling::AcctIdSourceEnum OrderCancelReject::acct_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::AcctIdSourceEnum >(acct_id_source_);
}
inline void OrderCancelReject::set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::AcctIdSourceEnum_IsValid(value));
  set_has_acct_id_source();
  acct_id_source_ = value;
}

// optional sfixed32 trade_date = 23;
inline bool OrderCancelReject::has_trade_date() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void OrderCancelReject::set_has_trade_date() {
  _has_bits_[0] |= 0x00400000u;
}
inline void OrderCancelReject::clear_has_trade_date() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void OrderCancelReject::clear_trade_date() {
  trade_date_ = 0;
  clear_has_trade_date();
}
inline ::google::protobuf::int32 OrderCancelReject::trade_date() const {
  return trade_date_;
}
inline void OrderCancelReject::set_trade_date(::google::protobuf::int32 value) {
  set_has_trade_date();
  trade_date_ = value;
}

// -------------------------------------------------------------------

// FillsGrp

// optional string fill_exec_id = 1;
inline bool FillsGrp::has_fill_exec_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FillsGrp::set_has_fill_exec_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FillsGrp::clear_has_fill_exec_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FillsGrp::clear_fill_exec_id() {
  if (fill_exec_id_ != &::google::protobuf::internal::kEmptyString) {
    fill_exec_id_->clear();
  }
  clear_has_fill_exec_id();
}
inline const ::std::string& FillsGrp::fill_exec_id() const {
  return *fill_exec_id_;
}
inline void FillsGrp::set_fill_exec_id(const ::std::string& value) {
  set_has_fill_exec_id();
  if (fill_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    fill_exec_id_ = new ::std::string;
  }
  fill_exec_id_->assign(value);
}
inline void FillsGrp::set_fill_exec_id(const char* value) {
  set_has_fill_exec_id();
  if (fill_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    fill_exec_id_ = new ::std::string;
  }
  fill_exec_id_->assign(value);
}
inline void FillsGrp::set_fill_exec_id(const char* value, size_t size) {
  set_has_fill_exec_id();
  if (fill_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    fill_exec_id_ = new ::std::string;
  }
  fill_exec_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FillsGrp::mutable_fill_exec_id() {
  set_has_fill_exec_id();
  if (fill_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    fill_exec_id_ = new ::std::string;
  }
  return fill_exec_id_;
}
inline ::std::string* FillsGrp::release_fill_exec_id() {
  clear_has_fill_exec_id();
  if (fill_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fill_exec_id_;
    fill_exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FillsGrp::set_allocated_fill_exec_id(::std::string* fill_exec_id) {
  if (fill_exec_id_ != &::google::protobuf::internal::kEmptyString) {
    delete fill_exec_id_;
  }
  if (fill_exec_id) {
    set_has_fill_exec_id();
    fill_exec_id_ = fill_exec_id;
  } else {
    clear_has_fill_exec_id();
    fill_exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 fill_px = 2;
inline bool FillsGrp::has_fill_px() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FillsGrp::set_has_fill_px() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FillsGrp::clear_has_fill_px() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FillsGrp::clear_fill_px() {
  fill_px_ = GOOGLE_LONGLONG(0);
  clear_has_fill_px();
}
inline ::google::protobuf::int64 FillsGrp::fill_px() const {
  return fill_px_;
}
inline void FillsGrp::set_fill_px(::google::protobuf::int64 value) {
  set_has_fill_px();
  fill_px_ = value;
}

// optional sfixed32 fill_px_exponent = 3;
inline bool FillsGrp::has_fill_px_exponent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FillsGrp::set_has_fill_px_exponent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FillsGrp::clear_has_fill_px_exponent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FillsGrp::clear_fill_px_exponent() {
  fill_px_exponent_ = 0;
  clear_has_fill_px_exponent();
}
inline ::google::protobuf::int32 FillsGrp::fill_px_exponent() const {
  return fill_px_exponent_;
}
inline void FillsGrp::set_fill_px_exponent(::google::protobuf::int32 value) {
  set_has_fill_px_exponent();
  fill_px_exponent_ = value;
}

// optional sfixed64 fill_qty = 4;
inline bool FillsGrp::has_fill_qty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FillsGrp::set_has_fill_qty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FillsGrp::clear_has_fill_qty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FillsGrp::clear_fill_qty() {
  fill_qty_ = GOOGLE_LONGLONG(0);
  clear_has_fill_qty();
}
inline ::google::protobuf::int64 FillsGrp::fill_qty() const {
  return fill_qty_;
}
inline void FillsGrp::set_fill_qty(::google::protobuf::int64 value) {
  set_has_fill_qty();
  fill_qty_ = value;
}

// optional sfixed32 fill_qty_exponent = 5;
inline bool FillsGrp::has_fill_qty_exponent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FillsGrp::set_has_fill_qty_exponent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FillsGrp::clear_has_fill_qty_exponent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FillsGrp::clear_fill_qty_exponent() {
  fill_qty_exponent_ = 0;
  clear_has_fill_qty_exponent();
}
inline ::google::protobuf::int32 FillsGrp::fill_qty_exponent() const {
  return fill_qty_exponent_;
}
inline void FillsGrp::set_fill_qty_exponent(::google::protobuf::int32 value) {
  set_has_fill_qty_exponent();
  fill_qty_exponent_ = value;
}

// repeated .Common.NestedParties4 nested_parties4 = 6;
inline int FillsGrp::nested_parties4_size() const {
  return nested_parties4_.size();
}
inline void FillsGrp::clear_nested_parties4() {
  nested_parties4_.Clear();
}
inline const ::Common::NestedParties4& FillsGrp::nested_parties4(int index) const {
  return nested_parties4_.Get(index);
}
inline ::Common::NestedParties4* FillsGrp::mutable_nested_parties4(int index) {
  return nested_parties4_.Mutable(index);
}
inline ::Common::NestedParties4* FillsGrp::add_nested_parties4() {
  return nested_parties4_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedParties4 >&
FillsGrp::nested_parties4() const {
  return nested_parties4_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NestedParties4 >*
FillsGrp::mutable_nested_parties4() {
  return &nested_parties4_;
}

// optional sfixed64 fill_liquidity_ind = 7;
inline bool FillsGrp::has_fill_liquidity_ind() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FillsGrp::set_has_fill_liquidity_ind() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FillsGrp::clear_has_fill_liquidity_ind() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FillsGrp::clear_fill_liquidity_ind() {
  fill_liquidity_ind_ = GOOGLE_LONGLONG(0);
  clear_has_fill_liquidity_ind();
}
inline ::google::protobuf::int64 FillsGrp::fill_liquidity_ind() const {
  return fill_liquidity_ind_;
}
inline void FillsGrp::set_fill_liquidity_ind(::google::protobuf::int64 value) {
  set_has_fill_liquidity_ind();
  fill_liquidity_ind_ = value;
}

// -------------------------------------------------------------------

// OrdRejReasonUnion

// optional .SingleGeneralOrderHandling.OrdRejReasonEnum ord_rej_reason = 1;
inline bool OrdRejReasonUnion::has_ord_rej_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrdRejReasonUnion::set_has_ord_rej_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrdRejReasonUnion::clear_has_ord_rej_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrdRejReasonUnion::clear_ord_rej_reason() {
  ord_rej_reason_ = 0;
  clear_has_ord_rej_reason();
}
inline ::SingleGeneralOrderHandling::OrdRejReasonEnum OrdRejReasonUnion::ord_rej_reason() const {
  return static_cast< ::SingleGeneralOrderHandling::OrdRejReasonEnum >(ord_rej_reason_);
}
inline void OrdRejReasonUnion::set_ord_rej_reason(::SingleGeneralOrderHandling::OrdRejReasonEnum value) {
  assert(::SingleGeneralOrderHandling::OrdRejReasonEnum_IsValid(value));
  set_has_ord_rej_reason();
  ord_rej_reason_ = value;
}

// optional sfixed64 ord_rej_reason_sfixed64 = 2;
inline bool OrdRejReasonUnion::has_ord_rej_reason_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrdRejReasonUnion::set_has_ord_rej_reason_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrdRejReasonUnion::clear_has_ord_rej_reason_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrdRejReasonUnion::clear_ord_rej_reason_sfixed64() {
  ord_rej_reason_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_ord_rej_reason_sfixed64();
}
inline ::google::protobuf::int64 OrdRejReasonUnion::ord_rej_reason_sfixed64() const {
  return ord_rej_reason_sfixed64_;
}
inline void OrdRejReasonUnion::set_ord_rej_reason_sfixed64(::google::protobuf::int64 value) {
  set_has_ord_rej_reason_sfixed64();
  ord_rej_reason_sfixed64_ = value;
}

// -------------------------------------------------------------------

// ExecRestatementReasonUnion

// optional .SingleGeneralOrderHandling.ExecRestatementReasonEnum exec_restatement_reason = 1;
inline bool ExecRestatementReasonUnion::has_exec_restatement_reason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecRestatementReasonUnion::set_has_exec_restatement_reason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecRestatementReasonUnion::clear_has_exec_restatement_reason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecRestatementReasonUnion::clear_exec_restatement_reason() {
  exec_restatement_reason_ = 0;
  clear_has_exec_restatement_reason();
}
inline ::SingleGeneralOrderHandling::ExecRestatementReasonEnum ExecRestatementReasonUnion::exec_restatement_reason() const {
  return static_cast< ::SingleGeneralOrderHandling::ExecRestatementReasonEnum >(exec_restatement_reason_);
}
inline void ExecRestatementReasonUnion::set_exec_restatement_reason(::SingleGeneralOrderHandling::ExecRestatementReasonEnum value) {
  assert(::SingleGeneralOrderHandling::ExecRestatementReasonEnum_IsValid(value));
  set_has_exec_restatement_reason();
  exec_restatement_reason_ = value;
}

// optional sfixed64 exec_restatement_reason_sfixed64 = 2;
inline bool ExecRestatementReasonUnion::has_exec_restatement_reason_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecRestatementReasonUnion::set_has_exec_restatement_reason_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecRestatementReasonUnion::clear_has_exec_restatement_reason_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecRestatementReasonUnion::clear_exec_restatement_reason_sfixed64() {
  exec_restatement_reason_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_exec_restatement_reason_sfixed64();
}
inline ::google::protobuf::int64 ExecRestatementReasonUnion::exec_restatement_reason_sfixed64() const {
  return exec_restatement_reason_sfixed64_;
}
inline void ExecRestatementReasonUnion::set_exec_restatement_reason_sfixed64(::google::protobuf::int64 value) {
  set_has_exec_restatement_reason_sfixed64();
  exec_restatement_reason_sfixed64_ = value;
}

// -------------------------------------------------------------------

// ExecutionReport

// optional string account = 1;
inline bool ExecutionReport::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutionReport::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutionReport::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutionReport::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ExecutionReport::account() const {
  return *account_;
}
inline void ExecutionReport::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ExecutionReport::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ExecutionReport::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ExecutionReport::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 avg_px = 2;
inline bool ExecutionReport::has_avg_px() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutionReport::set_has_avg_px() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutionReport::clear_has_avg_px() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutionReport::clear_avg_px() {
  avg_px_ = GOOGLE_LONGLONG(0);
  clear_has_avg_px();
}
inline ::google::protobuf::int64 ExecutionReport::avg_px() const {
  return avg_px_;
}
inline void ExecutionReport::set_avg_px(::google::protobuf::int64 value) {
  set_has_avg_px();
  avg_px_ = value;
}

// optional string cl_ord_id = 3;
inline bool ExecutionReport::has_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutionReport::set_has_cl_ord_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutionReport::clear_has_cl_ord_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutionReport::clear_cl_ord_id() {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_->clear();
  }
  clear_has_cl_ord_id();
}
inline const ::std::string& ExecutionReport::cl_ord_id() const {
  return *cl_ord_id_;
}
inline void ExecutionReport::set_cl_ord_id(const ::std::string& value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void ExecutionReport::set_cl_ord_id(const char* value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void ExecutionReport::set_cl_ord_id(const char* value, size_t size) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_cl_ord_id() {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  return cl_ord_id_;
}
inline ::std::string* ExecutionReport::release_cl_ord_id() {
  clear_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_id_;
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_cl_ord_id(::std::string* cl_ord_id) {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_id_;
  }
  if (cl_ord_id) {
    set_has_cl_ord_id();
    cl_ord_id_ = cl_ord_id;
  } else {
    clear_has_cl_ord_id();
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 cum_qty = 4;
inline bool ExecutionReport::has_cum_qty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutionReport::set_has_cum_qty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutionReport::clear_has_cum_qty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutionReport::clear_cum_qty() {
  cum_qty_ = GOOGLE_LONGLONG(0);
  clear_has_cum_qty();
}
inline ::google::protobuf::int64 ExecutionReport::cum_qty() const {
  return cum_qty_;
}
inline void ExecutionReport::set_cum_qty(::google::protobuf::int64 value) {
  set_has_cum_qty();
  cum_qty_ = value;
}

// optional sfixed32 cum_qty_exponent = 5;
inline bool ExecutionReport::has_cum_qty_exponent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutionReport::set_has_cum_qty_exponent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutionReport::clear_has_cum_qty_exponent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutionReport::clear_cum_qty_exponent() {
  cum_qty_exponent_ = 0;
  clear_has_cum_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::cum_qty_exponent() const {
  return cum_qty_exponent_;
}
inline void ExecutionReport::set_cum_qty_exponent(::google::protobuf::int32 value) {
  set_has_cum_qty_exponent();
  cum_qty_exponent_ = value;
}

// optional string currency = 6;
inline bool ExecutionReport::has_currency() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecutionReport::set_has_currency() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecutionReport::clear_has_currency() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecutionReport::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& ExecutionReport::currency() const {
  return *currency_;
}
inline void ExecutionReport::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void ExecutionReport::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void ExecutionReport::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* ExecutionReport::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string exec_id = 7;
inline bool ExecutionReport::has_exec_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutionReport::set_has_exec_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutionReport::clear_has_exec_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutionReport::clear_exec_id() {
  if (exec_id_ != &::google::protobuf::internal::kEmptyString) {
    exec_id_->clear();
  }
  clear_has_exec_id();
}
inline const ::std::string& ExecutionReport::exec_id() const {
  return *exec_id_;
}
inline void ExecutionReport::set_exec_id(const ::std::string& value) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(value);
}
inline void ExecutionReport::set_exec_id(const char* value) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(value);
}
inline void ExecutionReport::set_exec_id(const char* value, size_t size) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_exec_id() {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  return exec_id_;
}
inline ::std::string* ExecutionReport::release_exec_id() {
  clear_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exec_id_;
    exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_exec_id(::std::string* exec_id) {
  if (exec_id_ != &::google::protobuf::internal::kEmptyString) {
    delete exec_id_;
  }
  if (exec_id) {
    set_has_exec_id();
    exec_id_ = exec_id;
  } else {
    clear_has_exec_id();
    exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .SingleGeneralOrderHandling.ExecInstEnum exec_inst = 8 [packed = true];
inline int ExecutionReport::exec_inst_size() const {
  return exec_inst_.size();
}
inline void ExecutionReport::clear_exec_inst() {
  exec_inst_.Clear();
}
inline ::SingleGeneralOrderHandling::ExecInstEnum ExecutionReport::exec_inst(int index) const {
  return static_cast< ::SingleGeneralOrderHandling::ExecInstEnum >(exec_inst_.Get(index));
}
inline void ExecutionReport::set_exec_inst(int index, ::SingleGeneralOrderHandling::ExecInstEnum value) {
  assert(::SingleGeneralOrderHandling::ExecInstEnum_IsValid(value));
  exec_inst_.Set(index, value);
}
inline void ExecutionReport::add_exec_inst(::SingleGeneralOrderHandling::ExecInstEnum value) {
  assert(::SingleGeneralOrderHandling::ExecInstEnum_IsValid(value));
  exec_inst_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ExecutionReport::exec_inst() const {
  return exec_inst_;
}
inline ::google::protobuf::RepeatedField<int>*
ExecutionReport::mutable_exec_inst() {
  return &exec_inst_;
}

// optional string exec_ref_id = 9;
inline bool ExecutionReport::has_exec_ref_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExecutionReport::set_has_exec_ref_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExecutionReport::clear_has_exec_ref_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExecutionReport::clear_exec_ref_id() {
  if (exec_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    exec_ref_id_->clear();
  }
  clear_has_exec_ref_id();
}
inline const ::std::string& ExecutionReport::exec_ref_id() const {
  return *exec_ref_id_;
}
inline void ExecutionReport::set_exec_ref_id(const ::std::string& value) {
  set_has_exec_ref_id();
  if (exec_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_ref_id_ = new ::std::string;
  }
  exec_ref_id_->assign(value);
}
inline void ExecutionReport::set_exec_ref_id(const char* value) {
  set_has_exec_ref_id();
  if (exec_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_ref_id_ = new ::std::string;
  }
  exec_ref_id_->assign(value);
}
inline void ExecutionReport::set_exec_ref_id(const char* value, size_t size) {
  set_has_exec_ref_id();
  if (exec_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_ref_id_ = new ::std::string;
  }
  exec_ref_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_exec_ref_id() {
  set_has_exec_ref_id();
  if (exec_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_ref_id_ = new ::std::string;
  }
  return exec_ref_id_;
}
inline ::std::string* ExecutionReport::release_exec_ref_id() {
  clear_has_exec_ref_id();
  if (exec_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exec_ref_id_;
    exec_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_exec_ref_id(::std::string* exec_ref_id) {
  if (exec_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    delete exec_ref_id_;
  }
  if (exec_ref_id) {
    set_has_exec_ref_id();
    exec_ref_id_ = exec_ref_id;
  } else {
    clear_has_exec_ref_id();
    exec_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.LastCapacityEnum last_capacity = 10;
inline bool ExecutionReport::has_last_capacity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ExecutionReport::set_has_last_capacity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ExecutionReport::clear_has_last_capacity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ExecutionReport::clear_last_capacity() {
  last_capacity_ = 0;
  clear_has_last_capacity();
}
inline ::SingleGeneralOrderHandling::LastCapacityEnum ExecutionReport::last_capacity() const {
  return static_cast< ::SingleGeneralOrderHandling::LastCapacityEnum >(last_capacity_);
}
inline void ExecutionReport::set_last_capacity(::SingleGeneralOrderHandling::LastCapacityEnum value) {
  assert(::SingleGeneralOrderHandling::LastCapacityEnum_IsValid(value));
  set_has_last_capacity();
  last_capacity_ = value;
}

// optional string last_mkt = 11;
inline bool ExecutionReport::has_last_mkt() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExecutionReport::set_has_last_mkt() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExecutionReport::clear_has_last_mkt() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExecutionReport::clear_last_mkt() {
  if (last_mkt_ != &::google::protobuf::internal::kEmptyString) {
    last_mkt_->clear();
  }
  clear_has_last_mkt();
}
inline const ::std::string& ExecutionReport::last_mkt() const {
  return *last_mkt_;
}
inline void ExecutionReport::set_last_mkt(const ::std::string& value) {
  set_has_last_mkt();
  if (last_mkt_ == &::google::protobuf::internal::kEmptyString) {
    last_mkt_ = new ::std::string;
  }
  last_mkt_->assign(value);
}
inline void ExecutionReport::set_last_mkt(const char* value) {
  set_has_last_mkt();
  if (last_mkt_ == &::google::protobuf::internal::kEmptyString) {
    last_mkt_ = new ::std::string;
  }
  last_mkt_->assign(value);
}
inline void ExecutionReport::set_last_mkt(const char* value, size_t size) {
  set_has_last_mkt();
  if (last_mkt_ == &::google::protobuf::internal::kEmptyString) {
    last_mkt_ = new ::std::string;
  }
  last_mkt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_last_mkt() {
  set_has_last_mkt();
  if (last_mkt_ == &::google::protobuf::internal::kEmptyString) {
    last_mkt_ = new ::std::string;
  }
  return last_mkt_;
}
inline ::std::string* ExecutionReport::release_last_mkt() {
  clear_has_last_mkt();
  if (last_mkt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = last_mkt_;
    last_mkt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_last_mkt(::std::string* last_mkt) {
  if (last_mkt_ != &::google::protobuf::internal::kEmptyString) {
    delete last_mkt_;
  }
  if (last_mkt) {
    set_has_last_mkt();
    last_mkt_ = last_mkt;
  } else {
    clear_has_last_mkt();
    last_mkt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double last_px = 12;
inline bool ExecutionReport::has_last_px() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExecutionReport::set_has_last_px() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExecutionReport::clear_has_last_px() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExecutionReport::clear_last_px() {
  last_px_ = 0;
  clear_has_last_px();
}
inline double ExecutionReport::last_px() const {
  return last_px_;
}
inline void ExecutionReport::set_last_px(double value) {
  set_has_last_px();
  last_px_ = value;
}

// optional sfixed64 last_qty = 13;
inline bool ExecutionReport::has_last_qty() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ExecutionReport::set_has_last_qty() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ExecutionReport::clear_has_last_qty() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ExecutionReport::clear_last_qty() {
  last_qty_ = GOOGLE_LONGLONG(0);
  clear_has_last_qty();
}
inline ::google::protobuf::int64 ExecutionReport::last_qty() const {
  return last_qty_;
}
inline void ExecutionReport::set_last_qty(::google::protobuf::int64 value) {
  set_has_last_qty();
  last_qty_ = value;
}

// optional sfixed32 last_qty_exponent = 14;
inline bool ExecutionReport::has_last_qty_exponent() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ExecutionReport::set_has_last_qty_exponent() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ExecutionReport::clear_has_last_qty_exponent() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ExecutionReport::clear_last_qty_exponent() {
  last_qty_exponent_ = 0;
  clear_has_last_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::last_qty_exponent() const {
  return last_qty_exponent_;
}
inline void ExecutionReport::set_last_qty_exponent(::google::protobuf::int32 value) {
  set_has_last_qty_exponent();
  last_qty_exponent_ = value;
}

// optional string list_id = 15;
inline bool ExecutionReport::has_list_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ExecutionReport::set_has_list_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ExecutionReport::clear_has_list_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ExecutionReport::clear_list_id() {
  if (list_id_ != &::google::protobuf::internal::kEmptyString) {
    list_id_->clear();
  }
  clear_has_list_id();
}
inline const ::std::string& ExecutionReport::list_id() const {
  return *list_id_;
}
inline void ExecutionReport::set_list_id(const ::std::string& value) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(value);
}
inline void ExecutionReport::set_list_id(const char* value) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(value);
}
inline void ExecutionReport::set_list_id(const char* value, size_t size) {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  list_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_list_id() {
  set_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    list_id_ = new ::std::string;
  }
  return list_id_;
}
inline ::std::string* ExecutionReport::release_list_id() {
  clear_has_list_id();
  if (list_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = list_id_;
    list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_list_id(::std::string* list_id) {
  if (list_id_ != &::google::protobuf::internal::kEmptyString) {
    delete list_id_;
  }
  if (list_id) {
    set_has_list_id();
    list_id_ = list_id;
  } else {
    clear_has_list_id();
    list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.OrdRejReasonEnum ord_rej_reason = 16;
inline bool ExecutionReport::has_ord_rej_reason() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ExecutionReport::set_has_ord_rej_reason() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ExecutionReport::clear_has_ord_rej_reason() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ExecutionReport::clear_ord_rej_reason() {
  ord_rej_reason_ = 0;
  clear_has_ord_rej_reason();
}
inline ::SingleGeneralOrderHandling::OrdRejReasonEnum ExecutionReport::ord_rej_reason() const {
  return static_cast< ::SingleGeneralOrderHandling::OrdRejReasonEnum >(ord_rej_reason_);
}
inline void ExecutionReport::set_ord_rej_reason(::SingleGeneralOrderHandling::OrdRejReasonEnum value) {
  assert(::SingleGeneralOrderHandling::OrdRejReasonEnum_IsValid(value));
  set_has_ord_rej_reason();
  ord_rej_reason_ = value;
}

// optional .SingleGeneralOrderHandling.OrdStatusEnum ord_status = 17;
inline bool ExecutionReport::has_ord_status() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ExecutionReport::set_has_ord_status() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ExecutionReport::clear_has_ord_status() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ExecutionReport::clear_ord_status() {
  ord_status_ = 0;
  clear_has_ord_status();
}
inline ::SingleGeneralOrderHandling::OrdStatusEnum ExecutionReport::ord_status() const {
  return static_cast< ::SingleGeneralOrderHandling::OrdStatusEnum >(ord_status_);
}
inline void ExecutionReport::set_ord_status(::SingleGeneralOrderHandling::OrdStatusEnum value) {
  assert(::SingleGeneralOrderHandling::OrdStatusEnum_IsValid(value));
  set_has_ord_status();
  ord_status_ = value;
}

// optional .SingleGeneralOrderHandling.OrdTypeEnum ord_type = 18;
inline bool ExecutionReport::has_ord_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ExecutionReport::set_has_ord_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ExecutionReport::clear_has_ord_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ExecutionReport::clear_ord_type() {
  ord_type_ = 0;
  clear_has_ord_type();
}
inline ::SingleGeneralOrderHandling::OrdTypeEnum ExecutionReport::ord_type() const {
  return static_cast< ::SingleGeneralOrderHandling::OrdTypeEnum >(ord_type_);
}
inline void ExecutionReport::set_ord_type(::SingleGeneralOrderHandling::OrdTypeEnum value) {
  assert(::SingleGeneralOrderHandling::OrdTypeEnum_IsValid(value));
  set_has_ord_type();
  ord_type_ = value;
}

// optional string order_id = 19;
inline bool ExecutionReport::has_order_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ExecutionReport::set_has_order_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ExecutionReport::clear_has_order_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ExecutionReport::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& ExecutionReport::order_id() const {
  return *order_id_;
}
inline void ExecutionReport::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ExecutionReport::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ExecutionReport::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* ExecutionReport::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 price = 20;
inline bool ExecutionReport::has_price() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ExecutionReport::set_has_price() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ExecutionReport::clear_has_price() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ExecutionReport::clear_price() {
  price_ = GOOGLE_LONGLONG(0);
  clear_has_price();
}
inline ::google::protobuf::int64 ExecutionReport::price() const {
  return price_;
}
inline void ExecutionReport::set_price(::google::protobuf::int64 value) {
  set_has_price();
  price_ = value;
}

// optional sfixed32 price_exponent = 21;
inline bool ExecutionReport::has_price_exponent() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ExecutionReport::set_has_price_exponent() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ExecutionReport::clear_has_price_exponent() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ExecutionReport::clear_price_exponent() {
  price_exponent_ = 0;
  clear_has_price_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::price_exponent() const {
  return price_exponent_;
}
inline void ExecutionReport::set_price_exponent(::google::protobuf::int32 value) {
  set_has_price_exponent();
  price_exponent_ = value;
}

// optional sfixed32 settl_date = 22;
inline bool ExecutionReport::has_settl_date() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ExecutionReport::set_has_settl_date() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ExecutionReport::clear_has_settl_date() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ExecutionReport::clear_settl_date() {
  settl_date_ = 0;
  clear_has_settl_date();
}
inline ::google::protobuf::int32 ExecutionReport::settl_date() const {
  return settl_date_;
}
inline void ExecutionReport::set_settl_date(::google::protobuf::int32 value) {
  set_has_settl_date();
  settl_date_ = value;
}

// optional .SingleGeneralOrderHandling.SettlTypeEnum settl_type = 23;
inline bool ExecutionReport::has_settl_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ExecutionReport::set_has_settl_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ExecutionReport::clear_has_settl_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ExecutionReport::clear_settl_type() {
  settl_type_ = 0;
  clear_has_settl_type();
}
inline ::SingleGeneralOrderHandling::SettlTypeEnum ExecutionReport::settl_type() const {
  return static_cast< ::SingleGeneralOrderHandling::SettlTypeEnum >(settl_type_);
}
inline void ExecutionReport::set_settl_type(::SingleGeneralOrderHandling::SettlTypeEnum value) {
  assert(::SingleGeneralOrderHandling::SettlTypeEnum_IsValid(value));
  set_has_settl_type();
  settl_type_ = value;
}

// optional .SingleGeneralOrderHandling.SideEnum side = 24;
inline bool ExecutionReport::has_side() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ExecutionReport::set_has_side() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ExecutionReport::clear_has_side() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ExecutionReport::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::SingleGeneralOrderHandling::SideEnum ExecutionReport::side() const {
  return static_cast< ::SingleGeneralOrderHandling::SideEnum >(side_);
}
inline void ExecutionReport::set_side(::SingleGeneralOrderHandling::SideEnum value) {
  assert(::SingleGeneralOrderHandling::SideEnum_IsValid(value));
  set_has_side();
  side_ = value;
}

// optional .Session.StandardHeader standard_header = 25;
inline bool ExecutionReport::has_standard_header() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ExecutionReport::set_has_standard_header() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ExecutionReport::clear_has_standard_header() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ExecutionReport::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& ExecutionReport::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* ExecutionReport::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* ExecutionReport::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 26;
inline bool ExecutionReport::has_standard_trailer() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ExecutionReport::set_has_standard_trailer() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ExecutionReport::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ExecutionReport::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& ExecutionReport::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* ExecutionReport::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* ExecutionReport::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional sfixed64 stop_px = 27;
inline bool ExecutionReport::has_stop_px() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ExecutionReport::set_has_stop_px() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ExecutionReport::clear_has_stop_px() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ExecutionReport::clear_stop_px() {
  stop_px_ = GOOGLE_LONGLONG(0);
  clear_has_stop_px();
}
inline ::google::protobuf::int64 ExecutionReport::stop_px() const {
  return stop_px_;
}
inline void ExecutionReport::set_stop_px(::google::protobuf::int64 value) {
  set_has_stop_px();
  stop_px_ = value;
}

// optional sfixed32 stop_px_exponent = 28;
inline bool ExecutionReport::has_stop_px_exponent() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ExecutionReport::set_has_stop_px_exponent() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ExecutionReport::clear_has_stop_px_exponent() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ExecutionReport::clear_stop_px_exponent() {
  stop_px_exponent_ = 0;
  clear_has_stop_px_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::stop_px_exponent() const {
  return stop_px_exponent_;
}
inline void ExecutionReport::set_stop_px_exponent(::google::protobuf::int32 value) {
  set_has_stop_px_exponent();
  stop_px_exponent_ = value;
}

// optional string text = 29;
inline bool ExecutionReport::has_text() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ExecutionReport::set_has_text() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ExecutionReport::clear_has_text() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ExecutionReport::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ExecutionReport::text() const {
  return *text_;
}
inline void ExecutionReport::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ExecutionReport::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ExecutionReport::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ExecutionReport::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.TimeInForceEnum time_in_force = 30;
inline bool ExecutionReport::has_time_in_force() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ExecutionReport::set_has_time_in_force() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ExecutionReport::clear_has_time_in_force() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ExecutionReport::clear_time_in_force() {
  time_in_force_ = 0;
  clear_has_time_in_force();
}
inline ::SingleGeneralOrderHandling::TimeInForceEnum ExecutionReport::time_in_force() const {
  return static_cast< ::SingleGeneralOrderHandling::TimeInForceEnum >(time_in_force_);
}
inline void ExecutionReport::set_time_in_force(::SingleGeneralOrderHandling::TimeInForceEnum value) {
  assert(::SingleGeneralOrderHandling::TimeInForceEnum_IsValid(value));
  set_has_time_in_force();
  time_in_force_ = value;
}

// optional sfixed32 trade_date = 31;
inline bool ExecutionReport::has_trade_date() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ExecutionReport::set_has_trade_date() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ExecutionReport::clear_has_trade_date() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ExecutionReport::clear_trade_date() {
  trade_date_ = 0;
  clear_has_trade_date();
}
inline ::google::protobuf::int32 ExecutionReport::trade_date() const {
  return trade_date_;
}
inline void ExecutionReport::set_trade_date(::google::protobuf::int32 value) {
  set_has_trade_date();
  trade_date_ = value;
}

// optional sfixed64 transact_time = 32;
inline bool ExecutionReport::has_transact_time() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ExecutionReport::set_has_transact_time() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ExecutionReport::clear_has_transact_time() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ExecutionReport::clear_transact_time() {
  transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_transact_time();
}
inline ::google::protobuf::int64 ExecutionReport::transact_time() const {
  return transact_time_;
}
inline void ExecutionReport::set_transact_time(::google::protobuf::int64 value) {
  set_has_transact_time();
  transact_time_ = value;
}

// optional bool report_to_exch = 33;
inline bool ExecutionReport::has_report_to_exch() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ExecutionReport::set_has_report_to_exch() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ExecutionReport::clear_has_report_to_exch() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ExecutionReport::clear_report_to_exch() {
  report_to_exch_ = false;
  clear_has_report_to_exch();
}
inline bool ExecutionReport::report_to_exch() const {
  return report_to_exch_;
}
inline void ExecutionReport::set_report_to_exch(bool value) {
  set_has_report_to_exch();
  report_to_exch_ = value;
}

// optional sfixed64 expire_time = 34;
inline bool ExecutionReport::has_expire_time() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ExecutionReport::set_has_expire_time() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ExecutionReport::clear_has_expire_time() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ExecutionReport::clear_expire_time() {
  expire_time_ = GOOGLE_LONGLONG(0);
  clear_has_expire_time();
}
inline ::google::protobuf::int64 ExecutionReport::expire_time() const {
  return expire_time_;
}
inline void ExecutionReport::set_expire_time(::google::protobuf::int64 value) {
  set_has_expire_time();
  expire_time_ = value;
}

// optional sfixed64 net_money = 35;
inline bool ExecutionReport::has_net_money() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ExecutionReport::set_has_net_money() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ExecutionReport::clear_has_net_money() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ExecutionReport::clear_net_money() {
  net_money_ = GOOGLE_LONGLONG(0);
  clear_has_net_money();
}
inline ::google::protobuf::int64 ExecutionReport::net_money() const {
  return net_money_;
}
inline void ExecutionReport::set_net_money(::google::protobuf::int64 value) {
  set_has_net_money();
  net_money_ = value;
}

// optional sfixed32 net_money_exponent = 36;
inline bool ExecutionReport::has_net_money_exponent() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ExecutionReport::set_has_net_money_exponent() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ExecutionReport::clear_has_net_money_exponent() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ExecutionReport::clear_net_money_exponent() {
  net_money_exponent_ = 0;
  clear_has_net_money_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::net_money_exponent() const {
  return net_money_exponent_;
}
inline void ExecutionReport::set_net_money_exponent(::google::protobuf::int32 value) {
  set_has_net_money_exponent();
  net_money_exponent_ = value;
}

// optional sfixed64 settl_curr_amt = 37;
inline bool ExecutionReport::has_settl_curr_amt() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ExecutionReport::set_has_settl_curr_amt() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ExecutionReport::clear_has_settl_curr_amt() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ExecutionReport::clear_settl_curr_amt() {
  settl_curr_amt_ = GOOGLE_LONGLONG(0);
  clear_has_settl_curr_amt();
}
inline ::google::protobuf::int64 ExecutionReport::settl_curr_amt() const {
  return settl_curr_amt_;
}
inline void ExecutionReport::set_settl_curr_amt(::google::protobuf::int64 value) {
  set_has_settl_curr_amt();
  settl_curr_amt_ = value;
}

// optional sfixed32 settl_curr_amt_exponent = 38;
inline bool ExecutionReport::has_settl_curr_amt_exponent() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ExecutionReport::set_has_settl_curr_amt_exponent() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ExecutionReport::clear_has_settl_curr_amt_exponent() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ExecutionReport::clear_settl_curr_amt_exponent() {
  settl_curr_amt_exponent_ = 0;
  clear_has_settl_curr_amt_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::settl_curr_amt_exponent() const {
  return settl_curr_amt_exponent_;
}
inline void ExecutionReport::set_settl_curr_amt_exponent(::google::protobuf::int32 value) {
  set_has_settl_curr_amt_exponent();
  settl_curr_amt_exponent_ = value;
}

// optional string settl_currency = 39;
inline bool ExecutionReport::has_settl_currency() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ExecutionReport::set_has_settl_currency() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ExecutionReport::clear_has_settl_currency() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ExecutionReport::clear_settl_currency() {
  if (settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    settl_currency_->clear();
  }
  clear_has_settl_currency();
}
inline const ::std::string& ExecutionReport::settl_currency() const {
  return *settl_currency_;
}
inline void ExecutionReport::set_settl_currency(const ::std::string& value) {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  settl_currency_->assign(value);
}
inline void ExecutionReport::set_settl_currency(const char* value) {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  settl_currency_->assign(value);
}
inline void ExecutionReport::set_settl_currency(const char* value, size_t size) {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  settl_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_settl_currency() {
  set_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    settl_currency_ = new ::std::string;
  }
  return settl_currency_;
}
inline ::std::string* ExecutionReport::release_settl_currency() {
  clear_has_settl_currency();
  if (settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = settl_currency_;
    settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_settl_currency(::std::string* settl_currency) {
  if (settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete settl_currency_;
  }
  if (settl_currency) {
    set_has_settl_currency();
    settl_currency_ = settl_currency;
  } else {
    clear_has_settl_currency();
    settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.ExecTypeEnum exec_type = 40;
inline bool ExecutionReport::has_exec_type() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void ExecutionReport::set_has_exec_type() {
  _has_bits_[1] |= 0x00000080u;
}
inline void ExecutionReport::clear_has_exec_type() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void ExecutionReport::clear_exec_type() {
  exec_type_ = 0;
  clear_has_exec_type();
}
inline ::SingleGeneralOrderHandling::ExecTypeEnum ExecutionReport::exec_type() const {
  return static_cast< ::SingleGeneralOrderHandling::ExecTypeEnum >(exec_type_);
}
inline void ExecutionReport::set_exec_type(::SingleGeneralOrderHandling::ExecTypeEnum value) {
  assert(::SingleGeneralOrderHandling::ExecTypeEnum_IsValid(value));
  set_has_exec_type();
  exec_type_ = value;
}

// optional sfixed64 last_forward_points = 41;
inline bool ExecutionReport::has_last_forward_points() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void ExecutionReport::set_has_last_forward_points() {
  _has_bits_[1] |= 0x00000100u;
}
inline void ExecutionReport::clear_has_last_forward_points() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void ExecutionReport::clear_last_forward_points() {
  last_forward_points_ = GOOGLE_LONGLONG(0);
  clear_has_last_forward_points();
}
inline ::google::protobuf::int64 ExecutionReport::last_forward_points() const {
  return last_forward_points_;
}
inline void ExecutionReport::set_last_forward_points(::google::protobuf::int64 value) {
  set_has_last_forward_points();
  last_forward_points_ = value;
}

// optional sfixed32 last_forward_points_exponent = 42;
inline bool ExecutionReport::has_last_forward_points_exponent() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void ExecutionReport::set_has_last_forward_points_exponent() {
  _has_bits_[1] |= 0x00000200u;
}
inline void ExecutionReport::clear_has_last_forward_points_exponent() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void ExecutionReport::clear_last_forward_points_exponent() {
  last_forward_points_exponent_ = 0;
  clear_has_last_forward_points_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::last_forward_points_exponent() const {
  return last_forward_points_exponent_;
}
inline void ExecutionReport::set_last_forward_points_exponent(::google::protobuf::int32 value) {
  set_has_last_forward_points_exponent();
  last_forward_points_exponent_ = value;
}

// optional sfixed64 last_spot_rate = 43;
inline bool ExecutionReport::has_last_spot_rate() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void ExecutionReport::set_has_last_spot_rate() {
  _has_bits_[1] |= 0x00000400u;
}
inline void ExecutionReport::clear_has_last_spot_rate() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void ExecutionReport::clear_last_spot_rate() {
  last_spot_rate_ = GOOGLE_LONGLONG(0);
  clear_has_last_spot_rate();
}
inline ::google::protobuf::int64 ExecutionReport::last_spot_rate() const {
  return last_spot_rate_;
}
inline void ExecutionReport::set_last_spot_rate(::google::protobuf::int64 value) {
  set_has_last_spot_rate();
  last_spot_rate_ = value;
}

// optional sfixed32 last_spot_rate_exponent = 44;
inline bool ExecutionReport::has_last_spot_rate_exponent() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void ExecutionReport::set_has_last_spot_rate_exponent() {
  _has_bits_[1] |= 0x00000800u;
}
inline void ExecutionReport::clear_has_last_spot_rate_exponent() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void ExecutionReport::clear_last_spot_rate_exponent() {
  last_spot_rate_exponent_ = 0;
  clear_has_last_spot_rate_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::last_spot_rate_exponent() const {
  return last_spot_rate_exponent_;
}
inline void ExecutionReport::set_last_spot_rate_exponent(::google::protobuf::int32 value) {
  set_has_last_spot_rate_exponent();
  last_spot_rate_exponent_ = value;
}

// optional sfixed64 leaves_qty = 45;
inline bool ExecutionReport::has_leaves_qty() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void ExecutionReport::set_has_leaves_qty() {
  _has_bits_[1] |= 0x00001000u;
}
inline void ExecutionReport::clear_has_leaves_qty() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void ExecutionReport::clear_leaves_qty() {
  leaves_qty_ = GOOGLE_LONGLONG(0);
  clear_has_leaves_qty();
}
inline ::google::protobuf::int64 ExecutionReport::leaves_qty() const {
  return leaves_qty_;
}
inline void ExecutionReport::set_leaves_qty(::google::protobuf::int64 value) {
  set_has_leaves_qty();
  leaves_qty_ = value;
}

// optional sfixed32 leaves_qty_exponent = 46;
inline bool ExecutionReport::has_leaves_qty_exponent() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void ExecutionReport::set_has_leaves_qty_exponent() {
  _has_bits_[1] |= 0x00002000u;
}
inline void ExecutionReport::clear_has_leaves_qty_exponent() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void ExecutionReport::clear_leaves_qty_exponent() {
  leaves_qty_exponent_ = 0;
  clear_has_leaves_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::leaves_qty_exponent() const {
  return leaves_qty_exponent_;
}
inline void ExecutionReport::set_leaves_qty_exponent(::google::protobuf::int32 value) {
  set_has_leaves_qty_exponent();
  leaves_qty_exponent_ = value;
}

// optional string orig_cl_ord_id = 47;
inline bool ExecutionReport::has_orig_cl_ord_id() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void ExecutionReport::set_has_orig_cl_ord_id() {
  _has_bits_[1] |= 0x00004000u;
}
inline void ExecutionReport::clear_has_orig_cl_ord_id() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void ExecutionReport::clear_orig_cl_ord_id() {
  if (orig_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_->clear();
  }
  clear_has_orig_cl_ord_id();
}
inline const ::std::string& ExecutionReport::orig_cl_ord_id() const {
  return *orig_cl_ord_id_;
}
inline void ExecutionReport::set_orig_cl_ord_id(const ::std::string& value) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(value);
}
inline void ExecutionReport::set_orig_cl_ord_id(const char* value) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(value);
}
inline void ExecutionReport::set_orig_cl_ord_id(const char* value, size_t size) {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  orig_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_orig_cl_ord_id() {
  set_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cl_ord_id_ = new ::std::string;
  }
  return orig_cl_ord_id_;
}
inline ::std::string* ExecutionReport::release_orig_cl_ord_id() {
  clear_has_orig_cl_ord_id();
  if (orig_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orig_cl_ord_id_;
    orig_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_orig_cl_ord_id(::std::string* orig_cl_ord_id) {
  if (orig_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete orig_cl_ord_id_;
  }
  if (orig_cl_ord_id) {
    set_has_orig_cl_ord_id();
    orig_cl_ord_id_ = orig_cl_ord_id;
  } else {
    clear_has_orig_cl_ord_id();
    orig_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string secondary_order_id = 48;
inline bool ExecutionReport::has_secondary_order_id() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void ExecutionReport::set_has_secondary_order_id() {
  _has_bits_[1] |= 0x00008000u;
}
inline void ExecutionReport::clear_has_secondary_order_id() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void ExecutionReport::clear_secondary_order_id() {
  if (secondary_order_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_->clear();
  }
  clear_has_secondary_order_id();
}
inline const ::std::string& ExecutionReport::secondary_order_id() const {
  return *secondary_order_id_;
}
inline void ExecutionReport::set_secondary_order_id(const ::std::string& value) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(value);
}
inline void ExecutionReport::set_secondary_order_id(const char* value) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(value);
}
inline void ExecutionReport::set_secondary_order_id(const char* value, size_t size) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_secondary_order_id() {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  return secondary_order_id_;
}
inline ::std::string* ExecutionReport::release_secondary_order_id() {
  clear_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_order_id_;
    secondary_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_secondary_order_id(::std::string* secondary_order_id) {
  if (secondary_order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_order_id_;
  }
  if (secondary_order_id) {
    set_has_secondary_order_id();
    secondary_order_id_ = secondary_order_id;
  } else {
    clear_has_secondary_order_id();
    secondary_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double settl_curr_fx_rate = 49;
inline bool ExecutionReport::has_settl_curr_fx_rate() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void ExecutionReport::set_has_settl_curr_fx_rate() {
  _has_bits_[1] |= 0x00010000u;
}
inline void ExecutionReport::clear_has_settl_curr_fx_rate() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void ExecutionReport::clear_settl_curr_fx_rate() {
  settl_curr_fx_rate_ = 0;
  clear_has_settl_curr_fx_rate();
}
inline double ExecutionReport::settl_curr_fx_rate() const {
  return settl_curr_fx_rate_;
}
inline void ExecutionReport::set_settl_curr_fx_rate(double value) {
  set_has_settl_curr_fx_rate();
  settl_curr_fx_rate_ = value;
}

// optional .SingleGeneralOrderHandling.SettlCurrFxRateCalcEnum settl_curr_fx_rate_calc = 50;
inline bool ExecutionReport::has_settl_curr_fx_rate_calc() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void ExecutionReport::set_has_settl_curr_fx_rate_calc() {
  _has_bits_[1] |= 0x00020000u;
}
inline void ExecutionReport::clear_has_settl_curr_fx_rate_calc() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void ExecutionReport::clear_settl_curr_fx_rate_calc() {
  settl_curr_fx_rate_calc_ = 0;
  clear_has_settl_curr_fx_rate_calc();
}
inline ::SingleGeneralOrderHandling::SettlCurrFxRateCalcEnum ExecutionReport::settl_curr_fx_rate_calc() const {
  return static_cast< ::SingleGeneralOrderHandling::SettlCurrFxRateCalcEnum >(settl_curr_fx_rate_calc_);
}
inline void ExecutionReport::set_settl_curr_fx_rate_calc(::SingleGeneralOrderHandling::SettlCurrFxRateCalcEnum value) {
  assert(::SingleGeneralOrderHandling::SettlCurrFxRateCalcEnum_IsValid(value));
  set_has_settl_curr_fx_rate_calc();
  settl_curr_fx_rate_calc_ = value;
}

// optional string compliance_id = 51;
inline bool ExecutionReport::has_compliance_id() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void ExecutionReport::set_has_compliance_id() {
  _has_bits_[1] |= 0x00040000u;
}
inline void ExecutionReport::clear_has_compliance_id() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void ExecutionReport::clear_compliance_id() {
  if (compliance_id_ != &::google::protobuf::internal::kEmptyString) {
    compliance_id_->clear();
  }
  clear_has_compliance_id();
}
inline const ::std::string& ExecutionReport::compliance_id() const {
  return *compliance_id_;
}
inline void ExecutionReport::set_compliance_id(const ::std::string& value) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(value);
}
inline void ExecutionReport::set_compliance_id(const char* value) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(value);
}
inline void ExecutionReport::set_compliance_id(const char* value, size_t size) {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  compliance_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_compliance_id() {
  set_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    compliance_id_ = new ::std::string;
  }
  return compliance_id_;
}
inline ::std::string* ExecutionReport::release_compliance_id() {
  clear_has_compliance_id();
  if (compliance_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = compliance_id_;
    compliance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_compliance_id(::std::string* compliance_id) {
  if (compliance_id_ != &::google::protobuf::internal::kEmptyString) {
    delete compliance_id_;
  }
  if (compliance_id) {
    set_has_compliance_id();
    compliance_id_ = compliance_id;
  } else {
    clear_has_compliance_id();
    compliance_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 day_avg_px = 52;
inline bool ExecutionReport::has_day_avg_px() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void ExecutionReport::set_has_day_avg_px() {
  _has_bits_[1] |= 0x00080000u;
}
inline void ExecutionReport::clear_has_day_avg_px() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void ExecutionReport::clear_day_avg_px() {
  day_avg_px_ = GOOGLE_LONGLONG(0);
  clear_has_day_avg_px();
}
inline ::google::protobuf::int64 ExecutionReport::day_avg_px() const {
  return day_avg_px_;
}
inline void ExecutionReport::set_day_avg_px(::google::protobuf::int64 value) {
  set_has_day_avg_px();
  day_avg_px_ = value;
}

// optional sfixed32 day_avg_px_exponent = 53;
inline bool ExecutionReport::has_day_avg_px_exponent() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void ExecutionReport::set_has_day_avg_px_exponent() {
  _has_bits_[1] |= 0x00100000u;
}
inline void ExecutionReport::clear_has_day_avg_px_exponent() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void ExecutionReport::clear_day_avg_px_exponent() {
  day_avg_px_exponent_ = 0;
  clear_has_day_avg_px_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::day_avg_px_exponent() const {
  return day_avg_px_exponent_;
}
inline void ExecutionReport::set_day_avg_px_exponent(::google::protobuf::int32 value) {
  set_has_day_avg_px_exponent();
  day_avg_px_exponent_ = value;
}

// optional sfixed64 day_cum_qty = 54;
inline bool ExecutionReport::has_day_cum_qty() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void ExecutionReport::set_has_day_cum_qty() {
  _has_bits_[1] |= 0x00200000u;
}
inline void ExecutionReport::clear_has_day_cum_qty() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void ExecutionReport::clear_day_cum_qty() {
  day_cum_qty_ = GOOGLE_LONGLONG(0);
  clear_has_day_cum_qty();
}
inline ::google::protobuf::int64 ExecutionReport::day_cum_qty() const {
  return day_cum_qty_;
}
inline void ExecutionReport::set_day_cum_qty(::google::protobuf::int64 value) {
  set_has_day_cum_qty();
  day_cum_qty_ = value;
}

// optional sfixed32 day_cum_qty_exponent = 55;
inline bool ExecutionReport::has_day_cum_qty_exponent() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void ExecutionReport::set_has_day_cum_qty_exponent() {
  _has_bits_[1] |= 0x00400000u;
}
inline void ExecutionReport::clear_has_day_cum_qty_exponent() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void ExecutionReport::clear_day_cum_qty_exponent() {
  day_cum_qty_exponent_ = 0;
  clear_has_day_cum_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::day_cum_qty_exponent() const {
  return day_cum_qty_exponent_;
}
inline void ExecutionReport::set_day_cum_qty_exponent(::google::protobuf::int32 value) {
  set_has_day_cum_qty_exponent();
  day_cum_qty_exponent_ = value;
}

// optional sfixed64 day_order_qty = 56;
inline bool ExecutionReport::has_day_order_qty() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void ExecutionReport::set_has_day_order_qty() {
  _has_bits_[1] |= 0x00800000u;
}
inline void ExecutionReport::clear_has_day_order_qty() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void ExecutionReport::clear_day_order_qty() {
  day_order_qty_ = GOOGLE_LONGLONG(0);
  clear_has_day_order_qty();
}
inline ::google::protobuf::int64 ExecutionReport::day_order_qty() const {
  return day_order_qty_;
}
inline void ExecutionReport::set_day_order_qty(::google::protobuf::int64 value) {
  set_has_day_order_qty();
  day_order_qty_ = value;
}

// optional sfixed32 day_order_qty_exponent = 57;
inline bool ExecutionReport::has_day_order_qty_exponent() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void ExecutionReport::set_has_day_order_qty_exponent() {
  _has_bits_[1] |= 0x01000000u;
}
inline void ExecutionReport::clear_has_day_order_qty_exponent() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void ExecutionReport::clear_day_order_qty_exponent() {
  day_order_qty_exponent_ = 0;
  clear_has_day_order_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::day_order_qty_exponent() const {
  return day_order_qty_exponent_;
}
inline void ExecutionReport::set_day_order_qty_exponent(::google::protobuf::int32 value) {
  set_has_day_order_qty_exponent();
  day_order_qty_exponent_ = value;
}

// optional sfixed64 effective_time = 58;
inline bool ExecutionReport::has_effective_time() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void ExecutionReport::set_has_effective_time() {
  _has_bits_[1] |= 0x02000000u;
}
inline void ExecutionReport::clear_has_effective_time() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void ExecutionReport::clear_effective_time() {
  effective_time_ = GOOGLE_LONGLONG(0);
  clear_has_effective_time();
}
inline ::google::protobuf::int64 ExecutionReport::effective_time() const {
  return effective_time_;
}
inline void ExecutionReport::set_effective_time(::google::protobuf::int64 value) {
  set_has_effective_time();
  effective_time_ = value;
}

// optional bytes encoded_text = 59;
inline bool ExecutionReport::has_encoded_text() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void ExecutionReport::set_has_encoded_text() {
  _has_bits_[1] |= 0x04000000u;
}
inline void ExecutionReport::clear_has_encoded_text() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void ExecutionReport::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& ExecutionReport::encoded_text() const {
  return *encoded_text_;
}
inline void ExecutionReport::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void ExecutionReport::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void ExecutionReport::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* ExecutionReport::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 60;
inline bool ExecutionReport::has_encoded_text_len() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void ExecutionReport::set_has_encoded_text_len() {
  _has_bits_[1] |= 0x08000000u;
}
inline void ExecutionReport::clear_has_encoded_text_len() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void ExecutionReport::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 ExecutionReport::encoded_text_len() const {
  return encoded_text_len_;
}
inline void ExecutionReport::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional .SingleGeneralOrderHandling.ExecRestatementReasonEnum exec_restatement_reason = 61;
inline bool ExecutionReport::has_exec_restatement_reason() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void ExecutionReport::set_has_exec_restatement_reason() {
  _has_bits_[1] |= 0x10000000u;
}
inline void ExecutionReport::clear_has_exec_restatement_reason() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void ExecutionReport::clear_exec_restatement_reason() {
  exec_restatement_reason_ = 0;
  clear_has_exec_restatement_reason();
}
inline ::SingleGeneralOrderHandling::ExecRestatementReasonEnum ExecutionReport::exec_restatement_reason() const {
  return static_cast< ::SingleGeneralOrderHandling::ExecRestatementReasonEnum >(exec_restatement_reason_);
}
inline void ExecutionReport::set_exec_restatement_reason(::SingleGeneralOrderHandling::ExecRestatementReasonEnum value) {
  assert(::SingleGeneralOrderHandling::ExecRestatementReasonEnum_IsValid(value));
  set_has_exec_restatement_reason();
  exec_restatement_reason_ = value;
}

// optional sfixed32 expire_date = 62;
inline bool ExecutionReport::has_expire_date() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void ExecutionReport::set_has_expire_date() {
  _has_bits_[1] |= 0x20000000u;
}
inline void ExecutionReport::clear_has_expire_date() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void ExecutionReport::clear_expire_date() {
  expire_date_ = 0;
  clear_has_expire_date();
}
inline ::google::protobuf::int32 ExecutionReport::expire_date() const {
  return expire_date_;
}
inline void ExecutionReport::set_expire_date(::google::protobuf::int32 value) {
  set_has_expire_date();
  expire_date_ = value;
}

// optional .SingleGeneralOrderHandling.GtBookingInstEnum gt_booking_inst = 63;
inline bool ExecutionReport::has_gt_booking_inst() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void ExecutionReport::set_has_gt_booking_inst() {
  _has_bits_[1] |= 0x40000000u;
}
inline void ExecutionReport::clear_has_gt_booking_inst() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void ExecutionReport::clear_gt_booking_inst() {
  gt_booking_inst_ = 0;
  clear_has_gt_booking_inst();
}
inline ::SingleGeneralOrderHandling::GtBookingInstEnum ExecutionReport::gt_booking_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::GtBookingInstEnum >(gt_booking_inst_);
}
inline void ExecutionReport::set_gt_booking_inst(::SingleGeneralOrderHandling::GtBookingInstEnum value) {
  assert(::SingleGeneralOrderHandling::GtBookingInstEnum_IsValid(value));
  set_has_gt_booking_inst();
  gt_booking_inst_ = value;
}

// optional sfixed64 gross_trade_amt = 64;
inline bool ExecutionReport::has_gross_trade_amt() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void ExecutionReport::set_has_gross_trade_amt() {
  _has_bits_[1] |= 0x80000000u;
}
inline void ExecutionReport::clear_has_gross_trade_amt() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void ExecutionReport::clear_gross_trade_amt() {
  gross_trade_amt_ = GOOGLE_LONGLONG(0);
  clear_has_gross_trade_amt();
}
inline ::google::protobuf::int64 ExecutionReport::gross_trade_amt() const {
  return gross_trade_amt_;
}
inline void ExecutionReport::set_gross_trade_amt(::google::protobuf::int64 value) {
  set_has_gross_trade_amt();
  gross_trade_amt_ = value;
}

// optional sfixed32 gross_trade_amt_exponent = 65;
inline bool ExecutionReport::has_gross_trade_amt_exponent() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void ExecutionReport::set_has_gross_trade_amt_exponent() {
  _has_bits_[2] |= 0x00000001u;
}
inline void ExecutionReport::clear_has_gross_trade_amt_exponent() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void ExecutionReport::clear_gross_trade_amt_exponent() {
  gross_trade_amt_exponent_ = 0;
  clear_has_gross_trade_amt_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::gross_trade_amt_exponent() const {
  return gross_trade_amt_exponent_;
}
inline void ExecutionReport::set_gross_trade_amt_exponent(::google::protobuf::int32 value) {
  set_has_gross_trade_amt_exponent();
  gross_trade_amt_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.HandlInstEnum handl_inst = 66;
inline bool ExecutionReport::has_handl_inst() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void ExecutionReport::set_has_handl_inst() {
  _has_bits_[2] |= 0x00000002u;
}
inline void ExecutionReport::clear_has_handl_inst() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void ExecutionReport::clear_handl_inst() {
  handl_inst_ = 0;
  clear_has_handl_inst();
}
inline ::SingleGeneralOrderHandling::HandlInstEnum ExecutionReport::handl_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::HandlInstEnum >(handl_inst_);
}
inline void ExecutionReport::set_handl_inst(::SingleGeneralOrderHandling::HandlInstEnum value) {
  assert(::SingleGeneralOrderHandling::HandlInstEnum_IsValid(value));
  set_has_handl_inst();
  handl_inst_ = value;
}

// optional sfixed64 max_floor = 67;
inline bool ExecutionReport::has_max_floor() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void ExecutionReport::set_has_max_floor() {
  _has_bits_[2] |= 0x00000004u;
}
inline void ExecutionReport::clear_has_max_floor() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void ExecutionReport::clear_max_floor() {
  max_floor_ = GOOGLE_LONGLONG(0);
  clear_has_max_floor();
}
inline ::google::protobuf::int64 ExecutionReport::max_floor() const {
  return max_floor_;
}
inline void ExecutionReport::set_max_floor(::google::protobuf::int64 value) {
  set_has_max_floor();
  max_floor_ = value;
}

// optional sfixed32 max_floor_exponent = 68;
inline bool ExecutionReport::has_max_floor_exponent() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void ExecutionReport::set_has_max_floor_exponent() {
  _has_bits_[2] |= 0x00000008u;
}
inline void ExecutionReport::clear_has_max_floor_exponent() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void ExecutionReport::clear_max_floor_exponent() {
  max_floor_exponent_ = 0;
  clear_has_max_floor_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::max_floor_exponent() const {
  return max_floor_exponent_;
}
inline void ExecutionReport::set_max_floor_exponent(::google::protobuf::int32 value) {
  set_has_max_floor_exponent();
  max_floor_exponent_ = value;
}

// optional sfixed64 max_show = 69;
inline bool ExecutionReport::has_max_show() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void ExecutionReport::set_has_max_show() {
  _has_bits_[2] |= 0x00000010u;
}
inline void ExecutionReport::clear_has_max_show() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void ExecutionReport::clear_max_show() {
  max_show_ = GOOGLE_LONGLONG(0);
  clear_has_max_show();
}
inline ::google::protobuf::int64 ExecutionReport::max_show() const {
  return max_show_;
}
inline void ExecutionReport::set_max_show(::google::protobuf::int64 value) {
  set_has_max_show();
  max_show_ = value;
}

// optional sfixed32 max_show_exponent = 70;
inline bool ExecutionReport::has_max_show_exponent() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void ExecutionReport::set_has_max_show_exponent() {
  _has_bits_[2] |= 0x00000020u;
}
inline void ExecutionReport::clear_has_max_show_exponent() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void ExecutionReport::clear_max_show_exponent() {
  max_show_exponent_ = 0;
  clear_has_max_show_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::max_show_exponent() const {
  return max_show_exponent_;
}
inline void ExecutionReport::set_max_show_exponent(::google::protobuf::int32 value) {
  set_has_max_show_exponent();
  max_show_exponent_ = value;
}

// optional sfixed64 min_qty = 71;
inline bool ExecutionReport::has_min_qty() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void ExecutionReport::set_has_min_qty() {
  _has_bits_[2] |= 0x00000040u;
}
inline void ExecutionReport::clear_has_min_qty() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void ExecutionReport::clear_min_qty() {
  min_qty_ = GOOGLE_LONGLONG(0);
  clear_has_min_qty();
}
inline ::google::protobuf::int64 ExecutionReport::min_qty() const {
  return min_qty_;
}
inline void ExecutionReport::set_min_qty(::google::protobuf::int64 value) {
  set_has_min_qty();
  min_qty_ = value;
}

// optional sfixed32 min_qty_exponent = 72;
inline bool ExecutionReport::has_min_qty_exponent() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void ExecutionReport::set_has_min_qty_exponent() {
  _has_bits_[2] |= 0x00000080u;
}
inline void ExecutionReport::clear_has_min_qty_exponent() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void ExecutionReport::clear_min_qty_exponent() {
  min_qty_exponent_ = 0;
  clear_has_min_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::min_qty_exponent() const {
  return min_qty_exponent_;
}
inline void ExecutionReport::set_min_qty_exponent(::google::protobuf::int32 value) {
  set_has_min_qty_exponent();
  min_qty_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.MultiLegReportingTypeEnum multi_leg_reporting_type = 73;
inline bool ExecutionReport::has_multi_leg_reporting_type() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void ExecutionReport::set_has_multi_leg_reporting_type() {
  _has_bits_[2] |= 0x00000100u;
}
inline void ExecutionReport::clear_has_multi_leg_reporting_type() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void ExecutionReport::clear_multi_leg_reporting_type() {
  multi_leg_reporting_type_ = 0;
  clear_has_multi_leg_reporting_type();
}
inline ::SingleGeneralOrderHandling::MultiLegReportingTypeEnum ExecutionReport::multi_leg_reporting_type() const {
  return static_cast< ::SingleGeneralOrderHandling::MultiLegReportingTypeEnum >(multi_leg_reporting_type_);
}
inline void ExecutionReport::set_multi_leg_reporting_type(::SingleGeneralOrderHandling::MultiLegReportingTypeEnum value) {
  assert(::SingleGeneralOrderHandling::MultiLegReportingTypeEnum_IsValid(value));
  set_has_multi_leg_reporting_type();
  multi_leg_reporting_type_ = value;
}

// optional sfixed64 order_qty2 = 74;
inline bool ExecutionReport::has_order_qty2() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void ExecutionReport::set_has_order_qty2() {
  _has_bits_[2] |= 0x00000200u;
}
inline void ExecutionReport::clear_has_order_qty2() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void ExecutionReport::clear_order_qty2() {
  order_qty2_ = GOOGLE_LONGLONG(0);
  clear_has_order_qty2();
}
inline ::google::protobuf::int64 ExecutionReport::order_qty2() const {
  return order_qty2_;
}
inline void ExecutionReport::set_order_qty2(::google::protobuf::int64 value) {
  set_has_order_qty2();
  order_qty2_ = value;
}

// optional sfixed32 order_qty2_exponent = 75;
inline bool ExecutionReport::has_order_qty2_exponent() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void ExecutionReport::set_has_order_qty2_exponent() {
  _has_bits_[2] |= 0x00000400u;
}
inline void ExecutionReport::clear_has_order_qty2_exponent() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void ExecutionReport::clear_order_qty2_exponent() {
  order_qty2_exponent_ = 0;
  clear_has_order_qty2_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::order_qty2_exponent() const {
  return order_qty2_exponent_;
}
inline void ExecutionReport::set_order_qty2_exponent(::google::protobuf::int32 value) {
  set_has_order_qty2_exponent();
  order_qty2_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.PositionEffectEnum position_effect = 76;
inline bool ExecutionReport::has_position_effect() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void ExecutionReport::set_has_position_effect() {
  _has_bits_[2] |= 0x00000800u;
}
inline void ExecutionReport::clear_has_position_effect() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void ExecutionReport::clear_position_effect() {
  position_effect_ = 0;
  clear_has_position_effect();
}
inline ::SingleGeneralOrderHandling::PositionEffectEnum ExecutionReport::position_effect() const {
  return static_cast< ::SingleGeneralOrderHandling::PositionEffectEnum >(position_effect_);
}
inline void ExecutionReport::set_position_effect(::SingleGeneralOrderHandling::PositionEffectEnum value) {
  assert(::SingleGeneralOrderHandling::PositionEffectEnum_IsValid(value));
  set_has_position_effect();
  position_effect_ = value;
}

// optional sfixed32 settl_date2 = 77;
inline bool ExecutionReport::has_settl_date2() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void ExecutionReport::set_has_settl_date2() {
  _has_bits_[2] |= 0x00001000u;
}
inline void ExecutionReport::clear_has_settl_date2() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void ExecutionReport::clear_settl_date2() {
  settl_date2_ = 0;
  clear_has_settl_date2();
}
inline ::google::protobuf::int32 ExecutionReport::settl_date2() const {
  return settl_date2_;
}
inline void ExecutionReport::set_settl_date2(::google::protobuf::int32 value) {
  set_has_settl_date2();
  settl_date2_ = value;
}

// optional bool solicited_flag = 78;
inline bool ExecutionReport::has_solicited_flag() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void ExecutionReport::set_has_solicited_flag() {
  _has_bits_[2] |= 0x00002000u;
}
inline void ExecutionReport::clear_has_solicited_flag() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void ExecutionReport::clear_solicited_flag() {
  solicited_flag_ = false;
  clear_has_solicited_flag();
}
inline bool ExecutionReport::solicited_flag() const {
  return solicited_flag_;
}
inline void ExecutionReport::set_solicited_flag(bool value) {
  set_has_solicited_flag();
  solicited_flag_ = value;
}

// optional .SingleGeneralOrderHandling.TradingSessionIdEnum trading_session_id = 79;
inline bool ExecutionReport::has_trading_session_id() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void ExecutionReport::set_has_trading_session_id() {
  _has_bits_[2] |= 0x00004000u;
}
inline void ExecutionReport::clear_has_trading_session_id() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void ExecutionReport::clear_trading_session_id() {
  trading_session_id_ = 0;
  clear_has_trading_session_id();
}
inline ::SingleGeneralOrderHandling::TradingSessionIdEnum ExecutionReport::trading_session_id() const {
  return static_cast< ::SingleGeneralOrderHandling::TradingSessionIdEnum >(trading_session_id_);
}
inline void ExecutionReport::set_trading_session_id(::SingleGeneralOrderHandling::TradingSessionIdEnum value) {
  assert(::SingleGeneralOrderHandling::TradingSessionIdEnum_IsValid(value));
  set_has_trading_session_id();
  trading_session_id_ = value;
}

// optional .SingleGeneralOrderHandling.AccountTypeEnum account_type = 80;
inline bool ExecutionReport::has_account_type() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void ExecutionReport::set_has_account_type() {
  _has_bits_[2] |= 0x00008000u;
}
inline void ExecutionReport::clear_has_account_type() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void ExecutionReport::clear_account_type() {
  account_type_ = 0;
  clear_has_account_type();
}
inline ::SingleGeneralOrderHandling::AccountTypeEnum ExecutionReport::account_type() const {
  return static_cast< ::SingleGeneralOrderHandling::AccountTypeEnum >(account_type_);
}
inline void ExecutionReport::set_account_type(::SingleGeneralOrderHandling::AccountTypeEnum value) {
  assert(::SingleGeneralOrderHandling::AccountTypeEnum_IsValid(value));
  set_has_account_type();
  account_type_ = value;
}

// optional sfixed64 accrued_interest_amt = 81;
inline bool ExecutionReport::has_accrued_interest_amt() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void ExecutionReport::set_has_accrued_interest_amt() {
  _has_bits_[2] |= 0x00010000u;
}
inline void ExecutionReport::clear_has_accrued_interest_amt() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void ExecutionReport::clear_accrued_interest_amt() {
  accrued_interest_amt_ = GOOGLE_LONGLONG(0);
  clear_has_accrued_interest_amt();
}
inline ::google::protobuf::int64 ExecutionReport::accrued_interest_amt() const {
  return accrued_interest_amt_;
}
inline void ExecutionReport::set_accrued_interest_amt(::google::protobuf::int64 value) {
  set_has_accrued_interest_amt();
  accrued_interest_amt_ = value;
}

// optional sfixed32 accrued_interest_amt_exponent = 82;
inline bool ExecutionReport::has_accrued_interest_amt_exponent() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void ExecutionReport::set_has_accrued_interest_amt_exponent() {
  _has_bits_[2] |= 0x00020000u;
}
inline void ExecutionReport::clear_has_accrued_interest_amt_exponent() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void ExecutionReport::clear_accrued_interest_amt_exponent() {
  accrued_interest_amt_exponent_ = 0;
  clear_has_accrued_interest_amt_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::accrued_interest_amt_exponent() const {
  return accrued_interest_amt_exponent_;
}
inline void ExecutionReport::set_accrued_interest_amt_exponent(::google::protobuf::int32 value) {
  set_has_accrued_interest_amt_exponent();
  accrued_interest_amt_exponent_ = value;
}

// optional sfixed64 accrued_interest_rate = 83;
inline bool ExecutionReport::has_accrued_interest_rate() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void ExecutionReport::set_has_accrued_interest_rate() {
  _has_bits_[2] |= 0x00040000u;
}
inline void ExecutionReport::clear_has_accrued_interest_rate() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void ExecutionReport::clear_accrued_interest_rate() {
  accrued_interest_rate_ = GOOGLE_LONGLONG(0);
  clear_has_accrued_interest_rate();
}
inline ::google::protobuf::int64 ExecutionReport::accrued_interest_rate() const {
  return accrued_interest_rate_;
}
inline void ExecutionReport::set_accrued_interest_rate(::google::protobuf::int64 value) {
  set_has_accrued_interest_rate();
  accrued_interest_rate_ = value;
}

// optional sfixed32 accrued_interest_rate_exponent = 84;
inline bool ExecutionReport::has_accrued_interest_rate_exponent() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void ExecutionReport::set_has_accrued_interest_rate_exponent() {
  _has_bits_[2] |= 0x00080000u;
}
inline void ExecutionReport::clear_has_accrued_interest_rate_exponent() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void ExecutionReport::clear_accrued_interest_rate_exponent() {
  accrued_interest_rate_exponent_ = 0;
  clear_has_accrued_interest_rate_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::accrued_interest_rate_exponent() const {
  return accrued_interest_rate_exponent_;
}
inline void ExecutionReport::set_accrued_interest_rate_exponent(::google::protobuf::int32 value) {
  set_has_accrued_interest_rate_exponent();
  accrued_interest_rate_exponent_ = value;
}

// optional sfixed32 basis_feature_date = 85;
inline bool ExecutionReport::has_basis_feature_date() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void ExecutionReport::set_has_basis_feature_date() {
  _has_bits_[2] |= 0x00100000u;
}
inline void ExecutionReport::clear_has_basis_feature_date() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void ExecutionReport::clear_basis_feature_date() {
  basis_feature_date_ = 0;
  clear_has_basis_feature_date();
}
inline ::google::protobuf::int32 ExecutionReport::basis_feature_date() const {
  return basis_feature_date_;
}
inline void ExecutionReport::set_basis_feature_date(::google::protobuf::int32 value) {
  set_has_basis_feature_date();
  basis_feature_date_ = value;
}

// optional sfixed64 basis_feature_price = 86;
inline bool ExecutionReport::has_basis_feature_price() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void ExecutionReport::set_has_basis_feature_price() {
  _has_bits_[2] |= 0x00200000u;
}
inline void ExecutionReport::clear_has_basis_feature_price() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void ExecutionReport::clear_basis_feature_price() {
  basis_feature_price_ = GOOGLE_LONGLONG(0);
  clear_has_basis_feature_price();
}
inline ::google::protobuf::int64 ExecutionReport::basis_feature_price() const {
  return basis_feature_price_;
}
inline void ExecutionReport::set_basis_feature_price(::google::protobuf::int64 value) {
  set_has_basis_feature_price();
  basis_feature_price_ = value;
}

// optional sfixed32 basis_feature_price_exponent = 87;
inline bool ExecutionReport::has_basis_feature_price_exponent() const {
  return (_has_bits_[2] & 0x00400000u) != 0;
}
inline void ExecutionReport::set_has_basis_feature_price_exponent() {
  _has_bits_[2] |= 0x00400000u;
}
inline void ExecutionReport::clear_has_basis_feature_price_exponent() {
  _has_bits_[2] &= ~0x00400000u;
}
inline void ExecutionReport::clear_basis_feature_price_exponent() {
  basis_feature_price_exponent_ = 0;
  clear_has_basis_feature_price_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::basis_feature_price_exponent() const {
  return basis_feature_price_exponent_;
}
inline void ExecutionReport::set_basis_feature_price_exponent(::google::protobuf::int32 value) {
  set_has_basis_feature_price_exponent();
  basis_feature_price_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.BookingUnitEnum booking_unit = 88;
inline bool ExecutionReport::has_booking_unit() const {
  return (_has_bits_[2] & 0x00800000u) != 0;
}
inline void ExecutionReport::set_has_booking_unit() {
  _has_bits_[2] |= 0x00800000u;
}
inline void ExecutionReport::clear_has_booking_unit() {
  _has_bits_[2] &= ~0x00800000u;
}
inline void ExecutionReport::clear_booking_unit() {
  booking_unit_ = 0;
  clear_has_booking_unit();
}
inline ::SingleGeneralOrderHandling::BookingUnitEnum ExecutionReport::booking_unit() const {
  return static_cast< ::SingleGeneralOrderHandling::BookingUnitEnum >(booking_unit_);
}
inline void ExecutionReport::set_booking_unit(::SingleGeneralOrderHandling::BookingUnitEnum value) {
  assert(::SingleGeneralOrderHandling::BookingUnitEnum_IsValid(value));
  set_has_booking_unit();
  booking_unit_ = value;
}

// optional .SingleGeneralOrderHandling.CancellationRightsEnum cancellation_rights = 89;
inline bool ExecutionReport::has_cancellation_rights() const {
  return (_has_bits_[2] & 0x01000000u) != 0;
}
inline void ExecutionReport::set_has_cancellation_rights() {
  _has_bits_[2] |= 0x01000000u;
}
inline void ExecutionReport::clear_has_cancellation_rights() {
  _has_bits_[2] &= ~0x01000000u;
}
inline void ExecutionReport::clear_cancellation_rights() {
  cancellation_rights_ = 0;
  clear_has_cancellation_rights();
}
inline ::SingleGeneralOrderHandling::CancellationRightsEnum ExecutionReport::cancellation_rights() const {
  return static_cast< ::SingleGeneralOrderHandling::CancellationRightsEnum >(cancellation_rights_);
}
inline void ExecutionReport::set_cancellation_rights(::SingleGeneralOrderHandling::CancellationRightsEnum value) {
  assert(::SingleGeneralOrderHandling::CancellationRightsEnum_IsValid(value));
  set_has_cancellation_rights();
  cancellation_rights_ = value;
}

// optional .SingleGeneralOrderHandling.CashMarginEnum cash_margin = 90;
inline bool ExecutionReport::has_cash_margin() const {
  return (_has_bits_[2] & 0x02000000u) != 0;
}
inline void ExecutionReport::set_has_cash_margin() {
  _has_bits_[2] |= 0x02000000u;
}
inline void ExecutionReport::clear_has_cash_margin() {
  _has_bits_[2] &= ~0x02000000u;
}
inline void ExecutionReport::clear_cash_margin() {
  cash_margin_ = 0;
  clear_has_cash_margin();
}
inline ::SingleGeneralOrderHandling::CashMarginEnum ExecutionReport::cash_margin() const {
  return static_cast< ::SingleGeneralOrderHandling::CashMarginEnum >(cash_margin_);
}
inline void ExecutionReport::set_cash_margin(::SingleGeneralOrderHandling::CashMarginEnum value) {
  assert(::SingleGeneralOrderHandling::CashMarginEnum_IsValid(value));
  set_has_cash_margin();
  cash_margin_ = value;
}

// optional string cl_ord_link_id = 91;
inline bool ExecutionReport::has_cl_ord_link_id() const {
  return (_has_bits_[2] & 0x04000000u) != 0;
}
inline void ExecutionReport::set_has_cl_ord_link_id() {
  _has_bits_[2] |= 0x04000000u;
}
inline void ExecutionReport::clear_has_cl_ord_link_id() {
  _has_bits_[2] &= ~0x04000000u;
}
inline void ExecutionReport::clear_cl_ord_link_id() {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_->clear();
  }
  clear_has_cl_ord_link_id();
}
inline const ::std::string& ExecutionReport::cl_ord_link_id() const {
  return *cl_ord_link_id_;
}
inline void ExecutionReport::set_cl_ord_link_id(const ::std::string& value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void ExecutionReport::set_cl_ord_link_id(const char* value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void ExecutionReport::set_cl_ord_link_id(const char* value, size_t size) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_cl_ord_link_id() {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  return cl_ord_link_id_;
}
inline ::std::string* ExecutionReport::release_cl_ord_link_id() {
  clear_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_link_id_;
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id) {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_link_id_;
  }
  if (cl_ord_link_id) {
    set_has_cl_ord_link_id();
    cl_ord_link_id_ = cl_ord_link_id;
  } else {
    clear_has_cl_ord_link_id();
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.ClearingFeeIndicatorEnum clearing_fee_indicator = 92;
inline bool ExecutionReport::has_clearing_fee_indicator() const {
  return (_has_bits_[2] & 0x08000000u) != 0;
}
inline void ExecutionReport::set_has_clearing_fee_indicator() {
  _has_bits_[2] |= 0x08000000u;
}
inline void ExecutionReport::clear_has_clearing_fee_indicator() {
  _has_bits_[2] &= ~0x08000000u;
}
inline void ExecutionReport::clear_clearing_fee_indicator() {
  clearing_fee_indicator_ = 0;
  clear_has_clearing_fee_indicator();
}
inline ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum ExecutionReport::clearing_fee_indicator() const {
  return static_cast< ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum >(clearing_fee_indicator_);
}
inline void ExecutionReport::set_clearing_fee_indicator(::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum value) {
  assert(::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum_IsValid(value));
  set_has_clearing_fee_indicator();
  clearing_fee_indicator_ = value;
}

// optional .Common.CommissionData commission_data = 93;
inline bool ExecutionReport::has_commission_data() const {
  return (_has_bits_[2] & 0x10000000u) != 0;
}
inline void ExecutionReport::set_has_commission_data() {
  _has_bits_[2] |= 0x10000000u;
}
inline void ExecutionReport::clear_has_commission_data() {
  _has_bits_[2] &= ~0x10000000u;
}
inline void ExecutionReport::clear_commission_data() {
  if (commission_data_ != NULL) commission_data_->::Common::CommissionData::Clear();
  clear_has_commission_data();
}
inline const ::Common::CommissionData& ExecutionReport::commission_data() const {
  return commission_data_ != NULL ? *commission_data_ : *default_instance_->commission_data_;
}
inline ::Common::CommissionData* ExecutionReport::mutable_commission_data() {
  set_has_commission_data();
  if (commission_data_ == NULL) commission_data_ = new ::Common::CommissionData;
  return commission_data_;
}
inline ::Common::CommissionData* ExecutionReport::release_commission_data() {
  clear_has_commission_data();
  ::Common::CommissionData* temp = commission_data_;
  commission_data_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_commission_data(::Common::CommissionData* commission_data) {
  delete commission_data_;
  commission_data_ = commission_data;
  if (commission_data) {
    set_has_commission_data();
  } else {
    clear_has_commission_data();
  }
}

// optional sfixed64 concession = 94;
inline bool ExecutionReport::has_concession() const {
  return (_has_bits_[2] & 0x20000000u) != 0;
}
inline void ExecutionReport::set_has_concession() {
  _has_bits_[2] |= 0x20000000u;
}
inline void ExecutionReport::clear_has_concession() {
  _has_bits_[2] &= ~0x20000000u;
}
inline void ExecutionReport::clear_concession() {
  concession_ = GOOGLE_LONGLONG(0);
  clear_has_concession();
}
inline ::google::protobuf::int64 ExecutionReport::concession() const {
  return concession_;
}
inline void ExecutionReport::set_concession(::google::protobuf::int64 value) {
  set_has_concession();
  concession_ = value;
}

// optional sfixed32 concession_exponent = 95;
inline bool ExecutionReport::has_concession_exponent() const {
  return (_has_bits_[2] & 0x40000000u) != 0;
}
inline void ExecutionReport::set_has_concession_exponent() {
  _has_bits_[2] |= 0x40000000u;
}
inline void ExecutionReport::clear_has_concession_exponent() {
  _has_bits_[2] &= ~0x40000000u;
}
inline void ExecutionReport::clear_concession_exponent() {
  concession_exponent_ = 0;
  clear_has_concession_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::concession_exponent() const {
  return concession_exponent_;
}
inline void ExecutionReport::set_concession_exponent(::google::protobuf::int32 value) {
  set_has_concession_exponent();
  concession_exponent_ = value;
}

// optional string cross_id = 96;
inline bool ExecutionReport::has_cross_id() const {
  return (_has_bits_[2] & 0x80000000u) != 0;
}
inline void ExecutionReport::set_has_cross_id() {
  _has_bits_[2] |= 0x80000000u;
}
inline void ExecutionReport::clear_has_cross_id() {
  _has_bits_[2] &= ~0x80000000u;
}
inline void ExecutionReport::clear_cross_id() {
  if (cross_id_ != &::google::protobuf::internal::kEmptyString) {
    cross_id_->clear();
  }
  clear_has_cross_id();
}
inline const ::std::string& ExecutionReport::cross_id() const {
  return *cross_id_;
}
inline void ExecutionReport::set_cross_id(const ::std::string& value) {
  set_has_cross_id();
  if (cross_id_ == &::google::protobuf::internal::kEmptyString) {
    cross_id_ = new ::std::string;
  }
  cross_id_->assign(value);
}
inline void ExecutionReport::set_cross_id(const char* value) {
  set_has_cross_id();
  if (cross_id_ == &::google::protobuf::internal::kEmptyString) {
    cross_id_ = new ::std::string;
  }
  cross_id_->assign(value);
}
inline void ExecutionReport::set_cross_id(const char* value, size_t size) {
  set_has_cross_id();
  if (cross_id_ == &::google::protobuf::internal::kEmptyString) {
    cross_id_ = new ::std::string;
  }
  cross_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_cross_id() {
  set_has_cross_id();
  if (cross_id_ == &::google::protobuf::internal::kEmptyString) {
    cross_id_ = new ::std::string;
  }
  return cross_id_;
}
inline ::std::string* ExecutionReport::release_cross_id() {
  clear_has_cross_id();
  if (cross_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cross_id_;
    cross_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_cross_id(::std::string* cross_id) {
  if (cross_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cross_id_;
  }
  if (cross_id) {
    set_has_cross_id();
    cross_id_ = cross_id;
  } else {
    clear_has_cross_id();
    cross_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.CrossTypeEnum cross_type = 97;
inline bool ExecutionReport::has_cross_type() const {
  return (_has_bits_[3] & 0x00000001u) != 0;
}
inline void ExecutionReport::set_has_cross_type() {
  _has_bits_[3] |= 0x00000001u;
}
inline void ExecutionReport::clear_has_cross_type() {
  _has_bits_[3] &= ~0x00000001u;
}
inline void ExecutionReport::clear_cross_type() {
  cross_type_ = 0;
  clear_has_cross_type();
}
inline ::SingleGeneralOrderHandling::CrossTypeEnum ExecutionReport::cross_type() const {
  return static_cast< ::SingleGeneralOrderHandling::CrossTypeEnum >(cross_type_);
}
inline void ExecutionReport::set_cross_type(::SingleGeneralOrderHandling::CrossTypeEnum value) {
  assert(::SingleGeneralOrderHandling::CrossTypeEnum_IsValid(value));
  set_has_cross_type();
  cross_type_ = value;
}

// optional .SingleGeneralOrderHandling.CustOrderCapacityEnum cust_order_capacity = 98;
inline bool ExecutionReport::has_cust_order_capacity() const {
  return (_has_bits_[3] & 0x00000002u) != 0;
}
inline void ExecutionReport::set_has_cust_order_capacity() {
  _has_bits_[3] |= 0x00000002u;
}
inline void ExecutionReport::clear_has_cust_order_capacity() {
  _has_bits_[3] &= ~0x00000002u;
}
inline void ExecutionReport::clear_cust_order_capacity() {
  cust_order_capacity_ = 0;
  clear_has_cust_order_capacity();
}
inline ::SingleGeneralOrderHandling::CustOrderCapacityEnum ExecutionReport::cust_order_capacity() const {
  return static_cast< ::SingleGeneralOrderHandling::CustOrderCapacityEnum >(cust_order_capacity_);
}
inline void ExecutionReport::set_cust_order_capacity(::SingleGeneralOrderHandling::CustOrderCapacityEnum value) {
  assert(::SingleGeneralOrderHandling::CustOrderCapacityEnum_IsValid(value));
  set_has_cust_order_capacity();
  cust_order_capacity_ = value;
}

// optional .SingleGeneralOrderHandling.DayBookingInstEnum day_booking_inst = 99;
inline bool ExecutionReport::has_day_booking_inst() const {
  return (_has_bits_[3] & 0x00000004u) != 0;
}
inline void ExecutionReport::set_has_day_booking_inst() {
  _has_bits_[3] |= 0x00000004u;
}
inline void ExecutionReport::clear_has_day_booking_inst() {
  _has_bits_[3] &= ~0x00000004u;
}
inline void ExecutionReport::clear_day_booking_inst() {
  day_booking_inst_ = 0;
  clear_has_day_booking_inst();
}
inline ::SingleGeneralOrderHandling::DayBookingInstEnum ExecutionReport::day_booking_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::DayBookingInstEnum >(day_booking_inst_);
}
inline void ExecutionReport::set_day_booking_inst(::SingleGeneralOrderHandling::DayBookingInstEnum value) {
  assert(::SingleGeneralOrderHandling::DayBookingInstEnum_IsValid(value));
  set_has_day_booking_inst();
  day_booking_inst_ = value;
}

// optional string designation = 100;
inline bool ExecutionReport::has_designation() const {
  return (_has_bits_[3] & 0x00000008u) != 0;
}
inline void ExecutionReport::set_has_designation() {
  _has_bits_[3] |= 0x00000008u;
}
inline void ExecutionReport::clear_has_designation() {
  _has_bits_[3] &= ~0x00000008u;
}
inline void ExecutionReport::clear_designation() {
  if (designation_ != &::google::protobuf::internal::kEmptyString) {
    designation_->clear();
  }
  clear_has_designation();
}
inline const ::std::string& ExecutionReport::designation() const {
  return *designation_;
}
inline void ExecutionReport::set_designation(const ::std::string& value) {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  designation_->assign(value);
}
inline void ExecutionReport::set_designation(const char* value) {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  designation_->assign(value);
}
inline void ExecutionReport::set_designation(const char* value, size_t size) {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  designation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_designation() {
  set_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    designation_ = new ::std::string;
  }
  return designation_;
}
inline ::std::string* ExecutionReport::release_designation() {
  clear_has_designation();
  if (designation_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = designation_;
    designation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_designation(::std::string* designation) {
  if (designation_ != &::google::protobuf::internal::kEmptyString) {
    delete designation_;
  }
  if (designation) {
    set_has_designation();
    designation_ = designation;
  } else {
    clear_has_designation();
    designation_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 ex_date = 101;
inline bool ExecutionReport::has_ex_date() const {
  return (_has_bits_[3] & 0x00000010u) != 0;
}
inline void ExecutionReport::set_has_ex_date() {
  _has_bits_[3] |= 0x00000010u;
}
inline void ExecutionReport::clear_has_ex_date() {
  _has_bits_[3] &= ~0x00000010u;
}
inline void ExecutionReport::clear_ex_date() {
  ex_date_ = 0;
  clear_has_ex_date();
}
inline ::google::protobuf::int32 ExecutionReport::ex_date() const {
  return ex_date_;
}
inline void ExecutionReport::set_ex_date(::google::protobuf::int32 value) {
  set_has_ex_date();
  ex_date_ = value;
}

// optional double exec_price_adjustment = 102;
inline bool ExecutionReport::has_exec_price_adjustment() const {
  return (_has_bits_[3] & 0x00000020u) != 0;
}
inline void ExecutionReport::set_has_exec_price_adjustment() {
  _has_bits_[3] |= 0x00000020u;
}
inline void ExecutionReport::clear_has_exec_price_adjustment() {
  _has_bits_[3] &= ~0x00000020u;
}
inline void ExecutionReport::clear_exec_price_adjustment() {
  exec_price_adjustment_ = 0;
  clear_has_exec_price_adjustment();
}
inline double ExecutionReport::exec_price_adjustment() const {
  return exec_price_adjustment_;
}
inline void ExecutionReport::set_exec_price_adjustment(double value) {
  set_has_exec_price_adjustment();
  exec_price_adjustment_ = value;
}

// optional .SingleGeneralOrderHandling.ExecPriceTypeEnum exec_price_type = 103;
inline bool ExecutionReport::has_exec_price_type() const {
  return (_has_bits_[3] & 0x00000040u) != 0;
}
inline void ExecutionReport::set_has_exec_price_type() {
  _has_bits_[3] |= 0x00000040u;
}
inline void ExecutionReport::clear_has_exec_price_type() {
  _has_bits_[3] &= ~0x00000040u;
}
inline void ExecutionReport::clear_exec_price_type() {
  exec_price_type_ = 0;
  clear_has_exec_price_type();
}
inline ::SingleGeneralOrderHandling::ExecPriceTypeEnum ExecutionReport::exec_price_type() const {
  return static_cast< ::SingleGeneralOrderHandling::ExecPriceTypeEnum >(exec_price_type_);
}
inline void ExecutionReport::set_exec_price_type(::SingleGeneralOrderHandling::ExecPriceTypeEnum value) {
  assert(::SingleGeneralOrderHandling::ExecPriceTypeEnum_IsValid(value));
  set_has_exec_price_type();
  exec_price_type_ = value;
}

// optional sfixed64 exec_valuation_point = 104;
inline bool ExecutionReport::has_exec_valuation_point() const {
  return (_has_bits_[3] & 0x00000080u) != 0;
}
inline void ExecutionReport::set_has_exec_valuation_point() {
  _has_bits_[3] |= 0x00000080u;
}
inline void ExecutionReport::clear_has_exec_valuation_point() {
  _has_bits_[3] &= ~0x00000080u;
}
inline void ExecutionReport::clear_exec_valuation_point() {
  exec_valuation_point_ = GOOGLE_LONGLONG(0);
  clear_has_exec_valuation_point();
}
inline ::google::protobuf::int64 ExecutionReport::exec_valuation_point() const {
  return exec_valuation_point_;
}
inline void ExecutionReport::set_exec_valuation_point(::google::protobuf::int64 value) {
  set_has_exec_valuation_point();
  exec_valuation_point_ = value;
}

// optional .Common.Instrument instrument = 105;
inline bool ExecutionReport::has_instrument() const {
  return (_has_bits_[3] & 0x00000100u) != 0;
}
inline void ExecutionReport::set_has_instrument() {
  _has_bits_[3] |= 0x00000100u;
}
inline void ExecutionReport::clear_has_instrument() {
  _has_bits_[3] &= ~0x00000100u;
}
inline void ExecutionReport::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& ExecutionReport::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* ExecutionReport::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* ExecutionReport::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional sfixed64 last_forward_points2 = 106;
inline bool ExecutionReport::has_last_forward_points2() const {
  return (_has_bits_[3] & 0x00000200u) != 0;
}
inline void ExecutionReport::set_has_last_forward_points2() {
  _has_bits_[3] |= 0x00000200u;
}
inline void ExecutionReport::clear_has_last_forward_points2() {
  _has_bits_[3] &= ~0x00000200u;
}
inline void ExecutionReport::clear_last_forward_points2() {
  last_forward_points2_ = GOOGLE_LONGLONG(0);
  clear_has_last_forward_points2();
}
inline ::google::protobuf::int64 ExecutionReport::last_forward_points2() const {
  return last_forward_points2_;
}
inline void ExecutionReport::set_last_forward_points2(::google::protobuf::int64 value) {
  set_has_last_forward_points2();
  last_forward_points2_ = value;
}

// optional sfixed32 last_forward_points2_exponent = 107;
inline bool ExecutionReport::has_last_forward_points2_exponent() const {
  return (_has_bits_[3] & 0x00000400u) != 0;
}
inline void ExecutionReport::set_has_last_forward_points2_exponent() {
  _has_bits_[3] |= 0x00000400u;
}
inline void ExecutionReport::clear_has_last_forward_points2_exponent() {
  _has_bits_[3] &= ~0x00000400u;
}
inline void ExecutionReport::clear_last_forward_points2_exponent() {
  last_forward_points2_exponent_ = 0;
  clear_has_last_forward_points2_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::last_forward_points2_exponent() const {
  return last_forward_points2_exponent_;
}
inline void ExecutionReport::set_last_forward_points2_exponent(::google::protobuf::int32 value) {
  set_has_last_forward_points2_exponent();
  last_forward_points2_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.MoneyLaunderingStatusEnum money_laundering_status = 108;
inline bool ExecutionReport::has_money_laundering_status() const {
  return (_has_bits_[3] & 0x00000800u) != 0;
}
inline void ExecutionReport::set_has_money_laundering_status() {
  _has_bits_[3] |= 0x00000800u;
}
inline void ExecutionReport::clear_has_money_laundering_status() {
  _has_bits_[3] &= ~0x00000800u;
}
inline void ExecutionReport::clear_money_laundering_status() {
  money_laundering_status_ = 0;
  clear_has_money_laundering_status();
}
inline ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum ExecutionReport::money_laundering_status() const {
  return static_cast< ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum >(money_laundering_status_);
}
inline void ExecutionReport::set_money_laundering_status(::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum value) {
  assert(::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum_IsValid(value));
  set_has_money_laundering_status();
  money_laundering_status_ = value;
}

// optional sfixed64 num_days_interest = 109;
inline bool ExecutionReport::has_num_days_interest() const {
  return (_has_bits_[3] & 0x00001000u) != 0;
}
inline void ExecutionReport::set_has_num_days_interest() {
  _has_bits_[3] |= 0x00001000u;
}
inline void ExecutionReport::clear_has_num_days_interest() {
  _has_bits_[3] &= ~0x00001000u;
}
inline void ExecutionReport::clear_num_days_interest() {
  num_days_interest_ = GOOGLE_LONGLONG(0);
  clear_has_num_days_interest();
}
inline ::google::protobuf::int64 ExecutionReport::num_days_interest() const {
  return num_days_interest_;
}
inline void ExecutionReport::set_num_days_interest(::google::protobuf::int64 value) {
  set_has_num_days_interest();
  num_days_interest_ = value;
}

// optional .SingleGeneralOrderHandling.OrderCapacityEnum order_capacity = 110;
inline bool ExecutionReport::has_order_capacity() const {
  return (_has_bits_[3] & 0x00002000u) != 0;
}
inline void ExecutionReport::set_has_order_capacity() {
  _has_bits_[3] |= 0x00002000u;
}
inline void ExecutionReport::clear_has_order_capacity() {
  _has_bits_[3] &= ~0x00002000u;
}
inline void ExecutionReport::clear_order_capacity() {
  order_capacity_ = 0;
  clear_has_order_capacity();
}
inline ::SingleGeneralOrderHandling::OrderCapacityEnum ExecutionReport::order_capacity() const {
  return static_cast< ::SingleGeneralOrderHandling::OrderCapacityEnum >(order_capacity_);
}
inline void ExecutionReport::set_order_capacity(::SingleGeneralOrderHandling::OrderCapacityEnum value) {
  assert(::SingleGeneralOrderHandling::OrderCapacityEnum_IsValid(value));
  set_has_order_capacity();
  order_capacity_ = value;
}

// optional .Common.OrderQtyData order_qty_data = 111;
inline bool ExecutionReport::has_order_qty_data() const {
  return (_has_bits_[3] & 0x00004000u) != 0;
}
inline void ExecutionReport::set_has_order_qty_data() {
  _has_bits_[3] |= 0x00004000u;
}
inline void ExecutionReport::clear_has_order_qty_data() {
  _has_bits_[3] &= ~0x00004000u;
}
inline void ExecutionReport::clear_order_qty_data() {
  if (order_qty_data_ != NULL) order_qty_data_->::Common::OrderQtyData::Clear();
  clear_has_order_qty_data();
}
inline const ::Common::OrderQtyData& ExecutionReport::order_qty_data() const {
  return order_qty_data_ != NULL ? *order_qty_data_ : *default_instance_->order_qty_data_;
}
inline ::Common::OrderQtyData* ExecutionReport::mutable_order_qty_data() {
  set_has_order_qty_data();
  if (order_qty_data_ == NULL) order_qty_data_ = new ::Common::OrderQtyData;
  return order_qty_data_;
}
inline ::Common::OrderQtyData* ExecutionReport::release_order_qty_data() {
  clear_has_order_qty_data();
  ::Common::OrderQtyData* temp = order_qty_data_;
  order_qty_data_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data) {
  delete order_qty_data_;
  order_qty_data_ = order_qty_data;
  if (order_qty_data) {
    set_has_order_qty_data();
  } else {
    clear_has_order_qty_data();
  }
}

// repeated .SingleGeneralOrderHandling.OrderRestrictionsEnum order_restrictions = 112 [packed = true];
inline int ExecutionReport::order_restrictions_size() const {
  return order_restrictions_.size();
}
inline void ExecutionReport::clear_order_restrictions() {
  order_restrictions_.Clear();
}
inline ::SingleGeneralOrderHandling::OrderRestrictionsEnum ExecutionReport::order_restrictions(int index) const {
  return static_cast< ::SingleGeneralOrderHandling::OrderRestrictionsEnum >(order_restrictions_.Get(index));
}
inline void ExecutionReport::set_order_restrictions(int index, ::SingleGeneralOrderHandling::OrderRestrictionsEnum value) {
  assert(::SingleGeneralOrderHandling::OrderRestrictionsEnum_IsValid(value));
  order_restrictions_.Set(index, value);
}
inline void ExecutionReport::add_order_restrictions(::SingleGeneralOrderHandling::OrderRestrictionsEnum value) {
  assert(::SingleGeneralOrderHandling::OrderRestrictionsEnum_IsValid(value));
  order_restrictions_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
ExecutionReport::order_restrictions() const {
  return order_restrictions_;
}
inline ::google::protobuf::RepeatedField<int>*
ExecutionReport::mutable_order_restrictions() {
  return &order_restrictions_;
}

// optional string orig_cross_id = 113;
inline bool ExecutionReport::has_orig_cross_id() const {
  return (_has_bits_[3] & 0x00010000u) != 0;
}
inline void ExecutionReport::set_has_orig_cross_id() {
  _has_bits_[3] |= 0x00010000u;
}
inline void ExecutionReport::clear_has_orig_cross_id() {
  _has_bits_[3] &= ~0x00010000u;
}
inline void ExecutionReport::clear_orig_cross_id() {
  if (orig_cross_id_ != &::google::protobuf::internal::kEmptyString) {
    orig_cross_id_->clear();
  }
  clear_has_orig_cross_id();
}
inline const ::std::string& ExecutionReport::orig_cross_id() const {
  return *orig_cross_id_;
}
inline void ExecutionReport::set_orig_cross_id(const ::std::string& value) {
  set_has_orig_cross_id();
  if (orig_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cross_id_ = new ::std::string;
  }
  orig_cross_id_->assign(value);
}
inline void ExecutionReport::set_orig_cross_id(const char* value) {
  set_has_orig_cross_id();
  if (orig_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cross_id_ = new ::std::string;
  }
  orig_cross_id_->assign(value);
}
inline void ExecutionReport::set_orig_cross_id(const char* value, size_t size) {
  set_has_orig_cross_id();
  if (orig_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cross_id_ = new ::std::string;
  }
  orig_cross_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_orig_cross_id() {
  set_has_orig_cross_id();
  if (orig_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    orig_cross_id_ = new ::std::string;
  }
  return orig_cross_id_;
}
inline ::std::string* ExecutionReport::release_orig_cross_id() {
  clear_has_orig_cross_id();
  if (orig_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orig_cross_id_;
    orig_cross_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_orig_cross_id(::std::string* orig_cross_id) {
  if (orig_cross_id_ != &::google::protobuf::internal::kEmptyString) {
    delete orig_cross_id_;
  }
  if (orig_cross_id) {
    set_has_orig_cross_id();
    orig_cross_id_ = orig_cross_id;
  } else {
    clear_has_orig_cross_id();
    orig_cross_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.Parties parties = 114;
inline int ExecutionReport::parties_size() const {
  return parties_.size();
}
inline void ExecutionReport::clear_parties() {
  parties_.Clear();
}
inline const ::Common::Parties& ExecutionReport::parties(int index) const {
  return parties_.Get(index);
}
inline ::Common::Parties* ExecutionReport::mutable_parties(int index) {
  return parties_.Mutable(index);
}
inline ::Common::Parties* ExecutionReport::add_parties() {
  return parties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
ExecutionReport::parties() const {
  return parties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
ExecutionReport::mutable_parties() {
  return &parties_;
}

// optional .SingleGeneralOrderHandling.PreallocMethodEnum prealloc_method = 115;
inline bool ExecutionReport::has_prealloc_method() const {
  return (_has_bits_[3] & 0x00040000u) != 0;
}
inline void ExecutionReport::set_has_prealloc_method() {
  _has_bits_[3] |= 0x00040000u;
}
inline void ExecutionReport::clear_has_prealloc_method() {
  _has_bits_[3] &= ~0x00040000u;
}
inline void ExecutionReport::clear_prealloc_method() {
  prealloc_method_ = 0;
  clear_has_prealloc_method();
}
inline ::SingleGeneralOrderHandling::PreallocMethodEnum ExecutionReport::prealloc_method() const {
  return static_cast< ::SingleGeneralOrderHandling::PreallocMethodEnum >(prealloc_method_);
}
inline void ExecutionReport::set_prealloc_method(::SingleGeneralOrderHandling::PreallocMethodEnum value) {
  assert(::SingleGeneralOrderHandling::PreallocMethodEnum_IsValid(value));
  set_has_prealloc_method();
  prealloc_method_ = value;
}

// optional sfixed64 price_improvement = 116;
inline bool ExecutionReport::has_price_improvement() const {
  return (_has_bits_[3] & 0x00080000u) != 0;
}
inline void ExecutionReport::set_has_price_improvement() {
  _has_bits_[3] |= 0x00080000u;
}
inline void ExecutionReport::clear_has_price_improvement() {
  _has_bits_[3] &= ~0x00080000u;
}
inline void ExecutionReport::clear_price_improvement() {
  price_improvement_ = GOOGLE_LONGLONG(0);
  clear_has_price_improvement();
}
inline ::google::protobuf::int64 ExecutionReport::price_improvement() const {
  return price_improvement_;
}
inline void ExecutionReport::set_price_improvement(::google::protobuf::int64 value) {
  set_has_price_improvement();
  price_improvement_ = value;
}

// optional sfixed32 price_improvement_exponent = 117;
inline bool ExecutionReport::has_price_improvement_exponent() const {
  return (_has_bits_[3] & 0x00100000u) != 0;
}
inline void ExecutionReport::set_has_price_improvement_exponent() {
  _has_bits_[3] |= 0x00100000u;
}
inline void ExecutionReport::clear_has_price_improvement_exponent() {
  _has_bits_[3] &= ~0x00100000u;
}
inline void ExecutionReport::clear_price_improvement_exponent() {
  price_improvement_exponent_ = 0;
  clear_has_price_improvement_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::price_improvement_exponent() const {
  return price_improvement_exponent_;
}
inline void ExecutionReport::set_price_improvement_exponent(::google::protobuf::int32 value) {
  set_has_price_improvement_exponent();
  price_improvement_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.PriceTypeEnum price_type = 118;
inline bool ExecutionReport::has_price_type() const {
  return (_has_bits_[3] & 0x00200000u) != 0;
}
inline void ExecutionReport::set_has_price_type() {
  _has_bits_[3] |= 0x00200000u;
}
inline void ExecutionReport::clear_has_price_type() {
  _has_bits_[3] &= ~0x00200000u;
}
inline void ExecutionReport::clear_price_type() {
  price_type_ = 0;
  clear_has_price_type();
}
inline ::SingleGeneralOrderHandling::PriceTypeEnum ExecutionReport::price_type() const {
  return static_cast< ::SingleGeneralOrderHandling::PriceTypeEnum >(price_type_);
}
inline void ExecutionReport::set_price_type(::SingleGeneralOrderHandling::PriceTypeEnum value) {
  assert(::SingleGeneralOrderHandling::PriceTypeEnum_IsValid(value));
  set_has_price_type();
  price_type_ = value;
}

// optional .SingleGeneralOrderHandling.PriorityIndicatorEnum priority_indicator = 119;
inline bool ExecutionReport::has_priority_indicator() const {
  return (_has_bits_[3] & 0x00400000u) != 0;
}
inline void ExecutionReport::set_has_priority_indicator() {
  _has_bits_[3] |= 0x00400000u;
}
inline void ExecutionReport::clear_has_priority_indicator() {
  _has_bits_[3] &= ~0x00400000u;
}
inline void ExecutionReport::clear_priority_indicator() {
  priority_indicator_ = 0;
  clear_has_priority_indicator();
}
inline ::SingleGeneralOrderHandling::PriorityIndicatorEnum ExecutionReport::priority_indicator() const {
  return static_cast< ::SingleGeneralOrderHandling::PriorityIndicatorEnum >(priority_indicator_);
}
inline void ExecutionReport::set_priority_indicator(::SingleGeneralOrderHandling::PriorityIndicatorEnum value) {
  assert(::SingleGeneralOrderHandling::PriorityIndicatorEnum_IsValid(value));
  set_has_priority_indicator();
  priority_indicator_ = value;
}

// optional string regist_id = 120;
inline bool ExecutionReport::has_regist_id() const {
  return (_has_bits_[3] & 0x00800000u) != 0;
}
inline void ExecutionReport::set_has_regist_id() {
  _has_bits_[3] |= 0x00800000u;
}
inline void ExecutionReport::clear_has_regist_id() {
  _has_bits_[3] &= ~0x00800000u;
}
inline void ExecutionReport::clear_regist_id() {
  if (regist_id_ != &::google::protobuf::internal::kEmptyString) {
    regist_id_->clear();
  }
  clear_has_regist_id();
}
inline const ::std::string& ExecutionReport::regist_id() const {
  return *regist_id_;
}
inline void ExecutionReport::set_regist_id(const ::std::string& value) {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  regist_id_->assign(value);
}
inline void ExecutionReport::set_regist_id(const char* value) {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  regist_id_->assign(value);
}
inline void ExecutionReport::set_regist_id(const char* value, size_t size) {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  regist_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_regist_id() {
  set_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    regist_id_ = new ::std::string;
  }
  return regist_id_;
}
inline ::std::string* ExecutionReport::release_regist_id() {
  clear_has_regist_id();
  if (regist_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = regist_id_;
    regist_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_regist_id(::std::string* regist_id) {
  if (regist_id_ != &::google::protobuf::internal::kEmptyString) {
    delete regist_id_;
  }
  if (regist_id) {
    set_has_regist_id();
    regist_id_ = regist_id;
  } else {
    clear_has_regist_id();
    regist_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string secondary_cl_ord_id = 121;
inline bool ExecutionReport::has_secondary_cl_ord_id() const {
  return (_has_bits_[3] & 0x01000000u) != 0;
}
inline void ExecutionReport::set_has_secondary_cl_ord_id() {
  _has_bits_[3] |= 0x01000000u;
}
inline void ExecutionReport::clear_has_secondary_cl_ord_id() {
  _has_bits_[3] &= ~0x01000000u;
}
inline void ExecutionReport::clear_secondary_cl_ord_id() {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_->clear();
  }
  clear_has_secondary_cl_ord_id();
}
inline const ::std::string& ExecutionReport::secondary_cl_ord_id() const {
  return *secondary_cl_ord_id_;
}
inline void ExecutionReport::set_secondary_cl_ord_id(const ::std::string& value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void ExecutionReport::set_secondary_cl_ord_id(const char* value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void ExecutionReport::set_secondary_cl_ord_id(const char* value, size_t size) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_secondary_cl_ord_id() {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  return secondary_cl_ord_id_;
}
inline ::std::string* ExecutionReport::release_secondary_cl_ord_id() {
  clear_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_cl_ord_id_;
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id) {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_cl_ord_id_;
  }
  if (secondary_cl_ord_id) {
    set_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = secondary_cl_ord_id;
  } else {
    clear_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string secondary_exec_id = 122;
inline bool ExecutionReport::has_secondary_exec_id() const {
  return (_has_bits_[3] & 0x02000000u) != 0;
}
inline void ExecutionReport::set_has_secondary_exec_id() {
  _has_bits_[3] |= 0x02000000u;
}
inline void ExecutionReport::clear_has_secondary_exec_id() {
  _has_bits_[3] &= ~0x02000000u;
}
inline void ExecutionReport::clear_secondary_exec_id() {
  if (secondary_exec_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_exec_id_->clear();
  }
  clear_has_secondary_exec_id();
}
inline const ::std::string& ExecutionReport::secondary_exec_id() const {
  return *secondary_exec_id_;
}
inline void ExecutionReport::set_secondary_exec_id(const ::std::string& value) {
  set_has_secondary_exec_id();
  if (secondary_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_exec_id_ = new ::std::string;
  }
  secondary_exec_id_->assign(value);
}
inline void ExecutionReport::set_secondary_exec_id(const char* value) {
  set_has_secondary_exec_id();
  if (secondary_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_exec_id_ = new ::std::string;
  }
  secondary_exec_id_->assign(value);
}
inline void ExecutionReport::set_secondary_exec_id(const char* value, size_t size) {
  set_has_secondary_exec_id();
  if (secondary_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_exec_id_ = new ::std::string;
  }
  secondary_exec_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_secondary_exec_id() {
  set_has_secondary_exec_id();
  if (secondary_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_exec_id_ = new ::std::string;
  }
  return secondary_exec_id_;
}
inline ::std::string* ExecutionReport::release_secondary_exec_id() {
  clear_has_secondary_exec_id();
  if (secondary_exec_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_exec_id_;
    secondary_exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_secondary_exec_id(::std::string* secondary_exec_id) {
  if (secondary_exec_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_exec_id_;
  }
  if (secondary_exec_id) {
    set_has_secondary_exec_id();
    secondary_exec_id_ = secondary_exec_id;
  } else {
    clear_has_secondary_exec_id();
    secondary_exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 123;
inline bool ExecutionReport::has_spread_or_benchmark_curve_data() const {
  return (_has_bits_[3] & 0x04000000u) != 0;
}
inline void ExecutionReport::set_has_spread_or_benchmark_curve_data() {
  _has_bits_[3] |= 0x04000000u;
}
inline void ExecutionReport::clear_has_spread_or_benchmark_curve_data() {
  _has_bits_[3] &= ~0x04000000u;
}
inline void ExecutionReport::clear_spread_or_benchmark_curve_data() {
  if (spread_or_benchmark_curve_data_ != NULL) spread_or_benchmark_curve_data_->::Common::SpreadOrBenchmarkCurveData::Clear();
  clear_has_spread_or_benchmark_curve_data();
}
inline const ::Common::SpreadOrBenchmarkCurveData& ExecutionReport::spread_or_benchmark_curve_data() const {
  return spread_or_benchmark_curve_data_ != NULL ? *spread_or_benchmark_curve_data_ : *default_instance_->spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* ExecutionReport::mutable_spread_or_benchmark_curve_data() {
  set_has_spread_or_benchmark_curve_data();
  if (spread_or_benchmark_curve_data_ == NULL) spread_or_benchmark_curve_data_ = new ::Common::SpreadOrBenchmarkCurveData;
  return spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* ExecutionReport::release_spread_or_benchmark_curve_data() {
  clear_has_spread_or_benchmark_curve_data();
  ::Common::SpreadOrBenchmarkCurveData* temp = spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data) {
  delete spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = spread_or_benchmark_curve_data;
  if (spread_or_benchmark_curve_data) {
    set_has_spread_or_benchmark_curve_data();
  } else {
    clear_has_spread_or_benchmark_curve_data();
  }
}

// repeated .Common.Stipulations stipulations = 124;
inline int ExecutionReport::stipulations_size() const {
  return stipulations_.size();
}
inline void ExecutionReport::clear_stipulations() {
  stipulations_.Clear();
}
inline const ::Common::Stipulations& ExecutionReport::stipulations(int index) const {
  return stipulations_.Get(index);
}
inline ::Common::Stipulations* ExecutionReport::mutable_stipulations(int index) {
  return stipulations_.Mutable(index);
}
inline ::Common::Stipulations* ExecutionReport::add_stipulations() {
  return stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
ExecutionReport::stipulations() const {
  return stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
ExecutionReport::mutable_stipulations() {
  return &stipulations_;
}

// optional sfixed64 total_takedown = 125;
inline bool ExecutionReport::has_total_takedown() const {
  return (_has_bits_[3] & 0x10000000u) != 0;
}
inline void ExecutionReport::set_has_total_takedown() {
  _has_bits_[3] |= 0x10000000u;
}
inline void ExecutionReport::clear_has_total_takedown() {
  _has_bits_[3] &= ~0x10000000u;
}
inline void ExecutionReport::clear_total_takedown() {
  total_takedown_ = GOOGLE_LONGLONG(0);
  clear_has_total_takedown();
}
inline ::google::protobuf::int64 ExecutionReport::total_takedown() const {
  return total_takedown_;
}
inline void ExecutionReport::set_total_takedown(::google::protobuf::int64 value) {
  set_has_total_takedown();
  total_takedown_ = value;
}

// optional sfixed32 total_takedown_exponent = 126;
inline bool ExecutionReport::has_total_takedown_exponent() const {
  return (_has_bits_[3] & 0x20000000u) != 0;
}
inline void ExecutionReport::set_has_total_takedown_exponent() {
  _has_bits_[3] |= 0x20000000u;
}
inline void ExecutionReport::clear_has_total_takedown_exponent() {
  _has_bits_[3] &= ~0x20000000u;
}
inline void ExecutionReport::clear_total_takedown_exponent() {
  total_takedown_exponent_ = 0;
  clear_has_total_takedown_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::total_takedown_exponent() const {
  return total_takedown_exponent_;
}
inline void ExecutionReport::set_total_takedown_exponent(::google::protobuf::int32 value) {
  set_has_total_takedown_exponent();
  total_takedown_exponent_ = value;
}

// optional sfixed32 trade_origination_date = 127;
inline bool ExecutionReport::has_trade_origination_date() const {
  return (_has_bits_[3] & 0x40000000u) != 0;
}
inline void ExecutionReport::set_has_trade_origination_date() {
  _has_bits_[3] |= 0x40000000u;
}
inline void ExecutionReport::clear_has_trade_origination_date() {
  _has_bits_[3] &= ~0x40000000u;
}
inline void ExecutionReport::clear_trade_origination_date() {
  trade_origination_date_ = 0;
  clear_has_trade_origination_date();
}
inline ::google::protobuf::int32 ExecutionReport::trade_origination_date() const {
  return trade_origination_date_;
}
inline void ExecutionReport::set_trade_origination_date(::google::protobuf::int32 value) {
  set_has_trade_origination_date();
  trade_origination_date_ = value;
}

// optional bool traded_flat_switch = 128;
inline bool ExecutionReport::has_traded_flat_switch() const {
  return (_has_bits_[3] & 0x80000000u) != 0;
}
inline void ExecutionReport::set_has_traded_flat_switch() {
  _has_bits_[3] |= 0x80000000u;
}
inline void ExecutionReport::clear_has_traded_flat_switch() {
  _has_bits_[3] &= ~0x80000000u;
}
inline void ExecutionReport::clear_traded_flat_switch() {
  traded_flat_switch_ = false;
  clear_has_traded_flat_switch();
}
inline bool ExecutionReport::traded_flat_switch() const {
  return traded_flat_switch_;
}
inline void ExecutionReport::set_traded_flat_switch(bool value) {
  set_has_traded_flat_switch();
  traded_flat_switch_ = value;
}

// optional .SingleGeneralOrderHandling.TradingSessionSubIdEnum trading_session_sub_id = 129;
inline bool ExecutionReport::has_trading_session_sub_id() const {
  return (_has_bits_[4] & 0x00000001u) != 0;
}
inline void ExecutionReport::set_has_trading_session_sub_id() {
  _has_bits_[4] |= 0x00000001u;
}
inline void ExecutionReport::clear_has_trading_session_sub_id() {
  _has_bits_[4] &= ~0x00000001u;
}
inline void ExecutionReport::clear_trading_session_sub_id() {
  trading_session_sub_id_ = 0;
  clear_has_trading_session_sub_id();
}
inline ::SingleGeneralOrderHandling::TradingSessionSubIdEnum ExecutionReport::trading_session_sub_id() const {
  return static_cast< ::SingleGeneralOrderHandling::TradingSessionSubIdEnum >(trading_session_sub_id_);
}
inline void ExecutionReport::set_trading_session_sub_id(::SingleGeneralOrderHandling::TradingSessionSubIdEnum value) {
  assert(::SingleGeneralOrderHandling::TradingSessionSubIdEnum_IsValid(value));
  set_has_trading_session_sub_id();
  trading_session_sub_id_ = value;
}

// optional sfixed64 trans_bkd_time = 130;
inline bool ExecutionReport::has_trans_bkd_time() const {
  return (_has_bits_[4] & 0x00000002u) != 0;
}
inline void ExecutionReport::set_has_trans_bkd_time() {
  _has_bits_[4] |= 0x00000002u;
}
inline void ExecutionReport::clear_has_trans_bkd_time() {
  _has_bits_[4] &= ~0x00000002u;
}
inline void ExecutionReport::clear_trans_bkd_time() {
  trans_bkd_time_ = GOOGLE_LONGLONG(0);
  clear_has_trans_bkd_time();
}
inline ::google::protobuf::int64 ExecutionReport::trans_bkd_time() const {
  return trans_bkd_time_;
}
inline void ExecutionReport::set_trans_bkd_time(::google::protobuf::int64 value) {
  set_has_trans_bkd_time();
  trans_bkd_time_ = value;
}

// optional sfixed64 underlying_last_px = 131;
inline bool ExecutionReport::has_underlying_last_px() const {
  return (_has_bits_[4] & 0x00000004u) != 0;
}
inline void ExecutionReport::set_has_underlying_last_px() {
  _has_bits_[4] |= 0x00000004u;
}
inline void ExecutionReport::clear_has_underlying_last_px() {
  _has_bits_[4] &= ~0x00000004u;
}
inline void ExecutionReport::clear_underlying_last_px() {
  underlying_last_px_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_last_px();
}
inline ::google::protobuf::int64 ExecutionReport::underlying_last_px() const {
  return underlying_last_px_;
}
inline void ExecutionReport::set_underlying_last_px(::google::protobuf::int64 value) {
  set_has_underlying_last_px();
  underlying_last_px_ = value;
}

// optional sfixed32 underlying_last_px_exponent = 132;
inline bool ExecutionReport::has_underlying_last_px_exponent() const {
  return (_has_bits_[4] & 0x00000008u) != 0;
}
inline void ExecutionReport::set_has_underlying_last_px_exponent() {
  _has_bits_[4] |= 0x00000008u;
}
inline void ExecutionReport::clear_has_underlying_last_px_exponent() {
  _has_bits_[4] &= ~0x00000008u;
}
inline void ExecutionReport::clear_underlying_last_px_exponent() {
  underlying_last_px_exponent_ = 0;
  clear_has_underlying_last_px_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::underlying_last_px_exponent() const {
  return underlying_last_px_exponent_;
}
inline void ExecutionReport::set_underlying_last_px_exponent(::google::protobuf::int32 value) {
  set_has_underlying_last_px_exponent();
  underlying_last_px_exponent_ = value;
}

// optional sfixed64 underlying_last_qty = 133;
inline bool ExecutionReport::has_underlying_last_qty() const {
  return (_has_bits_[4] & 0x00000010u) != 0;
}
inline void ExecutionReport::set_has_underlying_last_qty() {
  _has_bits_[4] |= 0x00000010u;
}
inline void ExecutionReport::clear_has_underlying_last_qty() {
  _has_bits_[4] &= ~0x00000010u;
}
inline void ExecutionReport::clear_underlying_last_qty() {
  underlying_last_qty_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_last_qty();
}
inline ::google::protobuf::int64 ExecutionReport::underlying_last_qty() const {
  return underlying_last_qty_;
}
inline void ExecutionReport::set_underlying_last_qty(::google::protobuf::int64 value) {
  set_has_underlying_last_qty();
  underlying_last_qty_ = value;
}

// optional sfixed32 underlying_last_qty_exponent = 134;
inline bool ExecutionReport::has_underlying_last_qty_exponent() const {
  return (_has_bits_[4] & 0x00000020u) != 0;
}
inline void ExecutionReport::set_has_underlying_last_qty_exponent() {
  _has_bits_[4] |= 0x00000020u;
}
inline void ExecutionReport::clear_has_underlying_last_qty_exponent() {
  _has_bits_[4] &= ~0x00000020u;
}
inline void ExecutionReport::clear_underlying_last_qty_exponent() {
  underlying_last_qty_exponent_ = 0;
  clear_has_underlying_last_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::underlying_last_qty_exponent() const {
  return underlying_last_qty_exponent_;
}
inline void ExecutionReport::set_underlying_last_qty_exponent(::google::protobuf::int32 value) {
  set_has_underlying_last_qty_exponent();
  underlying_last_qty_exponent_ = value;
}

// optional bool working_indicator = 135;
inline bool ExecutionReport::has_working_indicator() const {
  return (_has_bits_[4] & 0x00000040u) != 0;
}
inline void ExecutionReport::set_has_working_indicator() {
  _has_bits_[4] |= 0x00000040u;
}
inline void ExecutionReport::clear_has_working_indicator() {
  _has_bits_[4] &= ~0x00000040u;
}
inline void ExecutionReport::clear_working_indicator() {
  working_indicator_ = false;
  clear_has_working_indicator();
}
inline bool ExecutionReport::working_indicator() const {
  return working_indicator_;
}
inline void ExecutionReport::set_working_indicator(bool value) {
  set_has_working_indicator();
  working_indicator_ = value;
}

// optional .Common.YieldData yield_data = 136;
inline bool ExecutionReport::has_yield_data() const {
  return (_has_bits_[4] & 0x00000080u) != 0;
}
inline void ExecutionReport::set_has_yield_data() {
  _has_bits_[4] |= 0x00000080u;
}
inline void ExecutionReport::clear_has_yield_data() {
  _has_bits_[4] &= ~0x00000080u;
}
inline void ExecutionReport::clear_yield_data() {
  if (yield_data_ != NULL) yield_data_->::Common::YieldData::Clear();
  clear_has_yield_data();
}
inline const ::Common::YieldData& ExecutionReport::yield_data() const {
  return yield_data_ != NULL ? *yield_data_ : *default_instance_->yield_data_;
}
inline ::Common::YieldData* ExecutionReport::mutable_yield_data() {
  set_has_yield_data();
  if (yield_data_ == NULL) yield_data_ = new ::Common::YieldData;
  return yield_data_;
}
inline ::Common::YieldData* ExecutionReport::release_yield_data() {
  clear_has_yield_data();
  ::Common::YieldData* temp = yield_data_;
  yield_data_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_yield_data(::Common::YieldData* yield_data) {
  delete yield_data_;
  yield_data_ = yield_data;
  if (yield_data) {
    set_has_yield_data();
  } else {
    clear_has_yield_data();
  }
}

// optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 137;
inline bool ExecutionReport::has_acct_id_source() const {
  return (_has_bits_[4] & 0x00000100u) != 0;
}
inline void ExecutionReport::set_has_acct_id_source() {
  _has_bits_[4] |= 0x00000100u;
}
inline void ExecutionReport::clear_has_acct_id_source() {
  _has_bits_[4] &= ~0x00000100u;
}
inline void ExecutionReport::clear_acct_id_source() {
  acct_id_source_ = 0;
  clear_has_acct_id_source();
}
inline ::SingleGeneralOrderHandling::AcctIdSourceEnum ExecutionReport::acct_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::AcctIdSourceEnum >(acct_id_source_);
}
inline void ExecutionReport::set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::AcctIdSourceEnum_IsValid(value));
  set_has_acct_id_source();
  acct_id_source_ = value;
}

// optional bool aggressor_indicator = 138;
inline bool ExecutionReport::has_aggressor_indicator() const {
  return (_has_bits_[4] & 0x00000200u) != 0;
}
inline void ExecutionReport::set_has_aggressor_indicator() {
  _has_bits_[4] |= 0x00000200u;
}
inline void ExecutionReport::clear_has_aggressor_indicator() {
  _has_bits_[4] &= ~0x00000200u;
}
inline void ExecutionReport::clear_aggressor_indicator() {
  aggressor_indicator_ = false;
  clear_has_aggressor_indicator();
}
inline bool ExecutionReport::aggressor_indicator() const {
  return aggressor_indicator_;
}
inline void ExecutionReport::set_aggressor_indicator(bool value) {
  set_has_aggressor_indicator();
  aggressor_indicator_ = value;
}

// optional .SingleGeneralOrderHandling.BookingTypeEnum booking_type = 139;
inline bool ExecutionReport::has_booking_type() const {
  return (_has_bits_[4] & 0x00000400u) != 0;
}
inline void ExecutionReport::set_has_booking_type() {
  _has_bits_[4] |= 0x00000400u;
}
inline void ExecutionReport::clear_has_booking_type() {
  _has_bits_[4] &= ~0x00000400u;
}
inline void ExecutionReport::clear_booking_type() {
  booking_type_ = 0;
  clear_has_booking_type();
}
inline ::SingleGeneralOrderHandling::BookingTypeEnum ExecutionReport::booking_type() const {
  return static_cast< ::SingleGeneralOrderHandling::BookingTypeEnum >(booking_type_);
}
inline void ExecutionReport::set_booking_type(::SingleGeneralOrderHandling::BookingTypeEnum value) {
  assert(::SingleGeneralOrderHandling::BookingTypeEnum_IsValid(value));
  set_has_booking_type();
  booking_type_ = value;
}

// optional sfixed64 calculated_ccy_last_qty = 140;
inline bool ExecutionReport::has_calculated_ccy_last_qty() const {
  return (_has_bits_[4] & 0x00000800u) != 0;
}
inline void ExecutionReport::set_has_calculated_ccy_last_qty() {
  _has_bits_[4] |= 0x00000800u;
}
inline void ExecutionReport::clear_has_calculated_ccy_last_qty() {
  _has_bits_[4] &= ~0x00000800u;
}
inline void ExecutionReport::clear_calculated_ccy_last_qty() {
  calculated_ccy_last_qty_ = GOOGLE_LONGLONG(0);
  clear_has_calculated_ccy_last_qty();
}
inline ::google::protobuf::int64 ExecutionReport::calculated_ccy_last_qty() const {
  return calculated_ccy_last_qty_;
}
inline void ExecutionReport::set_calculated_ccy_last_qty(::google::protobuf::int64 value) {
  set_has_calculated_ccy_last_qty();
  calculated_ccy_last_qty_ = value;
}

// optional sfixed32 calculated_ccy_last_qty_exponent = 141;
inline bool ExecutionReport::has_calculated_ccy_last_qty_exponent() const {
  return (_has_bits_[4] & 0x00001000u) != 0;
}
inline void ExecutionReport::set_has_calculated_ccy_last_qty_exponent() {
  _has_bits_[4] |= 0x00001000u;
}
inline void ExecutionReport::clear_has_calculated_ccy_last_qty_exponent() {
  _has_bits_[4] &= ~0x00001000u;
}
inline void ExecutionReport::clear_calculated_ccy_last_qty_exponent() {
  calculated_ccy_last_qty_exponent_ = 0;
  clear_has_calculated_ccy_last_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::calculated_ccy_last_qty_exponent() const {
  return calculated_ccy_last_qty_exponent_;
}
inline void ExecutionReport::set_calculated_ccy_last_qty_exponent(::google::protobuf::int32 value) {
  set_has_calculated_ccy_last_qty_exponent();
  calculated_ccy_last_qty_exponent_ = value;
}

// repeated .Common.ContAmtGrp cont_amt_grp = 142;
inline int ExecutionReport::cont_amt_grp_size() const {
  return cont_amt_grp_.size();
}
inline void ExecutionReport::clear_cont_amt_grp() {
  cont_amt_grp_.Clear();
}
inline const ::Common::ContAmtGrp& ExecutionReport::cont_amt_grp(int index) const {
  return cont_amt_grp_.Get(index);
}
inline ::Common::ContAmtGrp* ExecutionReport::mutable_cont_amt_grp(int index) {
  return cont_amt_grp_.Mutable(index);
}
inline ::Common::ContAmtGrp* ExecutionReport::add_cont_amt_grp() {
  return cont_amt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::ContAmtGrp >&
ExecutionReport::cont_amt_grp() const {
  return cont_amt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::ContAmtGrp >*
ExecutionReport::mutable_cont_amt_grp() {
  return &cont_amt_grp_;
}

// repeated .Common.ContraGrp contra_grp = 143;
inline int ExecutionReport::contra_grp_size() const {
  return contra_grp_.size();
}
inline void ExecutionReport::clear_contra_grp() {
  contra_grp_.Clear();
}
inline const ::Common::ContraGrp& ExecutionReport::contra_grp(int index) const {
  return contra_grp_.Get(index);
}
inline ::Common::ContraGrp* ExecutionReport::mutable_contra_grp(int index) {
  return contra_grp_.Mutable(index);
}
inline ::Common::ContraGrp* ExecutionReport::add_contra_grp() {
  return contra_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::ContraGrp >&
ExecutionReport::contra_grp() const {
  return contra_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::ContraGrp >*
ExecutionReport::mutable_contra_grp() {
  return &contra_grp_;
}

// optional bool copy_msg_indicator = 144;
inline bool ExecutionReport::has_copy_msg_indicator() const {
  return (_has_bits_[4] & 0x00008000u) != 0;
}
inline void ExecutionReport::set_has_copy_msg_indicator() {
  _has_bits_[4] |= 0x00008000u;
}
inline void ExecutionReport::clear_has_copy_msg_indicator() {
  _has_bits_[4] &= ~0x00008000u;
}
inline void ExecutionReport::clear_copy_msg_indicator() {
  copy_msg_indicator_ = false;
  clear_has_copy_msg_indicator();
}
inline bool ExecutionReport::copy_msg_indicator() const {
  return copy_msg_indicator_;
}
inline void ExecutionReport::set_copy_msg_indicator(bool value) {
  set_has_copy_msg_indicator();
  copy_msg_indicator_ = value;
}

// optional bool cust_directed_order = 145;
inline bool ExecutionReport::has_cust_directed_order() const {
  return (_has_bits_[4] & 0x00010000u) != 0;
}
inline void ExecutionReport::set_has_cust_directed_order() {
  _has_bits_[4] |= 0x00010000u;
}
inline void ExecutionReport::clear_has_cust_directed_order() {
  _has_bits_[4] &= ~0x00010000u;
}
inline void ExecutionReport::clear_cust_directed_order() {
  cust_directed_order_ = false;
  clear_has_cust_directed_order();
}
inline bool ExecutionReport::cust_directed_order() const {
  return cust_directed_order_;
}
inline void ExecutionReport::set_cust_directed_order(bool value) {
  set_has_cust_directed_order();
  cust_directed_order_ = value;
}

// optional .SingleGeneralOrderHandling.CustOrderHandlingInstEnum cust_order_handling_inst = 146;
inline bool ExecutionReport::has_cust_order_handling_inst() const {
  return (_has_bits_[4] & 0x00020000u) != 0;
}
inline void ExecutionReport::set_has_cust_order_handling_inst() {
  _has_bits_[4] |= 0x00020000u;
}
inline void ExecutionReport::clear_has_cust_order_handling_inst() {
  _has_bits_[4] &= ~0x00020000u;
}
inline void ExecutionReport::clear_cust_order_handling_inst() {
  cust_order_handling_inst_ = 0;
  clear_has_cust_order_handling_inst();
}
inline ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum ExecutionReport::cust_order_handling_inst() const {
  return static_cast< ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum >(cust_order_handling_inst_);
}
inline void ExecutionReport::set_cust_order_handling_inst(::SingleGeneralOrderHandling::CustOrderHandlingInstEnum value) {
  assert(::SingleGeneralOrderHandling::CustOrderHandlingInstEnum_IsValid(value));
  set_has_cust_order_handling_inst();
  cust_order_handling_inst_ = value;
}

// optional .Common.DiscretionInstructions discretion_instructions = 147;
inline bool ExecutionReport::has_discretion_instructions() const {
  return (_has_bits_[4] & 0x00040000u) != 0;
}
inline void ExecutionReport::set_has_discretion_instructions() {
  _has_bits_[4] |= 0x00040000u;
}
inline void ExecutionReport::clear_has_discretion_instructions() {
  _has_bits_[4] &= ~0x00040000u;
}
inline void ExecutionReport::clear_discretion_instructions() {
  if (discretion_instructions_ != NULL) discretion_instructions_->::Common::DiscretionInstructions::Clear();
  clear_has_discretion_instructions();
}
inline const ::Common::DiscretionInstructions& ExecutionReport::discretion_instructions() const {
  return discretion_instructions_ != NULL ? *discretion_instructions_ : *default_instance_->discretion_instructions_;
}
inline ::Common::DiscretionInstructions* ExecutionReport::mutable_discretion_instructions() {
  set_has_discretion_instructions();
  if (discretion_instructions_ == NULL) discretion_instructions_ = new ::Common::DiscretionInstructions;
  return discretion_instructions_;
}
inline ::Common::DiscretionInstructions* ExecutionReport::release_discretion_instructions() {
  clear_has_discretion_instructions();
  ::Common::DiscretionInstructions* temp = discretion_instructions_;
  discretion_instructions_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_discretion_instructions(::Common::DiscretionInstructions* discretion_instructions) {
  delete discretion_instructions_;
  discretion_instructions_ = discretion_instructions;
  if (discretion_instructions) {
    set_has_discretion_instructions();
  } else {
    clear_has_discretion_instructions();
  }
}

// optional sfixed64 discretion_price = 148;
inline bool ExecutionReport::has_discretion_price() const {
  return (_has_bits_[4] & 0x00080000u) != 0;
}
inline void ExecutionReport::set_has_discretion_price() {
  _has_bits_[4] |= 0x00080000u;
}
inline void ExecutionReport::clear_has_discretion_price() {
  _has_bits_[4] &= ~0x00080000u;
}
inline void ExecutionReport::clear_discretion_price() {
  discretion_price_ = GOOGLE_LONGLONG(0);
  clear_has_discretion_price();
}
inline ::google::protobuf::int64 ExecutionReport::discretion_price() const {
  return discretion_price_;
}
inline void ExecutionReport::set_discretion_price(::google::protobuf::int64 value) {
  set_has_discretion_price();
  discretion_price_ = value;
}

// optional sfixed32 discretion_price_exponent = 149;
inline bool ExecutionReport::has_discretion_price_exponent() const {
  return (_has_bits_[4] & 0x00100000u) != 0;
}
inline void ExecutionReport::set_has_discretion_price_exponent() {
  _has_bits_[4] |= 0x00100000u;
}
inline void ExecutionReport::clear_has_discretion_price_exponent() {
  _has_bits_[4] &= ~0x00100000u;
}
inline void ExecutionReport::clear_discretion_price_exponent() {
  discretion_price_exponent_ = 0;
  clear_has_discretion_price_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::discretion_price_exponent() const {
  return discretion_price_exponent_;
}
inline void ExecutionReport::set_discretion_price_exponent(::google::protobuf::int32 value) {
  set_has_discretion_price_exponent();
  discretion_price_exponent_ = value;
}

// optional .Common.DisplayInstruction display_instruction = 150;
inline bool ExecutionReport::has_display_instruction() const {
  return (_has_bits_[4] & 0x00200000u) != 0;
}
inline void ExecutionReport::set_has_display_instruction() {
  _has_bits_[4] |= 0x00200000u;
}
inline void ExecutionReport::clear_has_display_instruction() {
  _has_bits_[4] &= ~0x00200000u;
}
inline void ExecutionReport::clear_display_instruction() {
  if (display_instruction_ != NULL) display_instruction_->::Common::DisplayInstruction::Clear();
  clear_has_display_instruction();
}
inline const ::Common::DisplayInstruction& ExecutionReport::display_instruction() const {
  return display_instruction_ != NULL ? *display_instruction_ : *default_instance_->display_instruction_;
}
inline ::Common::DisplayInstruction* ExecutionReport::mutable_display_instruction() {
  set_has_display_instruction();
  if (display_instruction_ == NULL) display_instruction_ = new ::Common::DisplayInstruction;
  return display_instruction_;
}
inline ::Common::DisplayInstruction* ExecutionReport::release_display_instruction() {
  clear_has_display_instruction();
  ::Common::DisplayInstruction* temp = display_instruction_;
  display_instruction_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_display_instruction(::Common::DisplayInstruction* display_instruction) {
  delete display_instruction_;
  display_instruction_ = display_instruction;
  if (display_instruction) {
    set_has_display_instruction();
  } else {
    clear_has_display_instruction();
  }
}

// optional sfixed64 end_accrued_interest_amt = 151;
inline bool ExecutionReport::has_end_accrued_interest_amt() const {
  return (_has_bits_[4] & 0x00400000u) != 0;
}
inline void ExecutionReport::set_has_end_accrued_interest_amt() {
  _has_bits_[4] |= 0x00400000u;
}
inline void ExecutionReport::clear_has_end_accrued_interest_amt() {
  _has_bits_[4] &= ~0x00400000u;
}
inline void ExecutionReport::clear_end_accrued_interest_amt() {
  end_accrued_interest_amt_ = GOOGLE_LONGLONG(0);
  clear_has_end_accrued_interest_amt();
}
inline ::google::protobuf::int64 ExecutionReport::end_accrued_interest_amt() const {
  return end_accrued_interest_amt_;
}
inline void ExecutionReport::set_end_accrued_interest_amt(::google::protobuf::int64 value) {
  set_has_end_accrued_interest_amt();
  end_accrued_interest_amt_ = value;
}

// optional sfixed32 end_accrued_interest_amt_exponent = 152;
inline bool ExecutionReport::has_end_accrued_interest_amt_exponent() const {
  return (_has_bits_[4] & 0x00800000u) != 0;
}
inline void ExecutionReport::set_has_end_accrued_interest_amt_exponent() {
  _has_bits_[4] |= 0x00800000u;
}
inline void ExecutionReport::clear_has_end_accrued_interest_amt_exponent() {
  _has_bits_[4] &= ~0x00800000u;
}
inline void ExecutionReport::clear_end_accrued_interest_amt_exponent() {
  end_accrued_interest_amt_exponent_ = 0;
  clear_has_end_accrued_interest_amt_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::end_accrued_interest_amt_exponent() const {
  return end_accrued_interest_amt_exponent_;
}
inline void ExecutionReport::set_end_accrued_interest_amt_exponent(::google::protobuf::int32 value) {
  set_has_end_accrued_interest_amt_exponent();
  end_accrued_interest_amt_exponent_ = value;
}

// optional sfixed64 end_cash = 153;
inline bool ExecutionReport::has_end_cash() const {
  return (_has_bits_[4] & 0x01000000u) != 0;
}
inline void ExecutionReport::set_has_end_cash() {
  _has_bits_[4] |= 0x01000000u;
}
inline void ExecutionReport::clear_has_end_cash() {
  _has_bits_[4] &= ~0x01000000u;
}
inline void ExecutionReport::clear_end_cash() {
  end_cash_ = GOOGLE_LONGLONG(0);
  clear_has_end_cash();
}
inline ::google::protobuf::int64 ExecutionReport::end_cash() const {
  return end_cash_;
}
inline void ExecutionReport::set_end_cash(::google::protobuf::int64 value) {
  set_has_end_cash();
  end_cash_ = value;
}

// optional sfixed32 end_cash_exponent = 154;
inline bool ExecutionReport::has_end_cash_exponent() const {
  return (_has_bits_[4] & 0x02000000u) != 0;
}
inline void ExecutionReport::set_has_end_cash_exponent() {
  _has_bits_[4] |= 0x02000000u;
}
inline void ExecutionReport::clear_has_end_cash_exponent() {
  _has_bits_[4] &= ~0x02000000u;
}
inline void ExecutionReport::clear_end_cash_exponent() {
  end_cash_exponent_ = 0;
  clear_has_end_cash_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::end_cash_exponent() const {
  return end_cash_exponent_;
}
inline void ExecutionReport::set_end_cash_exponent(::google::protobuf::int32 value) {
  set_has_end_cash_exponent();
  end_cash_exponent_ = value;
}

// optional .Common.FinancingDetails financing_details = 155;
inline bool ExecutionReport::has_financing_details() const {
  return (_has_bits_[4] & 0x04000000u) != 0;
}
inline void ExecutionReport::set_has_financing_details() {
  _has_bits_[4] |= 0x04000000u;
}
inline void ExecutionReport::clear_has_financing_details() {
  _has_bits_[4] &= ~0x04000000u;
}
inline void ExecutionReport::clear_financing_details() {
  if (financing_details_ != NULL) financing_details_->::Common::FinancingDetails::Clear();
  clear_has_financing_details();
}
inline const ::Common::FinancingDetails& ExecutionReport::financing_details() const {
  return financing_details_ != NULL ? *financing_details_ : *default_instance_->financing_details_;
}
inline ::Common::FinancingDetails* ExecutionReport::mutable_financing_details() {
  set_has_financing_details();
  if (financing_details_ == NULL) financing_details_ = new ::Common::FinancingDetails;
  return financing_details_;
}
inline ::Common::FinancingDetails* ExecutionReport::release_financing_details() {
  clear_has_financing_details();
  ::Common::FinancingDetails* temp = financing_details_;
  financing_details_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_financing_details(::Common::FinancingDetails* financing_details) {
  delete financing_details_;
  financing_details_ = financing_details;
  if (financing_details) {
    set_has_financing_details();
  } else {
    clear_has_financing_details();
  }
}

// optional string host_cross_id = 156;
inline bool ExecutionReport::has_host_cross_id() const {
  return (_has_bits_[4] & 0x08000000u) != 0;
}
inline void ExecutionReport::set_has_host_cross_id() {
  _has_bits_[4] |= 0x08000000u;
}
inline void ExecutionReport::clear_has_host_cross_id() {
  _has_bits_[4] &= ~0x08000000u;
}
inline void ExecutionReport::clear_host_cross_id() {
  if (host_cross_id_ != &::google::protobuf::internal::kEmptyString) {
    host_cross_id_->clear();
  }
  clear_has_host_cross_id();
}
inline const ::std::string& ExecutionReport::host_cross_id() const {
  return *host_cross_id_;
}
inline void ExecutionReport::set_host_cross_id(const ::std::string& value) {
  set_has_host_cross_id();
  if (host_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    host_cross_id_ = new ::std::string;
  }
  host_cross_id_->assign(value);
}
inline void ExecutionReport::set_host_cross_id(const char* value) {
  set_has_host_cross_id();
  if (host_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    host_cross_id_ = new ::std::string;
  }
  host_cross_id_->assign(value);
}
inline void ExecutionReport::set_host_cross_id(const char* value, size_t size) {
  set_has_host_cross_id();
  if (host_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    host_cross_id_ = new ::std::string;
  }
  host_cross_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_host_cross_id() {
  set_has_host_cross_id();
  if (host_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    host_cross_id_ = new ::std::string;
  }
  return host_cross_id_;
}
inline ::std::string* ExecutionReport::release_host_cross_id() {
  clear_has_host_cross_id();
  if (host_cross_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_cross_id_;
    host_cross_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_host_cross_id(::std::string* host_cross_id) {
  if (host_cross_id_ != &::google::protobuf::internal::kEmptyString) {
    delete host_cross_id_;
  }
  if (host_cross_id) {
    set_has_host_cross_id();
    host_cross_id_ = host_cross_id;
  } else {
    clear_has_host_cross_id();
    host_cross_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.InstrmtLegExecGrp instrmt_leg_exec_grp = 157;
inline int ExecutionReport::instrmt_leg_exec_grp_size() const {
  return instrmt_leg_exec_grp_.size();
}
inline void ExecutionReport::clear_instrmt_leg_exec_grp() {
  instrmt_leg_exec_grp_.Clear();
}
inline const ::Common::InstrmtLegExecGrp& ExecutionReport::instrmt_leg_exec_grp(int index) const {
  return instrmt_leg_exec_grp_.Get(index);
}
inline ::Common::InstrmtLegExecGrp* ExecutionReport::mutable_instrmt_leg_exec_grp(int index) {
  return instrmt_leg_exec_grp_.Mutable(index);
}
inline ::Common::InstrmtLegExecGrp* ExecutionReport::add_instrmt_leg_exec_grp() {
  return instrmt_leg_exec_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegExecGrp >&
ExecutionReport::instrmt_leg_exec_grp() const {
  return instrmt_leg_exec_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegExecGrp >*
ExecutionReport::mutable_instrmt_leg_exec_grp() {
  return &instrmt_leg_exec_grp_;
}

// optional sfixed64 interest_at_maturity = 158;
inline bool ExecutionReport::has_interest_at_maturity() const {
  return (_has_bits_[4] & 0x20000000u) != 0;
}
inline void ExecutionReport::set_has_interest_at_maturity() {
  _has_bits_[4] |= 0x20000000u;
}
inline void ExecutionReport::clear_has_interest_at_maturity() {
  _has_bits_[4] &= ~0x20000000u;
}
inline void ExecutionReport::clear_interest_at_maturity() {
  interest_at_maturity_ = GOOGLE_LONGLONG(0);
  clear_has_interest_at_maturity();
}
inline ::google::protobuf::int64 ExecutionReport::interest_at_maturity() const {
  return interest_at_maturity_;
}
inline void ExecutionReport::set_interest_at_maturity(::google::protobuf::int64 value) {
  set_has_interest_at_maturity();
  interest_at_maturity_ = value;
}

// optional sfixed32 interest_at_maturity_exponent = 159;
inline bool ExecutionReport::has_interest_at_maturity_exponent() const {
  return (_has_bits_[4] & 0x40000000u) != 0;
}
inline void ExecutionReport::set_has_interest_at_maturity_exponent() {
  _has_bits_[4] |= 0x40000000u;
}
inline void ExecutionReport::clear_has_interest_at_maturity_exponent() {
  _has_bits_[4] &= ~0x40000000u;
}
inline void ExecutionReport::clear_interest_at_maturity_exponent() {
  interest_at_maturity_exponent_ = 0;
  clear_has_interest_at_maturity_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::interest_at_maturity_exponent() const {
  return interest_at_maturity_exponent_;
}
inline void ExecutionReport::set_interest_at_maturity_exponent(::google::protobuf::int32 value) {
  set_has_interest_at_maturity_exponent();
  interest_at_maturity_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.LastLiquidityIndEnum last_liquidity_ind = 160;
inline bool ExecutionReport::has_last_liquidity_ind() const {
  return (_has_bits_[4] & 0x80000000u) != 0;
}
inline void ExecutionReport::set_has_last_liquidity_ind() {
  _has_bits_[4] |= 0x80000000u;
}
inline void ExecutionReport::clear_has_last_liquidity_ind() {
  _has_bits_[4] &= ~0x80000000u;
}
inline void ExecutionReport::clear_last_liquidity_ind() {
  last_liquidity_ind_ = 0;
  clear_has_last_liquidity_ind();
}
inline ::SingleGeneralOrderHandling::LastLiquidityIndEnum ExecutionReport::last_liquidity_ind() const {
  return static_cast< ::SingleGeneralOrderHandling::LastLiquidityIndEnum >(last_liquidity_ind_);
}
inline void ExecutionReport::set_last_liquidity_ind(::SingleGeneralOrderHandling::LastLiquidityIndEnum value) {
  assert(::SingleGeneralOrderHandling::LastLiquidityIndEnum_IsValid(value));
  set_has_last_liquidity_ind();
  last_liquidity_ind_ = value;
}

// optional sfixed64 last_par_px = 161;
inline bool ExecutionReport::has_last_par_px() const {
  return (_has_bits_[5] & 0x00000001u) != 0;
}
inline void ExecutionReport::set_has_last_par_px() {
  _has_bits_[5] |= 0x00000001u;
}
inline void ExecutionReport::clear_has_last_par_px() {
  _has_bits_[5] &= ~0x00000001u;
}
inline void ExecutionReport::clear_last_par_px() {
  last_par_px_ = GOOGLE_LONGLONG(0);
  clear_has_last_par_px();
}
inline ::google::protobuf::int64 ExecutionReport::last_par_px() const {
  return last_par_px_;
}
inline void ExecutionReport::set_last_par_px(::google::protobuf::int64 value) {
  set_has_last_par_px();
  last_par_px_ = value;
}

// optional sfixed32 last_par_px_exponent = 162;
inline bool ExecutionReport::has_last_par_px_exponent() const {
  return (_has_bits_[5] & 0x00000002u) != 0;
}
inline void ExecutionReport::set_has_last_par_px_exponent() {
  _has_bits_[5] |= 0x00000002u;
}
inline void ExecutionReport::clear_has_last_par_px_exponent() {
  _has_bits_[5] &= ~0x00000002u;
}
inline void ExecutionReport::clear_last_par_px_exponent() {
  last_par_px_exponent_ = 0;
  clear_has_last_par_px_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::last_par_px_exponent() const {
  return last_par_px_exponent_;
}
inline void ExecutionReport::set_last_par_px_exponent(::google::protobuf::int32 value) {
  set_has_last_par_px_exponent();
  last_par_px_exponent_ = value;
}

// optional bool last_rpt_requested = 163;
inline bool ExecutionReport::has_last_rpt_requested() const {
  return (_has_bits_[5] & 0x00000004u) != 0;
}
inline void ExecutionReport::set_has_last_rpt_requested() {
  _has_bits_[5] |= 0x00000004u;
}
inline void ExecutionReport::clear_has_last_rpt_requested() {
  _has_bits_[5] &= ~0x00000004u;
}
inline void ExecutionReport::clear_last_rpt_requested() {
  last_rpt_requested_ = false;
  clear_has_last_rpt_requested();
}
inline bool ExecutionReport::last_rpt_requested() const {
  return last_rpt_requested_;
}
inline void ExecutionReport::set_last_rpt_requested(bool value) {
  set_has_last_rpt_requested();
  last_rpt_requested_ = value;
}

// optional sfixed64 last_swap_points = 164;
inline bool ExecutionReport::has_last_swap_points() const {
  return (_has_bits_[5] & 0x00000008u) != 0;
}
inline void ExecutionReport::set_has_last_swap_points() {
  _has_bits_[5] |= 0x00000008u;
}
inline void ExecutionReport::clear_has_last_swap_points() {
  _has_bits_[5] &= ~0x00000008u;
}
inline void ExecutionReport::clear_last_swap_points() {
  last_swap_points_ = GOOGLE_LONGLONG(0);
  clear_has_last_swap_points();
}
inline ::google::protobuf::int64 ExecutionReport::last_swap_points() const {
  return last_swap_points_;
}
inline void ExecutionReport::set_last_swap_points(::google::protobuf::int64 value) {
  set_has_last_swap_points();
  last_swap_points_ = value;
}

// optional sfixed32 last_swap_points_exponent = 165;
inline bool ExecutionReport::has_last_swap_points_exponent() const {
  return (_has_bits_[5] & 0x00000010u) != 0;
}
inline void ExecutionReport::set_has_last_swap_points_exponent() {
  _has_bits_[5] |= 0x00000010u;
}
inline void ExecutionReport::clear_has_last_swap_points_exponent() {
  _has_bits_[5] &= ~0x00000010u;
}
inline void ExecutionReport::clear_last_swap_points_exponent() {
  last_swap_points_exponent_ = 0;
  clear_has_last_swap_points_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::last_swap_points_exponent() const {
  return last_swap_points_exponent_;
}
inline void ExecutionReport::set_last_swap_points_exponent(::google::protobuf::int32 value) {
  set_has_last_swap_points_exponent();
  last_swap_points_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.LotTypeEnum lot_type = 166;
inline bool ExecutionReport::has_lot_type() const {
  return (_has_bits_[5] & 0x00000020u) != 0;
}
inline void ExecutionReport::set_has_lot_type() {
  _has_bits_[5] |= 0x00000020u;
}
inline void ExecutionReport::clear_has_lot_type() {
  _has_bits_[5] &= ~0x00000020u;
}
inline void ExecutionReport::clear_lot_type() {
  lot_type_ = 0;
  clear_has_lot_type();
}
inline ::SingleGeneralOrderHandling::LotTypeEnum ExecutionReport::lot_type() const {
  return static_cast< ::SingleGeneralOrderHandling::LotTypeEnum >(lot_type_);
}
inline void ExecutionReport::set_lot_type(::SingleGeneralOrderHandling::LotTypeEnum value) {
  assert(::SingleGeneralOrderHandling::LotTypeEnum_IsValid(value));
  set_has_lot_type();
  lot_type_ = value;
}

// optional bool manual_order_indicator = 167;
inline bool ExecutionReport::has_manual_order_indicator() const {
  return (_has_bits_[5] & 0x00000040u) != 0;
}
inline void ExecutionReport::set_has_manual_order_indicator() {
  _has_bits_[5] |= 0x00000040u;
}
inline void ExecutionReport::clear_has_manual_order_indicator() {
  _has_bits_[5] &= ~0x00000040u;
}
inline void ExecutionReport::clear_manual_order_indicator() {
  manual_order_indicator_ = false;
  clear_has_manual_order_indicator();
}
inline bool ExecutionReport::manual_order_indicator() const {
  return manual_order_indicator_;
}
inline void ExecutionReport::set_manual_order_indicator(bool value) {
  set_has_manual_order_indicator();
  manual_order_indicator_ = value;
}

// optional string mass_status_req_id = 168;
inline bool ExecutionReport::has_mass_status_req_id() const {
  return (_has_bits_[5] & 0x00000080u) != 0;
}
inline void ExecutionReport::set_has_mass_status_req_id() {
  _has_bits_[5] |= 0x00000080u;
}
inline void ExecutionReport::clear_has_mass_status_req_id() {
  _has_bits_[5] &= ~0x00000080u;
}
inline void ExecutionReport::clear_mass_status_req_id() {
  if (mass_status_req_id_ != &::google::protobuf::internal::kEmptyString) {
    mass_status_req_id_->clear();
  }
  clear_has_mass_status_req_id();
}
inline const ::std::string& ExecutionReport::mass_status_req_id() const {
  return *mass_status_req_id_;
}
inline void ExecutionReport::set_mass_status_req_id(const ::std::string& value) {
  set_has_mass_status_req_id();
  if (mass_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    mass_status_req_id_ = new ::std::string;
  }
  mass_status_req_id_->assign(value);
}
inline void ExecutionReport::set_mass_status_req_id(const char* value) {
  set_has_mass_status_req_id();
  if (mass_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    mass_status_req_id_ = new ::std::string;
  }
  mass_status_req_id_->assign(value);
}
inline void ExecutionReport::set_mass_status_req_id(const char* value, size_t size) {
  set_has_mass_status_req_id();
  if (mass_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    mass_status_req_id_ = new ::std::string;
  }
  mass_status_req_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_mass_status_req_id() {
  set_has_mass_status_req_id();
  if (mass_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    mass_status_req_id_ = new ::std::string;
  }
  return mass_status_req_id_;
}
inline ::std::string* ExecutionReport::release_mass_status_req_id() {
  clear_has_mass_status_req_id();
  if (mass_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mass_status_req_id_;
    mass_status_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_mass_status_req_id(::std::string* mass_status_req_id) {
  if (mass_status_req_id_ != &::google::protobuf::internal::kEmptyString) {
    delete mass_status_req_id_;
  }
  if (mass_status_req_id) {
    set_has_mass_status_req_id();
    mass_status_req_id_ = mass_status_req_id;
  } else {
    clear_has_mass_status_req_id();
    mass_status_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 match_increment = 169;
inline bool ExecutionReport::has_match_increment() const {
  return (_has_bits_[5] & 0x00000100u) != 0;
}
inline void ExecutionReport::set_has_match_increment() {
  _has_bits_[5] |= 0x00000100u;
}
inline void ExecutionReport::clear_has_match_increment() {
  _has_bits_[5] &= ~0x00000100u;
}
inline void ExecutionReport::clear_match_increment() {
  match_increment_ = GOOGLE_LONGLONG(0);
  clear_has_match_increment();
}
inline ::google::protobuf::int64 ExecutionReport::match_increment() const {
  return match_increment_;
}
inline void ExecutionReport::set_match_increment(::google::protobuf::int64 value) {
  set_has_match_increment();
  match_increment_ = value;
}

// optional sfixed32 match_increment_exponent = 170;
inline bool ExecutionReport::has_match_increment_exponent() const {
  return (_has_bits_[5] & 0x00000200u) != 0;
}
inline void ExecutionReport::set_has_match_increment_exponent() {
  _has_bits_[5] |= 0x00000200u;
}
inline void ExecutionReport::clear_has_match_increment_exponent() {
  _has_bits_[5] &= ~0x00000200u;
}
inline void ExecutionReport::clear_match_increment_exponent() {
  match_increment_exponent_ = 0;
  clear_has_match_increment_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::match_increment_exponent() const {
  return match_increment_exponent_;
}
inline void ExecutionReport::set_match_increment_exponent(::google::protobuf::int32 value) {
  set_has_match_increment_exponent();
  match_increment_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.MatchTypeEnum match_type = 171;
inline bool ExecutionReport::has_match_type() const {
  return (_has_bits_[5] & 0x00000400u) != 0;
}
inline void ExecutionReport::set_has_match_type() {
  _has_bits_[5] |= 0x00000400u;
}
inline void ExecutionReport::clear_has_match_type() {
  _has_bits_[5] &= ~0x00000400u;
}
inline void ExecutionReport::clear_match_type() {
  match_type_ = 0;
  clear_has_match_type();
}
inline ::SingleGeneralOrderHandling::MatchTypeEnum ExecutionReport::match_type() const {
  return static_cast< ::SingleGeneralOrderHandling::MatchTypeEnum >(match_type_);
}
inline void ExecutionReport::set_match_type(::SingleGeneralOrderHandling::MatchTypeEnum value) {
  assert(::SingleGeneralOrderHandling::MatchTypeEnum_IsValid(value));
  set_has_match_type();
  match_type_ = value;
}

// optional sfixed64 max_price_levels = 172;
inline bool ExecutionReport::has_max_price_levels() const {
  return (_has_bits_[5] & 0x00000800u) != 0;
}
inline void ExecutionReport::set_has_max_price_levels() {
  _has_bits_[5] |= 0x00000800u;
}
inline void ExecutionReport::clear_has_max_price_levels() {
  _has_bits_[5] &= ~0x00000800u;
}
inline void ExecutionReport::clear_max_price_levels() {
  max_price_levels_ = GOOGLE_LONGLONG(0);
  clear_has_max_price_levels();
}
inline ::google::protobuf::int64 ExecutionReport::max_price_levels() const {
  return max_price_levels_;
}
inline void ExecutionReport::set_max_price_levels(::google::protobuf::int64 value) {
  set_has_max_price_levels();
  max_price_levels_ = value;
}

// repeated .Common.MiscFeesGrp misc_fees_grp = 173;
inline int ExecutionReport::misc_fees_grp_size() const {
  return misc_fees_grp_.size();
}
inline void ExecutionReport::clear_misc_fees_grp() {
  misc_fees_grp_.Clear();
}
inline const ::Common::MiscFeesGrp& ExecutionReport::misc_fees_grp(int index) const {
  return misc_fees_grp_.Get(index);
}
inline ::Common::MiscFeesGrp* ExecutionReport::mutable_misc_fees_grp(int index) {
  return misc_fees_grp_.Mutable(index);
}
inline ::Common::MiscFeesGrp* ExecutionReport::add_misc_fees_grp() {
  return misc_fees_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::MiscFeesGrp >&
ExecutionReport::misc_fees_grp() const {
  return misc_fees_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::MiscFeesGrp >*
ExecutionReport::mutable_misc_fees_grp() {
  return &misc_fees_grp_;
}

// optional string ord_status_req_id = 174;
inline bool ExecutionReport::has_ord_status_req_id() const {
  return (_has_bits_[5] & 0x00002000u) != 0;
}
inline void ExecutionReport::set_has_ord_status_req_id() {
  _has_bits_[5] |= 0x00002000u;
}
inline void ExecutionReport::clear_has_ord_status_req_id() {
  _has_bits_[5] &= ~0x00002000u;
}
inline void ExecutionReport::clear_ord_status_req_id() {
  if (ord_status_req_id_ != &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_->clear();
  }
  clear_has_ord_status_req_id();
}
inline const ::std::string& ExecutionReport::ord_status_req_id() const {
  return *ord_status_req_id_;
}
inline void ExecutionReport::set_ord_status_req_id(const ::std::string& value) {
  set_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_ = new ::std::string;
  }
  ord_status_req_id_->assign(value);
}
inline void ExecutionReport::set_ord_status_req_id(const char* value) {
  set_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_ = new ::std::string;
  }
  ord_status_req_id_->assign(value);
}
inline void ExecutionReport::set_ord_status_req_id(const char* value, size_t size) {
  set_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_ = new ::std::string;
  }
  ord_status_req_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_ord_status_req_id() {
  set_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_ = new ::std::string;
  }
  return ord_status_req_id_;
}
inline ::std::string* ExecutionReport::release_ord_status_req_id() {
  clear_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ord_status_req_id_;
    ord_status_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_ord_status_req_id(::std::string* ord_status_req_id) {
  if (ord_status_req_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ord_status_req_id_;
  }
  if (ord_status_req_id) {
    set_has_ord_status_req_id();
    ord_status_req_id_ = ord_status_req_id;
  } else {
    clear_has_ord_status_req_id();
    ord_status_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.OrderCategoryEnum order_category = 175;
inline bool ExecutionReport::has_order_category() const {
  return (_has_bits_[5] & 0x00004000u) != 0;
}
inline void ExecutionReport::set_has_order_category() {
  _has_bits_[5] |= 0x00004000u;
}
inline void ExecutionReport::clear_has_order_category() {
  _has_bits_[5] &= ~0x00004000u;
}
inline void ExecutionReport::clear_order_category() {
  order_category_ = 0;
  clear_has_order_category();
}
inline ::SingleGeneralOrderHandling::OrderCategoryEnum ExecutionReport::order_category() const {
  return static_cast< ::SingleGeneralOrderHandling::OrderCategoryEnum >(order_category_);
}
inline void ExecutionReport::set_order_category(::SingleGeneralOrderHandling::OrderCategoryEnum value) {
  assert(::SingleGeneralOrderHandling::OrderCategoryEnum_IsValid(value));
  set_has_order_category();
  order_category_ = value;
}

// optional .SingleGeneralOrderHandling.OrderHandlingInstSourceEnum order_handling_inst_source = 176;
inline bool ExecutionReport::has_order_handling_inst_source() const {
  return (_has_bits_[5] & 0x00008000u) != 0;
}
inline void ExecutionReport::set_has_order_handling_inst_source() {
  _has_bits_[5] |= 0x00008000u;
}
inline void ExecutionReport::clear_has_order_handling_inst_source() {
  _has_bits_[5] &= ~0x00008000u;
}
inline void ExecutionReport::clear_order_handling_inst_source() {
  order_handling_inst_source_ = 0;
  clear_has_order_handling_inst_source();
}
inline ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum ExecutionReport::order_handling_inst_source() const {
  return static_cast< ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum >(order_handling_inst_source_);
}
inline void ExecutionReport::set_order_handling_inst_source(::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum value) {
  assert(::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum_IsValid(value));
  set_has_order_handling_inst_source();
  order_handling_inst_source_ = value;
}

// optional sfixed64 participation_rate = 177;
inline bool ExecutionReport::has_participation_rate() const {
  return (_has_bits_[5] & 0x00010000u) != 0;
}
inline void ExecutionReport::set_has_participation_rate() {
  _has_bits_[5] |= 0x00010000u;
}
inline void ExecutionReport::clear_has_participation_rate() {
  _has_bits_[5] &= ~0x00010000u;
}
inline void ExecutionReport::clear_participation_rate() {
  participation_rate_ = GOOGLE_LONGLONG(0);
  clear_has_participation_rate();
}
inline ::google::protobuf::int64 ExecutionReport::participation_rate() const {
  return participation_rate_;
}
inline void ExecutionReport::set_participation_rate(::google::protobuf::int64 value) {
  set_has_participation_rate();
  participation_rate_ = value;
}

// optional sfixed32 participation_rate_exponent = 178;
inline bool ExecutionReport::has_participation_rate_exponent() const {
  return (_has_bits_[5] & 0x00020000u) != 0;
}
inline void ExecutionReport::set_has_participation_rate_exponent() {
  _has_bits_[5] |= 0x00020000u;
}
inline void ExecutionReport::clear_has_participation_rate_exponent() {
  _has_bits_[5] &= ~0x00020000u;
}
inline void ExecutionReport::clear_participation_rate_exponent() {
  participation_rate_exponent_ = 0;
  clear_has_participation_rate_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::participation_rate_exponent() const {
  return participation_rate_exponent_;
}
inline void ExecutionReport::set_participation_rate_exponent(::google::protobuf::int32 value) {
  set_has_participation_rate_exponent();
  participation_rate_exponent_ = value;
}

// optional .Common.PegInstructions peg_instructions = 179;
inline bool ExecutionReport::has_peg_instructions() const {
  return (_has_bits_[5] & 0x00040000u) != 0;
}
inline void ExecutionReport::set_has_peg_instructions() {
  _has_bits_[5] |= 0x00040000u;
}
inline void ExecutionReport::clear_has_peg_instructions() {
  _has_bits_[5] &= ~0x00040000u;
}
inline void ExecutionReport::clear_peg_instructions() {
  if (peg_instructions_ != NULL) peg_instructions_->::Common::PegInstructions::Clear();
  clear_has_peg_instructions();
}
inline const ::Common::PegInstructions& ExecutionReport::peg_instructions() const {
  return peg_instructions_ != NULL ? *peg_instructions_ : *default_instance_->peg_instructions_;
}
inline ::Common::PegInstructions* ExecutionReport::mutable_peg_instructions() {
  set_has_peg_instructions();
  if (peg_instructions_ == NULL) peg_instructions_ = new ::Common::PegInstructions;
  return peg_instructions_;
}
inline ::Common::PegInstructions* ExecutionReport::release_peg_instructions() {
  clear_has_peg_instructions();
  ::Common::PegInstructions* temp = peg_instructions_;
  peg_instructions_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_peg_instructions(::Common::PegInstructions* peg_instructions) {
  delete peg_instructions_;
  peg_instructions_ = peg_instructions;
  if (peg_instructions) {
    set_has_peg_instructions();
  } else {
    clear_has_peg_instructions();
  }
}

// optional sfixed64 pegged_price = 180;
inline bool ExecutionReport::has_pegged_price() const {
  return (_has_bits_[5] & 0x00080000u) != 0;
}
inline void ExecutionReport::set_has_pegged_price() {
  _has_bits_[5] |= 0x00080000u;
}
inline void ExecutionReport::clear_has_pegged_price() {
  _has_bits_[5] &= ~0x00080000u;
}
inline void ExecutionReport::clear_pegged_price() {
  pegged_price_ = GOOGLE_LONGLONG(0);
  clear_has_pegged_price();
}
inline ::google::protobuf::int64 ExecutionReport::pegged_price() const {
  return pegged_price_;
}
inline void ExecutionReport::set_pegged_price(::google::protobuf::int64 value) {
  set_has_pegged_price();
  pegged_price_ = value;
}

// optional sfixed32 pegged_price_exponent = 181;
inline bool ExecutionReport::has_pegged_price_exponent() const {
  return (_has_bits_[5] & 0x00100000u) != 0;
}
inline void ExecutionReport::set_has_pegged_price_exponent() {
  _has_bits_[5] |= 0x00100000u;
}
inline void ExecutionReport::clear_has_pegged_price_exponent() {
  _has_bits_[5] &= ~0x00100000u;
}
inline void ExecutionReport::clear_pegged_price_exponent() {
  pegged_price_exponent_ = 0;
  clear_has_pegged_price_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::pegged_price_exponent() const {
  return pegged_price_exponent_;
}
inline void ExecutionReport::set_pegged_price_exponent(::google::protobuf::int32 value) {
  set_has_pegged_price_exponent();
  pegged_price_exponent_ = value;
}

// optional sfixed64 pegged_ref_price = 182;
inline bool ExecutionReport::has_pegged_ref_price() const {
  return (_has_bits_[5] & 0x00200000u) != 0;
}
inline void ExecutionReport::set_has_pegged_ref_price() {
  _has_bits_[5] |= 0x00200000u;
}
inline void ExecutionReport::clear_has_pegged_ref_price() {
  _has_bits_[5] &= ~0x00200000u;
}
inline void ExecutionReport::clear_pegged_ref_price() {
  pegged_ref_price_ = GOOGLE_LONGLONG(0);
  clear_has_pegged_ref_price();
}
inline ::google::protobuf::int64 ExecutionReport::pegged_ref_price() const {
  return pegged_ref_price_;
}
inline void ExecutionReport::set_pegged_ref_price(::google::protobuf::int64 value) {
  set_has_pegged_ref_price();
  pegged_ref_price_ = value;
}

// optional sfixed32 pegged_ref_price_exponent = 183;
inline bool ExecutionReport::has_pegged_ref_price_exponent() const {
  return (_has_bits_[5] & 0x00400000u) != 0;
}
inline void ExecutionReport::set_has_pegged_ref_price_exponent() {
  _has_bits_[5] |= 0x00400000u;
}
inline void ExecutionReport::clear_has_pegged_ref_price_exponent() {
  _has_bits_[5] &= ~0x00400000u;
}
inline void ExecutionReport::clear_pegged_ref_price_exponent() {
  pegged_ref_price_exponent_ = 0;
  clear_has_pegged_ref_price_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::pegged_ref_price_exponent() const {
  return pegged_ref_price_exponent_;
}
inline void ExecutionReport::set_pegged_ref_price_exponent(::google::protobuf::int32 value) {
  set_has_pegged_ref_price_exponent();
  pegged_ref_price_exponent_ = value;
}

// optional bool pre_trade_anonymity = 184;
inline bool ExecutionReport::has_pre_trade_anonymity() const {
  return (_has_bits_[5] & 0x00800000u) != 0;
}
inline void ExecutionReport::set_has_pre_trade_anonymity() {
  _has_bits_[5] |= 0x00800000u;
}
inline void ExecutionReport::clear_has_pre_trade_anonymity() {
  _has_bits_[5] &= ~0x00800000u;
}
inline void ExecutionReport::clear_pre_trade_anonymity() {
  pre_trade_anonymity_ = false;
  clear_has_pre_trade_anonymity();
}
inline bool ExecutionReport::pre_trade_anonymity() const {
  return pre_trade_anonymity_;
}
inline void ExecutionReport::set_pre_trade_anonymity(bool value) {
  set_has_pre_trade_anonymity();
  pre_trade_anonymity_ = value;
}

// optional .SingleGeneralOrderHandling.PriceProtectionScopeEnum price_protection_scope = 185;
inline bool ExecutionReport::has_price_protection_scope() const {
  return (_has_bits_[5] & 0x01000000u) != 0;
}
inline void ExecutionReport::set_has_price_protection_scope() {
  _has_bits_[5] |= 0x01000000u;
}
inline void ExecutionReport::clear_has_price_protection_scope() {
  _has_bits_[5] &= ~0x01000000u;
}
inline void ExecutionReport::clear_price_protection_scope() {
  price_protection_scope_ = 0;
  clear_has_price_protection_scope();
}
inline ::SingleGeneralOrderHandling::PriceProtectionScopeEnum ExecutionReport::price_protection_scope() const {
  return static_cast< ::SingleGeneralOrderHandling::PriceProtectionScopeEnum >(price_protection_scope_);
}
inline void ExecutionReport::set_price_protection_scope(::SingleGeneralOrderHandling::PriceProtectionScopeEnum value) {
  assert(::SingleGeneralOrderHandling::PriceProtectionScopeEnum_IsValid(value));
  set_has_price_protection_scope();
  price_protection_scope_ = value;
}

// optional .SingleGeneralOrderHandling.QtyTypeEnum qty_type = 186;
inline bool ExecutionReport::has_qty_type() const {
  return (_has_bits_[5] & 0x02000000u) != 0;
}
inline void ExecutionReport::set_has_qty_type() {
  _has_bits_[5] |= 0x02000000u;
}
inline void ExecutionReport::clear_has_qty_type() {
  _has_bits_[5] &= ~0x02000000u;
}
inline void ExecutionReport::clear_qty_type() {
  qty_type_ = 0;
  clear_has_qty_type();
}
inline ::SingleGeneralOrderHandling::QtyTypeEnum ExecutionReport::qty_type() const {
  return static_cast< ::SingleGeneralOrderHandling::QtyTypeEnum >(qty_type_);
}
inline void ExecutionReport::set_qty_type(::SingleGeneralOrderHandling::QtyTypeEnum value) {
  assert(::SingleGeneralOrderHandling::QtyTypeEnum_IsValid(value));
  set_has_qty_type();
  qty_type_ = value;
}

// optional string quote_resp_id = 187;
inline bool ExecutionReport::has_quote_resp_id() const {
  return (_has_bits_[5] & 0x04000000u) != 0;
}
inline void ExecutionReport::set_has_quote_resp_id() {
  _has_bits_[5] |= 0x04000000u;
}
inline void ExecutionReport::clear_has_quote_resp_id() {
  _has_bits_[5] &= ~0x04000000u;
}
inline void ExecutionReport::clear_quote_resp_id() {
  if (quote_resp_id_ != &::google::protobuf::internal::kEmptyString) {
    quote_resp_id_->clear();
  }
  clear_has_quote_resp_id();
}
inline const ::std::string& ExecutionReport::quote_resp_id() const {
  return *quote_resp_id_;
}
inline void ExecutionReport::set_quote_resp_id(const ::std::string& value) {
  set_has_quote_resp_id();
  if (quote_resp_id_ == &::google::protobuf::internal::kEmptyString) {
    quote_resp_id_ = new ::std::string;
  }
  quote_resp_id_->assign(value);
}
inline void ExecutionReport::set_quote_resp_id(const char* value) {
  set_has_quote_resp_id();
  if (quote_resp_id_ == &::google::protobuf::internal::kEmptyString) {
    quote_resp_id_ = new ::std::string;
  }
  quote_resp_id_->assign(value);
}
inline void ExecutionReport::set_quote_resp_id(const char* value, size_t size) {
  set_has_quote_resp_id();
  if (quote_resp_id_ == &::google::protobuf::internal::kEmptyString) {
    quote_resp_id_ = new ::std::string;
  }
  quote_resp_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_quote_resp_id() {
  set_has_quote_resp_id();
  if (quote_resp_id_ == &::google::protobuf::internal::kEmptyString) {
    quote_resp_id_ = new ::std::string;
  }
  return quote_resp_id_;
}
inline ::std::string* ExecutionReport::release_quote_resp_id() {
  clear_has_quote_resp_id();
  if (quote_resp_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = quote_resp_id_;
    quote_resp_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_quote_resp_id(::std::string* quote_resp_id) {
  if (quote_resp_id_ != &::google::protobuf::internal::kEmptyString) {
    delete quote_resp_id_;
  }
  if (quote_resp_id) {
    set_has_quote_resp_id();
    quote_resp_id_ = quote_resp_id;
  } else {
    clear_has_quote_resp_id();
    quote_resp_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string received_dept_id = 188;
inline bool ExecutionReport::has_received_dept_id() const {
  return (_has_bits_[5] & 0x08000000u) != 0;
}
inline void ExecutionReport::set_has_received_dept_id() {
  _has_bits_[5] |= 0x08000000u;
}
inline void ExecutionReport::clear_has_received_dept_id() {
  _has_bits_[5] &= ~0x08000000u;
}
inline void ExecutionReport::clear_received_dept_id() {
  if (received_dept_id_ != &::google::protobuf::internal::kEmptyString) {
    received_dept_id_->clear();
  }
  clear_has_received_dept_id();
}
inline const ::std::string& ExecutionReport::received_dept_id() const {
  return *received_dept_id_;
}
inline void ExecutionReport::set_received_dept_id(const ::std::string& value) {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  received_dept_id_->assign(value);
}
inline void ExecutionReport::set_received_dept_id(const char* value) {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  received_dept_id_->assign(value);
}
inline void ExecutionReport::set_received_dept_id(const char* value, size_t size) {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  received_dept_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_received_dept_id() {
  set_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    received_dept_id_ = new ::std::string;
  }
  return received_dept_id_;
}
inline ::std::string* ExecutionReport::release_received_dept_id() {
  clear_has_received_dept_id();
  if (received_dept_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = received_dept_id_;
    received_dept_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_received_dept_id(::std::string* received_dept_id) {
  if (received_dept_id_ != &::google::protobuf::internal::kEmptyString) {
    delete received_dept_id_;
  }
  if (received_dept_id) {
    set_has_received_dept_id();
    received_dept_id_ = received_dept_id;
  } else {
    clear_has_received_dept_id();
    received_dept_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 start_cash = 189;
inline bool ExecutionReport::has_start_cash() const {
  return (_has_bits_[5] & 0x10000000u) != 0;
}
inline void ExecutionReport::set_has_start_cash() {
  _has_bits_[5] |= 0x10000000u;
}
inline void ExecutionReport::clear_has_start_cash() {
  _has_bits_[5] &= ~0x10000000u;
}
inline void ExecutionReport::clear_start_cash() {
  start_cash_ = GOOGLE_LONGLONG(0);
  clear_has_start_cash();
}
inline ::google::protobuf::int64 ExecutionReport::start_cash() const {
  return start_cash_;
}
inline void ExecutionReport::set_start_cash(::google::protobuf::int64 value) {
  set_has_start_cash();
  start_cash_ = value;
}

// optional sfixed32 start_cash_exponent = 190;
inline bool ExecutionReport::has_start_cash_exponent() const {
  return (_has_bits_[5] & 0x20000000u) != 0;
}
inline void ExecutionReport::set_has_start_cash_exponent() {
  _has_bits_[5] |= 0x20000000u;
}
inline void ExecutionReport::clear_has_start_cash_exponent() {
  _has_bits_[5] &= ~0x20000000u;
}
inline void ExecutionReport::clear_start_cash_exponent() {
  start_cash_exponent_ = 0;
  clear_has_start_cash_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::start_cash_exponent() const {
  return start_cash_exponent_;
}
inline void ExecutionReport::set_start_cash_exponent(::google::protobuf::int32 value) {
  set_has_start_cash_exponent();
  start_cash_exponent_ = value;
}

// repeated .Common.StrategyParametersGrp strategy_parameters_grp = 191;
inline int ExecutionReport::strategy_parameters_grp_size() const {
  return strategy_parameters_grp_.size();
}
inline void ExecutionReport::clear_strategy_parameters_grp() {
  strategy_parameters_grp_.Clear();
}
inline const ::Common::StrategyParametersGrp& ExecutionReport::strategy_parameters_grp(int index) const {
  return strategy_parameters_grp_.Get(index);
}
inline ::Common::StrategyParametersGrp* ExecutionReport::mutable_strategy_parameters_grp(int index) {
  return strategy_parameters_grp_.Mutable(index);
}
inline ::Common::StrategyParametersGrp* ExecutionReport::add_strategy_parameters_grp() {
  return strategy_parameters_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >&
ExecutionReport::strategy_parameters_grp() const {
  return strategy_parameters_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::StrategyParametersGrp >*
ExecutionReport::mutable_strategy_parameters_grp() {
  return &strategy_parameters_grp_;
}

// optional .SingleGeneralOrderHandling.TargetStrategyEnum target_strategy = 192;
inline bool ExecutionReport::has_target_strategy() const {
  return (_has_bits_[5] & 0x80000000u) != 0;
}
inline void ExecutionReport::set_has_target_strategy() {
  _has_bits_[5] |= 0x80000000u;
}
inline void ExecutionReport::clear_has_target_strategy() {
  _has_bits_[5] &= ~0x80000000u;
}
inline void ExecutionReport::clear_target_strategy() {
  target_strategy_ = 0;
  clear_has_target_strategy();
}
inline ::SingleGeneralOrderHandling::TargetStrategyEnum ExecutionReport::target_strategy() const {
  return static_cast< ::SingleGeneralOrderHandling::TargetStrategyEnum >(target_strategy_);
}
inline void ExecutionReport::set_target_strategy(::SingleGeneralOrderHandling::TargetStrategyEnum value) {
  assert(::SingleGeneralOrderHandling::TargetStrategyEnum_IsValid(value));
  set_has_target_strategy();
  target_strategy_ = value;
}

// optional string target_strategy_parameters = 193;
inline bool ExecutionReport::has_target_strategy_parameters() const {
  return (_has_bits_[6] & 0x00000001u) != 0;
}
inline void ExecutionReport::set_has_target_strategy_parameters() {
  _has_bits_[6] |= 0x00000001u;
}
inline void ExecutionReport::clear_has_target_strategy_parameters() {
  _has_bits_[6] &= ~0x00000001u;
}
inline void ExecutionReport::clear_target_strategy_parameters() {
  if (target_strategy_parameters_ != &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_->clear();
  }
  clear_has_target_strategy_parameters();
}
inline const ::std::string& ExecutionReport::target_strategy_parameters() const {
  return *target_strategy_parameters_;
}
inline void ExecutionReport::set_target_strategy_parameters(const ::std::string& value) {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  target_strategy_parameters_->assign(value);
}
inline void ExecutionReport::set_target_strategy_parameters(const char* value) {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  target_strategy_parameters_->assign(value);
}
inline void ExecutionReport::set_target_strategy_parameters(const char* value, size_t size) {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  target_strategy_parameters_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_target_strategy_parameters() {
  set_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    target_strategy_parameters_ = new ::std::string;
  }
  return target_strategy_parameters_;
}
inline ::std::string* ExecutionReport::release_target_strategy_parameters() {
  clear_has_target_strategy_parameters();
  if (target_strategy_parameters_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_strategy_parameters_;
    target_strategy_parameters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_target_strategy_parameters(::std::string* target_strategy_parameters) {
  if (target_strategy_parameters_ != &::google::protobuf::internal::kEmptyString) {
    delete target_strategy_parameters_;
  }
  if (target_strategy_parameters) {
    set_has_target_strategy_parameters();
    target_strategy_parameters_ = target_strategy_parameters;
  } else {
    clear_has_target_strategy_parameters();
    target_strategy_parameters_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double target_strategy_performance = 194;
inline bool ExecutionReport::has_target_strategy_performance() const {
  return (_has_bits_[6] & 0x00000002u) != 0;
}
inline void ExecutionReport::set_has_target_strategy_performance() {
  _has_bits_[6] |= 0x00000002u;
}
inline void ExecutionReport::clear_has_target_strategy_performance() {
  _has_bits_[6] &= ~0x00000002u;
}
inline void ExecutionReport::clear_target_strategy_performance() {
  target_strategy_performance_ = 0;
  clear_has_target_strategy_performance();
}
inline double ExecutionReport::target_strategy_performance() const {
  return target_strategy_performance_;
}
inline void ExecutionReport::set_target_strategy_performance(double value) {
  set_has_target_strategy_performance();
  target_strategy_performance_ = value;
}

// optional string time_bracket = 195;
inline bool ExecutionReport::has_time_bracket() const {
  return (_has_bits_[6] & 0x00000004u) != 0;
}
inline void ExecutionReport::set_has_time_bracket() {
  _has_bits_[6] |= 0x00000004u;
}
inline void ExecutionReport::clear_has_time_bracket() {
  _has_bits_[6] &= ~0x00000004u;
}
inline void ExecutionReport::clear_time_bracket() {
  if (time_bracket_ != &::google::protobuf::internal::kEmptyString) {
    time_bracket_->clear();
  }
  clear_has_time_bracket();
}
inline const ::std::string& ExecutionReport::time_bracket() const {
  return *time_bracket_;
}
inline void ExecutionReport::set_time_bracket(const ::std::string& value) {
  set_has_time_bracket();
  if (time_bracket_ == &::google::protobuf::internal::kEmptyString) {
    time_bracket_ = new ::std::string;
  }
  time_bracket_->assign(value);
}
inline void ExecutionReport::set_time_bracket(const char* value) {
  set_has_time_bracket();
  if (time_bracket_ == &::google::protobuf::internal::kEmptyString) {
    time_bracket_ = new ::std::string;
  }
  time_bracket_->assign(value);
}
inline void ExecutionReport::set_time_bracket(const char* value, size_t size) {
  set_has_time_bracket();
  if (time_bracket_ == &::google::protobuf::internal::kEmptyString) {
    time_bracket_ = new ::std::string;
  }
  time_bracket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_time_bracket() {
  set_has_time_bracket();
  if (time_bracket_ == &::google::protobuf::internal::kEmptyString) {
    time_bracket_ = new ::std::string;
  }
  return time_bracket_;
}
inline ::std::string* ExecutionReport::release_time_bracket() {
  clear_has_time_bracket();
  if (time_bracket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_bracket_;
    time_bracket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_time_bracket(::std::string* time_bracket) {
  if (time_bracket_ != &::google::protobuf::internal::kEmptyString) {
    delete time_bracket_;
  }
  if (time_bracket) {
    set_has_time_bracket();
    time_bracket_ = time_bracket;
  } else {
    clear_has_time_bracket();
    time_bracket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 tot_num_reports = 196;
inline bool ExecutionReport::has_tot_num_reports() const {
  return (_has_bits_[6] & 0x00000008u) != 0;
}
inline void ExecutionReport::set_has_tot_num_reports() {
  _has_bits_[6] |= 0x00000008u;
}
inline void ExecutionReport::clear_has_tot_num_reports() {
  _has_bits_[6] &= ~0x00000008u;
}
inline void ExecutionReport::clear_tot_num_reports() {
  tot_num_reports_ = GOOGLE_LONGLONG(0);
  clear_has_tot_num_reports();
}
inline ::google::protobuf::int64 ExecutionReport::tot_num_reports() const {
  return tot_num_reports_;
}
inline void ExecutionReport::set_tot_num_reports(::google::protobuf::int64 value) {
  set_has_tot_num_reports();
  tot_num_reports_ = value;
}

// repeated .Common.TrdRegTimestamps trd_reg_timestamps = 197;
inline int ExecutionReport::trd_reg_timestamps_size() const {
  return trd_reg_timestamps_.size();
}
inline void ExecutionReport::clear_trd_reg_timestamps() {
  trd_reg_timestamps_.Clear();
}
inline const ::Common::TrdRegTimestamps& ExecutionReport::trd_reg_timestamps(int index) const {
  return trd_reg_timestamps_.Get(index);
}
inline ::Common::TrdRegTimestamps* ExecutionReport::mutable_trd_reg_timestamps(int index) {
  return trd_reg_timestamps_.Mutable(index);
}
inline ::Common::TrdRegTimestamps* ExecutionReport::add_trd_reg_timestamps() {
  return trd_reg_timestamps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >&
ExecutionReport::trd_reg_timestamps() const {
  return trd_reg_timestamps_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::TrdRegTimestamps >*
ExecutionReport::mutable_trd_reg_timestamps() {
  return &trd_reg_timestamps_;
}

// optional .Common.TriggeringInstruction triggering_instruction = 198;
inline bool ExecutionReport::has_triggering_instruction() const {
  return (_has_bits_[6] & 0x00000020u) != 0;
}
inline void ExecutionReport::set_has_triggering_instruction() {
  _has_bits_[6] |= 0x00000020u;
}
inline void ExecutionReport::clear_has_triggering_instruction() {
  _has_bits_[6] &= ~0x00000020u;
}
inline void ExecutionReport::clear_triggering_instruction() {
  if (triggering_instruction_ != NULL) triggering_instruction_->::Common::TriggeringInstruction::Clear();
  clear_has_triggering_instruction();
}
inline const ::Common::TriggeringInstruction& ExecutionReport::triggering_instruction() const {
  return triggering_instruction_ != NULL ? *triggering_instruction_ : *default_instance_->triggering_instruction_;
}
inline ::Common::TriggeringInstruction* ExecutionReport::mutable_triggering_instruction() {
  set_has_triggering_instruction();
  if (triggering_instruction_ == NULL) triggering_instruction_ = new ::Common::TriggeringInstruction;
  return triggering_instruction_;
}
inline ::Common::TriggeringInstruction* ExecutionReport::release_triggering_instruction() {
  clear_has_triggering_instruction();
  ::Common::TriggeringInstruction* temp = triggering_instruction_;
  triggering_instruction_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_triggering_instruction(::Common::TriggeringInstruction* triggering_instruction) {
  delete triggering_instruction_;
  triggering_instruction_ = triggering_instruction;
  if (triggering_instruction) {
    set_has_triggering_instruction();
  } else {
    clear_has_triggering_instruction();
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 199;
inline int ExecutionReport::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void ExecutionReport::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& ExecutionReport::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* ExecutionReport::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* ExecutionReport::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
ExecutionReport::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
ExecutionReport::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// optional string alloc_id = 200;
inline bool ExecutionReport::has_alloc_id() const {
  return (_has_bits_[6] & 0x00000080u) != 0;
}
inline void ExecutionReport::set_has_alloc_id() {
  _has_bits_[6] |= 0x00000080u;
}
inline void ExecutionReport::clear_has_alloc_id() {
  _has_bits_[6] &= ~0x00000080u;
}
inline void ExecutionReport::clear_alloc_id() {
  if (alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    alloc_id_->clear();
  }
  clear_has_alloc_id();
}
inline const ::std::string& ExecutionReport::alloc_id() const {
  return *alloc_id_;
}
inline void ExecutionReport::set_alloc_id(const ::std::string& value) {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  alloc_id_->assign(value);
}
inline void ExecutionReport::set_alloc_id(const char* value) {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  alloc_id_->assign(value);
}
inline void ExecutionReport::set_alloc_id(const char* value, size_t size) {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  alloc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_alloc_id() {
  set_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    alloc_id_ = new ::std::string;
  }
  return alloc_id_;
}
inline ::std::string* ExecutionReport::release_alloc_id() {
  clear_has_alloc_id();
  if (alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alloc_id_;
    alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_alloc_id(::std::string* alloc_id) {
  if (alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    delete alloc_id_;
  }
  if (alloc_id) {
    set_has_alloc_id();
    alloc_id_ = alloc_id;
  } else {
    clear_has_alloc_id();
    alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.ApplicationSequenceControl application_sequence_control = 201;
inline bool ExecutionReport::has_application_sequence_control() const {
  return (_has_bits_[6] & 0x00000100u) != 0;
}
inline void ExecutionReport::set_has_application_sequence_control() {
  _has_bits_[6] |= 0x00000100u;
}
inline void ExecutionReport::clear_has_application_sequence_control() {
  _has_bits_[6] &= ~0x00000100u;
}
inline void ExecutionReport::clear_application_sequence_control() {
  if (application_sequence_control_ != NULL) application_sequence_control_->::Common::ApplicationSequenceControl::Clear();
  clear_has_application_sequence_control();
}
inline const ::Common::ApplicationSequenceControl& ExecutionReport::application_sequence_control() const {
  return application_sequence_control_ != NULL ? *application_sequence_control_ : *default_instance_->application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* ExecutionReport::mutable_application_sequence_control() {
  set_has_application_sequence_control();
  if (application_sequence_control_ == NULL) application_sequence_control_ = new ::Common::ApplicationSequenceControl;
  return application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* ExecutionReport::release_application_sequence_control() {
  clear_has_application_sequence_control();
  ::Common::ApplicationSequenceControl* temp = application_sequence_control_;
  application_sequence_control_ = NULL;
  return temp;
}
inline void ExecutionReport::set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control) {
  delete application_sequence_control_;
  application_sequence_control_ = application_sequence_control;
  if (application_sequence_control) {
    set_has_application_sequence_control();
  } else {
    clear_has_application_sequence_control();
  }
}

// optional sfixed64 dividend_yield = 202;
inline bool ExecutionReport::has_dividend_yield() const {
  return (_has_bits_[6] & 0x00000200u) != 0;
}
inline void ExecutionReport::set_has_dividend_yield() {
  _has_bits_[6] |= 0x00000200u;
}
inline void ExecutionReport::clear_has_dividend_yield() {
  _has_bits_[6] &= ~0x00000200u;
}
inline void ExecutionReport::clear_dividend_yield() {
  dividend_yield_ = GOOGLE_LONGLONG(0);
  clear_has_dividend_yield();
}
inline ::google::protobuf::int64 ExecutionReport::dividend_yield() const {
  return dividend_yield_;
}
inline void ExecutionReport::set_dividend_yield(::google::protobuf::int64 value) {
  set_has_dividend_yield();
  dividend_yield_ = value;
}

// optional sfixed32 dividend_yield_exponent = 203;
inline bool ExecutionReport::has_dividend_yield_exponent() const {
  return (_has_bits_[6] & 0x00000400u) != 0;
}
inline void ExecutionReport::set_has_dividend_yield_exponent() {
  _has_bits_[6] |= 0x00000400u;
}
inline void ExecutionReport::clear_has_dividend_yield_exponent() {
  _has_bits_[6] &= ~0x00000400u;
}
inline void ExecutionReport::clear_dividend_yield_exponent() {
  dividend_yield_exponent_ = 0;
  clear_has_dividend_yield_exponent();
}
inline ::google::protobuf::int32 ExecutionReport::dividend_yield_exponent() const {
  return dividend_yield_exponent_;
}
inline void ExecutionReport::set_dividend_yield_exponent(::google::protobuf::int32 value) {
  set_has_dividend_yield_exponent();
  dividend_yield_exponent_ = value;
}

// repeated .SingleGeneralOrderHandling.FillsGrp fills_grp = 204;
inline int ExecutionReport::fills_grp_size() const {
  return fills_grp_.size();
}
inline void ExecutionReport::clear_fills_grp() {
  fills_grp_.Clear();
}
inline const ::SingleGeneralOrderHandling::FillsGrp& ExecutionReport::fills_grp(int index) const {
  return fills_grp_.Get(index);
}
inline ::SingleGeneralOrderHandling::FillsGrp* ExecutionReport::mutable_fills_grp(int index) {
  return fills_grp_.Mutable(index);
}
inline ::SingleGeneralOrderHandling::FillsGrp* ExecutionReport::add_fills_grp() {
  return fills_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SingleGeneralOrderHandling::FillsGrp >&
ExecutionReport::fills_grp() const {
  return fills_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::SingleGeneralOrderHandling::FillsGrp >*
ExecutionReport::mutable_fills_grp() {
  return &fills_grp_;
}

// optional bool last_fragment = 205;
inline bool ExecutionReport::has_last_fragment() const {
  return (_has_bits_[6] & 0x00001000u) != 0;
}
inline void ExecutionReport::set_has_last_fragment() {
  _has_bits_[6] |= 0x00001000u;
}
inline void ExecutionReport::clear_has_last_fragment() {
  _has_bits_[6] &= ~0x00001000u;
}
inline void ExecutionReport::clear_last_fragment() {
  last_fragment_ = false;
  clear_has_last_fragment();
}
inline bool ExecutionReport::last_fragment() const {
  return last_fragment_;
}
inline void ExecutionReport::set_last_fragment(bool value) {
  set_has_last_fragment();
  last_fragment_ = value;
}

// repeated .Common.PreAllocGrp pre_alloc_grp = 206;
inline int ExecutionReport::pre_alloc_grp_size() const {
  return pre_alloc_grp_.size();
}
inline void ExecutionReport::clear_pre_alloc_grp() {
  pre_alloc_grp_.Clear();
}
inline const ::Common::PreAllocGrp& ExecutionReport::pre_alloc_grp(int index) const {
  return pre_alloc_grp_.Get(index);
}
inline ::Common::PreAllocGrp* ExecutionReport::mutable_pre_alloc_grp(int index) {
  return pre_alloc_grp_.Mutable(index);
}
inline ::Common::PreAllocGrp* ExecutionReport::add_pre_alloc_grp() {
  return pre_alloc_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >&
ExecutionReport::pre_alloc_grp() const {
  return pre_alloc_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::PreAllocGrp >*
ExecutionReport::mutable_pre_alloc_grp() {
  return &pre_alloc_grp_;
}

// optional double price_delta = 207;
inline bool ExecutionReport::has_price_delta() const {
  return (_has_bits_[6] & 0x00004000u) != 0;
}
inline void ExecutionReport::set_has_price_delta() {
  _has_bits_[6] |= 0x00004000u;
}
inline void ExecutionReport::clear_has_price_delta() {
  _has_bits_[6] &= ~0x00004000u;
}
inline void ExecutionReport::clear_price_delta() {
  price_delta_ = 0;
  clear_has_price_delta();
}
inline double ExecutionReport::price_delta() const {
  return price_delta_;
}
inline void ExecutionReport::set_price_delta(double value) {
  set_has_price_delta();
  price_delta_ = value;
}

// optional double risk_free_rate = 208;
inline bool ExecutionReport::has_risk_free_rate() const {
  return (_has_bits_[6] & 0x00008000u) != 0;
}
inline void ExecutionReport::set_has_risk_free_rate() {
  _has_bits_[6] |= 0x00008000u;
}
inline void ExecutionReport::clear_has_risk_free_rate() {
  _has_bits_[6] &= ~0x00008000u;
}
inline void ExecutionReport::clear_risk_free_rate() {
  risk_free_rate_ = 0;
  clear_has_risk_free_rate();
}
inline double ExecutionReport::risk_free_rate() const {
  return risk_free_rate_;
}
inline void ExecutionReport::set_risk_free_rate(double value) {
  set_has_risk_free_rate();
  risk_free_rate_ = value;
}

// optional double time_to_expiration = 209;
inline bool ExecutionReport::has_time_to_expiration() const {
  return (_has_bits_[6] & 0x00010000u) != 0;
}
inline void ExecutionReport::set_has_time_to_expiration() {
  _has_bits_[6] |= 0x00010000u;
}
inline void ExecutionReport::clear_has_time_to_expiration() {
  _has_bits_[6] &= ~0x00010000u;
}
inline void ExecutionReport::clear_time_to_expiration() {
  time_to_expiration_ = 0;
  clear_has_time_to_expiration();
}
inline double ExecutionReport::time_to_expiration() const {
  return time_to_expiration_;
}
inline void ExecutionReport::set_time_to_expiration(double value) {
  set_has_time_to_expiration();
  time_to_expiration_ = value;
}

// optional sfixed64 tot_no_fills = 210;
inline bool ExecutionReport::has_tot_no_fills() const {
  return (_has_bits_[6] & 0x00020000u) != 0;
}
inline void ExecutionReport::set_has_tot_no_fills() {
  _has_bits_[6] |= 0x00020000u;
}
inline void ExecutionReport::clear_has_tot_no_fills() {
  _has_bits_[6] &= ~0x00020000u;
}
inline void ExecutionReport::clear_tot_no_fills() {
  tot_no_fills_ = GOOGLE_LONGLONG(0);
  clear_has_tot_no_fills();
}
inline ::google::protobuf::int64 ExecutionReport::tot_no_fills() const {
  return tot_no_fills_;
}
inline void ExecutionReport::set_tot_no_fills(::google::protobuf::int64 value) {
  set_has_tot_no_fills();
  tot_no_fills_ = value;
}

// optional string trd_match_id = 211;
inline bool ExecutionReport::has_trd_match_id() const {
  return (_has_bits_[6] & 0x00040000u) != 0;
}
inline void ExecutionReport::set_has_trd_match_id() {
  _has_bits_[6] |= 0x00040000u;
}
inline void ExecutionReport::clear_has_trd_match_id() {
  _has_bits_[6] &= ~0x00040000u;
}
inline void ExecutionReport::clear_trd_match_id() {
  if (trd_match_id_ != &::google::protobuf::internal::kEmptyString) {
    trd_match_id_->clear();
  }
  clear_has_trd_match_id();
}
inline const ::std::string& ExecutionReport::trd_match_id() const {
  return *trd_match_id_;
}
inline void ExecutionReport::set_trd_match_id(const ::std::string& value) {
  set_has_trd_match_id();
  if (trd_match_id_ == &::google::protobuf::internal::kEmptyString) {
    trd_match_id_ = new ::std::string;
  }
  trd_match_id_->assign(value);
}
inline void ExecutionReport::set_trd_match_id(const char* value) {
  set_has_trd_match_id();
  if (trd_match_id_ == &::google::protobuf::internal::kEmptyString) {
    trd_match_id_ = new ::std::string;
  }
  trd_match_id_->assign(value);
}
inline void ExecutionReport::set_trd_match_id(const char* value, size_t size) {
  set_has_trd_match_id();
  if (trd_match_id_ == &::google::protobuf::internal::kEmptyString) {
    trd_match_id_ = new ::std::string;
  }
  trd_match_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionReport::mutable_trd_match_id() {
  set_has_trd_match_id();
  if (trd_match_id_ == &::google::protobuf::internal::kEmptyString) {
    trd_match_id_ = new ::std::string;
  }
  return trd_match_id_;
}
inline ::std::string* ExecutionReport::release_trd_match_id() {
  clear_has_trd_match_id();
  if (trd_match_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trd_match_id_;
    trd_match_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionReport::set_allocated_trd_match_id(::std::string* trd_match_id) {
  if (trd_match_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trd_match_id_;
  }
  if (trd_match_id) {
    set_has_trd_match_id();
    trd_match_id_ = trd_match_id;
  } else {
    clear_has_trd_match_id();
    trd_match_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double volatility = 212;
inline bool ExecutionReport::has_volatility() const {
  return (_has_bits_[6] & 0x00080000u) != 0;
}
inline void ExecutionReport::set_has_volatility() {
  _has_bits_[6] |= 0x00080000u;
}
inline void ExecutionReport::clear_has_volatility() {
  _has_bits_[6] &= ~0x00080000u;
}
inline void ExecutionReport::clear_volatility() {
  volatility_ = 0;
  clear_has_volatility();
}
inline double ExecutionReport::volatility() const {
  return volatility_;
}
inline void ExecutionReport::set_volatility(double value) {
  set_has_volatility();
  volatility_ = value;
}

// repeated .Common.RateSource rate_source = 213;
inline int ExecutionReport::rate_source_size() const {
  return rate_source_.size();
}
inline void ExecutionReport::clear_rate_source() {
  rate_source_.Clear();
}
inline const ::Common::RateSource& ExecutionReport::rate_source(int index) const {
  return rate_source_.Get(index);
}
inline ::Common::RateSource* ExecutionReport::mutable_rate_source(int index) {
  return rate_source_.Mutable(index);
}
inline ::Common::RateSource* ExecutionReport::add_rate_source() {
  return rate_source_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::RateSource >&
ExecutionReport::rate_source() const {
  return rate_source_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::RateSource >*
ExecutionReport::mutable_rate_source() {
  return &rate_source_;
}

// -------------------------------------------------------------------

// OrderStatusRequest

// optional string cl_ord_id = 1;
inline bool OrderStatusRequest::has_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderStatusRequest::set_has_cl_ord_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderStatusRequest::clear_has_cl_ord_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderStatusRequest::clear_cl_ord_id() {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_->clear();
  }
  clear_has_cl_ord_id();
}
inline const ::std::string& OrderStatusRequest::cl_ord_id() const {
  return *cl_ord_id_;
}
inline void OrderStatusRequest::set_cl_ord_id(const ::std::string& value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void OrderStatusRequest::set_cl_ord_id(const char* value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void OrderStatusRequest::set_cl_ord_id(const char* value, size_t size) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderStatusRequest::mutable_cl_ord_id() {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  return cl_ord_id_;
}
inline ::std::string* OrderStatusRequest::release_cl_ord_id() {
  clear_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_id_;
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderStatusRequest::set_allocated_cl_ord_id(::std::string* cl_ord_id) {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_id_;
  }
  if (cl_ord_id) {
    set_has_cl_ord_id();
    cl_ord_id_ = cl_ord_id;
  } else {
    clear_has_cl_ord_id();
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string order_id = 2;
inline bool OrderStatusRequest::has_order_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderStatusRequest::set_has_order_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderStatusRequest::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderStatusRequest::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& OrderStatusRequest::order_id() const {
  return *order_id_;
}
inline void OrderStatusRequest::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderStatusRequest::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void OrderStatusRequest::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderStatusRequest::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* OrderStatusRequest::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderStatusRequest::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.SideEnum side = 3;
inline bool OrderStatusRequest::has_side() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderStatusRequest::set_has_side() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderStatusRequest::clear_has_side() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderStatusRequest::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::SingleGeneralOrderHandling::SideEnum OrderStatusRequest::side() const {
  return static_cast< ::SingleGeneralOrderHandling::SideEnum >(side_);
}
inline void OrderStatusRequest::set_side(::SingleGeneralOrderHandling::SideEnum value) {
  assert(::SingleGeneralOrderHandling::SideEnum_IsValid(value));
  set_has_side();
  side_ = value;
}

// optional .Session.StandardHeader standard_header = 4;
inline bool OrderStatusRequest::has_standard_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderStatusRequest::set_has_standard_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderStatusRequest::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderStatusRequest::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& OrderStatusRequest::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* OrderStatusRequest::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* OrderStatusRequest::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void OrderStatusRequest::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 5;
inline bool OrderStatusRequest::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderStatusRequest::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderStatusRequest::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderStatusRequest::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& OrderStatusRequest::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* OrderStatusRequest::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* OrderStatusRequest::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void OrderStatusRequest::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional string account = 6;
inline bool OrderStatusRequest::has_account() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderStatusRequest::set_has_account() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderStatusRequest::clear_has_account() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderStatusRequest::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& OrderStatusRequest::account() const {
  return *account_;
}
inline void OrderStatusRequest::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void OrderStatusRequest::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void OrderStatusRequest::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderStatusRequest::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* OrderStatusRequest::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderStatusRequest::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cl_ord_link_id = 7;
inline bool OrderStatusRequest::has_cl_ord_link_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderStatusRequest::set_has_cl_ord_link_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderStatusRequest::clear_has_cl_ord_link_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderStatusRequest::clear_cl_ord_link_id() {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_->clear();
  }
  clear_has_cl_ord_link_id();
}
inline const ::std::string& OrderStatusRequest::cl_ord_link_id() const {
  return *cl_ord_link_id_;
}
inline void OrderStatusRequest::set_cl_ord_link_id(const ::std::string& value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void OrderStatusRequest::set_cl_ord_link_id(const char* value) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(value);
}
inline void OrderStatusRequest::set_cl_ord_link_id(const char* value, size_t size) {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  cl_ord_link_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderStatusRequest::mutable_cl_ord_link_id() {
  set_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_link_id_ = new ::std::string;
  }
  return cl_ord_link_id_;
}
inline ::std::string* OrderStatusRequest::release_cl_ord_link_id() {
  clear_has_cl_ord_link_id();
  if (cl_ord_link_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_link_id_;
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderStatusRequest::set_allocated_cl_ord_link_id(::std::string* cl_ord_link_id) {
  if (cl_ord_link_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_link_id_;
  }
  if (cl_ord_link_id) {
    set_has_cl_ord_link_id();
    cl_ord_link_id_ = cl_ord_link_id;
  } else {
    clear_has_cl_ord_link_id();
    cl_ord_link_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.Instrument instrument = 8;
inline bool OrderStatusRequest::has_instrument() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderStatusRequest::set_has_instrument() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderStatusRequest::clear_has_instrument() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderStatusRequest::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& OrderStatusRequest::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* OrderStatusRequest::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* OrderStatusRequest::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void OrderStatusRequest::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// repeated .Common.Parties parties = 9;
inline int OrderStatusRequest::parties_size() const {
  return parties_.size();
}
inline void OrderStatusRequest::clear_parties() {
  parties_.Clear();
}
inline const ::Common::Parties& OrderStatusRequest::parties(int index) const {
  return parties_.Get(index);
}
inline ::Common::Parties* OrderStatusRequest::mutable_parties(int index) {
  return parties_.Mutable(index);
}
inline ::Common::Parties* OrderStatusRequest::add_parties() {
  return parties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Parties >&
OrderStatusRequest::parties() const {
  return parties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Parties >*
OrderStatusRequest::mutable_parties() {
  return &parties_;
}

// optional string secondary_cl_ord_id = 10;
inline bool OrderStatusRequest::has_secondary_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OrderStatusRequest::set_has_secondary_cl_ord_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OrderStatusRequest::clear_has_secondary_cl_ord_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OrderStatusRequest::clear_secondary_cl_ord_id() {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_->clear();
  }
  clear_has_secondary_cl_ord_id();
}
inline const ::std::string& OrderStatusRequest::secondary_cl_ord_id() const {
  return *secondary_cl_ord_id_;
}
inline void OrderStatusRequest::set_secondary_cl_ord_id(const ::std::string& value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void OrderStatusRequest::set_secondary_cl_ord_id(const char* value) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(value);
}
inline void OrderStatusRequest::set_secondary_cl_ord_id(const char* value, size_t size) {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  secondary_cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderStatusRequest::mutable_secondary_cl_ord_id() {
  set_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_cl_ord_id_ = new ::std::string;
  }
  return secondary_cl_ord_id_;
}
inline ::std::string* OrderStatusRequest::release_secondary_cl_ord_id() {
  clear_has_secondary_cl_ord_id();
  if (secondary_cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_cl_ord_id_;
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderStatusRequest::set_allocated_secondary_cl_ord_id(::std::string* secondary_cl_ord_id) {
  if (secondary_cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_cl_ord_id_;
  }
  if (secondary_cl_ord_id) {
    set_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = secondary_cl_ord_id;
  } else {
    clear_has_secondary_cl_ord_id();
    secondary_cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.AcctIdSourceEnum acct_id_source = 11;
inline bool OrderStatusRequest::has_acct_id_source() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void OrderStatusRequest::set_has_acct_id_source() {
  _has_bits_[0] |= 0x00000400u;
}
inline void OrderStatusRequest::clear_has_acct_id_source() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void OrderStatusRequest::clear_acct_id_source() {
  acct_id_source_ = 0;
  clear_has_acct_id_source();
}
inline ::SingleGeneralOrderHandling::AcctIdSourceEnum OrderStatusRequest::acct_id_source() const {
  return static_cast< ::SingleGeneralOrderHandling::AcctIdSourceEnum >(acct_id_source_);
}
inline void OrderStatusRequest::set_acct_id_source(::SingleGeneralOrderHandling::AcctIdSourceEnum value) {
  assert(::SingleGeneralOrderHandling::AcctIdSourceEnum_IsValid(value));
  set_has_acct_id_source();
  acct_id_source_ = value;
}

// optional .Common.FinancingDetails financing_details = 12;
inline bool OrderStatusRequest::has_financing_details() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OrderStatusRequest::set_has_financing_details() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OrderStatusRequest::clear_has_financing_details() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OrderStatusRequest::clear_financing_details() {
  if (financing_details_ != NULL) financing_details_->::Common::FinancingDetails::Clear();
  clear_has_financing_details();
}
inline const ::Common::FinancingDetails& OrderStatusRequest::financing_details() const {
  return financing_details_ != NULL ? *financing_details_ : *default_instance_->financing_details_;
}
inline ::Common::FinancingDetails* OrderStatusRequest::mutable_financing_details() {
  set_has_financing_details();
  if (financing_details_ == NULL) financing_details_ = new ::Common::FinancingDetails;
  return financing_details_;
}
inline ::Common::FinancingDetails* OrderStatusRequest::release_financing_details() {
  clear_has_financing_details();
  ::Common::FinancingDetails* temp = financing_details_;
  financing_details_ = NULL;
  return temp;
}
inline void OrderStatusRequest::set_allocated_financing_details(::Common::FinancingDetails* financing_details) {
  delete financing_details_;
  financing_details_ = financing_details;
  if (financing_details) {
    set_has_financing_details();
  } else {
    clear_has_financing_details();
  }
}

// optional string ord_status_req_id = 13;
inline bool OrderStatusRequest::has_ord_status_req_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OrderStatusRequest::set_has_ord_status_req_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OrderStatusRequest::clear_has_ord_status_req_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OrderStatusRequest::clear_ord_status_req_id() {
  if (ord_status_req_id_ != &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_->clear();
  }
  clear_has_ord_status_req_id();
}
inline const ::std::string& OrderStatusRequest::ord_status_req_id() const {
  return *ord_status_req_id_;
}
inline void OrderStatusRequest::set_ord_status_req_id(const ::std::string& value) {
  set_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_ = new ::std::string;
  }
  ord_status_req_id_->assign(value);
}
inline void OrderStatusRequest::set_ord_status_req_id(const char* value) {
  set_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_ = new ::std::string;
  }
  ord_status_req_id_->assign(value);
}
inline void OrderStatusRequest::set_ord_status_req_id(const char* value, size_t size) {
  set_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_ = new ::std::string;
  }
  ord_status_req_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OrderStatusRequest::mutable_ord_status_req_id() {
  set_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    ord_status_req_id_ = new ::std::string;
  }
  return ord_status_req_id_;
}
inline ::std::string* OrderStatusRequest::release_ord_status_req_id() {
  clear_has_ord_status_req_id();
  if (ord_status_req_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ord_status_req_id_;
    ord_status_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OrderStatusRequest::set_allocated_ord_status_req_id(::std::string* ord_status_req_id) {
  if (ord_status_req_id_ != &::google::protobuf::internal::kEmptyString) {
    delete ord_status_req_id_;
  }
  if (ord_status_req_id) {
    set_has_ord_status_req_id();
    ord_status_req_id_ = ord_status_req_id;
  } else {
    clear_has_ord_status_req_id();
    ord_status_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 14;
inline int OrderStatusRequest::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void OrderStatusRequest::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& OrderStatusRequest::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* OrderStatusRequest::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* OrderStatusRequest::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
OrderStatusRequest::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
OrderStatusRequest::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// -------------------------------------------------------------------

// ExecutionAcknowledgement

// optional sfixed64 avg_px = 1;
inline bool ExecutionAcknowledgement::has_avg_px() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecutionAcknowledgement::set_has_avg_px() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecutionAcknowledgement::clear_has_avg_px() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecutionAcknowledgement::clear_avg_px() {
  avg_px_ = GOOGLE_LONGLONG(0);
  clear_has_avg_px();
}
inline ::google::protobuf::int64 ExecutionAcknowledgement::avg_px() const {
  return avg_px_;
}
inline void ExecutionAcknowledgement::set_avg_px(::google::protobuf::int64 value) {
  set_has_avg_px();
  avg_px_ = value;
}

// optional string cl_ord_id = 2;
inline bool ExecutionAcknowledgement::has_cl_ord_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecutionAcknowledgement::set_has_cl_ord_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecutionAcknowledgement::clear_has_cl_ord_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecutionAcknowledgement::clear_cl_ord_id() {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_->clear();
  }
  clear_has_cl_ord_id();
}
inline const ::std::string& ExecutionAcknowledgement::cl_ord_id() const {
  return *cl_ord_id_;
}
inline void ExecutionAcknowledgement::set_cl_ord_id(const ::std::string& value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void ExecutionAcknowledgement::set_cl_ord_id(const char* value) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(value);
}
inline void ExecutionAcknowledgement::set_cl_ord_id(const char* value, size_t size) {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  cl_ord_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionAcknowledgement::mutable_cl_ord_id() {
  set_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    cl_ord_id_ = new ::std::string;
  }
  return cl_ord_id_;
}
inline ::std::string* ExecutionAcknowledgement::release_cl_ord_id() {
  clear_has_cl_ord_id();
  if (cl_ord_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cl_ord_id_;
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionAcknowledgement::set_allocated_cl_ord_id(::std::string* cl_ord_id) {
  if (cl_ord_id_ != &::google::protobuf::internal::kEmptyString) {
    delete cl_ord_id_;
  }
  if (cl_ord_id) {
    set_has_cl_ord_id();
    cl_ord_id_ = cl_ord_id;
  } else {
    clear_has_cl_ord_id();
    cl_ord_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 cum_qty = 3;
inline bool ExecutionAcknowledgement::has_cum_qty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecutionAcknowledgement::set_has_cum_qty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecutionAcknowledgement::clear_has_cum_qty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecutionAcknowledgement::clear_cum_qty() {
  cum_qty_ = GOOGLE_LONGLONG(0);
  clear_has_cum_qty();
}
inline ::google::protobuf::int64 ExecutionAcknowledgement::cum_qty() const {
  return cum_qty_;
}
inline void ExecutionAcknowledgement::set_cum_qty(::google::protobuf::int64 value) {
  set_has_cum_qty();
  cum_qty_ = value;
}

// optional sfixed32 cum_qty_exponent = 4;
inline bool ExecutionAcknowledgement::has_cum_qty_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecutionAcknowledgement::set_has_cum_qty_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecutionAcknowledgement::clear_has_cum_qty_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecutionAcknowledgement::clear_cum_qty_exponent() {
  cum_qty_exponent_ = 0;
  clear_has_cum_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionAcknowledgement::cum_qty_exponent() const {
  return cum_qty_exponent_;
}
inline void ExecutionAcknowledgement::set_cum_qty_exponent(::google::protobuf::int32 value) {
  set_has_cum_qty_exponent();
  cum_qty_exponent_ = value;
}

// optional .SingleGeneralOrderHandling.DKReasonEnum dkreason = 5;
inline bool ExecutionAcknowledgement::has_dkreason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExecutionAcknowledgement::set_has_dkreason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExecutionAcknowledgement::clear_has_dkreason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExecutionAcknowledgement::clear_dkreason() {
  dkreason_ = 0;
  clear_has_dkreason();
}
inline ::SingleGeneralOrderHandling::DKReasonEnum ExecutionAcknowledgement::dkreason() const {
  return static_cast< ::SingleGeneralOrderHandling::DKReasonEnum >(dkreason_);
}
inline void ExecutionAcknowledgement::set_dkreason(::SingleGeneralOrderHandling::DKReasonEnum value) {
  assert(::SingleGeneralOrderHandling::DKReasonEnum_IsValid(value));
  set_has_dkreason();
  dkreason_ = value;
}

// optional bytes encoded_text = 6;
inline bool ExecutionAcknowledgement::has_encoded_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecutionAcknowledgement::set_has_encoded_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecutionAcknowledgement::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecutionAcknowledgement::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& ExecutionAcknowledgement::encoded_text() const {
  return *encoded_text_;
}
inline void ExecutionAcknowledgement::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void ExecutionAcknowledgement::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void ExecutionAcknowledgement::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionAcknowledgement::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* ExecutionAcknowledgement::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionAcknowledgement::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 7;
inline bool ExecutionAcknowledgement::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecutionAcknowledgement::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecutionAcknowledgement::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecutionAcknowledgement::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 ExecutionAcknowledgement::encoded_text_len() const {
  return encoded_text_len_;
}
inline void ExecutionAcknowledgement::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional .SingleGeneralOrderHandling.ExecAckStatusEnum exec_ack_status = 8;
inline bool ExecutionAcknowledgement::has_exec_ack_status() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExecutionAcknowledgement::set_has_exec_ack_status() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExecutionAcknowledgement::clear_has_exec_ack_status() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExecutionAcknowledgement::clear_exec_ack_status() {
  exec_ack_status_ = 0;
  clear_has_exec_ack_status();
}
inline ::SingleGeneralOrderHandling::ExecAckStatusEnum ExecutionAcknowledgement::exec_ack_status() const {
  return static_cast< ::SingleGeneralOrderHandling::ExecAckStatusEnum >(exec_ack_status_);
}
inline void ExecutionAcknowledgement::set_exec_ack_status(::SingleGeneralOrderHandling::ExecAckStatusEnum value) {
  assert(::SingleGeneralOrderHandling::ExecAckStatusEnum_IsValid(value));
  set_has_exec_ack_status();
  exec_ack_status_ = value;
}

// optional string exec_id = 9;
inline bool ExecutionAcknowledgement::has_exec_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExecutionAcknowledgement::set_has_exec_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExecutionAcknowledgement::clear_has_exec_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExecutionAcknowledgement::clear_exec_id() {
  if (exec_id_ != &::google::protobuf::internal::kEmptyString) {
    exec_id_->clear();
  }
  clear_has_exec_id();
}
inline const ::std::string& ExecutionAcknowledgement::exec_id() const {
  return *exec_id_;
}
inline void ExecutionAcknowledgement::set_exec_id(const ::std::string& value) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(value);
}
inline void ExecutionAcknowledgement::set_exec_id(const char* value) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(value);
}
inline void ExecutionAcknowledgement::set_exec_id(const char* value, size_t size) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionAcknowledgement::mutable_exec_id() {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  return exec_id_;
}
inline ::std::string* ExecutionAcknowledgement::release_exec_id() {
  clear_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exec_id_;
    exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionAcknowledgement::set_allocated_exec_id(::std::string* exec_id) {
  if (exec_id_ != &::google::protobuf::internal::kEmptyString) {
    delete exec_id_;
  }
  if (exec_id) {
    set_has_exec_id();
    exec_id_ = exec_id;
  } else {
    clear_has_exec_id();
    exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.InstrmtLegGrp instrmt_leg_grp = 10;
inline int ExecutionAcknowledgement::instrmt_leg_grp_size() const {
  return instrmt_leg_grp_.size();
}
inline void ExecutionAcknowledgement::clear_instrmt_leg_grp() {
  instrmt_leg_grp_.Clear();
}
inline const ::Common::InstrmtLegGrp& ExecutionAcknowledgement::instrmt_leg_grp(int index) const {
  return instrmt_leg_grp_.Get(index);
}
inline ::Common::InstrmtLegGrp* ExecutionAcknowledgement::mutable_instrmt_leg_grp(int index) {
  return instrmt_leg_grp_.Mutable(index);
}
inline ::Common::InstrmtLegGrp* ExecutionAcknowledgement::add_instrmt_leg_grp() {
  return instrmt_leg_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
ExecutionAcknowledgement::instrmt_leg_grp() const {
  return instrmt_leg_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
ExecutionAcknowledgement::mutable_instrmt_leg_grp() {
  return &instrmt_leg_grp_;
}

// optional .Common.Instrument instrument = 11;
inline bool ExecutionAcknowledgement::has_instrument() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ExecutionAcknowledgement::set_has_instrument() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ExecutionAcknowledgement::clear_has_instrument() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ExecutionAcknowledgement::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& ExecutionAcknowledgement::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* ExecutionAcknowledgement::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* ExecutionAcknowledgement::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void ExecutionAcknowledgement::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional sfixed64 last_par_px = 12;
inline bool ExecutionAcknowledgement::has_last_par_px() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ExecutionAcknowledgement::set_has_last_par_px() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ExecutionAcknowledgement::clear_has_last_par_px() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ExecutionAcknowledgement::clear_last_par_px() {
  last_par_px_ = GOOGLE_LONGLONG(0);
  clear_has_last_par_px();
}
inline ::google::protobuf::int64 ExecutionAcknowledgement::last_par_px() const {
  return last_par_px_;
}
inline void ExecutionAcknowledgement::set_last_par_px(::google::protobuf::int64 value) {
  set_has_last_par_px();
  last_par_px_ = value;
}

// optional sfixed32 last_par_px_exponent = 13;
inline bool ExecutionAcknowledgement::has_last_par_px_exponent() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_last_par_px_exponent() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ExecutionAcknowledgement::clear_has_last_par_px_exponent() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ExecutionAcknowledgement::clear_last_par_px_exponent() {
  last_par_px_exponent_ = 0;
  clear_has_last_par_px_exponent();
}
inline ::google::protobuf::int32 ExecutionAcknowledgement::last_par_px_exponent() const {
  return last_par_px_exponent_;
}
inline void ExecutionAcknowledgement::set_last_par_px_exponent(::google::protobuf::int32 value) {
  set_has_last_par_px_exponent();
  last_par_px_exponent_ = value;
}

// optional double last_px = 14;
inline bool ExecutionAcknowledgement::has_last_px() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_last_px() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ExecutionAcknowledgement::clear_has_last_px() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ExecutionAcknowledgement::clear_last_px() {
  last_px_ = 0;
  clear_has_last_px();
}
inline double ExecutionAcknowledgement::last_px() const {
  return last_px_;
}
inline void ExecutionAcknowledgement::set_last_px(double value) {
  set_has_last_px();
  last_px_ = value;
}

// optional sfixed64 last_qty = 15;
inline bool ExecutionAcknowledgement::has_last_qty() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_last_qty() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ExecutionAcknowledgement::clear_has_last_qty() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ExecutionAcknowledgement::clear_last_qty() {
  last_qty_ = GOOGLE_LONGLONG(0);
  clear_has_last_qty();
}
inline ::google::protobuf::int64 ExecutionAcknowledgement::last_qty() const {
  return last_qty_;
}
inline void ExecutionAcknowledgement::set_last_qty(::google::protobuf::int64 value) {
  set_has_last_qty();
  last_qty_ = value;
}

// optional sfixed32 last_qty_exponent = 16;
inline bool ExecutionAcknowledgement::has_last_qty_exponent() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_last_qty_exponent() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ExecutionAcknowledgement::clear_has_last_qty_exponent() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ExecutionAcknowledgement::clear_last_qty_exponent() {
  last_qty_exponent_ = 0;
  clear_has_last_qty_exponent();
}
inline ::google::protobuf::int32 ExecutionAcknowledgement::last_qty_exponent() const {
  return last_qty_exponent_;
}
inline void ExecutionAcknowledgement::set_last_qty_exponent(::google::protobuf::int32 value) {
  set_has_last_qty_exponent();
  last_qty_exponent_ = value;
}

// optional string order_id = 17;
inline bool ExecutionAcknowledgement::has_order_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_order_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ExecutionAcknowledgement::clear_has_order_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ExecutionAcknowledgement::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& ExecutionAcknowledgement::order_id() const {
  return *order_id_;
}
inline void ExecutionAcknowledgement::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ExecutionAcknowledgement::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void ExecutionAcknowledgement::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionAcknowledgement::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* ExecutionAcknowledgement::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionAcknowledgement::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.OrderQtyData order_qty_data = 18;
inline bool ExecutionAcknowledgement::has_order_qty_data() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_order_qty_data() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ExecutionAcknowledgement::clear_has_order_qty_data() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ExecutionAcknowledgement::clear_order_qty_data() {
  if (order_qty_data_ != NULL) order_qty_data_->::Common::OrderQtyData::Clear();
  clear_has_order_qty_data();
}
inline const ::Common::OrderQtyData& ExecutionAcknowledgement::order_qty_data() const {
  return order_qty_data_ != NULL ? *order_qty_data_ : *default_instance_->order_qty_data_;
}
inline ::Common::OrderQtyData* ExecutionAcknowledgement::mutable_order_qty_data() {
  set_has_order_qty_data();
  if (order_qty_data_ == NULL) order_qty_data_ = new ::Common::OrderQtyData;
  return order_qty_data_;
}
inline ::Common::OrderQtyData* ExecutionAcknowledgement::release_order_qty_data() {
  clear_has_order_qty_data();
  ::Common::OrderQtyData* temp = order_qty_data_;
  order_qty_data_ = NULL;
  return temp;
}
inline void ExecutionAcknowledgement::set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data) {
  delete order_qty_data_;
  order_qty_data_ = order_qty_data;
  if (order_qty_data) {
    set_has_order_qty_data();
  } else {
    clear_has_order_qty_data();
  }
}

// optional .SingleGeneralOrderHandling.PriceTypeEnum price_type = 19;
inline bool ExecutionAcknowledgement::has_price_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_price_type() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ExecutionAcknowledgement::clear_has_price_type() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ExecutionAcknowledgement::clear_price_type() {
  price_type_ = 0;
  clear_has_price_type();
}
inline ::SingleGeneralOrderHandling::PriceTypeEnum ExecutionAcknowledgement::price_type() const {
  return static_cast< ::SingleGeneralOrderHandling::PriceTypeEnum >(price_type_);
}
inline void ExecutionAcknowledgement::set_price_type(::SingleGeneralOrderHandling::PriceTypeEnum value) {
  assert(::SingleGeneralOrderHandling::PriceTypeEnum_IsValid(value));
  set_has_price_type();
  price_type_ = value;
}

// optional string secondary_order_id = 20;
inline bool ExecutionAcknowledgement::has_secondary_order_id() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_secondary_order_id() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ExecutionAcknowledgement::clear_has_secondary_order_id() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ExecutionAcknowledgement::clear_secondary_order_id() {
  if (secondary_order_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_->clear();
  }
  clear_has_secondary_order_id();
}
inline const ::std::string& ExecutionAcknowledgement::secondary_order_id() const {
  return *secondary_order_id_;
}
inline void ExecutionAcknowledgement::set_secondary_order_id(const ::std::string& value) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(value);
}
inline void ExecutionAcknowledgement::set_secondary_order_id(const char* value) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(value);
}
inline void ExecutionAcknowledgement::set_secondary_order_id(const char* value, size_t size) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionAcknowledgement::mutable_secondary_order_id() {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  return secondary_order_id_;
}
inline ::std::string* ExecutionAcknowledgement::release_secondary_order_id() {
  clear_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_order_id_;
    secondary_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionAcknowledgement::set_allocated_secondary_order_id(::std::string* secondary_order_id) {
  if (secondary_order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_order_id_;
  }
  if (secondary_order_id) {
    set_has_secondary_order_id();
    secondary_order_id_ = secondary_order_id;
  } else {
    clear_has_secondary_order_id();
    secondary_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.SideEnum side = 21;
inline bool ExecutionAcknowledgement::has_side() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_side() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ExecutionAcknowledgement::clear_has_side() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ExecutionAcknowledgement::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::SingleGeneralOrderHandling::SideEnum ExecutionAcknowledgement::side() const {
  return static_cast< ::SingleGeneralOrderHandling::SideEnum >(side_);
}
inline void ExecutionAcknowledgement::set_side(::SingleGeneralOrderHandling::SideEnum value) {
  assert(::SingleGeneralOrderHandling::SideEnum_IsValid(value));
  set_has_side();
  side_ = value;
}

// optional .Session.StandardHeader standard_header = 22;
inline bool ExecutionAcknowledgement::has_standard_header() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_standard_header() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ExecutionAcknowledgement::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ExecutionAcknowledgement::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& ExecutionAcknowledgement::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* ExecutionAcknowledgement::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* ExecutionAcknowledgement::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void ExecutionAcknowledgement::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 23;
inline bool ExecutionAcknowledgement::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ExecutionAcknowledgement::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ExecutionAcknowledgement::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& ExecutionAcknowledgement::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* ExecutionAcknowledgement::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* ExecutionAcknowledgement::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void ExecutionAcknowledgement::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional string text = 24;
inline bool ExecutionAcknowledgement::has_text() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ExecutionAcknowledgement::set_has_text() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ExecutionAcknowledgement::clear_has_text() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ExecutionAcknowledgement::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ExecutionAcknowledgement::text() const {
  return *text_;
}
inline void ExecutionAcknowledgement::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ExecutionAcknowledgement::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ExecutionAcknowledgement::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecutionAcknowledgement::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ExecutionAcknowledgement::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecutionAcknowledgement::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 25;
inline int ExecutionAcknowledgement::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void ExecutionAcknowledgement::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& ExecutionAcknowledgement::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* ExecutionAcknowledgement::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* ExecutionAcknowledgement::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
ExecutionAcknowledgement::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
ExecutionAcknowledgement::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// -------------------------------------------------------------------

// DontKnowTrade

// optional .SingleGeneralOrderHandling.DKReasonEnum dkreason = 1;
inline bool DontKnowTrade::has_dkreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DontKnowTrade::set_has_dkreason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DontKnowTrade::clear_has_dkreason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DontKnowTrade::clear_dkreason() {
  dkreason_ = 0;
  clear_has_dkreason();
}
inline ::SingleGeneralOrderHandling::DKReasonEnum DontKnowTrade::dkreason() const {
  return static_cast< ::SingleGeneralOrderHandling::DKReasonEnum >(dkreason_);
}
inline void DontKnowTrade::set_dkreason(::SingleGeneralOrderHandling::DKReasonEnum value) {
  assert(::SingleGeneralOrderHandling::DKReasonEnum_IsValid(value));
  set_has_dkreason();
  dkreason_ = value;
}

// optional string exec_id = 2;
inline bool DontKnowTrade::has_exec_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DontKnowTrade::set_has_exec_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DontKnowTrade::clear_has_exec_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DontKnowTrade::clear_exec_id() {
  if (exec_id_ != &::google::protobuf::internal::kEmptyString) {
    exec_id_->clear();
  }
  clear_has_exec_id();
}
inline const ::std::string& DontKnowTrade::exec_id() const {
  return *exec_id_;
}
inline void DontKnowTrade::set_exec_id(const ::std::string& value) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(value);
}
inline void DontKnowTrade::set_exec_id(const char* value) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(value);
}
inline void DontKnowTrade::set_exec_id(const char* value, size_t size) {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  exec_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DontKnowTrade::mutable_exec_id() {
  set_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    exec_id_ = new ::std::string;
  }
  return exec_id_;
}
inline ::std::string* DontKnowTrade::release_exec_id() {
  clear_has_exec_id();
  if (exec_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exec_id_;
    exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DontKnowTrade::set_allocated_exec_id(::std::string* exec_id) {
  if (exec_id_ != &::google::protobuf::internal::kEmptyString) {
    delete exec_id_;
  }
  if (exec_id) {
    set_has_exec_id();
    exec_id_ = exec_id;
  } else {
    clear_has_exec_id();
    exec_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double last_px = 3;
inline bool DontKnowTrade::has_last_px() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DontKnowTrade::set_has_last_px() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DontKnowTrade::clear_has_last_px() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DontKnowTrade::clear_last_px() {
  last_px_ = 0;
  clear_has_last_px();
}
inline double DontKnowTrade::last_px() const {
  return last_px_;
}
inline void DontKnowTrade::set_last_px(double value) {
  set_has_last_px();
  last_px_ = value;
}

// optional sfixed64 last_qty = 4;
inline bool DontKnowTrade::has_last_qty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DontKnowTrade::set_has_last_qty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DontKnowTrade::clear_has_last_qty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DontKnowTrade::clear_last_qty() {
  last_qty_ = GOOGLE_LONGLONG(0);
  clear_has_last_qty();
}
inline ::google::protobuf::int64 DontKnowTrade::last_qty() const {
  return last_qty_;
}
inline void DontKnowTrade::set_last_qty(::google::protobuf::int64 value) {
  set_has_last_qty();
  last_qty_ = value;
}

// optional sfixed32 last_qty_exponent = 5;
inline bool DontKnowTrade::has_last_qty_exponent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DontKnowTrade::set_has_last_qty_exponent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DontKnowTrade::clear_has_last_qty_exponent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DontKnowTrade::clear_last_qty_exponent() {
  last_qty_exponent_ = 0;
  clear_has_last_qty_exponent();
}
inline ::google::protobuf::int32 DontKnowTrade::last_qty_exponent() const {
  return last_qty_exponent_;
}
inline void DontKnowTrade::set_last_qty_exponent(::google::protobuf::int32 value) {
  set_has_last_qty_exponent();
  last_qty_exponent_ = value;
}

// optional string order_id = 6;
inline bool DontKnowTrade::has_order_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DontKnowTrade::set_has_order_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DontKnowTrade::clear_has_order_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DontKnowTrade::clear_order_id() {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    order_id_->clear();
  }
  clear_has_order_id();
}
inline const ::std::string& DontKnowTrade::order_id() const {
  return *order_id_;
}
inline void DontKnowTrade::set_order_id(const ::std::string& value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void DontKnowTrade::set_order_id(const char* value) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(value);
}
inline void DontKnowTrade::set_order_id(const char* value, size_t size) {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DontKnowTrade::mutable_order_id() {
  set_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    order_id_ = new ::std::string;
  }
  return order_id_;
}
inline ::std::string* DontKnowTrade::release_order_id() {
  clear_has_order_id();
  if (order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = order_id_;
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DontKnowTrade::set_allocated_order_id(::std::string* order_id) {
  if (order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete order_id_;
  }
  if (order_id) {
    set_has_order_id();
    order_id_ = order_id;
  } else {
    clear_has_order_id();
    order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SingleGeneralOrderHandling.SideEnum side = 7;
inline bool DontKnowTrade::has_side() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DontKnowTrade::set_has_side() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DontKnowTrade::clear_has_side() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DontKnowTrade::clear_side() {
  side_ = 0;
  clear_has_side();
}
inline ::SingleGeneralOrderHandling::SideEnum DontKnowTrade::side() const {
  return static_cast< ::SingleGeneralOrderHandling::SideEnum >(side_);
}
inline void DontKnowTrade::set_side(::SingleGeneralOrderHandling::SideEnum value) {
  assert(::SingleGeneralOrderHandling::SideEnum_IsValid(value));
  set_has_side();
  side_ = value;
}

// optional .Session.StandardHeader standard_header = 8;
inline bool DontKnowTrade::has_standard_header() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DontKnowTrade::set_has_standard_header() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DontKnowTrade::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DontKnowTrade::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& DontKnowTrade::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* DontKnowTrade::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* DontKnowTrade::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void DontKnowTrade::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 9;
inline bool DontKnowTrade::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DontKnowTrade::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DontKnowTrade::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DontKnowTrade::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& DontKnowTrade::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* DontKnowTrade::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* DontKnowTrade::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void DontKnowTrade::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional string text = 10;
inline bool DontKnowTrade::has_text() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DontKnowTrade::set_has_text() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DontKnowTrade::clear_has_text() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DontKnowTrade::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& DontKnowTrade::text() const {
  return *text_;
}
inline void DontKnowTrade::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DontKnowTrade::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void DontKnowTrade::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DontKnowTrade::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* DontKnowTrade::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DontKnowTrade::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_text = 11;
inline bool DontKnowTrade::has_encoded_text() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DontKnowTrade::set_has_encoded_text() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DontKnowTrade::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DontKnowTrade::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& DontKnowTrade::encoded_text() const {
  return *encoded_text_;
}
inline void DontKnowTrade::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void DontKnowTrade::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void DontKnowTrade::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DontKnowTrade::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* DontKnowTrade::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DontKnowTrade::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 12;
inline bool DontKnowTrade::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DontKnowTrade::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DontKnowTrade::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DontKnowTrade::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 DontKnowTrade::encoded_text_len() const {
  return encoded_text_len_;
}
inline void DontKnowTrade::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional .Common.Instrument instrument = 13;
inline bool DontKnowTrade::has_instrument() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DontKnowTrade::set_has_instrument() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DontKnowTrade::clear_has_instrument() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DontKnowTrade::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& DontKnowTrade::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* DontKnowTrade::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* DontKnowTrade::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void DontKnowTrade::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional .Common.OrderQtyData order_qty_data = 14;
inline bool DontKnowTrade::has_order_qty_data() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DontKnowTrade::set_has_order_qty_data() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DontKnowTrade::clear_has_order_qty_data() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DontKnowTrade::clear_order_qty_data() {
  if (order_qty_data_ != NULL) order_qty_data_->::Common::OrderQtyData::Clear();
  clear_has_order_qty_data();
}
inline const ::Common::OrderQtyData& DontKnowTrade::order_qty_data() const {
  return order_qty_data_ != NULL ? *order_qty_data_ : *default_instance_->order_qty_data_;
}
inline ::Common::OrderQtyData* DontKnowTrade::mutable_order_qty_data() {
  set_has_order_qty_data();
  if (order_qty_data_ == NULL) order_qty_data_ = new ::Common::OrderQtyData;
  return order_qty_data_;
}
inline ::Common::OrderQtyData* DontKnowTrade::release_order_qty_data() {
  clear_has_order_qty_data();
  ::Common::OrderQtyData* temp = order_qty_data_;
  order_qty_data_ = NULL;
  return temp;
}
inline void DontKnowTrade::set_allocated_order_qty_data(::Common::OrderQtyData* order_qty_data) {
  delete order_qty_data_;
  order_qty_data_ = order_qty_data;
  if (order_qty_data) {
    set_has_order_qty_data();
  } else {
    clear_has_order_qty_data();
  }
}

// repeated .Common.InstrmtLegGrp instrmt_leg_grp = 15;
inline int DontKnowTrade::instrmt_leg_grp_size() const {
  return instrmt_leg_grp_.size();
}
inline void DontKnowTrade::clear_instrmt_leg_grp() {
  instrmt_leg_grp_.Clear();
}
inline const ::Common::InstrmtLegGrp& DontKnowTrade::instrmt_leg_grp(int index) const {
  return instrmt_leg_grp_.Get(index);
}
inline ::Common::InstrmtLegGrp* DontKnowTrade::mutable_instrmt_leg_grp(int index) {
  return instrmt_leg_grp_.Mutable(index);
}
inline ::Common::InstrmtLegGrp* DontKnowTrade::add_instrmt_leg_grp() {
  return instrmt_leg_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
DontKnowTrade::instrmt_leg_grp() const {
  return instrmt_leg_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
DontKnowTrade::mutable_instrmt_leg_grp() {
  return &instrmt_leg_grp_;
}

// optional string secondary_order_id = 16;
inline bool DontKnowTrade::has_secondary_order_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void DontKnowTrade::set_has_secondary_order_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void DontKnowTrade::clear_has_secondary_order_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void DontKnowTrade::clear_secondary_order_id() {
  if (secondary_order_id_ != &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_->clear();
  }
  clear_has_secondary_order_id();
}
inline const ::std::string& DontKnowTrade::secondary_order_id() const {
  return *secondary_order_id_;
}
inline void DontKnowTrade::set_secondary_order_id(const ::std::string& value) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(value);
}
inline void DontKnowTrade::set_secondary_order_id(const char* value) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(value);
}
inline void DontKnowTrade::set_secondary_order_id(const char* value, size_t size) {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  secondary_order_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DontKnowTrade::mutable_secondary_order_id() {
  set_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    secondary_order_id_ = new ::std::string;
  }
  return secondary_order_id_;
}
inline ::std::string* DontKnowTrade::release_secondary_order_id() {
  clear_has_secondary_order_id();
  if (secondary_order_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secondary_order_id_;
    secondary_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DontKnowTrade::set_allocated_secondary_order_id(::std::string* secondary_order_id) {
  if (secondary_order_id_ != &::google::protobuf::internal::kEmptyString) {
    delete secondary_order_id_;
  }
  if (secondary_order_id) {
    set_has_secondary_order_id();
    secondary_order_id_ = secondary_order_id;
  } else {
    clear_has_secondary_order_id();
    secondary_order_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 17;
inline int DontKnowTrade::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void DontKnowTrade::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& DontKnowTrade::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* DontKnowTrade::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* DontKnowTrade::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
DontKnowTrade::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
DontKnowTrade::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SingleGeneralOrderHandling

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::AcctIdSourceEnum>() {
  return ::SingleGeneralOrderHandling::AcctIdSourceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::AccountTypeEnum>() {
  return ::SingleGeneralOrderHandling::AccountTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::DayBookingInstEnum>() {
  return ::SingleGeneralOrderHandling::DayBookingInstEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::BookingUnitEnum>() {
  return ::SingleGeneralOrderHandling::BookingUnitEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::PreallocMethodEnum>() {
  return ::SingleGeneralOrderHandling::PreallocMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::SettlTypeEnum>() {
  return ::SingleGeneralOrderHandling::SettlTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::CashMarginEnum>() {
  return ::SingleGeneralOrderHandling::CashMarginEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum>() {
  return ::SingleGeneralOrderHandling::ClearingFeeIndicatorEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::HandlInstEnum>() {
  return ::SingleGeneralOrderHandling::HandlInstEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ExecInstEnum>() {
  return ::SingleGeneralOrderHandling::ExecInstEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ExDestinationIdSourceEnum>() {
  return ::SingleGeneralOrderHandling::ExDestinationIdSourceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ProcessCodeEnum>() {
  return ::SingleGeneralOrderHandling::ProcessCodeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::SideEnum>() {
  return ::SingleGeneralOrderHandling::SideEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::LocateReqdEnum>() {
  return ::SingleGeneralOrderHandling::LocateReqdEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::QtyTypeEnum>() {
  return ::SingleGeneralOrderHandling::QtyTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::OrdTypeEnum>() {
  return ::SingleGeneralOrderHandling::OrdTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::PriceTypeEnum>() {
  return ::SingleGeneralOrderHandling::PriceTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::PriceProtectionScopeEnum>() {
  return ::SingleGeneralOrderHandling::PriceProtectionScopeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::SolicitedFlagEnum>() {
  return ::SingleGeneralOrderHandling::SolicitedFlagEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::TimeInForceEnum>() {
  return ::SingleGeneralOrderHandling::TimeInForceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::GtBookingInstEnum>() {
  return ::SingleGeneralOrderHandling::GtBookingInstEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::OrderCapacityEnum>() {
  return ::SingleGeneralOrderHandling::OrderCapacityEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::OrderRestrictionsEnum>() {
  return ::SingleGeneralOrderHandling::OrderRestrictionsEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::CustOrderCapacityEnum>() {
  return ::SingleGeneralOrderHandling::CustOrderCapacityEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ForexReqEnum>() {
  return ::SingleGeneralOrderHandling::ForexReqEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::BookingTypeEnum>() {
  return ::SingleGeneralOrderHandling::BookingTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::PositionEffectEnum>() {
  return ::SingleGeneralOrderHandling::PositionEffectEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::CoveredOrUncoveredEnum>() {
  return ::SingleGeneralOrderHandling::CoveredOrUncoveredEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::TargetStrategyEnum>() {
  return ::SingleGeneralOrderHandling::TargetStrategyEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::CancellationRightsEnum>() {
  return ::SingleGeneralOrderHandling::CancellationRightsEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum>() {
  return ::SingleGeneralOrderHandling::MoneyLaunderingStatusEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum>() {
  return ::SingleGeneralOrderHandling::CustOrderHandlingInstEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum>() {
  return ::SingleGeneralOrderHandling::OrderHandlingInstSourceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::RefOrderIdSourceEnum>() {
  return ::SingleGeneralOrderHandling::RefOrderIdSourceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::OrdStatusEnum>() {
  return ::SingleGeneralOrderHandling::OrdStatusEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::WorkingIndicatorEnum>() {
  return ::SingleGeneralOrderHandling::WorkingIndicatorEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::CxlRejResponseToEnum>() {
  return ::SingleGeneralOrderHandling::CxlRejResponseToEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::CxlRejReasonEnum>() {
  return ::SingleGeneralOrderHandling::CxlRejReasonEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::LastRptRequestedEnum>() {
  return ::SingleGeneralOrderHandling::LastRptRequestedEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::CrossTypeEnum>() {
  return ::SingleGeneralOrderHandling::CrossTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ExecTypeEnum>() {
  return ::SingleGeneralOrderHandling::ExecTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::OrdRejReasonEnum>() {
  return ::SingleGeneralOrderHandling::OrdRejReasonEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ExecRestatementReasonEnum>() {
  return ::SingleGeneralOrderHandling::ExecRestatementReasonEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::MatchTypeEnum>() {
  return ::SingleGeneralOrderHandling::MatchTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::OrderCategoryEnum>() {
  return ::SingleGeneralOrderHandling::OrderCategoryEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::LotTypeEnum>() {
  return ::SingleGeneralOrderHandling::LotTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::AggressorIndicatorEnum>() {
  return ::SingleGeneralOrderHandling::AggressorIndicatorEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::TradingSessionIdEnum>() {
  return ::SingleGeneralOrderHandling::TradingSessionIdEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::TradingSessionSubIdEnum>() {
  return ::SingleGeneralOrderHandling::TradingSessionSubIdEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::LastCapacityEnum>() {
  return ::SingleGeneralOrderHandling::LastCapacityEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::LastFragmentEnum>() {
  return ::SingleGeneralOrderHandling::LastFragmentEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ReportToExchEnum>() {
  return ::SingleGeneralOrderHandling::ReportToExchEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::TradedFlatSwitchEnum>() {
  return ::SingleGeneralOrderHandling::TradedFlatSwitchEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::SettlCurrFxRateCalcEnum>() {
  return ::SingleGeneralOrderHandling::SettlCurrFxRateCalcEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::MultiLegReportingTypeEnum>() {
  return ::SingleGeneralOrderHandling::MultiLegReportingTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ExecPriceTypeEnum>() {
  return ::SingleGeneralOrderHandling::ExecPriceTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::PriorityIndicatorEnum>() {
  return ::SingleGeneralOrderHandling::PriorityIndicatorEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::LastLiquidityIndEnum>() {
  return ::SingleGeneralOrderHandling::LastLiquidityIndEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::ExecAckStatusEnum>() {
  return ::SingleGeneralOrderHandling::ExecAckStatusEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SingleGeneralOrderHandling::DKReasonEnum>() {
  return ::SingleGeneralOrderHandling::DKReasonEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_singlegeneralorderhandling_2eproto__INCLUDED
