// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_common_2eproto__INCLUDED
#define PROTOBUF_common_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "meta.pb.h"
#include "fix.pb.h"
// @@protoc_insertion_point(includes)

namespace Common {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_common_2eproto();
void protobuf_AssignDesc_common_2eproto();
void protobuf_ShutdownFile_common_2eproto();

class PartySubIdTypeUnion;
class PtysSubGrp;
class Parties;
class NstdPtysSubGrp;
class NestedParties;
class PreAllocGrp;
class DisplayInstruction;
class TradingSessionIdUnion;
class TradingSessionSubIdUnion;
class TrdgSesGrp;
class SecAltIdGrp;
class SecurityXml;
class EventTypeUnion;
class EvntGrp;
class InstrumentPtysSubGrp;
class InstrumentParties;
class ComplexEventTimes;
class ComplexEventDates;
class ComplexEvents;
class StrikePriceDeterminationMethodUnion;
class FlowScheduleTypeUnion;
class CpProgramUnion;
class Instrument;
class FinancingDetails;
class UndSecAltIdGrp;
class UnderlyingStipulations;
class UndlyInstrumentPtysSubGrp;
class UndlyInstrumentParties;
class UnderlyingFlowScheduleTypeUnion;
class UnderlyingInstrument;
class UndInstrmtGrp;
class Stipulations;
class OrderQtyData;
class TriggeringInstruction;
class SpreadOrBenchmarkCurveData;
class YieldData;
class CommissionData;
class PegInstructions;
class DiscretionInstructions;
class StrategyParametersGrp;
class TrdRegTimestamps;
class ApplicationSequenceControl;
class ContraGrp;
class NstdPtys4SubGrp;
class NestedParties4;
class RateSource;
class ContAmtGrp;
class LegSecAltIdGrp;
class LegFlowScheduleTypeUnion;
class InstrumentLeg;
class LegStipulations;
class NstdPtys2SubGrp;
class NestedParties2;
class LegPreAllocGrp;
class NstdPtys3SubGrp;
class NestedParties3;
class InstrmtLegExecGrp;
class MiscFeesGrp;
class InstrmtLegGrp;
class InstrmtLegIoiGrp;
class RoutingGrp;
class InstrAttribTypeUnion;
class AttrbGrp;
class InstrumentExtension;
class TickRules;
class LotTypeRules;
class PriceLimits;
class BaseTradingRules;
class OrdTypeRules;
class TimeInForceRules;
class ExecInstRules;
class MatchRules;
class MarketDataFeedTypes;
class TradingSessionRules;
class TradingSessionRulesGrp;
class NestedInstrumentAttribute;
class SecurityTradingRules;
class MaturityRules;
class StrikeRules;
class MarketSegmentGrp;
class LegBenchmarkCurveData;
class InstrmtLegSecListGrp;

enum PartySubIdTypeEnum {
  PARTY_SUB_ID_TYPE_APPLICATION = 0,
  PARTY_SUB_ID_TYPE_BIC = 1,
  PARTY_SUB_ID_TYPE_CSDPARTICIPANT_MEMBER_CODE = 2,
  PARTY_SUB_ID_TYPE_CASH_ACCOUNT_NAME = 3,
  PARTY_SUB_ID_TYPE_CASH_ACCOUNT_NUMBER = 4,
  PARTY_SUB_ID_TYPE_CONTACT_NAME = 5,
  PARTY_SUB_ID_TYPE_DEPARTMENT = 6,
  PARTY_SUB_ID_TYPE_EMAIL_ADDRESS = 7,
  PARTY_SUB_ID_TYPE_FAX_NUMBER = 8,
  PARTY_SUB_ID_TYPE_FIRM = 9,
  PARTY_SUB_ID_TYPE_FULL_LEGAL_NAME_OF_FIRM = 10,
  PARTY_SUB_ID_TYPE_FUND_ACCOUNT_NAME = 11,
  PARTY_SUB_ID_TYPE_LOCATION_DESK = 12,
  PARTY_SUB_ID_TYPE_PERSON = 13,
  PARTY_SUB_ID_TYPE_PHONE_NUMBER = 14,
  PARTY_SUB_ID_TYPE_POSITION_ACCOUNT_TYPE = 15,
  PARTY_SUB_ID_TYPE_POSTAL_ADDRESS = 16,
  PARTY_SUB_ID_TYPE_REGISTERED_ADDRESS = 17,
  PARTY_SUB_ID_TYPE_REGISTERED_ADDRESS_FOR_CONFIRMATION = 18,
  PARTY_SUB_ID_TYPE_REGISTRATION_NAME = 19,
  PARTY_SUB_ID_TYPE_REGISTRATION_NUMBER = 20,
  PARTY_SUB_ID_TYPE_REGULATORY_STATUS = 21,
  PARTY_SUB_ID_TYPE_SECURITIES_ACCOUNT_NAME = 22,
  PARTY_SUB_ID_TYPE_SECURITIES_ACCOUNT_NUMBER = 23,
  PARTY_SUB_ID_TYPE_SYSTEM = 24,
  PARTY_SUB_ID_TYPE_TELEX_NUMBER = 25,
  PARTY_SUB_ID_TYPE_SECURITY_LOCATE_ID = 26,
  PARTY_SUB_ID_TYPE_ELIGIBLE_COUNTERPARTY = 27,
  PARTY_SUB_ID_TYPE_EXECUTION_VENUE = 28,
  PARTY_SUB_ID_TYPE_LOCATION = 29,
  PARTY_SUB_ID_TYPE_MARKET_MAKER = 30,
  PARTY_SUB_ID_TYPE_PROFESSIONAL_CLIENT = 31,
  PARTY_SUB_ID_TYPE_CURRENCY_DELIVERY_IDENTIFIER = 32
};
bool PartySubIdTypeEnum_IsValid(int value);
const PartySubIdTypeEnum PartySubIdTypeEnum_MIN = PARTY_SUB_ID_TYPE_APPLICATION;
const PartySubIdTypeEnum PartySubIdTypeEnum_MAX = PARTY_SUB_ID_TYPE_CURRENCY_DELIVERY_IDENTIFIER;
const int PartySubIdTypeEnum_ARRAYSIZE = PartySubIdTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartySubIdTypeEnum_descriptor();
inline const ::std::string& PartySubIdTypeEnum_Name(PartySubIdTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartySubIdTypeEnum_descriptor(), value);
}
inline bool PartySubIdTypeEnum_Parse(
    const ::std::string& name, PartySubIdTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartySubIdTypeEnum>(
    PartySubIdTypeEnum_descriptor(), name, value);
}
enum PartyIdSourceEnum {
  PARTY_ID_SOURCE_AUSTRALIAN_BUSINESS_NUMBER = 0,
  PARTY_ID_SOURCE_AUSTRALIAN_TAX_FILE_NUMBER = 1,
  PARTY_ID_SOURCE_BIC = 2,
  PARTY_ID_SOURCE_CHINESE_INVESTOR_ID = 3,
  PARTY_ID_SOURCE_GENERAL_IDENTIFIER = 4,
  PARTY_ID_SOURCE_ISO_COUNTRY_CODE = 5,
  PARTY_ID_SOURCE_KOREAN_INVESTOR_ID = 6,
  PARTY_ID_SOURCE_MALAYSIAN_CENTRAL_DEPOSITORY = 7,
  PARTY_ID_SOURCE_PROPRIETARY = 8,
  PARTY_ID_SOURCE_SETTLEMENT_ENTITY_LOCATION = 9,
  PARTY_ID_SOURCE_TAIWANESE_FOREIGN_INVESTOR_ID = 10,
  PARTY_ID_SOURCE_TAIWANESE_TRADING_ACCT = 11,
  PARTY_ID_SOURCE_UK_NATIONAL_INSURANCE_OR_PENSION_NUMBER = 12,
  PARTY_ID_SOURCE_US_EMPLOYER_OR_TAX_ID_NUMBER = 13,
  PARTY_ID_SOURCE_US_SOCIAL_SECURITY_NUMBER = 14,
  PARTY_ID_SOURCE_CSDPARTICIPANT = 15,
  PARTY_ID_SOURCE_ISITCACRONYM = 16,
  PARTY_ID_SOURCE_MIC = 17
};
bool PartyIdSourceEnum_IsValid(int value);
const PartyIdSourceEnum PartyIdSourceEnum_MIN = PARTY_ID_SOURCE_AUSTRALIAN_BUSINESS_NUMBER;
const PartyIdSourceEnum PartyIdSourceEnum_MAX = PARTY_ID_SOURCE_MIC;
const int PartyIdSourceEnum_ARRAYSIZE = PartyIdSourceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartyIdSourceEnum_descriptor();
inline const ::std::string& PartyIdSourceEnum_Name(PartyIdSourceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartyIdSourceEnum_descriptor(), value);
}
inline bool PartyIdSourceEnum_Parse(
    const ::std::string& name, PartyIdSourceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartyIdSourceEnum>(
    PartyIdSourceEnum_descriptor(), name, value);
}
enum PartyRoleEnum {
  PARTY_ROLE_BROKER_OF_CREDIT = 0,
  PARTY_ROLE_CLEARING_FIRM = 1,
  PARTY_ROLE_CLIENT_ID = 2,
  PARTY_ROLE_CONTRA_CLEARING_FIRM = 3,
  PARTY_ROLE_CONTRA_FIRM = 4,
  PARTY_ROLE_CORRESPONDANT_CLEARING_FIRM = 5,
  PARTY_ROLE_ENTERING_FIRM = 6,
  PARTY_ROLE_EXECUTING_FIRM = 7,
  PARTY_ROLE_EXECUTING_SYSTEM = 8,
  PARTY_ROLE_EXECUTING_TRADER = 9,
  PARTY_ROLE_FUND_MANAGER_CLIENT_ID = 10,
  PARTY_ROLE_GIVEUP_CLEARING_FIRM = 11,
  PARTY_ROLE_INTRODUCING_FIRM = 12,
  PARTY_ROLE_INVESTOR_ID = 13,
  PARTY_ROLE_LOCATE = 14,
  PARTY_ROLE_ORDER_ORIGINATION_FIRM = 15,
  PARTY_ROLE_ORDER_ORIGINATION_TRADER = 16,
  PARTY_ROLE_SETTLEMENT_LOCATION = 17,
  PARTY_ROLE_SPONSORING_FIRM = 18,
  PARTY_ROLE_UNDERLYING_CONTRA_FIRM = 19,
  PARTY_ROLE_CONTRA_INVESTOR_ID = 20,
  PARTY_ROLE_TRANSFER_TO_FIRM = 21,
  PARTY_ROLE_AGENT = 22,
  PARTY_ROLE_BENEFICIARY = 23,
  PARTY_ROLE_BUYER = 24,
  PARTY_ROLE_CLEARING_ORGANIZATION = 25,
  PARTY_ROLE_CONTRA_TRADER = 26,
  PARTY_ROLE_CORRESPONDENT_BROKER = 27,
  PARTY_ROLE_CORRESPONDENT_CLEARING_ORGANIZATION = 28,
  PARTY_ROLE_CUSTODIAN = 29,
  PARTY_ROLE_CUSTOMER_ACCOUNT = 30,
  PARTY_ROLE_ENTERING_TRADER = 31,
  PARTY_ROLE_EXCHANGE = 32,
  PARTY_ROLE_INTERESTED_PARTY = 33,
  PARTY_ROLE_INTERMEDIARY = 34,
  PARTY_ROLE_LIQUIDITY_PROVIDER = 35,
  PARTY_ROLE_POSITION_ACCOUNT = 36,
  PARTY_ROLE_REGULATORY_BODY = 37,
  PARTY_ROLE_SUB_CUSTODIAN = 38,
  PARTY_ROLE_INTRODUCING_BROKER = 39,
  PARTY_ROLE_CONTRA_EXCHANGE = 40,
  PARTY_ROLE_CONTRA_POSITION_ACCOUNT = 41,
  PARTY_ROLE_INTERNAL_CARRY_ACCOUNT = 42,
  PARTY_ROLE_ORDER_ENTRY_OPERATOR_ID = 43,
  PARTY_ROLE_SECONDARY_ACCOUNT_NUMBER = 44,
  PARTY_ROLE_ASSET_MANAGER = 45,
  PARTY_ROLE_CLAIMING_ACCOUNT = 46,
  PARTY_ROLE_FOREIGN_FIRM = 47,
  PARTY_ROLE_LARGE_TRADER_REPORTABLE_ACCOUNT = 48,
  PARTY_ROLE_PLEDGEE_ACCOUNT = 49,
  PARTY_ROLE_PLEDGOR_ACCOUNT = 50,
  PARTY_ROLE_SENDER_LOCATION = 51,
  PARTY_ROLE_SESSION_ID = 52,
  PARTY_ROLE_THIRD_PARTY_ALLOCATION_FIRM = 53,
  PARTY_ROLE_TRADER_MNEMONIC = 54,
  PARTY_ROLE_ACCEPTABLE_COUNTERPARTY = 55,
  PARTY_ROLE_ENTERING_UNIT = 56,
  PARTY_ROLE_EXECUTING_UNIT = 57,
  PARTY_ROLE_UNACCEPTABLE_COUNTERPARTY = 58,
  PARTY_ROLE_COMPETENT_AUTHORITY_LIQUIDITY = 59,
  PARTY_ROLE_COMPETENT_AUTHORITY_TRANSACTION_VENUE = 60,
  PARTY_ROLE_DESK_ID = 61,
  PARTY_ROLE_EXECUTION_VENUE = 62,
  PARTY_ROLE_HOME_COMPETENT_AUTHORITY = 63,
  PARTY_ROLE_HOST_COMPETENT_AUTHORITY = 64,
  PARTY_ROLE_INVESTMENT_FIRM = 65,
  PARTY_ROLE_LOCATION_ID = 66,
  PARTY_ROLE_MARKET_DATA_ENTRY_ORIGINATOR = 67,
  PARTY_ROLE_MARKET_DATA_MARKET = 68,
  PARTY_ROLE_MARKET_MAKER = 69,
  PARTY_ROLE_MULTILATERAL_TRADING_FACILITY = 70,
  PARTY_ROLE_QUOTE_ORIGINATOR = 71,
  PARTY_ROLE_REGULATED_MARKET = 72,
  PARTY_ROLE_REPORT_ORIGINATOR = 73,
  PARTY_ROLE_REPORTING_INTERMEDIARY = 74,
  PARTY_ROLE_SYSTEMATIC_INTERNALISER = 75,
  PARTY_ROLE_ALLOCATION_ENTITY = 76,
  PARTY_ROLE_BROKER_CLEARING_ID = 77,
  PARTY_ROLE_PRIME_BROKER = 78,
  PARTY_ROLE_STEP_OUT_FIRM = 79,
  PARTY_ROLE_CENTRAL_REGISTRATION_DEPOSITORY = 80,
  PARTY_ROLE_ACCEPTABLE_SETTLING_COUNTERPARTY = 81,
  PARTY_ROLE_CLEARING_ACCOUNT = 82,
  PARTY_ROLE_UNACCEPTABLE_SETTLING_COUNTERPARTY = 83
};
bool PartyRoleEnum_IsValid(int value);
const PartyRoleEnum PartyRoleEnum_MIN = PARTY_ROLE_BROKER_OF_CREDIT;
const PartyRoleEnum PartyRoleEnum_MAX = PARTY_ROLE_UNACCEPTABLE_SETTLING_COUNTERPARTY;
const int PartyRoleEnum_ARRAYSIZE = PartyRoleEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartyRoleEnum_descriptor();
inline const ::std::string& PartyRoleEnum_Name(PartyRoleEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartyRoleEnum_descriptor(), value);
}
inline bool PartyRoleEnum_Parse(
    const ::std::string& name, PartyRoleEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartyRoleEnum>(
    PartyRoleEnum_descriptor(), name, value);
}
enum DisplayWhenEnum {
  DISPLAY_WHEN_EXHAUST = 0,
  DISPLAY_WHEN_IMMEDIATE = 1
};
bool DisplayWhenEnum_IsValid(int value);
const DisplayWhenEnum DisplayWhenEnum_MIN = DISPLAY_WHEN_EXHAUST;
const DisplayWhenEnum DisplayWhenEnum_MAX = DISPLAY_WHEN_IMMEDIATE;
const int DisplayWhenEnum_ARRAYSIZE = DisplayWhenEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DisplayWhenEnum_descriptor();
inline const ::std::string& DisplayWhenEnum_Name(DisplayWhenEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DisplayWhenEnum_descriptor(), value);
}
inline bool DisplayWhenEnum_Parse(
    const ::std::string& name, DisplayWhenEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplayWhenEnum>(
    DisplayWhenEnum_descriptor(), name, value);
}
enum DisplayMethodEnum {
  DISPLAY_METHOD_INITIAL = 0,
  DISPLAY_METHOD_NEW = 1,
  DISPLAY_METHOD_RANDOM = 2,
  DISPLAY_METHOD_UNDISCLOSED = 3
};
bool DisplayMethodEnum_IsValid(int value);
const DisplayMethodEnum DisplayMethodEnum_MIN = DISPLAY_METHOD_INITIAL;
const DisplayMethodEnum DisplayMethodEnum_MAX = DISPLAY_METHOD_UNDISCLOSED;
const int DisplayMethodEnum_ARRAYSIZE = DisplayMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DisplayMethodEnum_descriptor();
inline const ::std::string& DisplayMethodEnum_Name(DisplayMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DisplayMethodEnum_descriptor(), value);
}
inline bool DisplayMethodEnum_Parse(
    const ::std::string& name, DisplayMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DisplayMethodEnum>(
    DisplayMethodEnum_descriptor(), name, value);
}
enum TradingSessionIdEnum {
  TRADING_SESSION_ID_AFTER_HOURS = 0,
  TRADING_SESSION_ID_AFTERNOON = 1,
  TRADING_SESSION_ID_DAY = 2,
  TRADING_SESSION_ID_EVENING = 3,
  TRADING_SESSION_ID_HALF_DAY = 4,
  TRADING_SESSION_ID_MORNING = 5
};
bool TradingSessionIdEnum_IsValid(int value);
const TradingSessionIdEnum TradingSessionIdEnum_MIN = TRADING_SESSION_ID_AFTER_HOURS;
const TradingSessionIdEnum TradingSessionIdEnum_MAX = TRADING_SESSION_ID_MORNING;
const int TradingSessionIdEnum_ARRAYSIZE = TradingSessionIdEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradingSessionIdEnum_descriptor();
inline const ::std::string& TradingSessionIdEnum_Name(TradingSessionIdEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradingSessionIdEnum_descriptor(), value);
}
inline bool TradingSessionIdEnum_Parse(
    const ::std::string& name, TradingSessionIdEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradingSessionIdEnum>(
    TradingSessionIdEnum_descriptor(), name, value);
}
enum TradingSessionSubIdEnum {
  TRADING_SESSION_SUB_ID_CLOSING_OR_CLOSING_AUCTION = 0,
  TRADING_SESSION_SUB_ID_CONTINUOUS = 1,
  TRADING_SESSION_SUB_ID_INTRADAY_AUCTION = 2,
  TRADING_SESSION_SUB_ID_OPENING_OR_OPENING_AUCTION = 3,
  TRADING_SESSION_SUB_ID_POST_TRADING = 4,
  TRADING_SESSION_SUB_ID_PRE_TRADING = 5,
  TRADING_SESSION_SUB_ID_QUIESCENT = 6
};
bool TradingSessionSubIdEnum_IsValid(int value);
const TradingSessionSubIdEnum TradingSessionSubIdEnum_MIN = TRADING_SESSION_SUB_ID_CLOSING_OR_CLOSING_AUCTION;
const TradingSessionSubIdEnum TradingSessionSubIdEnum_MAX = TRADING_SESSION_SUB_ID_QUIESCENT;
const int TradingSessionSubIdEnum_ARRAYSIZE = TradingSessionSubIdEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradingSessionSubIdEnum_descriptor();
inline const ::std::string& TradingSessionSubIdEnum_Name(TradingSessionSubIdEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradingSessionSubIdEnum_descriptor(), value);
}
inline bool TradingSessionSubIdEnum_Parse(
    const ::std::string& name, TradingSessionSubIdEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradingSessionSubIdEnum>(
    TradingSessionSubIdEnum_descriptor(), name, value);
}
enum EventTypeEnum {
  EVENT_TYPE_CALL = 0,
  EVENT_TYPE_OTHER = 1,
  EVENT_TYPE_PUT = 2,
  EVENT_TYPE_SINKING_FUND_CALL = 3,
  EVENT_TYPE_TENDER = 4,
  EVENT_TYPE_ACTIVATION = 5,
  EVENT_TYPE_INACTIVIATION = 6,
  EVENT_TYPE_LAST_ELIGIBLE_TRADE_DATE = 7,
  EVENT_TYPE_FINAL_INVENTORY_DUE_DATE = 8,
  EVENT_TYPE_FIRST_DELIVERY_DATE = 9,
  EVENT_TYPE_FIRST_INTENT_DATE = 10,
  EVENT_TYPE_INITIAL_INVENTORY_DUE_DATE = 11,
  EVENT_TYPE_LAST_DELIVERY_DATE = 12,
  EVENT_TYPE_LAST_INTENT_DATE = 13,
  EVENT_TYPE_POSITION_REMOVAL_DATE = 14,
  EVENT_TYPE_SWAP_END_DATE = 15,
  EVENT_TYPE_SWAP_NEXT_ROLL_DATE = 16,
  EVENT_TYPE_SWAP_NEXT_START_DATE = 17,
  EVENT_TYPE_SWAP_ROLL_DATE = 18,
  EVENT_TYPE_SWAP_START_DATE = 19
};
bool EventTypeEnum_IsValid(int value);
const EventTypeEnum EventTypeEnum_MIN = EVENT_TYPE_CALL;
const EventTypeEnum EventTypeEnum_MAX = EVENT_TYPE_SWAP_START_DATE;
const int EventTypeEnum_ARRAYSIZE = EventTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventTypeEnum_descriptor();
inline const ::std::string& EventTypeEnum_Name(EventTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventTypeEnum_descriptor(), value);
}
inline bool EventTypeEnum_Parse(
    const ::std::string& name, EventTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventTypeEnum>(
    EventTypeEnum_descriptor(), name, value);
}
enum ComplexEventTypeEnum {
  COMPLEX_EVENT_TYPE_CAPPED = 0,
  COMPLEX_EVENT_TYPE_KNOCK_IN_UP = 1,
  COMPLEX_EVENT_TYPE_KNOCK_OUT_DOWN = 2,
  COMPLEX_EVENT_TYPE_KNOCK_OUT_UP = 3,
  COMPLEX_EVENT_TYPE_KOCK_IN_DOWN = 4,
  COMPLEX_EVENT_TYPE_RESET_BARRIER = 5,
  COMPLEX_EVENT_TYPE_ROLLING_BARRIER = 6,
  COMPLEX_EVENT_TYPE_TRIGGER = 7,
  COMPLEX_EVENT_TYPE_UNDERLYING = 8
};
bool ComplexEventTypeEnum_IsValid(int value);
const ComplexEventTypeEnum ComplexEventTypeEnum_MIN = COMPLEX_EVENT_TYPE_CAPPED;
const ComplexEventTypeEnum ComplexEventTypeEnum_MAX = COMPLEX_EVENT_TYPE_UNDERLYING;
const int ComplexEventTypeEnum_ARRAYSIZE = ComplexEventTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComplexEventTypeEnum_descriptor();
inline const ::std::string& ComplexEventTypeEnum_Name(ComplexEventTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComplexEventTypeEnum_descriptor(), value);
}
inline bool ComplexEventTypeEnum_Parse(
    const ::std::string& name, ComplexEventTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComplexEventTypeEnum>(
    ComplexEventTypeEnum_descriptor(), name, value);
}
enum ComplexEventPriceBoundaryMethodEnum {
  COMPLEX_EVENT_PRICE_BOUNDARY_METHOD_EQUAL_TO_COMPLEX_EVENT_PRICE = 0,
  COMPLEX_EVENT_PRICE_BOUNDARY_METHOD_GREATER_THAN_COMPLEX_EVENT_PRICE = 1,
  COMPLEX_EVENT_PRICE_BOUNDARY_METHOD_GREATER_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE = 2,
  COMPLEX_EVENT_PRICE_BOUNDARY_METHOD_LESS_THAN_COMPLEX_EVENT_PRICE = 3,
  COMPLEX_EVENT_PRICE_BOUNDARY_METHOD_LESS_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE = 4
};
bool ComplexEventPriceBoundaryMethodEnum_IsValid(int value);
const ComplexEventPriceBoundaryMethodEnum ComplexEventPriceBoundaryMethodEnum_MIN = COMPLEX_EVENT_PRICE_BOUNDARY_METHOD_EQUAL_TO_COMPLEX_EVENT_PRICE;
const ComplexEventPriceBoundaryMethodEnum ComplexEventPriceBoundaryMethodEnum_MAX = COMPLEX_EVENT_PRICE_BOUNDARY_METHOD_LESS_THAN_OR_EQUAL_TO_COMPLEX_EVENT_PRICE;
const int ComplexEventPriceBoundaryMethodEnum_ARRAYSIZE = ComplexEventPriceBoundaryMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComplexEventPriceBoundaryMethodEnum_descriptor();
inline const ::std::string& ComplexEventPriceBoundaryMethodEnum_Name(ComplexEventPriceBoundaryMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComplexEventPriceBoundaryMethodEnum_descriptor(), value);
}
inline bool ComplexEventPriceBoundaryMethodEnum_Parse(
    const ::std::string& name, ComplexEventPriceBoundaryMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComplexEventPriceBoundaryMethodEnum>(
    ComplexEventPriceBoundaryMethodEnum_descriptor(), name, value);
}
enum ComplexEventPriceTimeTypeEnum {
  COMPLEX_EVENT_PRICE_TIME_TYPE_EXPIRATION = 0,
  COMPLEX_EVENT_PRICE_TIME_TYPE_IMMEDIATE = 1,
  COMPLEX_EVENT_PRICE_TIME_TYPE_SPECIFIED_DATE = 2
};
bool ComplexEventPriceTimeTypeEnum_IsValid(int value);
const ComplexEventPriceTimeTypeEnum ComplexEventPriceTimeTypeEnum_MIN = COMPLEX_EVENT_PRICE_TIME_TYPE_EXPIRATION;
const ComplexEventPriceTimeTypeEnum ComplexEventPriceTimeTypeEnum_MAX = COMPLEX_EVENT_PRICE_TIME_TYPE_SPECIFIED_DATE;
const int ComplexEventPriceTimeTypeEnum_ARRAYSIZE = ComplexEventPriceTimeTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComplexEventPriceTimeTypeEnum_descriptor();
inline const ::std::string& ComplexEventPriceTimeTypeEnum_Name(ComplexEventPriceTimeTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComplexEventPriceTimeTypeEnum_descriptor(), value);
}
inline bool ComplexEventPriceTimeTypeEnum_Parse(
    const ::std::string& name, ComplexEventPriceTimeTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComplexEventPriceTimeTypeEnum>(
    ComplexEventPriceTimeTypeEnum_descriptor(), name, value);
}
enum ComplexEventConditionEnum {
  COMPLEX_EVENT_CONDITION_AND = 0,
  COMPLEX_EVENT_CONDITION_OR = 1
};
bool ComplexEventConditionEnum_IsValid(int value);
const ComplexEventConditionEnum ComplexEventConditionEnum_MIN = COMPLEX_EVENT_CONDITION_AND;
const ComplexEventConditionEnum ComplexEventConditionEnum_MAX = COMPLEX_EVENT_CONDITION_OR;
const int ComplexEventConditionEnum_ARRAYSIZE = ComplexEventConditionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ComplexEventConditionEnum_descriptor();
inline const ::std::string& ComplexEventConditionEnum_Name(ComplexEventConditionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ComplexEventConditionEnum_descriptor(), value);
}
inline bool ComplexEventConditionEnum_Parse(
    const ::std::string& name, ComplexEventConditionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ComplexEventConditionEnum>(
    ComplexEventConditionEnum_descriptor(), name, value);
}
enum SymbolSfxEnum {
  SYMBOL_SFX_EUCP_WITH_LUMP_SUM_INTEREST = 0,
  SYMBOL_SFX_WHEN_ISSUED = 1
};
bool SymbolSfxEnum_IsValid(int value);
const SymbolSfxEnum SymbolSfxEnum_MIN = SYMBOL_SFX_EUCP_WITH_LUMP_SUM_INTEREST;
const SymbolSfxEnum SymbolSfxEnum_MAX = SYMBOL_SFX_WHEN_ISSUED;
const int SymbolSfxEnum_ARRAYSIZE = SymbolSfxEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SymbolSfxEnum_descriptor();
inline const ::std::string& SymbolSfxEnum_Name(SymbolSfxEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SymbolSfxEnum_descriptor(), value);
}
inline bool SymbolSfxEnum_Parse(
    const ::std::string& name, SymbolSfxEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SymbolSfxEnum>(
    SymbolSfxEnum_descriptor(), name, value);
}
enum SecurityIdSourceEnum {
  SECURITY_ID_SOURCE_CUSIP = 0,
  SECURITY_ID_SOURCE_QUIK = 1,
  SECURITY_ID_SOURCE_SEDOL = 2,
  SECURITY_ID_SOURCE_ISIN_NUMBER = 3,
  SECURITY_ID_SOURCE_RIC_CODE = 4,
  SECURITY_ID_SOURCE_ISO_COUNTRY_CODE = 5,
  SECURITY_ID_SOURCE_ISO_CURRENCY_CODE = 6,
  SECURITY_ID_SOURCE_CONSOLIDATED_TAPE_ASSOCIATION = 7,
  SECURITY_ID_SOURCE_EXCHANGE_SYMBOL = 8,
  SECURITY_ID_SOURCE_BELGIAN = 9,
  SECURITY_ID_SOURCE_BLOOMBERG_SYMBOL = 10,
  SECURITY_ID_SOURCE_COMMON = 11,
  SECURITY_ID_SOURCE_DUTCH = 12,
  SECURITY_ID_SOURCE_SICOVAM = 13,
  SECURITY_ID_SOURCE_VALOREN = 14,
  SECURITY_ID_SOURCE_WERTPAPIER = 15,
  SECURITY_ID_SOURCE_CLEARING_HOUSE = 16,
  SECURITY_ID_SOURCE_ISDA_FPML_SPECIFICATION = 17,
  SECURITY_ID_SOURCE_OPTION_PRICE_REPORTING_AUTHORITY = 18,
  SECURITY_ID_SOURCE_LETTER_OF_CREDIT = 19,
  SECURITY_ID_SOURCE_ISDA_FPML_URL = 20,
  SECURITY_ID_SOURCE_MARKETPLACE_ASSIGNED_IDENTIFIER = 21
};
bool SecurityIdSourceEnum_IsValid(int value);
const SecurityIdSourceEnum SecurityIdSourceEnum_MIN = SECURITY_ID_SOURCE_CUSIP;
const SecurityIdSourceEnum SecurityIdSourceEnum_MAX = SECURITY_ID_SOURCE_MARKETPLACE_ASSIGNED_IDENTIFIER;
const int SecurityIdSourceEnum_ARRAYSIZE = SecurityIdSourceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityIdSourceEnum_descriptor();
inline const ::std::string& SecurityIdSourceEnum_Name(SecurityIdSourceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityIdSourceEnum_descriptor(), value);
}
inline bool SecurityIdSourceEnum_Parse(
    const ::std::string& name, SecurityIdSourceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityIdSourceEnum>(
    SecurityIdSourceEnum_descriptor(), name, value);
}
enum ProductEnum {
  PRODUCT_AGENCY = 0,
  PRODUCT_COMMODITY = 1,
  PRODUCT_CORPORATE = 2,
  PRODUCT_CURRENCY = 3,
  PRODUCT_EQUITY = 4,
  PRODUCT_GOVERNMENT = 5,
  PRODUCT_INDEX = 6,
  PRODUCT_LOAN = 7,
  PRODUCT_MONEYMARKET = 8,
  PRODUCT_MORTGAGE = 9,
  PRODUCT_MUNICIPAL = 10,
  PRODUCT_OTHER = 11,
  PRODUCT_FINANCING = 12
};
bool ProductEnum_IsValid(int value);
const ProductEnum ProductEnum_MIN = PRODUCT_AGENCY;
const ProductEnum ProductEnum_MAX = PRODUCT_FINANCING;
const int ProductEnum_ARRAYSIZE = ProductEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProductEnum_descriptor();
inline const ::std::string& ProductEnum_Name(ProductEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProductEnum_descriptor(), value);
}
inline bool ProductEnum_Parse(
    const ::std::string& name, ProductEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProductEnum>(
    ProductEnum_descriptor(), name, value);
}
enum SecurityTypeEnum {
  SECURITY_TYPE_BANKERS_ACCEPTANCE = 0,
  SECURITY_TYPE_CERTIFICATE_OF_DEPOSIT = 1,
  SECURITY_TYPE_COLLATERALIZED_MORTGAGE_OBLIGATION = 2,
  SECURITY_TYPE_COMMERCIAL_PAPER = 3,
  SECURITY_TYPE_COMMON_STOCK = 4,
  SECURITY_TYPE_CORPORATE_BOND = 5,
  SECURITY_TYPE_CORPORATE_PRIVATE_PLACEMENT = 6,
  SECURITY_TYPE_FOREIGN_EXCHANGE_CONTRACT = 7,
  SECURITY_TYPE_FUTURE = 8,
  SECURITY_TYPE_MISCELLANEOUS_PASS_THROUGH = 9,
  SECURITY_TYPE_MORTGAGE_INTEREST_ONLY = 10,
  SECURITY_TYPE_MORTGAGE_PRINCIPAL_ONLY = 11,
  SECURITY_TYPE_MORTGAGE_PRIVATE_PLACEMENT = 12,
  SECURITY_TYPE_MUTUAL_FUND = 13,
  SECURITY_TYPE_NO_SECURITY_TYPE = 14,
  SECURITY_TYPE_OPTION = 15,
  SECURITY_TYPE_PREFERRED_STOCK = 16,
  SECURITY_TYPE_TIME_DEPOSIT = 17,
  SECURITY_TYPE_US_TREASURY_BILL_OLD = 18,
  SECURITY_TYPE_WARRANT = 19,
  SECURITY_TYPE_CONVERTIBLE_BOND = 20,
  SECURITY_TYPE_IOETTEMORTGAGE = 21,
  SECURITY_TYPE_WILDCARD = 22,
  SECURITY_TYPE_AMENDED = 23,
  SECURITY_TYPE_ASSET_BACKED_SECURITIES = 24,
  SECURITY_TYPE_BANK_NOTES = 25,
  SECURITY_TYPE_BILL_OF_EXCHANGES = 26,
  SECURITY_TYPE_BRADY_BOND = 27,
  SECURITY_TYPE_BRIDGE_LOAN = 28,
  SECURITY_TYPE_CALL_LOANS = 29,
  SECURITY_TYPE_CERTIFICATE_OF_OBLIGATION = 30,
  SECURITY_TYPE_CERTIFICATE_OF_PARTICIPATION = 31,
  SECURITY_TYPE_CORP = 32,
  SECURITY_TYPE_DEBTOR_IN_POSSESSION = 33,
  SECURITY_TYPE_DEFAULTED = 34,
  SECURITY_TYPE_DEPOSIT_NOTES = 35,
  SECURITY_TYPE_DUAL_CURRENCY = 36,
  SECURITY_TYPE_EXTENDED_COMM_NOTE = 37,
  SECURITY_TYPE_FEDERAL_AGENCY_COUPON = 38,
  SECURITY_TYPE_FEDERAL_AGENCY_DISCOUNT_NOTE = 39,
  SECURITY_TYPE_GENERAL_OBLIGATION_BONDS = 40,
  SECURITY_TYPE_INDEXED_LINKED = 41,
  SECURITY_TYPE_INTEREST_STRIP_FROM_ANY_BOND_OR_NOTE = 42,
  SECURITY_TYPE_LETTER_OF_CREDIT = 43,
  SECURITY_TYPE_LIQUIDITY_NOTE = 44,
  SECURITY_TYPE_MANDATORY_TENDER = 45,
  SECURITY_TYPE_MATURED = 46,
  SECURITY_TYPE_MEDIUM_TERM_NOTES = 47,
  SECURITY_TYPE_MORTGAGE_BACKED_SECURITIES = 48,
  SECURITY_TYPE_MULTILEG_INSTRUMENT = 49,
  SECURITY_TYPE_OTHER_ANTICIPATION_NOTES = 50,
  SECURITY_TYPE_OVERNIGHT = 51,
  SECURITY_TYPE_PLAZOS_FIJOS = 52,
  SECURITY_TYPE_PRINCIPAL_STRIP_FROM_ANON_CALLABLE_BOND_OR_NOTE = 53,
  SECURITY_TYPE_PRINCIPAL_STRIP_OF_ACALLABLE_BOND_OR_NOTE = 54,
  SECURITY_TYPE_PRIVATE_EXPORT_FUNDING = 55,
  SECURITY_TYPE_PROMISSORY_NOTE = 56,
  SECURITY_TYPE_REPLACED = 57,
  SECURITY_TYPE_RETIRED = 58,
  SECURITY_TYPE_REVENUE_ANTICIPATION_NOTE = 59,
  SECURITY_TYPE_REVENUE_BONDS = 60,
  SECURITY_TYPE_REVOLVER = 61,
  SECURITY_TYPE_REVOLVER_LOAN = 62,
  SECURITY_TYPE_SHORT_TERM_LOAN_NOTE = 63,
  SECURITY_TYPE_SPECIAL_ASSESSMENT = 64,
  SECURITY_TYPE_SPECIAL_OBLIGATION = 65,
  SECURITY_TYPE_SPECIAL_TAX = 66,
  SECURITY_TYPE_STRUCTURED_NOTES = 67,
  SECURITY_TYPE_SWING_LINE_FACILITY = 68,
  SECURITY_TYPE_TAX_ALLOCATION = 69,
  SECURITY_TYPE_TAX_ANTICIPATION_NOTE = 70,
  SECURITY_TYPE_TAX_EXEMPT_COMMERCIAL_PAPER = 71,
  SECURITY_TYPE_TAX_REVENUE_ANTICIPATION_NOTE = 72,
  SECURITY_TYPE_TERM_LOAN = 73,
  SECURITY_TYPE_TO_BE_ANNOUNCED = 74,
  SECURITY_TYPE_TREASURY_INFLATION_PROTECTED_SECURITIES = 75,
  SECURITY_TYPE_US_TREASURY_BOND = 76,
  SECURITY_TYPE_US_TREASURY_NOTE_OLD = 77,
  SECURITY_TYPE_VARIABLE_RATE_DEMAND_NOTE = 78,
  SECURITY_TYPE_WITHDRAWN = 79,
  SECURITY_TYPE_YANKEE_CORPORATE_BOND = 80,
  SECURITY_TYPE_BUY_SELLBACK = 81,
  SECURITY_TYPE_EURO_CERTIFICATE_OF_DEPOSIT = 82,
  SECURITY_TYPE_EURO_COMMERCIAL_PAPER = 83,
  SECURITY_TYPE_EURO_CORPORATE_BOND = 84,
  SECURITY_TYPE_EURO_SOVEREIGNS = 85,
  SECURITY_TYPE_EURO_SUPRANATIONAL_COUPONS = 86,
  SECURITY_TYPE_FORWARD = 87,
  SECURITY_TYPE_PFANDBRIEFE = 88,
  SECURITY_TYPE_REPURCHASE = 89,
  SECURITY_TYPE_SECURITIES_LOAN = 90,
  SECURITY_TYPE_SECURITIES_PLEDGE = 91,
  SECURITY_TYPE_USD_SUPRANATIONAL_COUPONS = 92,
  SECURITY_TYPE_US_TREASURY_BILL = 93,
  SECURITY_TYPE_US_TREASURY_NOTE = 94,
  SECURITY_TYPE_YANKEE_CERTIFICATE_OF_DEPOSIT = 95,
  SECURITY_TYPE_OPTIONS_ON_FUTURES = 96,
  SECURITY_TYPE_OPTIONS_ON_PHYSICAL = 97,
  SECURITY_TYPE_CASH = 98,
  SECURITY_TYPE_OPTIONS_ON_COMBO = 99,
  SECURITY_TYPE_INTEREST_RATE_SWAP = 100,
  SECURITY_TYPE_BANK_DEPOSITORY_NOTE = 101,
  SECURITY_TYPE_CANADIAN_MONEY_MARKETS = 102,
  SECURITY_TYPE_CANADIAN_MORTGAGE_BONDS = 103,
  SECURITY_TYPE_CANADIAN_PROVINCIAL_BONDS = 104,
  SECURITY_TYPE_CANADIAN_TREASURY_BILLS = 105,
  SECURITY_TYPE_CANADIAN_TREASURY_NOTES = 106,
  SECURITY_TYPE_CREDIT_DEFAULT_SWAP = 107,
  SECURITY_TYPE_EURO_CORPORATE_FLOATING_RATE_NOTES = 108,
  SECURITY_TYPE_SECURED_LIQUIDITY_NOTE = 109,
  SECURITY_TYPE_TAXABLE_MUNICIPAL_CP = 110,
  SECURITY_TYPE_TERM_LIQUIDITY_NOTE = 111,
  SECURITY_TYPE_TREASURY_BILL = 112,
  SECURITY_TYPE_US_CORPORATE_FLOATING_RATE_NOTES = 113,
  SECURITY_TYPE_FX_FORWARD = 114,
  SECURITY_TYPE_FX_SPOT = 115,
  SECURITY_TYPE_FX_SWAP = 116,
  SECURITY_TYPE_NON_DELIVERABLE_FORWARD = 117
};
bool SecurityTypeEnum_IsValid(int value);
const SecurityTypeEnum SecurityTypeEnum_MIN = SECURITY_TYPE_BANKERS_ACCEPTANCE;
const SecurityTypeEnum SecurityTypeEnum_MAX = SECURITY_TYPE_NON_DELIVERABLE_FORWARD;
const int SecurityTypeEnum_ARRAYSIZE = SecurityTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityTypeEnum_descriptor();
inline const ::std::string& SecurityTypeEnum_Name(SecurityTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityTypeEnum_descriptor(), value);
}
inline bool SecurityTypeEnum_Parse(
    const ::std::string& name, SecurityTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityTypeEnum>(
    SecurityTypeEnum_descriptor(), name, value);
}
enum SecurityStatusEnum {
  SECURITY_STATUS_ACTIVE = 0,
  SECURITY_STATUS_INACTIVE = 1
};
bool SecurityStatusEnum_IsValid(int value);
const SecurityStatusEnum SecurityStatusEnum_MIN = SECURITY_STATUS_ACTIVE;
const SecurityStatusEnum SecurityStatusEnum_MAX = SECURITY_STATUS_INACTIVE;
const int SecurityStatusEnum_ARRAYSIZE = SecurityStatusEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityStatusEnum_descriptor();
inline const ::std::string& SecurityStatusEnum_Name(SecurityStatusEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityStatusEnum_descriptor(), value);
}
inline bool SecurityStatusEnum_Parse(
    const ::std::string& name, SecurityStatusEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityStatusEnum>(
    SecurityStatusEnum_descriptor(), name, value);
}
enum RestructuringTypeEnum {
  RESTRUCTURING_TYPE_FULL_RESTRUCTURING = 0,
  RESTRUCTURING_TYPE_MODIFIED_MOD_RESTRUCTURING = 1,
  RESTRUCTURING_TYPE_MODIFIED_RESTRUCTURING = 2,
  RESTRUCTURING_TYPE_NO_RESTRUCTURING_SPECIFIED = 3
};
bool RestructuringTypeEnum_IsValid(int value);
const RestructuringTypeEnum RestructuringTypeEnum_MIN = RESTRUCTURING_TYPE_FULL_RESTRUCTURING;
const RestructuringTypeEnum RestructuringTypeEnum_MAX = RESTRUCTURING_TYPE_NO_RESTRUCTURING_SPECIFIED;
const int RestructuringTypeEnum_ARRAYSIZE = RestructuringTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RestructuringTypeEnum_descriptor();
inline const ::std::string& RestructuringTypeEnum_Name(RestructuringTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RestructuringTypeEnum_descriptor(), value);
}
inline bool RestructuringTypeEnum_Parse(
    const ::std::string& name, RestructuringTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RestructuringTypeEnum>(
    RestructuringTypeEnum_descriptor(), name, value);
}
enum SeniorityEnum {
  SENIORITY_SENIOR = 0,
  SENIORITY_SENIOR_SECURED = 1,
  SENIORITY_SUBORDINATED = 2
};
bool SeniorityEnum_IsValid(int value);
const SeniorityEnum SeniorityEnum_MIN = SENIORITY_SENIOR;
const SeniorityEnum SeniorityEnum_MAX = SENIORITY_SUBORDINATED;
const int SeniorityEnum_ARRAYSIZE = SeniorityEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SeniorityEnum_descriptor();
inline const ::std::string& SeniorityEnum_Name(SeniorityEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SeniorityEnum_descriptor(), value);
}
inline bool SeniorityEnum_Parse(
    const ::std::string& name, SeniorityEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SeniorityEnum>(
    SeniorityEnum_descriptor(), name, value);
}
enum StrikePriceDeterminationMethodEnum {
  STRIKE_PRICE_DETERMINATION_METHOD_FIXED_STRIKE = 0,
  STRIKE_PRICE_DETERMINATION_METHOD_STRIKE_SET_AT_EXPIRATION = 1,
  STRIKE_PRICE_DETERMINATION_METHOD_STRIKE_SET_TO_AVERAGE_ACROSS_LIFE = 2,
  STRIKE_PRICE_DETERMINATION_METHOD_STRIKE_SET_TO_OPTIMAL_VALUE = 3
};
bool StrikePriceDeterminationMethodEnum_IsValid(int value);
const StrikePriceDeterminationMethodEnum StrikePriceDeterminationMethodEnum_MIN = STRIKE_PRICE_DETERMINATION_METHOD_FIXED_STRIKE;
const StrikePriceDeterminationMethodEnum StrikePriceDeterminationMethodEnum_MAX = STRIKE_PRICE_DETERMINATION_METHOD_STRIKE_SET_TO_OPTIMAL_VALUE;
const int StrikePriceDeterminationMethodEnum_ARRAYSIZE = StrikePriceDeterminationMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* StrikePriceDeterminationMethodEnum_descriptor();
inline const ::std::string& StrikePriceDeterminationMethodEnum_Name(StrikePriceDeterminationMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    StrikePriceDeterminationMethodEnum_descriptor(), value);
}
inline bool StrikePriceDeterminationMethodEnum_Parse(
    const ::std::string& name, StrikePriceDeterminationMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrikePriceDeterminationMethodEnum>(
    StrikePriceDeterminationMethodEnum_descriptor(), name, value);
}
enum StrikePriceBoundaryMethodEnum {
  STRIKE_PRICE_BOUNDARY_METHOD_EQUAL = 0,
  STRIKE_PRICE_BOUNDARY_METHOD_GREATER_THAN = 1,
  STRIKE_PRICE_BOUNDARY_METHOD_GREATER_THAN_OR_EQUAL = 2,
  STRIKE_PRICE_BOUNDARY_METHOD_LESS_THAN = 3,
  STRIKE_PRICE_BOUNDARY_METHOD_LESS_THAN_OR_EQUAL = 4
};
bool StrikePriceBoundaryMethodEnum_IsValid(int value);
const StrikePriceBoundaryMethodEnum StrikePriceBoundaryMethodEnum_MIN = STRIKE_PRICE_BOUNDARY_METHOD_EQUAL;
const StrikePriceBoundaryMethodEnum StrikePriceBoundaryMethodEnum_MAX = STRIKE_PRICE_BOUNDARY_METHOD_LESS_THAN_OR_EQUAL;
const int StrikePriceBoundaryMethodEnum_ARRAYSIZE = StrikePriceBoundaryMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* StrikePriceBoundaryMethodEnum_descriptor();
inline const ::std::string& StrikePriceBoundaryMethodEnum_Name(StrikePriceBoundaryMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    StrikePriceBoundaryMethodEnum_descriptor(), value);
}
inline bool StrikePriceBoundaryMethodEnum_Parse(
    const ::std::string& name, StrikePriceBoundaryMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrikePriceBoundaryMethodEnum>(
    StrikePriceBoundaryMethodEnum_descriptor(), name, value);
}
enum UnderlyingPriceDeterminationMethodEnum {
  UNDERLYING_PRICE_DETERMINATION_METHOD_OPTIMAL_VALUE = 0,
  UNDERLYING_PRICE_DETERMINATION_METHOD_REGULAR = 1,
  UNDERLYING_PRICE_DETERMINATION_METHOD_SPECIAL_REFERENCE = 2
};
bool UnderlyingPriceDeterminationMethodEnum_IsValid(int value);
const UnderlyingPriceDeterminationMethodEnum UnderlyingPriceDeterminationMethodEnum_MIN = UNDERLYING_PRICE_DETERMINATION_METHOD_OPTIMAL_VALUE;
const UnderlyingPriceDeterminationMethodEnum UnderlyingPriceDeterminationMethodEnum_MAX = UNDERLYING_PRICE_DETERMINATION_METHOD_SPECIAL_REFERENCE;
const int UnderlyingPriceDeterminationMethodEnum_ARRAYSIZE = UnderlyingPriceDeterminationMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnderlyingPriceDeterminationMethodEnum_descriptor();
inline const ::std::string& UnderlyingPriceDeterminationMethodEnum_Name(UnderlyingPriceDeterminationMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnderlyingPriceDeterminationMethodEnum_descriptor(), value);
}
inline bool UnderlyingPriceDeterminationMethodEnum_Parse(
    const ::std::string& name, UnderlyingPriceDeterminationMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnderlyingPriceDeterminationMethodEnum>(
    UnderlyingPriceDeterminationMethodEnum_descriptor(), name, value);
}
enum ContractMultiplierUnitEnum {
  CONTRACT_MULTIPLIER_UNIT_DAYS = 0,
  CONTRACT_MULTIPLIER_UNIT_HOURS = 1,
  CONTRACT_MULTIPLIER_UNIT_SHARES = 2
};
bool ContractMultiplierUnitEnum_IsValid(int value);
const ContractMultiplierUnitEnum ContractMultiplierUnitEnum_MIN = CONTRACT_MULTIPLIER_UNIT_DAYS;
const ContractMultiplierUnitEnum ContractMultiplierUnitEnum_MAX = CONTRACT_MULTIPLIER_UNIT_SHARES;
const int ContractMultiplierUnitEnum_ARRAYSIZE = ContractMultiplierUnitEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContractMultiplierUnitEnum_descriptor();
inline const ::std::string& ContractMultiplierUnitEnum_Name(ContractMultiplierUnitEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContractMultiplierUnitEnum_descriptor(), value);
}
inline bool ContractMultiplierUnitEnum_Parse(
    const ::std::string& name, ContractMultiplierUnitEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContractMultiplierUnitEnum>(
    ContractMultiplierUnitEnum_descriptor(), name, value);
}
enum FlowScheduleTypeEnum {
  FLOW_SCHEDULE_TYPE_NERC_CALENDAR_ALL_DAYS_IN_MONTH = 0,
  FLOW_SCHEDULE_TYPE_NERC_EASTERN_OFF_PEAK = 1,
  FLOW_SCHEDULE_TYPE_NERC_EASTERN_PEAK = 2,
  FLOW_SCHEDULE_TYPE_NERC_WESTERN_OFF_PEAK = 3,
  FLOW_SCHEDULE_TYPE_NERC_WESTERN_PEAK = 4
};
bool FlowScheduleTypeEnum_IsValid(int value);
const FlowScheduleTypeEnum FlowScheduleTypeEnum_MIN = FLOW_SCHEDULE_TYPE_NERC_CALENDAR_ALL_DAYS_IN_MONTH;
const FlowScheduleTypeEnum FlowScheduleTypeEnum_MAX = FLOW_SCHEDULE_TYPE_NERC_WESTERN_PEAK;
const int FlowScheduleTypeEnum_ARRAYSIZE = FlowScheduleTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* FlowScheduleTypeEnum_descriptor();
inline const ::std::string& FlowScheduleTypeEnum_Name(FlowScheduleTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    FlowScheduleTypeEnum_descriptor(), value);
}
inline bool FlowScheduleTypeEnum_Parse(
    const ::std::string& name, FlowScheduleTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FlowScheduleTypeEnum>(
    FlowScheduleTypeEnum_descriptor(), name, value);
}
enum UnitOfMeasureEnum {
  UNIT_OF_MEASURE_BARRELS = 0,
  UNIT_OF_MEASURE_BILLION_CUBIC_FEET = 1,
  UNIT_OF_MEASURE_BUSHELS = 2,
  UNIT_OF_MEASURE_GALLONS = 3,
  UNIT_OF_MEASURE_MEGAWATT_HOURS = 4,
  UNIT_OF_MEASURE_METRIC_TONS = 5,
  UNIT_OF_MEASURE_MILLION_BARRELS = 6,
  UNIT_OF_MEASURE_ONE_MILLION_BTU = 7,
  UNIT_OF_MEASURE_POUNDS = 8,
  UNIT_OF_MEASURE_TONS = 9,
  UNIT_OF_MEASURE_TROY_OUNCES = 10,
  UNIT_OF_MEASURE_USDOLLARS = 11,
  UNIT_OF_MEASURE_ALLOWANCES = 12
};
bool UnitOfMeasureEnum_IsValid(int value);
const UnitOfMeasureEnum UnitOfMeasureEnum_MIN = UNIT_OF_MEASURE_BARRELS;
const UnitOfMeasureEnum UnitOfMeasureEnum_MAX = UNIT_OF_MEASURE_ALLOWANCES;
const int UnitOfMeasureEnum_ARRAYSIZE = UnitOfMeasureEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnitOfMeasureEnum_descriptor();
inline const ::std::string& UnitOfMeasureEnum_Name(UnitOfMeasureEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitOfMeasureEnum_descriptor(), value);
}
inline bool UnitOfMeasureEnum_Parse(
    const ::std::string& name, UnitOfMeasureEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitOfMeasureEnum>(
    UnitOfMeasureEnum_descriptor(), name, value);
}
enum SettlMethodEnum {
  SETTL_METHOD_CASH_SETTLEMENT_REQUIRED = 0,
  SETTL_METHOD_PHYSICAL_SETTLEMENT_REQUIRED = 1
};
bool SettlMethodEnum_IsValid(int value);
const SettlMethodEnum SettlMethodEnum_MIN = SETTL_METHOD_CASH_SETTLEMENT_REQUIRED;
const SettlMethodEnum SettlMethodEnum_MAX = SETTL_METHOD_PHYSICAL_SETTLEMENT_REQUIRED;
const int SettlMethodEnum_ARRAYSIZE = SettlMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SettlMethodEnum_descriptor();
inline const ::std::string& SettlMethodEnum_Name(SettlMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SettlMethodEnum_descriptor(), value);
}
inline bool SettlMethodEnum_Parse(
    const ::std::string& name, SettlMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SettlMethodEnum>(
    SettlMethodEnum_descriptor(), name, value);
}
enum ExerciseStyleEnum {
  EXERCISE_STYLE_AMERICAN = 0,
  EXERCISE_STYLE_BERMUDA = 1,
  EXERCISE_STYLE_EUROPEAN = 2
};
bool ExerciseStyleEnum_IsValid(int value);
const ExerciseStyleEnum ExerciseStyleEnum_MIN = EXERCISE_STYLE_AMERICAN;
const ExerciseStyleEnum ExerciseStyleEnum_MAX = EXERCISE_STYLE_EUROPEAN;
const int ExerciseStyleEnum_ARRAYSIZE = ExerciseStyleEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExerciseStyleEnum_descriptor();
inline const ::std::string& ExerciseStyleEnum_Name(ExerciseStyleEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExerciseStyleEnum_descriptor(), value);
}
inline bool ExerciseStyleEnum_Parse(
    const ::std::string& name, ExerciseStyleEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExerciseStyleEnum>(
    ExerciseStyleEnum_descriptor(), name, value);
}
enum OptPayoutTypeEnum {
  OPT_PAYOUT_TYPE_BINARY = 0,
  OPT_PAYOUT_TYPE_CAPPED = 1,
  OPT_PAYOUT_TYPE_VANILLA = 2
};
bool OptPayoutTypeEnum_IsValid(int value);
const OptPayoutTypeEnum OptPayoutTypeEnum_MIN = OPT_PAYOUT_TYPE_BINARY;
const OptPayoutTypeEnum OptPayoutTypeEnum_MAX = OPT_PAYOUT_TYPE_VANILLA;
const int OptPayoutTypeEnum_ARRAYSIZE = OptPayoutTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OptPayoutTypeEnum_descriptor();
inline const ::std::string& OptPayoutTypeEnum_Name(OptPayoutTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OptPayoutTypeEnum_descriptor(), value);
}
inline bool OptPayoutTypeEnum_Parse(
    const ::std::string& name, OptPayoutTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OptPayoutTypeEnum>(
    OptPayoutTypeEnum_descriptor(), name, value);
}
enum PriceQuoteMethodEnum {
  PRICE_QUOTE_METHOD_INDEX = 0,
  PRICE_QUOTE_METHOD_INTEREST_RATE_INDEX = 1,
  PRICE_QUOTE_METHOD_STANDARD = 2,
  PRICE_QUOTE_METHOD_PERCENT_OF_PAR = 3
};
bool PriceQuoteMethodEnum_IsValid(int value);
const PriceQuoteMethodEnum PriceQuoteMethodEnum_MIN = PRICE_QUOTE_METHOD_INDEX;
const PriceQuoteMethodEnum PriceQuoteMethodEnum_MAX = PRICE_QUOTE_METHOD_PERCENT_OF_PAR;
const int PriceQuoteMethodEnum_ARRAYSIZE = PriceQuoteMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriceQuoteMethodEnum_descriptor();
inline const ::std::string& PriceQuoteMethodEnum_Name(PriceQuoteMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriceQuoteMethodEnum_descriptor(), value);
}
inline bool PriceQuoteMethodEnum_Parse(
    const ::std::string& name, PriceQuoteMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriceQuoteMethodEnum>(
    PriceQuoteMethodEnum_descriptor(), name, value);
}
enum ValuationMethodEnum {
  VALUATION_METHOD_FUTURES_STYLE_MARK_TO_MARKET = 0,
  VALUATION_METHOD_FUTURES_STYLE_WITH_AN_ATTACHED_CASH_ADJUSTMENT = 1,
  VALUATION_METHOD_PREMIUM_STYLE = 2,
  VALUATION_METHOD_CDS_IN_DELIVERY_USE_RECOVERY_RATE_TO_CALCULATE = 3,
  VALUATION_METHOD_CDS_STYLE_COLLATERALIZATION = 4
};
bool ValuationMethodEnum_IsValid(int value);
const ValuationMethodEnum ValuationMethodEnum_MIN = VALUATION_METHOD_FUTURES_STYLE_MARK_TO_MARKET;
const ValuationMethodEnum ValuationMethodEnum_MAX = VALUATION_METHOD_CDS_STYLE_COLLATERALIZATION;
const int ValuationMethodEnum_ARRAYSIZE = ValuationMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ValuationMethodEnum_descriptor();
inline const ::std::string& ValuationMethodEnum_Name(ValuationMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ValuationMethodEnum_descriptor(), value);
}
inline bool ValuationMethodEnum_Parse(
    const ::std::string& name, ValuationMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ValuationMethodEnum>(
    ValuationMethodEnum_descriptor(), name, value);
}
enum ListMethodEnum {
  LIST_METHOD_PRE_LISTED_ONLY = 0,
  LIST_METHOD_USER_REQUESTED = 1
};
bool ListMethodEnum_IsValid(int value);
const ListMethodEnum ListMethodEnum_MIN = LIST_METHOD_PRE_LISTED_ONLY;
const ListMethodEnum ListMethodEnum_MAX = LIST_METHOD_USER_REQUESTED;
const int ListMethodEnum_ARRAYSIZE = ListMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ListMethodEnum_descriptor();
inline const ::std::string& ListMethodEnum_Name(ListMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ListMethodEnum_descriptor(), value);
}
inline bool ListMethodEnum_Parse(
    const ::std::string& name, ListMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ListMethodEnum>(
    ListMethodEnum_descriptor(), name, value);
}
enum PutOrCallEnum {
  PUT_OR_CALL_CALL = 0,
  PUT_OR_CALL_PUT = 1
};
bool PutOrCallEnum_IsValid(int value);
const PutOrCallEnum PutOrCallEnum_MIN = PUT_OR_CALL_CALL;
const PutOrCallEnum PutOrCallEnum_MAX = PUT_OR_CALL_PUT;
const int PutOrCallEnum_ARRAYSIZE = PutOrCallEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PutOrCallEnum_descriptor();
inline const ::std::string& PutOrCallEnum_Name(PutOrCallEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PutOrCallEnum_descriptor(), value);
}
inline bool PutOrCallEnum_Parse(
    const ::std::string& name, PutOrCallEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PutOrCallEnum>(
    PutOrCallEnum_descriptor(), name, value);
}
enum TimeUnitEnum {
  TIME_UNIT_DAY = 0,
  TIME_UNIT_HOUR = 1,
  TIME_UNIT_MINUTE = 2,
  TIME_UNIT_MONTH = 3,
  TIME_UNIT_SECOND = 4,
  TIME_UNIT_WEEK = 5,
  TIME_UNIT_YEAR = 6
};
bool TimeUnitEnum_IsValid(int value);
const TimeUnitEnum TimeUnitEnum_MIN = TIME_UNIT_DAY;
const TimeUnitEnum TimeUnitEnum_MAX = TIME_UNIT_YEAR;
const int TimeUnitEnum_ARRAYSIZE = TimeUnitEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeUnitEnum_descriptor();
inline const ::std::string& TimeUnitEnum_Name(TimeUnitEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeUnitEnum_descriptor(), value);
}
inline bool TimeUnitEnum_Parse(
    const ::std::string& name, TimeUnitEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeUnitEnum>(
    TimeUnitEnum_descriptor(), name, value);
}
enum CpProgramEnum {
  CP_PROGRAM_OTHER = 0,
  CP_PROGRAM_PROGRAM3A3 = 1,
  CP_PROGRAM_PROGRAM42 = 2
};
bool CpProgramEnum_IsValid(int value);
const CpProgramEnum CpProgramEnum_MIN = CP_PROGRAM_OTHER;
const CpProgramEnum CpProgramEnum_MAX = CP_PROGRAM_PROGRAM42;
const int CpProgramEnum_ARRAYSIZE = CpProgramEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CpProgramEnum_descriptor();
inline const ::std::string& CpProgramEnum_Name(CpProgramEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CpProgramEnum_descriptor(), value);
}
inline bool CpProgramEnum_Parse(
    const ::std::string& name, CpProgramEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CpProgramEnum>(
    CpProgramEnum_descriptor(), name, value);
}
enum TerminationTypeEnum {
  TERMINATION_TYPE_FLEXIBLE = 0,
  TERMINATION_TYPE_OPEN = 1,
  TERMINATION_TYPE_OVERNIGHT = 2,
  TERMINATION_TYPE_TERM = 3
};
bool TerminationTypeEnum_IsValid(int value);
const TerminationTypeEnum TerminationTypeEnum_MIN = TERMINATION_TYPE_FLEXIBLE;
const TerminationTypeEnum TerminationTypeEnum_MAX = TERMINATION_TYPE_TERM;
const int TerminationTypeEnum_ARRAYSIZE = TerminationTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TerminationTypeEnum_descriptor();
inline const ::std::string& TerminationTypeEnum_Name(TerminationTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TerminationTypeEnum_descriptor(), value);
}
inline bool TerminationTypeEnum_Parse(
    const ::std::string& name, TerminationTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TerminationTypeEnum>(
    TerminationTypeEnum_descriptor(), name, value);
}
enum DeliveryTypeEnum {
  DELIVERY_TYPE_FREE = 0,
  DELIVERY_TYPE_HOLD_IN_CUSTODY = 1,
  DELIVERY_TYPE_TRI_PARTY = 2,
  DELIVERY_TYPE_VERSUS_PAYMENT = 3
};
bool DeliveryTypeEnum_IsValid(int value);
const DeliveryTypeEnum DeliveryTypeEnum_MIN = DELIVERY_TYPE_FREE;
const DeliveryTypeEnum DeliveryTypeEnum_MAX = DELIVERY_TYPE_VERSUS_PAYMENT;
const int DeliveryTypeEnum_ARRAYSIZE = DeliveryTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeliveryTypeEnum_descriptor();
inline const ::std::string& DeliveryTypeEnum_Name(DeliveryTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeliveryTypeEnum_descriptor(), value);
}
inline bool DeliveryTypeEnum_Parse(
    const ::std::string& name, DeliveryTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeliveryTypeEnum>(
    DeliveryTypeEnum_descriptor(), name, value);
}
enum UnderlyingSettlementTypeEnum {
  UNDERLYING_SETTLEMENT_TYPE_TPLUS1 = 0,
  UNDERLYING_SETTLEMENT_TYPE_TPLUS3 = 1,
  UNDERLYING_SETTLEMENT_TYPE_TPLUS4 = 2
};
bool UnderlyingSettlementTypeEnum_IsValid(int value);
const UnderlyingSettlementTypeEnum UnderlyingSettlementTypeEnum_MIN = UNDERLYING_SETTLEMENT_TYPE_TPLUS1;
const UnderlyingSettlementTypeEnum UnderlyingSettlementTypeEnum_MAX = UNDERLYING_SETTLEMENT_TYPE_TPLUS4;
const int UnderlyingSettlementTypeEnum_ARRAYSIZE = UnderlyingSettlementTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnderlyingSettlementTypeEnum_descriptor();
inline const ::std::string& UnderlyingSettlementTypeEnum_Name(UnderlyingSettlementTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnderlyingSettlementTypeEnum_descriptor(), value);
}
inline bool UnderlyingSettlementTypeEnum_Parse(
    const ::std::string& name, UnderlyingSettlementTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnderlyingSettlementTypeEnum>(
    UnderlyingSettlementTypeEnum_descriptor(), name, value);
}
enum UnderlyingCashTypeEnum {
  UNDERLYING_CASH_TYPE_DIFF = 0,
  UNDERLYING_CASH_TYPE_FIXED = 1
};
bool UnderlyingCashTypeEnum_IsValid(int value);
const UnderlyingCashTypeEnum UnderlyingCashTypeEnum_MIN = UNDERLYING_CASH_TYPE_DIFF;
const UnderlyingCashTypeEnum UnderlyingCashTypeEnum_MAX = UNDERLYING_CASH_TYPE_FIXED;
const int UnderlyingCashTypeEnum_ARRAYSIZE = UnderlyingCashTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnderlyingCashTypeEnum_descriptor();
inline const ::std::string& UnderlyingCashTypeEnum_Name(UnderlyingCashTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnderlyingCashTypeEnum_descriptor(), value);
}
inline bool UnderlyingCashTypeEnum_Parse(
    const ::std::string& name, UnderlyingCashTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnderlyingCashTypeEnum>(
    UnderlyingCashTypeEnum_descriptor(), name, value);
}
enum UnderlyingFxRateCalcEnum {
  UNDERLYING_FX_RATE_CALC_DIVIDE = 0,
  UNDERLYING_FX_RATE_CALC_MULTIPLY = 1
};
bool UnderlyingFxRateCalcEnum_IsValid(int value);
const UnderlyingFxRateCalcEnum UnderlyingFxRateCalcEnum_MIN = UNDERLYING_FX_RATE_CALC_DIVIDE;
const UnderlyingFxRateCalcEnum UnderlyingFxRateCalcEnum_MAX = UNDERLYING_FX_RATE_CALC_MULTIPLY;
const int UnderlyingFxRateCalcEnum_ARRAYSIZE = UnderlyingFxRateCalcEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnderlyingFxRateCalcEnum_descriptor();
inline const ::std::string& UnderlyingFxRateCalcEnum_Name(UnderlyingFxRateCalcEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnderlyingFxRateCalcEnum_descriptor(), value);
}
inline bool UnderlyingFxRateCalcEnum_Parse(
    const ::std::string& name, UnderlyingFxRateCalcEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnderlyingFxRateCalcEnum>(
    UnderlyingFxRateCalcEnum_descriptor(), name, value);
}
enum StipulationTypeEnum {
  STIPULATION_TYPE_ABSOLUTE_PREPAYMENT_SPEED = 0,
  STIPULATION_TYPE_CONSTANT_PREPAYMENT_PENALTY = 1,
  STIPULATION_TYPE_CONSTANT_PREPAYMENT_RATE = 2,
  STIPULATION_TYPE_CONSTANT_PREPAYMENT_YIELD = 3,
  STIPULATION_TYPE_FINAL_CP_ROF_HOME_EQUITY_PREPAYMENT_CURVE = 4,
  STIPULATION_TYPE_GEOGRAPHICS = 5,
  STIPULATION_TYPE_ISSUE_DATE = 6,
  STIPULATION_TYPE_LOT_VARIANCE = 7,
  STIPULATION_TYPE_MATURITY_YEAR_AND_MONTH = 8,
  STIPULATION_TYPE_MONTHLY_PREPAYMENT_RATE = 9,
  STIPULATION_TYPE_NUMBER_OF_PIECES = 10,
  STIPULATION_TYPE_PERCENT_OF_BMAPREPAYMENT_CURVE = 11,
  STIPULATION_TYPE_PERCENT_OF_MANUFACTURED_HOUSING_PREPAYMENT_CURVE = 12,
  STIPULATION_TYPE_PERCENT_OF_PROSPECTUS_PREPAYMENT_CURVE = 13,
  STIPULATION_TYPE_POOLS_MAXIMUM = 14,
  STIPULATION_TYPE_POOLS_PER_LOT = 15,
  STIPULATION_TYPE_POOLS_PER_MILLION = 16,
  STIPULATION_TYPE_POOLS_PER_TRADE = 17,
  STIPULATION_TYPE_PRODUCTION_YEAR = 18,
  STIPULATION_TYPE_SINGLE_MONTHLY_MORTALITY = 19,
  STIPULATION_TYPE_TRADE_VARIANCE = 20,
  STIPULATION_TYPE_WEIGHTED_AVERAGE_COUPON = 21,
  STIPULATION_TYPE_WEIGHTED_AVERAGE_LIFE_COUPON = 22,
  STIPULATION_TYPE_WEIGHTED_AVERAGE_LOAN_AGE = 23,
  STIPULATION_TYPE_WEIGHTED_AVERAGE_MATURITY = 24,
  STIPULATION_TYPE_ALTERNATIVE_MINIMUM_TAX = 25,
  STIPULATION_TYPE_AUTO_REINVESTMENT = 26,
  STIPULATION_TYPE_BANK_QUALIFIED = 27,
  STIPULATION_TYPE_BARGAIN_CONDITIONS = 28,
  STIPULATION_TYPE_BENCHMARK_PRICE_SOURCE = 29,
  STIPULATION_TYPE_CALL_PROTECTION = 30,
  STIPULATION_TYPE_COUPON_RANGE = 31,
  STIPULATION_TYPE_CUSTOM_START = 32,
  STIPULATION_TYPE_EXPLICIT_LOT_IDENTIFIER = 33,
  STIPULATION_TYPE_FREEFORM_TEXT = 34,
  STIPULATION_TYPE_ISO_CURRENCY_CODE = 35,
  STIPULATION_TYPE_INSURED = 36,
  STIPULATION_TYPE_ISSUE_SIZE_RANGE = 37,
  STIPULATION_TYPE_ISSUER = 38,
  STIPULATION_TYPE_LOOKBACK_DAYS = 39,
  STIPULATION_TYPE_MARKET_SECTOR = 40,
  STIPULATION_TYPE_MATURITY_RANGE = 41,
  STIPULATION_TYPE_MAXIMUM_SUBSTITUTIONS = 42,
  STIPULATION_TYPE_MINIMUM_DENOMINATION = 43,
  STIPULATION_TYPE_MINIMUM_INCREMENT = 44,
  STIPULATION_TYPE_MINIMUM_QUANTITY = 45,
  STIPULATION_TYPE_PAYMENT_FREQUENCY = 46,
  STIPULATION_TYPE_PRICE_RANGE = 47,
  STIPULATION_TYPE_PRICING_FREQUENCY = 48,
  STIPULATION_TYPE_PURPOSE = 49,
  STIPULATION_TYPE_RATING_SOURCE_AND_RANGE = 50,
  STIPULATION_TYPE_RESTRICTED = 51,
  STIPULATION_TYPE_SECURITY_TYPE_INCLUDED_OR_EXCLUDED = 52,
  STIPULATION_TYPE_STRUCTURE = 53,
  STIPULATION_TYPE_SUBSTITUTIONS_FREQUENCY = 54,
  STIPULATION_TYPE_SUBSTITUTIONS_LEFT = 55,
  STIPULATION_TYPE_TYPE_OF_REDEMPTION = 56,
  STIPULATION_TYPE_VALUATION_DISCOUNT = 57,
  STIPULATION_TYPE_WHOLE_POOL = 58,
  STIPULATION_TYPE_YIELD_RANGE = 59,
  STIPULATION_TYPE_AVAILABLE_OFFER_QUANTITY_TO_BE_SHOWN_TO_THE_STREET = 60,
  STIPULATION_TYPE_AVERAGE_FICOSCORE = 61,
  STIPULATION_TYPE_AVERAGE_LOAN_SIZE = 62,
  STIPULATION_TYPE_BROKER_CREDIT = 63,
  STIPULATION_TYPE_BROKER_SALES_CREDIT_OVERRIDE = 64,
  STIPULATION_TYPE_DISCOUNT_RATE = 65,
  STIPULATION_TYPE_INTEREST_OF_ROLLING_OR_CLOSING_TRADE = 66,
  STIPULATION_TYPE_MAXIMUM_LOAN_BALANCE = 67,
  STIPULATION_TYPE_MAXIMUM_ORDER_SIZE = 68,
  STIPULATION_TYPE_OFFER_PRICE_TO_BE_SHOWN_TO_INTERNAL_BROKERS = 69,
  STIPULATION_TYPE_OFFER_QUANTITY_TO_BE_SHOWN_TO_INTERNAL_BROKERS = 70,
  STIPULATION_TYPE_ORDER_QUANTITY_INCREMENT = 71,
  STIPULATION_TYPE_POOL_IDENTIFIER = 72,
  STIPULATION_TYPE_PRIMARY_OR_SECONDARY_MARKET_INDICATOR = 73,
  STIPULATION_TYPE_PRINCIPAL_OF_ROLLING_OR_CLOSING_TRADE = 74,
  STIPULATION_TYPE_REFERENCE_TO_ROLLING_OR_CLOSING_TRADE = 75,
  STIPULATION_TYPE_THE_MINIMUM_RESIDUAL_OFFER_QUANTITY = 76,
  STIPULATION_TYPE_TRADER_CREDIT = 77,
  STIPULATION_TYPE_TYPE_OF_ROLL_TRADE = 78,
  STIPULATION_TYPE_YIELD_TO_MATURITY = 79
};
bool StipulationTypeEnum_IsValid(int value);
const StipulationTypeEnum StipulationTypeEnum_MIN = STIPULATION_TYPE_ABSOLUTE_PREPAYMENT_SPEED;
const StipulationTypeEnum StipulationTypeEnum_MAX = STIPULATION_TYPE_YIELD_TO_MATURITY;
const int StipulationTypeEnum_ARRAYSIZE = StipulationTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* StipulationTypeEnum_descriptor();
inline const ::std::string& StipulationTypeEnum_Name(StipulationTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    StipulationTypeEnum_descriptor(), value);
}
inline bool StipulationTypeEnum_Parse(
    const ::std::string& name, StipulationTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StipulationTypeEnum>(
    StipulationTypeEnum_descriptor(), name, value);
}
enum RoundingDirectionEnum {
  ROUNDING_DIRECTION_ROUND_DOWN = 0,
  ROUNDING_DIRECTION_ROUND_TO_NEAREST = 1,
  ROUNDING_DIRECTION_ROUND_UP = 2
};
bool RoundingDirectionEnum_IsValid(int value);
const RoundingDirectionEnum RoundingDirectionEnum_MIN = ROUNDING_DIRECTION_ROUND_DOWN;
const RoundingDirectionEnum RoundingDirectionEnum_MAX = ROUNDING_DIRECTION_ROUND_UP;
const int RoundingDirectionEnum_ARRAYSIZE = RoundingDirectionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoundingDirectionEnum_descriptor();
inline const ::std::string& RoundingDirectionEnum_Name(RoundingDirectionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoundingDirectionEnum_descriptor(), value);
}
inline bool RoundingDirectionEnum_Parse(
    const ::std::string& name, RoundingDirectionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoundingDirectionEnum>(
    RoundingDirectionEnum_descriptor(), name, value);
}
enum TriggerTypeEnum {
  TRIGGER_TYPE_NEXT_AUCTION = 0,
  TRIGGER_TYPE_PARTIAL_EXECUTION = 1,
  TRIGGER_TYPE_PRICE_MOVEMENT = 2,
  TRIGGER_TYPE_SPECIFIED_TRADING_SESSION = 3
};
bool TriggerTypeEnum_IsValid(int value);
const TriggerTypeEnum TriggerTypeEnum_MIN = TRIGGER_TYPE_NEXT_AUCTION;
const TriggerTypeEnum TriggerTypeEnum_MAX = TRIGGER_TYPE_SPECIFIED_TRADING_SESSION;
const int TriggerTypeEnum_ARRAYSIZE = TriggerTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TriggerTypeEnum_descriptor();
inline const ::std::string& TriggerTypeEnum_Name(TriggerTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TriggerTypeEnum_descriptor(), value);
}
inline bool TriggerTypeEnum_Parse(
    const ::std::string& name, TriggerTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TriggerTypeEnum>(
    TriggerTypeEnum_descriptor(), name, value);
}
enum TriggerActionEnum {
  TRIGGER_ACTION_ACTIVATE = 0,
  TRIGGER_ACTION_CANCEL = 1,
  TRIGGER_ACTION_MODIFY = 2
};
bool TriggerActionEnum_IsValid(int value);
const TriggerActionEnum TriggerActionEnum_MIN = TRIGGER_ACTION_ACTIVATE;
const TriggerActionEnum TriggerActionEnum_MAX = TRIGGER_ACTION_MODIFY;
const int TriggerActionEnum_ARRAYSIZE = TriggerActionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TriggerActionEnum_descriptor();
inline const ::std::string& TriggerActionEnum_Name(TriggerActionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TriggerActionEnum_descriptor(), value);
}
inline bool TriggerActionEnum_Parse(
    const ::std::string& name, TriggerActionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TriggerActionEnum>(
    TriggerActionEnum_descriptor(), name, value);
}
enum TriggerPriceTypeEnum {
  TRIGGER_PRICE_TYPE_BEST_BID = 0,
  TRIGGER_PRICE_TYPE_BEST_BID_OR_LAST_TRADE = 1,
  TRIGGER_PRICE_TYPE_BEST_MID = 2,
  TRIGGER_PRICE_TYPE_BEST_OFFER = 3,
  TRIGGER_PRICE_TYPE_BEST_OFFER_OR_LAST_TRADE = 4,
  TRIGGER_PRICE_TYPE_LAST_TRADE = 5
};
bool TriggerPriceTypeEnum_IsValid(int value);
const TriggerPriceTypeEnum TriggerPriceTypeEnum_MIN = TRIGGER_PRICE_TYPE_BEST_BID;
const TriggerPriceTypeEnum TriggerPriceTypeEnum_MAX = TRIGGER_PRICE_TYPE_LAST_TRADE;
const int TriggerPriceTypeEnum_ARRAYSIZE = TriggerPriceTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TriggerPriceTypeEnum_descriptor();
inline const ::std::string& TriggerPriceTypeEnum_Name(TriggerPriceTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TriggerPriceTypeEnum_descriptor(), value);
}
inline bool TriggerPriceTypeEnum_Parse(
    const ::std::string& name, TriggerPriceTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TriggerPriceTypeEnum>(
    TriggerPriceTypeEnum_descriptor(), name, value);
}
enum TriggerPriceTypeScopeEnum {
  TRIGGER_PRICE_TYPE_SCOPE_GLOBAL = 0,
  TRIGGER_PRICE_TYPE_SCOPE_LOCAL = 1,
  TRIGGER_PRICE_TYPE_SCOPE_NATIONAL = 2,
  TRIGGER_PRICE_TYPE_SCOPE_NONE = 3
};
bool TriggerPriceTypeScopeEnum_IsValid(int value);
const TriggerPriceTypeScopeEnum TriggerPriceTypeScopeEnum_MIN = TRIGGER_PRICE_TYPE_SCOPE_GLOBAL;
const TriggerPriceTypeScopeEnum TriggerPriceTypeScopeEnum_MAX = TRIGGER_PRICE_TYPE_SCOPE_NONE;
const int TriggerPriceTypeScopeEnum_ARRAYSIZE = TriggerPriceTypeScopeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TriggerPriceTypeScopeEnum_descriptor();
inline const ::std::string& TriggerPriceTypeScopeEnum_Name(TriggerPriceTypeScopeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TriggerPriceTypeScopeEnum_descriptor(), value);
}
inline bool TriggerPriceTypeScopeEnum_Parse(
    const ::std::string& name, TriggerPriceTypeScopeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TriggerPriceTypeScopeEnum>(
    TriggerPriceTypeScopeEnum_descriptor(), name, value);
}
enum TriggerPriceDirectionEnum {
  TRIGGER_PRICE_DIRECTION_DOWN = 0,
  TRIGGER_PRICE_DIRECTION_UP = 1
};
bool TriggerPriceDirectionEnum_IsValid(int value);
const TriggerPriceDirectionEnum TriggerPriceDirectionEnum_MIN = TRIGGER_PRICE_DIRECTION_DOWN;
const TriggerPriceDirectionEnum TriggerPriceDirectionEnum_MAX = TRIGGER_PRICE_DIRECTION_UP;
const int TriggerPriceDirectionEnum_ARRAYSIZE = TriggerPriceDirectionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TriggerPriceDirectionEnum_descriptor();
inline const ::std::string& TriggerPriceDirectionEnum_Name(TriggerPriceDirectionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TriggerPriceDirectionEnum_descriptor(), value);
}
inline bool TriggerPriceDirectionEnum_Parse(
    const ::std::string& name, TriggerPriceDirectionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TriggerPriceDirectionEnum>(
    TriggerPriceDirectionEnum_descriptor(), name, value);
}
enum TriggerOrderTypeEnum {
  TRIGGER_ORDER_TYPE_LIMIT = 0,
  TRIGGER_ORDER_TYPE_MARKET = 1
};
bool TriggerOrderTypeEnum_IsValid(int value);
const TriggerOrderTypeEnum TriggerOrderTypeEnum_MIN = TRIGGER_ORDER_TYPE_LIMIT;
const TriggerOrderTypeEnum TriggerOrderTypeEnum_MAX = TRIGGER_ORDER_TYPE_MARKET;
const int TriggerOrderTypeEnum_ARRAYSIZE = TriggerOrderTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TriggerOrderTypeEnum_descriptor();
inline const ::std::string& TriggerOrderTypeEnum_Name(TriggerOrderTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TriggerOrderTypeEnum_descriptor(), value);
}
inline bool TriggerOrderTypeEnum_Parse(
    const ::std::string& name, TriggerOrderTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TriggerOrderTypeEnum>(
    TriggerOrderTypeEnum_descriptor(), name, value);
}
enum BenchmarkCurveNameEnum {
  BENCHMARK_CURVE_NAME_EURIBOR = 0,
  BENCHMARK_CURVE_NAME_FUTURE_SWAP = 1,
  BENCHMARK_CURVE_NAME_LIBID = 2,
  BENCHMARK_CURVE_NAME_LIBOR = 3,
  BENCHMARK_CURVE_NAME_MUNI_AAA = 4,
  BENCHMARK_CURVE_NAME_OTHER = 5,
  BENCHMARK_CURVE_NAME_PFANDBRIEFE = 6,
  BENCHMARK_CURVE_NAME_SWAP = 7,
  BENCHMARK_CURVE_NAME_TREASURY = 8,
  BENCHMARK_CURVE_NAME_EONIA = 9,
  BENCHMARK_CURVE_NAME_EUREPO = 10,
  BENCHMARK_CURVE_NAME_SONIA = 11
};
bool BenchmarkCurveNameEnum_IsValid(int value);
const BenchmarkCurveNameEnum BenchmarkCurveNameEnum_MIN = BENCHMARK_CURVE_NAME_EURIBOR;
const BenchmarkCurveNameEnum BenchmarkCurveNameEnum_MAX = BENCHMARK_CURVE_NAME_SONIA;
const int BenchmarkCurveNameEnum_ARRAYSIZE = BenchmarkCurveNameEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* BenchmarkCurveNameEnum_descriptor();
inline const ::std::string& BenchmarkCurveNameEnum_Name(BenchmarkCurveNameEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    BenchmarkCurveNameEnum_descriptor(), value);
}
inline bool BenchmarkCurveNameEnum_Parse(
    const ::std::string& name, BenchmarkCurveNameEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BenchmarkCurveNameEnum>(
    BenchmarkCurveNameEnum_descriptor(), name, value);
}
enum YieldTypeEnum {
  YIELD_TYPE_AFTER_TAX_YIELD = 0,
  YIELD_TYPE_ANNUAL_YIELD = 1,
  YIELD_TYPE_BOOK_YIELD = 2,
  YIELD_TYPE_CLOSING_YIELD = 3,
  YIELD_TYPE_CLOSING_YIELD_MOST_RECENT_MONTH = 4,
  YIELD_TYPE_CLOSING_YIELD_MOST_RECENT_QUARTER = 5,
  YIELD_TYPE_CLOSING_YIELD_MOST_RECENT_YEAR = 6,
  YIELD_TYPE_COMPOUND_YIELD = 7,
  YIELD_TYPE_CURRENT_YIELD = 8,
  YIELD_TYPE_GVNT_EQUIVALENT_YIELD = 9,
  YIELD_TYPE_INVERSE_FLOATER_BOND_YIELD = 10,
  YIELD_TYPE_MARK_TO_MARKET_YIELD = 11,
  YIELD_TYPE_MOST_RECENT_CLOSING_YIELD = 12,
  YIELD_TYPE_OPEN_AVERAGE_YIELD = 13,
  YIELD_TYPE_PREVIOUS_CLOSE_YIELD = 14,
  YIELD_TYPE_PROCEEDS_YIELD = 15,
  YIELD_TYPE_SEMI_ANNUAL_YIELD = 16,
  YIELD_TYPE_SIMPLE_YIELD = 17,
  YIELD_TYPE_TAX_EQUIVALENT_YIELD = 18,
  YIELD_TYPE_TRUE_GROSS_YIELD = 19,
  YIELD_TYPE_TRUE_YIELD = 20,
  YIELD_TYPE_YIELD_AT_ISSUE = 21,
  YIELD_TYPE_YIELD_CHANGE_SINCE_CLOSE = 22,
  YIELD_TYPE_YIELD_TO_AVERAGE_MATURITY = 23,
  YIELD_TYPE_YIELD_TO_LONGEST_AVERAGE_LIFE = 24,
  YIELD_TYPE_YIELD_TO_MATURITY = 25,
  YIELD_TYPE_YIELD_TO_NEXT_CALL = 26,
  YIELD_TYPE_YIELD_TO_NEXT_PUT = 27,
  YIELD_TYPE_YIELD_TO_NEXT_REFUND = 28,
  YIELD_TYPE_YIELD_TO_SHORTEST_AVERAGE_LIFE = 29,
  YIELD_TYPE_YIELD_TO_TENDER_DATE = 30,
  YIELD_TYPE_YIELD_TO_WORST = 31,
  YIELD_TYPE_YIELD_WITH_INFLATION_ASSUMPTION = 32,
  YIELD_TYPE_YIELD_VALUE_OF32NDS = 33
};
bool YieldTypeEnum_IsValid(int value);
const YieldTypeEnum YieldTypeEnum_MIN = YIELD_TYPE_AFTER_TAX_YIELD;
const YieldTypeEnum YieldTypeEnum_MAX = YIELD_TYPE_YIELD_VALUE_OF32NDS;
const int YieldTypeEnum_ARRAYSIZE = YieldTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* YieldTypeEnum_descriptor();
inline const ::std::string& YieldTypeEnum_Name(YieldTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    YieldTypeEnum_descriptor(), value);
}
inline bool YieldTypeEnum_Parse(
    const ::std::string& name, YieldTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YieldTypeEnum>(
    YieldTypeEnum_descriptor(), name, value);
}
enum CommTypeEnum {
  COMM_TYPE_ABSOLUTE = 0,
  COMM_TYPE_PER_UNIT = 1,
  COMM_TYPE_PERCENT = 2,
  COMM_TYPE_PERCENTAGE_WAIVED_CASH_DISCOUNT = 3,
  COMM_TYPE_PERCENTAGE_WAIVED_ENHANCED_UNITS = 4,
  COMM_TYPE_POINTS_PER_BOND_OR_CONTRACT = 5
};
bool CommTypeEnum_IsValid(int value);
const CommTypeEnum CommTypeEnum_MIN = COMM_TYPE_ABSOLUTE;
const CommTypeEnum CommTypeEnum_MAX = COMM_TYPE_POINTS_PER_BOND_OR_CONTRACT;
const int CommTypeEnum_ARRAYSIZE = CommTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CommTypeEnum_descriptor();
inline const ::std::string& CommTypeEnum_Name(CommTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CommTypeEnum_descriptor(), value);
}
inline bool CommTypeEnum_Parse(
    const ::std::string& name, CommTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CommTypeEnum>(
    CommTypeEnum_descriptor(), name, value);
}
enum FundRenewWaivEnum {
  FUND_RENEW_WAIV_NO = 0,
  FUND_RENEW_WAIV_YES = 1
};
bool FundRenewWaivEnum_IsValid(int value);
const FundRenewWaivEnum FundRenewWaivEnum_MIN = FUND_RENEW_WAIV_NO;
const FundRenewWaivEnum FundRenewWaivEnum_MAX = FUND_RENEW_WAIV_YES;
const int FundRenewWaivEnum_ARRAYSIZE = FundRenewWaivEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* FundRenewWaivEnum_descriptor();
inline const ::std::string& FundRenewWaivEnum_Name(FundRenewWaivEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    FundRenewWaivEnum_descriptor(), value);
}
inline bool FundRenewWaivEnum_Parse(
    const ::std::string& name, FundRenewWaivEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FundRenewWaivEnum>(
    FundRenewWaivEnum_descriptor(), name, value);
}
enum PegPriceTypeEnum {
  PEG_PRICE_TYPE_LAST_PEG = 0,
  PEG_PRICE_TYPE_MARKET_PEG = 1,
  PEG_PRICE_TYPE_MID_PRICE_PEG = 2,
  PEG_PRICE_TYPE_OPENING_PEG = 3,
  PEG_PRICE_TYPE_PEG_TO_LIMIT_PRICE = 4,
  PEG_PRICE_TYPE_PEG_TO_VWAP = 5,
  PEG_PRICE_TYPE_PRIMARY_PEG = 6,
  PEG_PRICE_TYPE_TRAILING_STOP_PEG = 7
};
bool PegPriceTypeEnum_IsValid(int value);
const PegPriceTypeEnum PegPriceTypeEnum_MIN = PEG_PRICE_TYPE_LAST_PEG;
const PegPriceTypeEnum PegPriceTypeEnum_MAX = PEG_PRICE_TYPE_TRAILING_STOP_PEG;
const int PegPriceTypeEnum_ARRAYSIZE = PegPriceTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PegPriceTypeEnum_descriptor();
inline const ::std::string& PegPriceTypeEnum_Name(PegPriceTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PegPriceTypeEnum_descriptor(), value);
}
inline bool PegPriceTypeEnum_Parse(
    const ::std::string& name, PegPriceTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PegPriceTypeEnum>(
    PegPriceTypeEnum_descriptor(), name, value);
}
enum PegMoveTypeEnum {
  PEG_MOVE_TYPE_FIXED = 0,
  PEG_MOVE_TYPE_FLOATING = 1
};
bool PegMoveTypeEnum_IsValid(int value);
const PegMoveTypeEnum PegMoveTypeEnum_MIN = PEG_MOVE_TYPE_FIXED;
const PegMoveTypeEnum PegMoveTypeEnum_MAX = PEG_MOVE_TYPE_FLOATING;
const int PegMoveTypeEnum_ARRAYSIZE = PegMoveTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PegMoveTypeEnum_descriptor();
inline const ::std::string& PegMoveTypeEnum_Name(PegMoveTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PegMoveTypeEnum_descriptor(), value);
}
inline bool PegMoveTypeEnum_Parse(
    const ::std::string& name, PegMoveTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PegMoveTypeEnum>(
    PegMoveTypeEnum_descriptor(), name, value);
}
enum PegOffsetTypeEnum {
  PEG_OFFSET_TYPE_BASIS_POINTS = 0,
  PEG_OFFSET_TYPE_PRICE = 1,
  PEG_OFFSET_TYPE_PRICE_TIER = 2,
  PEG_OFFSET_TYPE_TICKS = 3
};
bool PegOffsetTypeEnum_IsValid(int value);
const PegOffsetTypeEnum PegOffsetTypeEnum_MIN = PEG_OFFSET_TYPE_BASIS_POINTS;
const PegOffsetTypeEnum PegOffsetTypeEnum_MAX = PEG_OFFSET_TYPE_TICKS;
const int PegOffsetTypeEnum_ARRAYSIZE = PegOffsetTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PegOffsetTypeEnum_descriptor();
inline const ::std::string& PegOffsetTypeEnum_Name(PegOffsetTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PegOffsetTypeEnum_descriptor(), value);
}
inline bool PegOffsetTypeEnum_Parse(
    const ::std::string& name, PegOffsetTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PegOffsetTypeEnum>(
    PegOffsetTypeEnum_descriptor(), name, value);
}
enum PegLimitTypeEnum {
  PEG_LIMIT_TYPE_OR_BETTER = 0,
  PEG_LIMIT_TYPE_OR_WORSE = 1,
  PEG_LIMIT_TYPE_STRICT = 2
};
bool PegLimitTypeEnum_IsValid(int value);
const PegLimitTypeEnum PegLimitTypeEnum_MIN = PEG_LIMIT_TYPE_OR_BETTER;
const PegLimitTypeEnum PegLimitTypeEnum_MAX = PEG_LIMIT_TYPE_STRICT;
const int PegLimitTypeEnum_ARRAYSIZE = PegLimitTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PegLimitTypeEnum_descriptor();
inline const ::std::string& PegLimitTypeEnum_Name(PegLimitTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PegLimitTypeEnum_descriptor(), value);
}
inline bool PegLimitTypeEnum_Parse(
    const ::std::string& name, PegLimitTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PegLimitTypeEnum>(
    PegLimitTypeEnum_descriptor(), name, value);
}
enum PegRoundDirectionEnum {
  PEG_ROUND_DIRECTION_MORE_AGGRESSIVE = 0,
  PEG_ROUND_DIRECTION_MORE_PASSIVE = 1
};
bool PegRoundDirectionEnum_IsValid(int value);
const PegRoundDirectionEnum PegRoundDirectionEnum_MIN = PEG_ROUND_DIRECTION_MORE_AGGRESSIVE;
const PegRoundDirectionEnum PegRoundDirectionEnum_MAX = PEG_ROUND_DIRECTION_MORE_PASSIVE;
const int PegRoundDirectionEnum_ARRAYSIZE = PegRoundDirectionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PegRoundDirectionEnum_descriptor();
inline const ::std::string& PegRoundDirectionEnum_Name(PegRoundDirectionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PegRoundDirectionEnum_descriptor(), value);
}
inline bool PegRoundDirectionEnum_Parse(
    const ::std::string& name, PegRoundDirectionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PegRoundDirectionEnum>(
    PegRoundDirectionEnum_descriptor(), name, value);
}
enum PegScopeEnum {
  PEG_SCOPE_GLOBAL = 0,
  PEG_SCOPE_LOCAL = 1,
  PEG_SCOPE_NATIONAL = 2,
  PEG_SCOPE_NATIONAL_EXCLUDING_LOCAL = 3
};
bool PegScopeEnum_IsValid(int value);
const PegScopeEnum PegScopeEnum_MIN = PEG_SCOPE_GLOBAL;
const PegScopeEnum PegScopeEnum_MAX = PEG_SCOPE_NATIONAL_EXCLUDING_LOCAL;
const int PegScopeEnum_ARRAYSIZE = PegScopeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PegScopeEnum_descriptor();
inline const ::std::string& PegScopeEnum_Name(PegScopeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PegScopeEnum_descriptor(), value);
}
inline bool PegScopeEnum_Parse(
    const ::std::string& name, PegScopeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PegScopeEnum>(
    PegScopeEnum_descriptor(), name, value);
}
enum DiscretionInstEnum {
  DISCRETION_INST_RELATED_TO_DISPLAYED_PRICE = 0,
  DISCRETION_INST_RELATED_TO_LAST_TRADE_PRICE = 1,
  DISCRETION_INST_RELATED_TO_LOCAL_PRIMARY_PRICE = 2,
  DISCRETION_INST_RELATED_TO_MARKET_PRICE = 3,
  DISCRETION_INST_RELATED_TO_MIDPOINT_PRICE = 4,
  DISCRETION_INST_RELATED_TO_PRIMARY_PRICE = 5,
  DISCRETION_INST_RELATED_TO_VWAP = 6,
  DISCRETION_INST_AVERAGE_PRICE_GUARANTEE = 7
};
bool DiscretionInstEnum_IsValid(int value);
const DiscretionInstEnum DiscretionInstEnum_MIN = DISCRETION_INST_RELATED_TO_DISPLAYED_PRICE;
const DiscretionInstEnum DiscretionInstEnum_MAX = DISCRETION_INST_AVERAGE_PRICE_GUARANTEE;
const int DiscretionInstEnum_ARRAYSIZE = DiscretionInstEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscretionInstEnum_descriptor();
inline const ::std::string& DiscretionInstEnum_Name(DiscretionInstEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscretionInstEnum_descriptor(), value);
}
inline bool DiscretionInstEnum_Parse(
    const ::std::string& name, DiscretionInstEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscretionInstEnum>(
    DiscretionInstEnum_descriptor(), name, value);
}
enum DiscretionMoveTypeEnum {
  DISCRETION_MOVE_TYPE_FIXED = 0,
  DISCRETION_MOVE_TYPE_FLOATING = 1
};
bool DiscretionMoveTypeEnum_IsValid(int value);
const DiscretionMoveTypeEnum DiscretionMoveTypeEnum_MIN = DISCRETION_MOVE_TYPE_FIXED;
const DiscretionMoveTypeEnum DiscretionMoveTypeEnum_MAX = DISCRETION_MOVE_TYPE_FLOATING;
const int DiscretionMoveTypeEnum_ARRAYSIZE = DiscretionMoveTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscretionMoveTypeEnum_descriptor();
inline const ::std::string& DiscretionMoveTypeEnum_Name(DiscretionMoveTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscretionMoveTypeEnum_descriptor(), value);
}
inline bool DiscretionMoveTypeEnum_Parse(
    const ::std::string& name, DiscretionMoveTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscretionMoveTypeEnum>(
    DiscretionMoveTypeEnum_descriptor(), name, value);
}
enum DiscretionOffsetTypeEnum {
  DISCRETION_OFFSET_TYPE_BASIS_POINTS = 0,
  DISCRETION_OFFSET_TYPE_PRICE = 1,
  DISCRETION_OFFSET_TYPE_PRICE_TIER = 2,
  DISCRETION_OFFSET_TYPE_TICKS = 3
};
bool DiscretionOffsetTypeEnum_IsValid(int value);
const DiscretionOffsetTypeEnum DiscretionOffsetTypeEnum_MIN = DISCRETION_OFFSET_TYPE_BASIS_POINTS;
const DiscretionOffsetTypeEnum DiscretionOffsetTypeEnum_MAX = DISCRETION_OFFSET_TYPE_TICKS;
const int DiscretionOffsetTypeEnum_ARRAYSIZE = DiscretionOffsetTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscretionOffsetTypeEnum_descriptor();
inline const ::std::string& DiscretionOffsetTypeEnum_Name(DiscretionOffsetTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscretionOffsetTypeEnum_descriptor(), value);
}
inline bool DiscretionOffsetTypeEnum_Parse(
    const ::std::string& name, DiscretionOffsetTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscretionOffsetTypeEnum>(
    DiscretionOffsetTypeEnum_descriptor(), name, value);
}
enum DiscretionLimitTypeEnum {
  DISCRETION_LIMIT_TYPE_OR_BETTER = 0,
  DISCRETION_LIMIT_TYPE_OR_WORSE = 1,
  DISCRETION_LIMIT_TYPE_STRICT = 2
};
bool DiscretionLimitTypeEnum_IsValid(int value);
const DiscretionLimitTypeEnum DiscretionLimitTypeEnum_MIN = DISCRETION_LIMIT_TYPE_OR_BETTER;
const DiscretionLimitTypeEnum DiscretionLimitTypeEnum_MAX = DISCRETION_LIMIT_TYPE_STRICT;
const int DiscretionLimitTypeEnum_ARRAYSIZE = DiscretionLimitTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscretionLimitTypeEnum_descriptor();
inline const ::std::string& DiscretionLimitTypeEnum_Name(DiscretionLimitTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscretionLimitTypeEnum_descriptor(), value);
}
inline bool DiscretionLimitTypeEnum_Parse(
    const ::std::string& name, DiscretionLimitTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscretionLimitTypeEnum>(
    DiscretionLimitTypeEnum_descriptor(), name, value);
}
enum DiscretionRoundDirectionEnum {
  DISCRETION_ROUND_DIRECTION_MORE_AGGRESSIVE = 0,
  DISCRETION_ROUND_DIRECTION_MORE_PASSIVE = 1
};
bool DiscretionRoundDirectionEnum_IsValid(int value);
const DiscretionRoundDirectionEnum DiscretionRoundDirectionEnum_MIN = DISCRETION_ROUND_DIRECTION_MORE_AGGRESSIVE;
const DiscretionRoundDirectionEnum DiscretionRoundDirectionEnum_MAX = DISCRETION_ROUND_DIRECTION_MORE_PASSIVE;
const int DiscretionRoundDirectionEnum_ARRAYSIZE = DiscretionRoundDirectionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscretionRoundDirectionEnum_descriptor();
inline const ::std::string& DiscretionRoundDirectionEnum_Name(DiscretionRoundDirectionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscretionRoundDirectionEnum_descriptor(), value);
}
inline bool DiscretionRoundDirectionEnum_Parse(
    const ::std::string& name, DiscretionRoundDirectionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscretionRoundDirectionEnum>(
    DiscretionRoundDirectionEnum_descriptor(), name, value);
}
enum DiscretionScopeEnum {
  DISCRETION_SCOPE_GLOBAL = 0,
  DISCRETION_SCOPE_LOCAL = 1,
  DISCRETION_SCOPE_NATIONAL = 2,
  DISCRETION_SCOPE_NATIONAL_EXCLUDING_LOCAL = 3
};
bool DiscretionScopeEnum_IsValid(int value);
const DiscretionScopeEnum DiscretionScopeEnum_MIN = DISCRETION_SCOPE_GLOBAL;
const DiscretionScopeEnum DiscretionScopeEnum_MAX = DISCRETION_SCOPE_NATIONAL_EXCLUDING_LOCAL;
const int DiscretionScopeEnum_ARRAYSIZE = DiscretionScopeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DiscretionScopeEnum_descriptor();
inline const ::std::string& DiscretionScopeEnum_Name(DiscretionScopeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DiscretionScopeEnum_descriptor(), value);
}
inline bool DiscretionScopeEnum_Parse(
    const ::std::string& name, DiscretionScopeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DiscretionScopeEnum>(
    DiscretionScopeEnum_descriptor(), name, value);
}
enum StrategyParameterTypeEnum {
  STRATEGY_PARAMETER_TYPE_AMT = 0,
  STRATEGY_PARAMETER_TYPE_BOOLEAN = 1,
  STRATEGY_PARAMETER_TYPE_CHAR = 2,
  STRATEGY_PARAMETER_TYPE_CURRENCY = 3,
  STRATEGY_PARAMETER_TYPE_DATA = 4,
  STRATEGY_PARAMETER_TYPE_EXCHANGE = 5,
  STRATEGY_PARAMETER_TYPE_FLOAT = 6,
  STRATEGY_PARAMETER_TYPE_INT = 7,
  STRATEGY_PARAMETER_TYPE_LENGTH = 8,
  STRATEGY_PARAMETER_TYPE_LOCAL_MKT_DATE = 9,
  STRATEGY_PARAMETER_TYPE_MONTH_YEAR = 10,
  STRATEGY_PARAMETER_TYPE_MULTIPLE_CHAR_VALUE = 11,
  STRATEGY_PARAMETER_TYPE_NUM_IN_GROUP = 12,
  STRATEGY_PARAMETER_TYPE_PERCENTAGE = 13,
  STRATEGY_PARAMETER_TYPE_PRICE = 14,
  STRATEGY_PARAMETER_TYPE_PRICE_OFFSET = 15,
  STRATEGY_PARAMETER_TYPE_QTY = 16,
  STRATEGY_PARAMETER_TYPE_SEQ_NUM = 17,
  STRATEGY_PARAMETER_TYPE_STRING = 18,
  STRATEGY_PARAMETER_TYPE_TAG_NUM = 19,
  STRATEGY_PARAMETER_TYPE_UTC_DATE_ONLY = 20,
  STRATEGY_PARAMETER_TYPE_UTC_TIME_ONLY = 21,
  STRATEGY_PARAMETER_TYPE_UTC_TIMESTAMP = 22,
  STRATEGY_PARAMETER_TYPE_MULTIPLE_STRING_VALUE = 23,
  STRATEGY_PARAMETER_TYPE_COUNTRY = 24,
  STRATEGY_PARAMETER_TYPE_LANGUAGE = 25,
  STRATEGY_PARAMETER_TYPE_TZ_TIME_ONLY = 26,
  STRATEGY_PARAMETER_TYPE_TZ_TIMESTAMP = 27,
  STRATEGY_PARAMETER_TYPE_TENOR = 28
};
bool StrategyParameterTypeEnum_IsValid(int value);
const StrategyParameterTypeEnum StrategyParameterTypeEnum_MIN = STRATEGY_PARAMETER_TYPE_AMT;
const StrategyParameterTypeEnum StrategyParameterTypeEnum_MAX = STRATEGY_PARAMETER_TYPE_TENOR;
const int StrategyParameterTypeEnum_ARRAYSIZE = StrategyParameterTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* StrategyParameterTypeEnum_descriptor();
inline const ::std::string& StrategyParameterTypeEnum_Name(StrategyParameterTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    StrategyParameterTypeEnum_descriptor(), value);
}
inline bool StrategyParameterTypeEnum_Parse(
    const ::std::string& name, StrategyParameterTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StrategyParameterTypeEnum>(
    StrategyParameterTypeEnum_descriptor(), name, value);
}
enum TrdRegTimestampTypeEnum {
  TRD_REG_TIMESTAMP_TYPE_BROKER_EXECUTION = 0,
  TRD_REG_TIMESTAMP_TYPE_BROKER_RECEIPT = 1,
  TRD_REG_TIMESTAMP_TYPE_EXECUTION_TIME = 2,
  TRD_REG_TIMESTAMP_TYPE_TIME_IN = 3,
  TRD_REG_TIMESTAMP_TYPE_TIME_OUT = 4,
  TRD_REG_TIMESTAMP_TYPE_DESK_RECEIPT = 5,
  TRD_REG_TIMESTAMP_TYPE_SUBMISSION_TO_CLEARING = 6
};
bool TrdRegTimestampTypeEnum_IsValid(int value);
const TrdRegTimestampTypeEnum TrdRegTimestampTypeEnum_MIN = TRD_REG_TIMESTAMP_TYPE_BROKER_EXECUTION;
const TrdRegTimestampTypeEnum TrdRegTimestampTypeEnum_MAX = TRD_REG_TIMESTAMP_TYPE_SUBMISSION_TO_CLEARING;
const int TrdRegTimestampTypeEnum_ARRAYSIZE = TrdRegTimestampTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrdRegTimestampTypeEnum_descriptor();
inline const ::std::string& TrdRegTimestampTypeEnum_Name(TrdRegTimestampTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrdRegTimestampTypeEnum_descriptor(), value);
}
inline bool TrdRegTimestampTypeEnum_Parse(
    const ::std::string& name, TrdRegTimestampTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrdRegTimestampTypeEnum>(
    TrdRegTimestampTypeEnum_descriptor(), name, value);
}
enum DeskTypeEnum {
  DESK_TYPE_AGENCY = 0,
  DESK_TYPE_ARBITRAGE = 1,
  DESK_TYPE_DERIVATIVES = 2,
  DESK_TYPE_INSTITUTIONAL = 3,
  DESK_TYPE_INTERNATIONAL = 4,
  DESK_TYPE_OTHER = 5,
  DESK_TYPE_PREFERRED_TRADING = 6,
  DESK_TYPE_PROGRAM_TRADING = 7,
  DESK_TYPE_PROPRIETARY = 8,
  DESK_TYPE_SALES = 9,
  DESK_TYPE_TRADING = 10
};
bool DeskTypeEnum_IsValid(int value);
const DeskTypeEnum DeskTypeEnum_MIN = DESK_TYPE_AGENCY;
const DeskTypeEnum DeskTypeEnum_MAX = DESK_TYPE_TRADING;
const int DeskTypeEnum_ARRAYSIZE = DeskTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeskTypeEnum_descriptor();
inline const ::std::string& DeskTypeEnum_Name(DeskTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeskTypeEnum_descriptor(), value);
}
inline bool DeskTypeEnum_Parse(
    const ::std::string& name, DeskTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeskTypeEnum>(
    DeskTypeEnum_descriptor(), name, value);
}
enum DeskTypeSourceEnum {
  DESK_TYPE_SOURCE_NASDOATS = 0
};
bool DeskTypeSourceEnum_IsValid(int value);
const DeskTypeSourceEnum DeskTypeSourceEnum_MIN = DESK_TYPE_SOURCE_NASDOATS;
const DeskTypeSourceEnum DeskTypeSourceEnum_MAX = DESK_TYPE_SOURCE_NASDOATS;
const int DeskTypeSourceEnum_ARRAYSIZE = DeskTypeSourceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeskTypeSourceEnum_descriptor();
inline const ::std::string& DeskTypeSourceEnum_Name(DeskTypeSourceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeskTypeSourceEnum_descriptor(), value);
}
inline bool DeskTypeSourceEnum_Parse(
    const ::std::string& name, DeskTypeSourceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeskTypeSourceEnum>(
    DeskTypeSourceEnum_descriptor(), name, value);
}
enum DeskOrderHandlingInstEnum {
  DESK_ORDER_HANDLING_INST_ADD_ON_ORDER = 0,
  DESK_ORDER_HANDLING_INST_ALL_OR_NONE = 1,
  DESK_ORDER_HANDLING_INST_CASH_NOT_HELD = 2,
  DESK_ORDER_HANDLING_INST_DIRECTED_ORDER = 3,
  DESK_ORDER_HANDLING_INST_EXCHANGE_FOR_PHYSICAL_TRANSACTION = 4,
  DESK_ORDER_HANDLING_INST_FILL_OR_KILL = 5,
  DESK_ORDER_HANDLING_INST_IMBALANCE_ONLY = 6,
  DESK_ORDER_HANDLING_INST_IMMEDIATE_OR_CANCEL = 7,
  DESK_ORDER_HANDLING_INST_LIMIT_ON_CLOSE = 8,
  DESK_ORDER_HANDLING_INST_LIMIT_ON_OPEN = 9,
  DESK_ORDER_HANDLING_INST_MARKET_AT_CLOSE = 10,
  DESK_ORDER_HANDLING_INST_MARKET_AT_OPEN = 11,
  DESK_ORDER_HANDLING_INST_MARKET_ON_CLOSE = 12,
  DESK_ORDER_HANDLING_INST_MARKET_ON_OPEN = 13,
  DESK_ORDER_HANDLING_INST_MINIMUM_QUANTITY = 14,
  DESK_ORDER_HANDLING_INST_NOT_HELD = 15,
  DESK_ORDER_HANDLING_INST_OVER_THE_DAY = 16,
  DESK_ORDER_HANDLING_INST_PEGGED = 17,
  DESK_ORDER_HANDLING_INST_RESERVE_SIZE_ORDER = 18,
  DESK_ORDER_HANDLING_INST_SCALE = 19,
  DESK_ORDER_HANDLING_INST_STOP_STOCK_TRANSACTION = 20,
  DESK_ORDER_HANDLING_INST_TIME_ORDER = 21,
  DESK_ORDER_HANDLING_INST_TRAILING_STOP = 22,
  DESK_ORDER_HANDLING_INST_WORK = 23
};
bool DeskOrderHandlingInstEnum_IsValid(int value);
const DeskOrderHandlingInstEnum DeskOrderHandlingInstEnum_MIN = DESK_ORDER_HANDLING_INST_ADD_ON_ORDER;
const DeskOrderHandlingInstEnum DeskOrderHandlingInstEnum_MAX = DESK_ORDER_HANDLING_INST_WORK;
const int DeskOrderHandlingInstEnum_ARRAYSIZE = DeskOrderHandlingInstEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeskOrderHandlingInstEnum_descriptor();
inline const ::std::string& DeskOrderHandlingInstEnum_Name(DeskOrderHandlingInstEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeskOrderHandlingInstEnum_descriptor(), value);
}
inline bool DeskOrderHandlingInstEnum_Parse(
    const ::std::string& name, DeskOrderHandlingInstEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeskOrderHandlingInstEnum>(
    DeskOrderHandlingInstEnum_descriptor(), name, value);
}
enum RateSourceEnum {
  RATE_SOURCE_BLOOMBERG = 0,
  RATE_SOURCE_OTHER = 1,
  RATE_SOURCE_REUTERS = 2,
  RATE_SOURCE_TELERATE = 3
};
bool RateSourceEnum_IsValid(int value);
const RateSourceEnum RateSourceEnum_MIN = RATE_SOURCE_BLOOMBERG;
const RateSourceEnum RateSourceEnum_MAX = RATE_SOURCE_TELERATE;
const int RateSourceEnum_ARRAYSIZE = RateSourceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RateSourceEnum_descriptor();
inline const ::std::string& RateSourceEnum_Name(RateSourceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RateSourceEnum_descriptor(), value);
}
inline bool RateSourceEnum_Parse(
    const ::std::string& name, RateSourceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RateSourceEnum>(
    RateSourceEnum_descriptor(), name, value);
}
enum RateSourceTypeEnum {
  RATE_SOURCE_TYPE_PRIMARY = 0,
  RATE_SOURCE_TYPE_SECONDARY = 1
};
bool RateSourceTypeEnum_IsValid(int value);
const RateSourceTypeEnum RateSourceTypeEnum_MIN = RATE_SOURCE_TYPE_PRIMARY;
const RateSourceTypeEnum RateSourceTypeEnum_MAX = RATE_SOURCE_TYPE_SECONDARY;
const int RateSourceTypeEnum_ARRAYSIZE = RateSourceTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RateSourceTypeEnum_descriptor();
inline const ::std::string& RateSourceTypeEnum_Name(RateSourceTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RateSourceTypeEnum_descriptor(), value);
}
inline bool RateSourceTypeEnum_Parse(
    const ::std::string& name, RateSourceTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RateSourceTypeEnum>(
    RateSourceTypeEnum_descriptor(), name, value);
}
enum ContAmtTypeEnum {
  CONT_AMT_TYPE_COMMISSION_AMOUNT = 0,
  CONT_AMT_TYPE_COMMISSION_PERCENT = 1,
  CONT_AMT_TYPE_DILUTION_LEVY_AMOUNT = 2,
  CONT_AMT_TYPE_DILUTION_LEVY_PERCENT = 3,
  CONT_AMT_TYPE_DISCOUNT_AMOUNT = 4,
  CONT_AMT_TYPE_DISCOUNT_PERCENT = 5,
  CONT_AMT_TYPE_EXIT_CHARGE_AMOUNT = 6,
  CONT_AMT_TYPE_EXIT_CHARGE_PERCENT = 7,
  CONT_AMT_TYPE_FUND_BASED_RENEWAL_COMMISSION_ON_FUND = 8,
  CONT_AMT_TYPE_FUND_BASED_RENEWAL_COMMISSION_ON_ORDER = 9,
  CONT_AMT_TYPE_FUND_BASED_RENEWAL_COMMISSION_PERCENT = 10,
  CONT_AMT_TYPE_INITIAL_CHARGE_AMOUNT = 11,
  CONT_AMT_TYPE_INITIAL_CHARGE_PERCENT = 12,
  CONT_AMT_TYPE_NET_SETTLEMENT_AMOUNT = 13,
  CONT_AMT_TYPE_PROJECTED_FUND_VALUE = 14
};
bool ContAmtTypeEnum_IsValid(int value);
const ContAmtTypeEnum ContAmtTypeEnum_MIN = CONT_AMT_TYPE_COMMISSION_AMOUNT;
const ContAmtTypeEnum ContAmtTypeEnum_MAX = CONT_AMT_TYPE_PROJECTED_FUND_VALUE;
const int ContAmtTypeEnum_ARRAYSIZE = ContAmtTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContAmtTypeEnum_descriptor();
inline const ::std::string& ContAmtTypeEnum_Name(ContAmtTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContAmtTypeEnum_descriptor(), value);
}
inline bool ContAmtTypeEnum_Parse(
    const ::std::string& name, ContAmtTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContAmtTypeEnum>(
    ContAmtTypeEnum_descriptor(), name, value);
}
enum LegSwapTypeEnum {
  LEG_SWAP_TYPE_MODIFIED_DURATION = 0,
  LEG_SWAP_TYPE_PAR_FOR_PAR = 1,
  LEG_SWAP_TYPE_PROCEEDS = 2,
  LEG_SWAP_TYPE_RISK = 3
};
bool LegSwapTypeEnum_IsValid(int value);
const LegSwapTypeEnum LegSwapTypeEnum_MIN = LEG_SWAP_TYPE_MODIFIED_DURATION;
const LegSwapTypeEnum LegSwapTypeEnum_MAX = LEG_SWAP_TYPE_RISK;
const int LegSwapTypeEnum_ARRAYSIZE = LegSwapTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LegSwapTypeEnum_descriptor();
inline const ::std::string& LegSwapTypeEnum_Name(LegSwapTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LegSwapTypeEnum_descriptor(), value);
}
inline bool LegSwapTypeEnum_Parse(
    const ::std::string& name, LegSwapTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LegSwapTypeEnum>(
    LegSwapTypeEnum_descriptor(), name, value);
}
enum MiscFeeTypeEnum {
  MISC_FEE_TYPE_EXCHANGE_FEES = 0,
  MISC_FEE_TYPE_LEVY = 1,
  MISC_FEE_TYPE_LOCAL_COMMISSION = 2,
  MISC_FEE_TYPE_OTHER = 3,
  MISC_FEE_TYPE_REGULATORY = 4,
  MISC_FEE_TYPE_STAMP = 5,
  MISC_FEE_TYPE_TAX = 6,
  MISC_FEE_TYPE_MARKUP = 7,
  MISC_FEE_TYPE_CONSUMPTION_TAX = 8,
  MISC_FEE_TYPE_AGENT = 9,
  MISC_FEE_TYPE_CONVERSION = 10,
  MISC_FEE_TYPE_PER_TRANSACTION = 11,
  MISC_FEE_TYPE_SECURITY_LENDING = 12,
  MISC_FEE_TYPE_TRANSFER_FEE = 13
};
bool MiscFeeTypeEnum_IsValid(int value);
const MiscFeeTypeEnum MiscFeeTypeEnum_MIN = MISC_FEE_TYPE_EXCHANGE_FEES;
const MiscFeeTypeEnum MiscFeeTypeEnum_MAX = MISC_FEE_TYPE_TRANSFER_FEE;
const int MiscFeeTypeEnum_ARRAYSIZE = MiscFeeTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MiscFeeTypeEnum_descriptor();
inline const ::std::string& MiscFeeTypeEnum_Name(MiscFeeTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MiscFeeTypeEnum_descriptor(), value);
}
inline bool MiscFeeTypeEnum_Parse(
    const ::std::string& name, MiscFeeTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MiscFeeTypeEnum>(
    MiscFeeTypeEnum_descriptor(), name, value);
}
enum MiscFeeBasisEnum {
  MISC_FEE_BASIS_ABSOLUTE = 0,
  MISC_FEE_BASIS_PER_UNIT = 1,
  MISC_FEE_BASIS_PERCENTAGE = 2
};
bool MiscFeeBasisEnum_IsValid(int value);
const MiscFeeBasisEnum MiscFeeBasisEnum_MIN = MISC_FEE_BASIS_ABSOLUTE;
const MiscFeeBasisEnum MiscFeeBasisEnum_MAX = MISC_FEE_BASIS_PERCENTAGE;
const int MiscFeeBasisEnum_ARRAYSIZE = MiscFeeBasisEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MiscFeeBasisEnum_descriptor();
inline const ::std::string& MiscFeeBasisEnum_Name(MiscFeeBasisEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MiscFeeBasisEnum_descriptor(), value);
}
inline bool MiscFeeBasisEnum_Parse(
    const ::std::string& name, MiscFeeBasisEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MiscFeeBasisEnum>(
    MiscFeeBasisEnum_descriptor(), name, value);
}
enum RoutingTypeEnum {
  ROUTING_TYPE_BLOCK_FIRM = 0,
  ROUTING_TYPE_BLOCK_LIST = 1,
  ROUTING_TYPE_TARGET_FIRM = 2,
  ROUTING_TYPE_TARGET_LIST = 3
};
bool RoutingTypeEnum_IsValid(int value);
const RoutingTypeEnum RoutingTypeEnum_MIN = ROUTING_TYPE_BLOCK_FIRM;
const RoutingTypeEnum RoutingTypeEnum_MAX = ROUTING_TYPE_TARGET_LIST;
const int RoutingTypeEnum_ARRAYSIZE = RoutingTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoutingTypeEnum_descriptor();
inline const ::std::string& RoutingTypeEnum_Name(RoutingTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoutingTypeEnum_descriptor(), value);
}
inline bool RoutingTypeEnum_Parse(
    const ::std::string& name, RoutingTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoutingTypeEnum>(
    RoutingTypeEnum_descriptor(), name, value);
}
enum InstrAttribTypeEnum {
  INSTR_ATTRIB_TYPE_CALLABLE = 0,
  INSTR_ATTRIB_TYPE_CALLABLE_BELOW_MATURITY_VALUE = 1,
  INSTR_ATTRIB_TYPE_CALLABLE_WITHOUT_NOTICE = 2,
  INSTR_ATTRIB_TYPE_COUPON_PERIOD = 3,
  INSTR_ATTRIB_TYPE_ESCROWED_TO_MATURITY = 4,
  INSTR_ATTRIB_TYPE_ESCROWED_TO_REDEMPTION_DATE = 5,
  INSTR_ATTRIB_TYPE_FLAT = 6,
  INSTR_ATTRIB_TYPE_IN_DEFAULT = 7,
  INSTR_ATTRIB_TYPE_INDEXED = 8,
  INSTR_ATTRIB_TYPE_INTEREST_BEARING = 9,
  INSTR_ATTRIB_TYPE_LESS_FEE_FOR_PUT = 10,
  INSTR_ATTRIB_TYPE_NO_PERIODIC_PAYMENTS = 11,
  INSTR_ATTRIB_TYPE_ORIGINAL_ISSUE_DISCOUNT = 12,
  INSTR_ATTRIB_TYPE_ORIGINAL_ISSUE_DISCOUNT_PRICE = 13,
  INSTR_ATTRIB_TYPE_PRE_REFUNDED = 14,
  INSTR_ATTRIB_TYPE_STEPPED_COUPON = 15,
  INSTR_ATTRIB_TYPE_SUBJECT_TO_ALTERNATIVE_MINIMUM_TAX = 16,
  INSTR_ATTRIB_TYPE_TAXABLE = 17,
  INSTR_ATTRIB_TYPE_TEXT = 18,
  INSTR_ATTRIB_TYPE_UNRATED = 19,
  INSTR_ATTRIB_TYPE_VARIABLE_RATE = 20,
  INSTR_ATTRIB_TYPE_WHEN = 21,
  INSTR_ATTRIB_TYPE_ZERO_COUPON = 22,
  INSTR_ATTRIB_TYPE_PRICE_TICK_RULES_FOR_SECURITY = 23,
  INSTR_ATTRIB_TYPE_TRADE_TYPE_ELIGIBILITY_DETAILS_FOR_SECURITY = 24,
  INSTR_ATTRIB_TYPE_INSTRUMENT_DENOMINATOR = 25,
  INSTR_ATTRIB_TYPE_INSTRUMENT_NUMERATOR = 26,
  INSTR_ATTRIB_TYPE_INSTRUMENT_PRICE_PRECISION = 27,
  INSTR_ATTRIB_TYPE_INSTRUMENT_STRIKE_PRICE = 28,
  INSTR_ATTRIB_TYPE_TRADEABLE_INDICATOR = 29
};
bool InstrAttribTypeEnum_IsValid(int value);
const InstrAttribTypeEnum InstrAttribTypeEnum_MIN = INSTR_ATTRIB_TYPE_CALLABLE;
const InstrAttribTypeEnum InstrAttribTypeEnum_MAX = INSTR_ATTRIB_TYPE_TRADEABLE_INDICATOR;
const int InstrAttribTypeEnum_ARRAYSIZE = InstrAttribTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* InstrAttribTypeEnum_descriptor();
inline const ::std::string& InstrAttribTypeEnum_Name(InstrAttribTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    InstrAttribTypeEnum_descriptor(), value);
}
inline bool InstrAttribTypeEnum_Parse(
    const ::std::string& name, InstrAttribTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<InstrAttribTypeEnum>(
    InstrAttribTypeEnum_descriptor(), name, value);
}
enum DeliveryFormEnum {
  DELIVERY_FORM_BEARER = 0,
  DELIVERY_FORM_BOOK_ENTRY = 1
};
bool DeliveryFormEnum_IsValid(int value);
const DeliveryFormEnum DeliveryFormEnum_MIN = DELIVERY_FORM_BEARER;
const DeliveryFormEnum DeliveryFormEnum_MAX = DELIVERY_FORM_BOOK_ENTRY;
const int DeliveryFormEnum_ARRAYSIZE = DeliveryFormEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* DeliveryFormEnum_descriptor();
inline const ::std::string& DeliveryFormEnum_Name(DeliveryFormEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    DeliveryFormEnum_descriptor(), value);
}
inline bool DeliveryFormEnum_Parse(
    const ::std::string& name, DeliveryFormEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DeliveryFormEnum>(
    DeliveryFormEnum_descriptor(), name, value);
}
enum TickRuleTypeEnum {
  TICK_RULE_TYPE_FIXED = 0,
  TICK_RULE_TYPE_REGULAR = 1,
  TICK_RULE_TYPE_SETTLED_AS_ASPREAD_LEG = 2,
  TICK_RULE_TYPE_TRADED_AS_ASPREAD_LEG = 3,
  TICK_RULE_TYPE_VARIABLE = 4
};
bool TickRuleTypeEnum_IsValid(int value);
const TickRuleTypeEnum TickRuleTypeEnum_MIN = TICK_RULE_TYPE_FIXED;
const TickRuleTypeEnum TickRuleTypeEnum_MAX = TICK_RULE_TYPE_VARIABLE;
const int TickRuleTypeEnum_ARRAYSIZE = TickRuleTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TickRuleTypeEnum_descriptor();
inline const ::std::string& TickRuleTypeEnum_Name(TickRuleTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TickRuleTypeEnum_descriptor(), value);
}
inline bool TickRuleTypeEnum_Parse(
    const ::std::string& name, TickRuleTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TickRuleTypeEnum>(
    TickRuleTypeEnum_descriptor(), name, value);
}
enum LotTypeEnum {
  LOT_TYPE_BLOCK_LOT = 0,
  LOT_TYPE_ODD_LOT = 1,
  LOT_TYPE_ROUND_LOT = 2,
  LOT_TYPE_ROUND_LOT_BASED_UPON = 3
};
bool LotTypeEnum_IsValid(int value);
const LotTypeEnum LotTypeEnum_MIN = LOT_TYPE_BLOCK_LOT;
const LotTypeEnum LotTypeEnum_MAX = LOT_TYPE_ROUND_LOT_BASED_UPON;
const int LotTypeEnum_ARRAYSIZE = LotTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LotTypeEnum_descriptor();
inline const ::std::string& LotTypeEnum_Name(LotTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LotTypeEnum_descriptor(), value);
}
inline bool LotTypeEnum_Parse(
    const ::std::string& name, LotTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LotTypeEnum>(
    LotTypeEnum_descriptor(), name, value);
}
enum PriceLimitTypeEnum {
  PRICE_LIMIT_TYPE_PERCENTAGE = 0,
  PRICE_LIMIT_TYPE_PRICE = 1,
  PRICE_LIMIT_TYPE_TICKS = 2
};
bool PriceLimitTypeEnum_IsValid(int value);
const PriceLimitTypeEnum PriceLimitTypeEnum_MIN = PRICE_LIMIT_TYPE_PERCENTAGE;
const PriceLimitTypeEnum PriceLimitTypeEnum_MAX = PRICE_LIMIT_TYPE_TICKS;
const int PriceLimitTypeEnum_ARRAYSIZE = PriceLimitTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriceLimitTypeEnum_descriptor();
inline const ::std::string& PriceLimitTypeEnum_Name(PriceLimitTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriceLimitTypeEnum_descriptor(), value);
}
inline bool PriceLimitTypeEnum_Parse(
    const ::std::string& name, PriceLimitTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriceLimitTypeEnum>(
    PriceLimitTypeEnum_descriptor(), name, value);
}
enum ExpirationCycleEnum {
  EXPIRATION_CYCLE_EXPIRE_ON_TRADING_SESSION_CLOSE = 0,
  EXPIRATION_CYCLE_EXPIRE_ON_TRADING_SESSION_OPEN = 1,
  EXPIRATION_CYCLE_SPECIFIED_EXPIRATION = 2
};
bool ExpirationCycleEnum_IsValid(int value);
const ExpirationCycleEnum ExpirationCycleEnum_MIN = EXPIRATION_CYCLE_EXPIRE_ON_TRADING_SESSION_CLOSE;
const ExpirationCycleEnum ExpirationCycleEnum_MAX = EXPIRATION_CYCLE_SPECIFIED_EXPIRATION;
const int ExpirationCycleEnum_ARRAYSIZE = ExpirationCycleEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExpirationCycleEnum_descriptor();
inline const ::std::string& ExpirationCycleEnum_Name(ExpirationCycleEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExpirationCycleEnum_descriptor(), value);
}
inline bool ExpirationCycleEnum_Parse(
    const ::std::string& name, ExpirationCycleEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExpirationCycleEnum>(
    ExpirationCycleEnum_descriptor(), name, value);
}
enum ImpliedMarketIndicatorEnum {
  IMPLIED_MARKET_INDICATOR_BOTH_IMPLIED_IN_AND_IMPLIED_OUT = 0,
  IMPLIED_MARKET_INDICATOR_IMPLIED_IN = 1,
  IMPLIED_MARKET_INDICATOR_IMPLIED_OUT = 2,
  IMPLIED_MARKET_INDICATOR_NOT_IMPLIED = 3
};
bool ImpliedMarketIndicatorEnum_IsValid(int value);
const ImpliedMarketIndicatorEnum ImpliedMarketIndicatorEnum_MIN = IMPLIED_MARKET_INDICATOR_BOTH_IMPLIED_IN_AND_IMPLIED_OUT;
const ImpliedMarketIndicatorEnum ImpliedMarketIndicatorEnum_MAX = IMPLIED_MARKET_INDICATOR_NOT_IMPLIED;
const int ImpliedMarketIndicatorEnum_ARRAYSIZE = ImpliedMarketIndicatorEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImpliedMarketIndicatorEnum_descriptor();
inline const ::std::string& ImpliedMarketIndicatorEnum_Name(ImpliedMarketIndicatorEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImpliedMarketIndicatorEnum_descriptor(), value);
}
inline bool ImpliedMarketIndicatorEnum_Parse(
    const ::std::string& name, ImpliedMarketIndicatorEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImpliedMarketIndicatorEnum>(
    ImpliedMarketIndicatorEnum_descriptor(), name, value);
}
enum MultilegModelEnum {
  MULTILEG_MODEL_PREDEFINED_MULTILEG_SECURITY = 0,
  MULTILEG_MODEL_USER_DEFINED = 1,
  MULTILEG_MODEL_USER_DEFINED_MULTILEG_SECURITY = 2
};
bool MultilegModelEnum_IsValid(int value);
const MultilegModelEnum MultilegModelEnum_MIN = MULTILEG_MODEL_PREDEFINED_MULTILEG_SECURITY;
const MultilegModelEnum MultilegModelEnum_MAX = MULTILEG_MODEL_USER_DEFINED_MULTILEG_SECURITY;
const int MultilegModelEnum_ARRAYSIZE = MultilegModelEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MultilegModelEnum_descriptor();
inline const ::std::string& MultilegModelEnum_Name(MultilegModelEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MultilegModelEnum_descriptor(), value);
}
inline bool MultilegModelEnum_Parse(
    const ::std::string& name, MultilegModelEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultilegModelEnum>(
    MultilegModelEnum_descriptor(), name, value);
}
enum MultilegPriceMethodEnum {
  MULTILEG_PRICE_METHOD_CONTRACT_WEIGHTED_AVERAGE_PRICE = 0,
  MULTILEG_PRICE_METHOD_INDIVIDUAL = 1,
  MULTILEG_PRICE_METHOD_MULTIPLIED_PRICE = 2,
  MULTILEG_PRICE_METHOD_NET_PRICE = 3,
  MULTILEG_PRICE_METHOD_REVERSED_NET_PRICE = 4,
  MULTILEG_PRICE_METHOD_YIELD_DIFFERENCE = 5
};
bool MultilegPriceMethodEnum_IsValid(int value);
const MultilegPriceMethodEnum MultilegPriceMethodEnum_MIN = MULTILEG_PRICE_METHOD_CONTRACT_WEIGHTED_AVERAGE_PRICE;
const MultilegPriceMethodEnum MultilegPriceMethodEnum_MAX = MULTILEG_PRICE_METHOD_YIELD_DIFFERENCE;
const int MultilegPriceMethodEnum_ARRAYSIZE = MultilegPriceMethodEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MultilegPriceMethodEnum_descriptor();
inline const ::std::string& MultilegPriceMethodEnum_Name(MultilegPriceMethodEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MultilegPriceMethodEnum_descriptor(), value);
}
inline bool MultilegPriceMethodEnum_Parse(
    const ::std::string& name, MultilegPriceMethodEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MultilegPriceMethodEnum>(
    MultilegPriceMethodEnum_descriptor(), name, value);
}
enum PriceTypeEnum {
  PRICE_TYPE_FIXED_AMOUNT = 0,
  PRICE_TYPE_PER_UNIT = 1,
  PRICE_TYPE_PERCENTAGE = 2,
  PRICE_TYPE_DISCOUNT = 3,
  PRICE_TYPE_PREMIUM = 4,
  PRICE_TYPE_SPREAD = 5,
  PRICE_TYPE_TEDPRICE = 6,
  PRICE_TYPE_TEDYIELD = 7,
  PRICE_TYPE_FIXED_CABINET_TRADE_PRICE = 8,
  PRICE_TYPE_VARIABLE_CABINET_TRADE_PRICE = 9,
  PRICE_TYPE_YIELD = 10,
  PRICE_TYPE_PRODUCT_TICKS_IN_EIGHTS = 11,
  PRICE_TYPE_PRODUCT_TICKS_IN_FOURTHS = 12,
  PRICE_TYPE_PRODUCT_TICKS_IN_HALFS = 13,
  PRICE_TYPE_PRODUCT_TICKS_IN_ONE_TWENTY_EIGHTS = 14,
  PRICE_TYPE_PRODUCT_TICKS_IN_SIXTEENTHS = 15,
  PRICE_TYPE_PRODUCT_TICKS_IN_SIXTY_FORTHS = 16,
  PRICE_TYPE_PRODUCT_TICKS_IN_THIRTY_SECONDS = 17
};
bool PriceTypeEnum_IsValid(int value);
const PriceTypeEnum PriceTypeEnum_MIN = PRICE_TYPE_FIXED_AMOUNT;
const PriceTypeEnum PriceTypeEnum_MAX = PRICE_TYPE_PRODUCT_TICKS_IN_THIRTY_SECONDS;
const int PriceTypeEnum_ARRAYSIZE = PriceTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* PriceTypeEnum_descriptor();
inline const ::std::string& PriceTypeEnum_Name(PriceTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    PriceTypeEnum_descriptor(), value);
}
inline bool PriceTypeEnum_Parse(
    const ::std::string& name, PriceTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PriceTypeEnum>(
    PriceTypeEnum_descriptor(), name, value);
}
enum OrdTypeEnum {
  ORD_TYPE_LIMIT = 0,
  ORD_TYPE_LIMIT_ON_CLOSE = 1,
  ORD_TYPE_LIMIT_OR_BETTER = 2,
  ORD_TYPE_LIMIT_WITH_OR_WITHOUT = 3,
  ORD_TYPE_MARKET = 4,
  ORD_TYPE_MARKET_ON_CLOSE = 5,
  ORD_TYPE_ON_BASIS = 6,
  ORD_TYPE_ON_CLOSE = 7,
  ORD_TYPE_STOP = 8,
  ORD_TYPE_STOP_LIMIT = 9,
  ORD_TYPE_WITH_OR_WITHOUT = 10,
  ORD_TYPE_PEGGED = 11,
  ORD_TYPE_FOREX_MARKET = 12,
  ORD_TYPE_PREVIOUSLY_INDICATED = 13,
  ORD_TYPE_PREVIOUSLY_QUOTED = 14,
  ORD_TYPE_FOREX_LIMIT = 15,
  ORD_TYPE_FOREX_PREVIOUSLY_QUOTED = 16,
  ORD_TYPE_FOREX_SWAP = 17,
  ORD_TYPE_FUNARI = 18,
  ORD_TYPE_MARKET_IF_TOUCHED = 19,
  ORD_TYPE_MARKET_WITH_LEFT_OVER_AS_LIMIT = 20,
  ORD_TYPE_NEXT_FUND_VALUATION_POINT = 21,
  ORD_TYPE_PREVIOUS_FUND_VALUATION_POINT = 22,
  ORD_TYPE_COUNTER_ORDER_SELECTION = 23
};
bool OrdTypeEnum_IsValid(int value);
const OrdTypeEnum OrdTypeEnum_MIN = ORD_TYPE_LIMIT;
const OrdTypeEnum OrdTypeEnum_MAX = ORD_TYPE_COUNTER_ORDER_SELECTION;
const int OrdTypeEnum_ARRAYSIZE = OrdTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* OrdTypeEnum_descriptor();
inline const ::std::string& OrdTypeEnum_Name(OrdTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    OrdTypeEnum_descriptor(), value);
}
inline bool OrdTypeEnum_Parse(
    const ::std::string& name, OrdTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OrdTypeEnum>(
    OrdTypeEnum_descriptor(), name, value);
}
enum TimeInForceEnum {
  TIME_IN_FORCE_AT_THE_OPENING = 0,
  TIME_IN_FORCE_DAY = 1,
  TIME_IN_FORCE_FILL_OR_KILL = 2,
  TIME_IN_FORCE_GOOD_TILL_CANCEL = 3,
  TIME_IN_FORCE_GOOD_TILL_CROSSING = 4,
  TIME_IN_FORCE_IMMEDIATE_OR_CANCEL = 5,
  TIME_IN_FORCE_GOOD_TILL_DATE = 6,
  TIME_IN_FORCE_AT_THE_CLOSE = 7,
  TIME_IN_FORCE_AT_CROSSING = 8,
  TIME_IN_FORCE_GOOD_THROUGH_CROSSING = 9
};
bool TimeInForceEnum_IsValid(int value);
const TimeInForceEnum TimeInForceEnum_MIN = TIME_IN_FORCE_AT_THE_OPENING;
const TimeInForceEnum TimeInForceEnum_MAX = TIME_IN_FORCE_GOOD_THROUGH_CROSSING;
const int TimeInForceEnum_ARRAYSIZE = TimeInForceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeInForceEnum_descriptor();
inline const ::std::string& TimeInForceEnum_Name(TimeInForceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeInForceEnum_descriptor(), value);
}
inline bool TimeInForceEnum_Parse(
    const ::std::string& name, TimeInForceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeInForceEnum>(
    TimeInForceEnum_descriptor(), name, value);
}
enum MatchTypeEnum {
  MATCH_TYPE_A1EXACT_MATCH_SUMMARIZED_QUANTITY = 0,
  MATCH_TYPE_A2EXACT_MATCH_SUMMARIZED_QUANTITY = 1,
  MATCH_TYPE_A3EXACT_MATCH_SUMMARIZED_QUANTITY = 2,
  MATCH_TYPE_A4EXACT_MATCH_SUMMARIZED_QUANTITY = 3,
  MATCH_TYPE_A5EXACT_MATCH_SUMMARIZED_QUANTITY = 4,
  MATCH_TYPE_ACTACCEPTED_TRADE = 5,
  MATCH_TYPE_ACTDEFAULT_AFTER_M2 = 6,
  MATCH_TYPE_ACTDEFAULT_TRADE = 7,
  MATCH_TYPE_ACTM6MATCH = 8,
  MATCH_TYPE_EXACT_MATCH_MINUS_BADGES_TIMES = 9,
  MATCH_TYPE_EXACT_MATCH_PLUS2BADGES = 10,
  MATCH_TYPE_EXACT_MATCH_PLUS2BADGES_EXEC_TIME = 11,
  MATCH_TYPE_EXACT_MATCH_PLUS4BADGES = 12,
  MATCH_TYPE_EXACT_MATCH_PLUS4BADGES_EXEC_TIME = 13,
  MATCH_TYPE_EXACT_MATCH_PLUS_EXEC_TIME = 14,
  MATCH_TYPE_OCSLOCKED_IN = 15,
  MATCH_TYPE_STAMPED_ADVISORIES_OR_SPECIALIST_ACCEPTS = 16,
  MATCH_TYPE_SUMMARIZED_MATCH_MINUS_BADGES_TIMES = 17,
  MATCH_TYPE_AUTO_MATCH = 18,
  MATCH_TYPE_CALL_AUCTION = 19,
  MATCH_TYPE_CONFIRMED_TRADE_REPORT = 20,
  MATCH_TYPE_COUNTER_ORDER_SELECTION = 21,
  MATCH_TYPE_CROSS_AUCTION = 22,
  MATCH_TYPE_ONE_PARTY_TRADE_REPORT = 23,
  MATCH_TYPE_TWO_PARTY_TRADE_REPORT = 24,
  MATCH_TYPE_ISSUING = 25
};
bool MatchTypeEnum_IsValid(int value);
const MatchTypeEnum MatchTypeEnum_MIN = MATCH_TYPE_A1EXACT_MATCH_SUMMARIZED_QUANTITY;
const MatchTypeEnum MatchTypeEnum_MAX = MATCH_TYPE_ISSUING;
const int MatchTypeEnum_ARRAYSIZE = MatchTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MatchTypeEnum_descriptor();
inline const ::std::string& MatchTypeEnum_Name(MatchTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MatchTypeEnum_descriptor(), value);
}
inline bool MatchTypeEnum_Parse(
    const ::std::string& name, MatchTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MatchTypeEnum>(
    MatchTypeEnum_descriptor(), name, value);
}
enum MdBookTypeEnum {
  MD_BOOK_TYPE_ORDER_DEPTH = 0,
  MD_BOOK_TYPE_PRICE_DEPTH = 1,
  MD_BOOK_TYPE_TOP_OF_BOOK = 2
};
bool MdBookTypeEnum_IsValid(int value);
const MdBookTypeEnum MdBookTypeEnum_MIN = MD_BOOK_TYPE_ORDER_DEPTH;
const MdBookTypeEnum MdBookTypeEnum_MAX = MD_BOOK_TYPE_TOP_OF_BOOK;
const int MdBookTypeEnum_ARRAYSIZE = MdBookTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MdBookTypeEnum_descriptor();
inline const ::std::string& MdBookTypeEnum_Name(MdBookTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MdBookTypeEnum_descriptor(), value);
}
inline bool MdBookTypeEnum_Parse(
    const ::std::string& name, MdBookTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MdBookTypeEnum>(
    MdBookTypeEnum_descriptor(), name, value);
}
enum MaturityMonthYearFormatEnum {
  MATURITY_MONTH_YEAR_FORMAT_YEAR_MONTH_DAY = 0,
  MATURITY_MONTH_YEAR_FORMAT_YEAR_MONTH_ONLY = 1,
  MATURITY_MONTH_YEAR_FORMAT_YEAR_MONTH_WEEK = 2
};
bool MaturityMonthYearFormatEnum_IsValid(int value);
const MaturityMonthYearFormatEnum MaturityMonthYearFormatEnum_MIN = MATURITY_MONTH_YEAR_FORMAT_YEAR_MONTH_DAY;
const MaturityMonthYearFormatEnum MaturityMonthYearFormatEnum_MAX = MATURITY_MONTH_YEAR_FORMAT_YEAR_MONTH_WEEK;
const int MaturityMonthYearFormatEnum_ARRAYSIZE = MaturityMonthYearFormatEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MaturityMonthYearFormatEnum_descriptor();
inline const ::std::string& MaturityMonthYearFormatEnum_Name(MaturityMonthYearFormatEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MaturityMonthYearFormatEnum_descriptor(), value);
}
inline bool MaturityMonthYearFormatEnum_Parse(
    const ::std::string& name, MaturityMonthYearFormatEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MaturityMonthYearFormatEnum>(
    MaturityMonthYearFormatEnum_descriptor(), name, value);
}
enum MaturityMonthYearIncrementUnitsEnum {
  MATURITY_MONTH_YEAR_INCREMENT_UNITS_DAYS = 0,
  MATURITY_MONTH_YEAR_INCREMENT_UNITS_MONTHS = 1,
  MATURITY_MONTH_YEAR_INCREMENT_UNITS_WEEKS = 2,
  MATURITY_MONTH_YEAR_INCREMENT_UNITS_YEARS = 3
};
bool MaturityMonthYearIncrementUnitsEnum_IsValid(int value);
const MaturityMonthYearIncrementUnitsEnum MaturityMonthYearIncrementUnitsEnum_MIN = MATURITY_MONTH_YEAR_INCREMENT_UNITS_DAYS;
const MaturityMonthYearIncrementUnitsEnum MaturityMonthYearIncrementUnitsEnum_MAX = MATURITY_MONTH_YEAR_INCREMENT_UNITS_YEARS;
const int MaturityMonthYearIncrementUnitsEnum_ARRAYSIZE = MaturityMonthYearIncrementUnitsEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* MaturityMonthYearIncrementUnitsEnum_descriptor();
inline const ::std::string& MaturityMonthYearIncrementUnitsEnum_Name(MaturityMonthYearIncrementUnitsEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    MaturityMonthYearIncrementUnitsEnum_descriptor(), value);
}
inline bool MaturityMonthYearIncrementUnitsEnum_Parse(
    const ::std::string& name, MaturityMonthYearIncrementUnitsEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MaturityMonthYearIncrementUnitsEnum>(
    MaturityMonthYearIncrementUnitsEnum_descriptor(), name, value);
}
// ===================================================================

class PartySubIdTypeUnion : public ::google::protobuf::Message {
 public:
  PartySubIdTypeUnion();
  virtual ~PartySubIdTypeUnion();

  PartySubIdTypeUnion(const PartySubIdTypeUnion& from);

  inline PartySubIdTypeUnion& operator=(const PartySubIdTypeUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartySubIdTypeUnion& default_instance();

  void Swap(PartySubIdTypeUnion* other);

  // implements Message ----------------------------------------------

  PartySubIdTypeUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PartySubIdTypeUnion& from);
  void MergeFrom(const PartySubIdTypeUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.PartySubIdTypeEnum party_sub_id_type = 1;
  inline bool has_party_sub_id_type() const;
  inline void clear_party_sub_id_type();
  static const int kPartySubIdTypeFieldNumber = 1;
  inline ::Common::PartySubIdTypeEnum party_sub_id_type() const;
  inline void set_party_sub_id_type(::Common::PartySubIdTypeEnum value);

  // optional sfixed64 party_sub_id_type_sfixed64 = 2;
  inline bool has_party_sub_id_type_sfixed64() const;
  inline void clear_party_sub_id_type_sfixed64();
  static const int kPartySubIdTypeSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 party_sub_id_type_sfixed64() const;
  inline void set_party_sub_id_type_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.PartySubIdTypeUnion)
 private:
  inline void set_has_party_sub_id_type();
  inline void clear_has_party_sub_id_type();
  inline void set_has_party_sub_id_type_sfixed64();
  inline void clear_has_party_sub_id_type_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 party_sub_id_type_sfixed64_;
  int party_sub_id_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static PartySubIdTypeUnion* default_instance_;
};
// -------------------------------------------------------------------

class PtysSubGrp : public ::google::protobuf::Message {
 public:
  PtysSubGrp();
  virtual ~PtysSubGrp();

  PtysSubGrp(const PtysSubGrp& from);

  inline PtysSubGrp& operator=(const PtysSubGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PtysSubGrp& default_instance();

  void Swap(PtysSubGrp* other);

  // implements Message ----------------------------------------------

  PtysSubGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PtysSubGrp& from);
  void MergeFrom(const PtysSubGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string party_sub_id = 1;
  inline bool has_party_sub_id() const;
  inline void clear_party_sub_id();
  static const int kPartySubIdFieldNumber = 1;
  inline const ::std::string& party_sub_id() const;
  inline void set_party_sub_id(const ::std::string& value);
  inline void set_party_sub_id(const char* value);
  inline void set_party_sub_id(const char* value, size_t size);
  inline ::std::string* mutable_party_sub_id();
  inline ::std::string* release_party_sub_id();
  inline void set_allocated_party_sub_id(::std::string* party_sub_id);

  // optional .Common.PartySubIdTypeEnum party_sub_id_type = 2;
  inline bool has_party_sub_id_type() const;
  inline void clear_party_sub_id_type();
  static const int kPartySubIdTypeFieldNumber = 2;
  inline ::Common::PartySubIdTypeEnum party_sub_id_type() const;
  inline void set_party_sub_id_type(::Common::PartySubIdTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.PtysSubGrp)
 private:
  inline void set_has_party_sub_id();
  inline void clear_has_party_sub_id();
  inline void set_has_party_sub_id_type();
  inline void clear_has_party_sub_id_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* party_sub_id_;
  int party_sub_id_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static PtysSubGrp* default_instance_;
};
// -------------------------------------------------------------------

class Parties : public ::google::protobuf::Message {
 public:
  Parties();
  virtual ~Parties();

  Parties(const Parties& from);

  inline Parties& operator=(const Parties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Parties& default_instance();

  void Swap(Parties* other);

  // implements Message ----------------------------------------------

  Parties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Parties& from);
  void MergeFrom(const Parties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string party_id = 1;
  inline bool has_party_id() const;
  inline void clear_party_id();
  static const int kPartyIdFieldNumber = 1;
  inline const ::std::string& party_id() const;
  inline void set_party_id(const ::std::string& value);
  inline void set_party_id(const char* value);
  inline void set_party_id(const char* value, size_t size);
  inline ::std::string* mutable_party_id();
  inline ::std::string* release_party_id();
  inline void set_allocated_party_id(::std::string* party_id);

  // optional .Common.PartyIdSourceEnum party_id_source = 2;
  inline bool has_party_id_source() const;
  inline void clear_party_id_source();
  static const int kPartyIdSourceFieldNumber = 2;
  inline ::Common::PartyIdSourceEnum party_id_source() const;
  inline void set_party_id_source(::Common::PartyIdSourceEnum value);

  // optional .Common.PartyRoleEnum party_role = 3;
  inline bool has_party_role() const;
  inline void clear_party_role();
  static const int kPartyRoleFieldNumber = 3;
  inline ::Common::PartyRoleEnum party_role() const;
  inline void set_party_role(::Common::PartyRoleEnum value);

  // repeated .Common.PtysSubGrp ptys_sub_grp = 4;
  inline int ptys_sub_grp_size() const;
  inline void clear_ptys_sub_grp();
  static const int kPtysSubGrpFieldNumber = 4;
  inline const ::Common::PtysSubGrp& ptys_sub_grp(int index) const;
  inline ::Common::PtysSubGrp* mutable_ptys_sub_grp(int index);
  inline ::Common::PtysSubGrp* add_ptys_sub_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::PtysSubGrp >&
      ptys_sub_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::PtysSubGrp >*
      mutable_ptys_sub_grp();

  // @@protoc_insertion_point(class_scope:Common.Parties)
 private:
  inline void set_has_party_id();
  inline void clear_has_party_id();
  inline void set_has_party_id_source();
  inline void clear_has_party_id_source();
  inline void set_has_party_role();
  inline void clear_has_party_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* party_id_;
  int party_id_source_;
  int party_role_;
  ::google::protobuf::RepeatedPtrField< ::Common::PtysSubGrp > ptys_sub_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Parties* default_instance_;
};
// -------------------------------------------------------------------

class NstdPtysSubGrp : public ::google::protobuf::Message {
 public:
  NstdPtysSubGrp();
  virtual ~NstdPtysSubGrp();

  NstdPtysSubGrp(const NstdPtysSubGrp& from);

  inline NstdPtysSubGrp& operator=(const NstdPtysSubGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NstdPtysSubGrp& default_instance();

  void Swap(NstdPtysSubGrp* other);

  // implements Message ----------------------------------------------

  NstdPtysSubGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NstdPtysSubGrp& from);
  void MergeFrom(const NstdPtysSubGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nested_party_sub_id = 1;
  inline bool has_nested_party_sub_id() const;
  inline void clear_nested_party_sub_id();
  static const int kNestedPartySubIdFieldNumber = 1;
  inline const ::std::string& nested_party_sub_id() const;
  inline void set_nested_party_sub_id(const ::std::string& value);
  inline void set_nested_party_sub_id(const char* value);
  inline void set_nested_party_sub_id(const char* value, size_t size);
  inline ::std::string* mutable_nested_party_sub_id();
  inline ::std::string* release_nested_party_sub_id();
  inline void set_allocated_nested_party_sub_id(::std::string* nested_party_sub_id);

  // optional sfixed64 nested_party_sub_id_type = 2;
  inline bool has_nested_party_sub_id_type() const;
  inline void clear_nested_party_sub_id_type();
  static const int kNestedPartySubIdTypeFieldNumber = 2;
  inline ::google::protobuf::int64 nested_party_sub_id_type() const;
  inline void set_nested_party_sub_id_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.NstdPtysSubGrp)
 private:
  inline void set_has_nested_party_sub_id();
  inline void clear_has_nested_party_sub_id();
  inline void set_has_nested_party_sub_id_type();
  inline void clear_has_nested_party_sub_id_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nested_party_sub_id_;
  ::google::protobuf::int64 nested_party_sub_id_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NstdPtysSubGrp* default_instance_;
};
// -------------------------------------------------------------------

class NestedParties : public ::google::protobuf::Message {
 public:
  NestedParties();
  virtual ~NestedParties();

  NestedParties(const NestedParties& from);

  inline NestedParties& operator=(const NestedParties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NestedParties& default_instance();

  void Swap(NestedParties* other);

  // implements Message ----------------------------------------------

  NestedParties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NestedParties& from);
  void MergeFrom(const NestedParties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nested_party_id = 1;
  inline bool has_nested_party_id() const;
  inline void clear_nested_party_id();
  static const int kNestedPartyIdFieldNumber = 1;
  inline const ::std::string& nested_party_id() const;
  inline void set_nested_party_id(const ::std::string& value);
  inline void set_nested_party_id(const char* value);
  inline void set_nested_party_id(const char* value, size_t size);
  inline ::std::string* mutable_nested_party_id();
  inline ::std::string* release_nested_party_id();
  inline void set_allocated_nested_party_id(::std::string* nested_party_id);

  // optional string nested_party_id_source = 2;
  inline bool has_nested_party_id_source() const;
  inline void clear_nested_party_id_source();
  static const int kNestedPartyIdSourceFieldNumber = 2;
  inline const ::std::string& nested_party_id_source() const;
  inline void set_nested_party_id_source(const ::std::string& value);
  inline void set_nested_party_id_source(const char* value);
  inline void set_nested_party_id_source(const char* value, size_t size);
  inline ::std::string* mutable_nested_party_id_source();
  inline ::std::string* release_nested_party_id_source();
  inline void set_allocated_nested_party_id_source(::std::string* nested_party_id_source);

  // optional sfixed64 nested_party_role = 3;
  inline bool has_nested_party_role() const;
  inline void clear_nested_party_role();
  static const int kNestedPartyRoleFieldNumber = 3;
  inline ::google::protobuf::int64 nested_party_role() const;
  inline void set_nested_party_role(::google::protobuf::int64 value);

  // repeated .Common.NstdPtysSubGrp nstd_ptys_sub_grp = 4;
  inline int nstd_ptys_sub_grp_size() const;
  inline void clear_nstd_ptys_sub_grp();
  static const int kNstdPtysSubGrpFieldNumber = 4;
  inline const ::Common::NstdPtysSubGrp& nstd_ptys_sub_grp(int index) const;
  inline ::Common::NstdPtysSubGrp* mutable_nstd_ptys_sub_grp(int index);
  inline ::Common::NstdPtysSubGrp* add_nstd_ptys_sub_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NstdPtysSubGrp >&
      nstd_ptys_sub_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NstdPtysSubGrp >*
      mutable_nstd_ptys_sub_grp();

  // @@protoc_insertion_point(class_scope:Common.NestedParties)
 private:
  inline void set_has_nested_party_id();
  inline void clear_has_nested_party_id();
  inline void set_has_nested_party_id_source();
  inline void clear_has_nested_party_id_source();
  inline void set_has_nested_party_role();
  inline void clear_has_nested_party_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nested_party_id_;
  ::std::string* nested_party_id_source_;
  ::google::protobuf::int64 nested_party_role_;
  ::google::protobuf::RepeatedPtrField< ::Common::NstdPtysSubGrp > nstd_ptys_sub_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NestedParties* default_instance_;
};
// -------------------------------------------------------------------

class PreAllocGrp : public ::google::protobuf::Message {
 public:
  PreAllocGrp();
  virtual ~PreAllocGrp();

  PreAllocGrp(const PreAllocGrp& from);

  inline PreAllocGrp& operator=(const PreAllocGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PreAllocGrp& default_instance();

  void Swap(PreAllocGrp* other);

  // implements Message ----------------------------------------------

  PreAllocGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PreAllocGrp& from);
  void MergeFrom(const PreAllocGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string alloc_account = 1;
  inline bool has_alloc_account() const;
  inline void clear_alloc_account();
  static const int kAllocAccountFieldNumber = 1;
  inline const ::std::string& alloc_account() const;
  inline void set_alloc_account(const ::std::string& value);
  inline void set_alloc_account(const char* value);
  inline void set_alloc_account(const char* value, size_t size);
  inline ::std::string* mutable_alloc_account();
  inline ::std::string* release_alloc_account();
  inline void set_allocated_alloc_account(::std::string* alloc_account);

  // optional sfixed64 alloc_acct_id_source = 2;
  inline bool has_alloc_acct_id_source() const;
  inline void clear_alloc_acct_id_source();
  static const int kAllocAcctIdSourceFieldNumber = 2;
  inline ::google::protobuf::int64 alloc_acct_id_source() const;
  inline void set_alloc_acct_id_source(::google::protobuf::int64 value);

  // optional sfixed64 alloc_qty = 3;
  inline bool has_alloc_qty() const;
  inline void clear_alloc_qty();
  static const int kAllocQtyFieldNumber = 3;
  inline ::google::protobuf::int64 alloc_qty() const;
  inline void set_alloc_qty(::google::protobuf::int64 value);

  // optional sfixed32 alloc_qty_exponent = 4;
  inline bool has_alloc_qty_exponent() const;
  inline void clear_alloc_qty_exponent();
  static const int kAllocQtyExponentFieldNumber = 4;
  inline ::google::protobuf::int32 alloc_qty_exponent() const;
  inline void set_alloc_qty_exponent(::google::protobuf::int32 value);

  // optional string alloc_settl_currency = 5;
  inline bool has_alloc_settl_currency() const;
  inline void clear_alloc_settl_currency();
  static const int kAllocSettlCurrencyFieldNumber = 5;
  inline const ::std::string& alloc_settl_currency() const;
  inline void set_alloc_settl_currency(const ::std::string& value);
  inline void set_alloc_settl_currency(const char* value);
  inline void set_alloc_settl_currency(const char* value, size_t size);
  inline ::std::string* mutable_alloc_settl_currency();
  inline ::std::string* release_alloc_settl_currency();
  inline void set_allocated_alloc_settl_currency(::std::string* alloc_settl_currency);

  // optional string individual_alloc_id = 6;
  inline bool has_individual_alloc_id() const;
  inline void clear_individual_alloc_id();
  static const int kIndividualAllocIdFieldNumber = 6;
  inline const ::std::string& individual_alloc_id() const;
  inline void set_individual_alloc_id(const ::std::string& value);
  inline void set_individual_alloc_id(const char* value);
  inline void set_individual_alloc_id(const char* value, size_t size);
  inline ::std::string* mutable_individual_alloc_id();
  inline ::std::string* release_individual_alloc_id();
  inline void set_allocated_individual_alloc_id(::std::string* individual_alloc_id);

  // repeated .Common.NestedParties nested_parties = 7;
  inline int nested_parties_size() const;
  inline void clear_nested_parties();
  static const int kNestedPartiesFieldNumber = 7;
  inline const ::Common::NestedParties& nested_parties(int index) const;
  inline ::Common::NestedParties* mutable_nested_parties(int index);
  inline ::Common::NestedParties* add_nested_parties();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedParties >&
      nested_parties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NestedParties >*
      mutable_nested_parties();

  // @@protoc_insertion_point(class_scope:Common.PreAllocGrp)
 private:
  inline void set_has_alloc_account();
  inline void clear_has_alloc_account();
  inline void set_has_alloc_acct_id_source();
  inline void clear_has_alloc_acct_id_source();
  inline void set_has_alloc_qty();
  inline void clear_has_alloc_qty();
  inline void set_has_alloc_qty_exponent();
  inline void clear_has_alloc_qty_exponent();
  inline void set_has_alloc_settl_currency();
  inline void clear_has_alloc_settl_currency();
  inline void set_has_individual_alloc_id();
  inline void clear_has_individual_alloc_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* alloc_account_;
  ::google::protobuf::int64 alloc_acct_id_source_;
  ::google::protobuf::int64 alloc_qty_;
  ::std::string* alloc_settl_currency_;
  ::std::string* individual_alloc_id_;
  ::google::protobuf::RepeatedPtrField< ::Common::NestedParties > nested_parties_;
  ::google::protobuf::int32 alloc_qty_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static PreAllocGrp* default_instance_;
};
// -------------------------------------------------------------------

class DisplayInstruction : public ::google::protobuf::Message {
 public:
  DisplayInstruction();
  virtual ~DisplayInstruction();

  DisplayInstruction(const DisplayInstruction& from);

  inline DisplayInstruction& operator=(const DisplayInstruction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisplayInstruction& default_instance();

  void Swap(DisplayInstruction* other);

  // implements Message ----------------------------------------------

  DisplayInstruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisplayInstruction& from);
  void MergeFrom(const DisplayInstruction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 display_high_qty = 1;
  inline bool has_display_high_qty() const;
  inline void clear_display_high_qty();
  static const int kDisplayHighQtyFieldNumber = 1;
  inline ::google::protobuf::int64 display_high_qty() const;
  inline void set_display_high_qty(::google::protobuf::int64 value);

  // optional sfixed32 display_high_qty_exponent = 2;
  inline bool has_display_high_qty_exponent() const;
  inline void clear_display_high_qty_exponent();
  static const int kDisplayHighQtyExponentFieldNumber = 2;
  inline ::google::protobuf::int32 display_high_qty_exponent() const;
  inline void set_display_high_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 display_low_qty = 3;
  inline bool has_display_low_qty() const;
  inline void clear_display_low_qty();
  static const int kDisplayLowQtyFieldNumber = 3;
  inline ::google::protobuf::int64 display_low_qty() const;
  inline void set_display_low_qty(::google::protobuf::int64 value);

  // optional sfixed32 display_low_qty_exponent = 4;
  inline bool has_display_low_qty_exponent() const;
  inline void clear_display_low_qty_exponent();
  static const int kDisplayLowQtyExponentFieldNumber = 4;
  inline ::google::protobuf::int32 display_low_qty_exponent() const;
  inline void set_display_low_qty_exponent(::google::protobuf::int32 value);

  // optional .Common.DisplayMethodEnum display_method = 5;
  inline bool has_display_method() const;
  inline void clear_display_method();
  static const int kDisplayMethodFieldNumber = 5;
  inline ::Common::DisplayMethodEnum display_method() const;
  inline void set_display_method(::Common::DisplayMethodEnum value);

  // optional sfixed64 display_min_incr = 6;
  inline bool has_display_min_incr() const;
  inline void clear_display_min_incr();
  static const int kDisplayMinIncrFieldNumber = 6;
  inline ::google::protobuf::int64 display_min_incr() const;
  inline void set_display_min_incr(::google::protobuf::int64 value);

  // optional sfixed32 display_min_incr_exponent = 7;
  inline bool has_display_min_incr_exponent() const;
  inline void clear_display_min_incr_exponent();
  static const int kDisplayMinIncrExponentFieldNumber = 7;
  inline ::google::protobuf::int32 display_min_incr_exponent() const;
  inline void set_display_min_incr_exponent(::google::protobuf::int32 value);

  // optional sfixed64 display_qty = 8;
  inline bool has_display_qty() const;
  inline void clear_display_qty();
  static const int kDisplayQtyFieldNumber = 8;
  inline ::google::protobuf::int64 display_qty() const;
  inline void set_display_qty(::google::protobuf::int64 value);

  // optional sfixed32 display_qty_exponent = 9;
  inline bool has_display_qty_exponent() const;
  inline void clear_display_qty_exponent();
  static const int kDisplayQtyExponentFieldNumber = 9;
  inline ::google::protobuf::int32 display_qty_exponent() const;
  inline void set_display_qty_exponent(::google::protobuf::int32 value);

  // optional .Common.DisplayWhenEnum display_when = 10;
  inline bool has_display_when() const;
  inline void clear_display_when();
  static const int kDisplayWhenFieldNumber = 10;
  inline ::Common::DisplayWhenEnum display_when() const;
  inline void set_display_when(::Common::DisplayWhenEnum value);

  // optional sfixed64 refresh_qty = 11;
  inline bool has_refresh_qty() const;
  inline void clear_refresh_qty();
  static const int kRefreshQtyFieldNumber = 11;
  inline ::google::protobuf::int64 refresh_qty() const;
  inline void set_refresh_qty(::google::protobuf::int64 value);

  // optional sfixed32 refresh_qty_exponent = 12;
  inline bool has_refresh_qty_exponent() const;
  inline void clear_refresh_qty_exponent();
  static const int kRefreshQtyExponentFieldNumber = 12;
  inline ::google::protobuf::int32 refresh_qty_exponent() const;
  inline void set_refresh_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 secondary_display_qty = 13;
  inline bool has_secondary_display_qty() const;
  inline void clear_secondary_display_qty();
  static const int kSecondaryDisplayQtyFieldNumber = 13;
  inline ::google::protobuf::int64 secondary_display_qty() const;
  inline void set_secondary_display_qty(::google::protobuf::int64 value);

  // optional sfixed32 secondary_display_qty_exponent = 14;
  inline bool has_secondary_display_qty_exponent() const;
  inline void clear_secondary_display_qty_exponent();
  static const int kSecondaryDisplayQtyExponentFieldNumber = 14;
  inline ::google::protobuf::int32 secondary_display_qty_exponent() const;
  inline void set_secondary_display_qty_exponent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Common.DisplayInstruction)
 private:
  inline void set_has_display_high_qty();
  inline void clear_has_display_high_qty();
  inline void set_has_display_high_qty_exponent();
  inline void clear_has_display_high_qty_exponent();
  inline void set_has_display_low_qty();
  inline void clear_has_display_low_qty();
  inline void set_has_display_low_qty_exponent();
  inline void clear_has_display_low_qty_exponent();
  inline void set_has_display_method();
  inline void clear_has_display_method();
  inline void set_has_display_min_incr();
  inline void clear_has_display_min_incr();
  inline void set_has_display_min_incr_exponent();
  inline void clear_has_display_min_incr_exponent();
  inline void set_has_display_qty();
  inline void clear_has_display_qty();
  inline void set_has_display_qty_exponent();
  inline void clear_has_display_qty_exponent();
  inline void set_has_display_when();
  inline void clear_has_display_when();
  inline void set_has_refresh_qty();
  inline void clear_has_refresh_qty();
  inline void set_has_refresh_qty_exponent();
  inline void clear_has_refresh_qty_exponent();
  inline void set_has_secondary_display_qty();
  inline void clear_has_secondary_display_qty();
  inline void set_has_secondary_display_qty_exponent();
  inline void clear_has_secondary_display_qty_exponent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 display_high_qty_;
  ::google::protobuf::int64 display_low_qty_;
  ::google::protobuf::int32 display_high_qty_exponent_;
  ::google::protobuf::int32 display_low_qty_exponent_;
  ::google::protobuf::int64 display_min_incr_;
  int display_method_;
  ::google::protobuf::int32 display_min_incr_exponent_;
  ::google::protobuf::int64 display_qty_;
  ::google::protobuf::int32 display_qty_exponent_;
  int display_when_;
  ::google::protobuf::int64 refresh_qty_;
  ::google::protobuf::int64 secondary_display_qty_;
  ::google::protobuf::int32 refresh_qty_exponent_;
  ::google::protobuf::int32 secondary_display_qty_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DisplayInstruction* default_instance_;
};
// -------------------------------------------------------------------

class TradingSessionIdUnion : public ::google::protobuf::Message {
 public:
  TradingSessionIdUnion();
  virtual ~TradingSessionIdUnion();

  TradingSessionIdUnion(const TradingSessionIdUnion& from);

  inline TradingSessionIdUnion& operator=(const TradingSessionIdUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradingSessionIdUnion& default_instance();

  void Swap(TradingSessionIdUnion* other);

  // implements Message ----------------------------------------------

  TradingSessionIdUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradingSessionIdUnion& from);
  void MergeFrom(const TradingSessionIdUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.TradingSessionIdEnum trading_session_id = 1;
  inline bool has_trading_session_id() const;
  inline void clear_trading_session_id();
  static const int kTradingSessionIdFieldNumber = 1;
  inline ::Common::TradingSessionIdEnum trading_session_id() const;
  inline void set_trading_session_id(::Common::TradingSessionIdEnum value);

  // optional sfixed64 trading_session_id_sfixed64 = 2;
  inline bool has_trading_session_id_sfixed64() const;
  inline void clear_trading_session_id_sfixed64();
  static const int kTradingSessionIdSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 trading_session_id_sfixed64() const;
  inline void set_trading_session_id_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.TradingSessionIdUnion)
 private:
  inline void set_has_trading_session_id();
  inline void clear_has_trading_session_id();
  inline void set_has_trading_session_id_sfixed64();
  inline void clear_has_trading_session_id_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 trading_session_id_sfixed64_;
  int trading_session_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TradingSessionIdUnion* default_instance_;
};
// -------------------------------------------------------------------

class TradingSessionSubIdUnion : public ::google::protobuf::Message {
 public:
  TradingSessionSubIdUnion();
  virtual ~TradingSessionSubIdUnion();

  TradingSessionSubIdUnion(const TradingSessionSubIdUnion& from);

  inline TradingSessionSubIdUnion& operator=(const TradingSessionSubIdUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradingSessionSubIdUnion& default_instance();

  void Swap(TradingSessionSubIdUnion* other);

  // implements Message ----------------------------------------------

  TradingSessionSubIdUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradingSessionSubIdUnion& from);
  void MergeFrom(const TradingSessionSubIdUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.TradingSessionSubIdEnum trading_session_sub_id = 1;
  inline bool has_trading_session_sub_id() const;
  inline void clear_trading_session_sub_id();
  static const int kTradingSessionSubIdFieldNumber = 1;
  inline ::Common::TradingSessionSubIdEnum trading_session_sub_id() const;
  inline void set_trading_session_sub_id(::Common::TradingSessionSubIdEnum value);

  // optional sfixed64 trading_session_sub_id_sfixed64 = 2;
  inline bool has_trading_session_sub_id_sfixed64() const;
  inline void clear_trading_session_sub_id_sfixed64();
  static const int kTradingSessionSubIdSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 trading_session_sub_id_sfixed64() const;
  inline void set_trading_session_sub_id_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.TradingSessionSubIdUnion)
 private:
  inline void set_has_trading_session_sub_id();
  inline void clear_has_trading_session_sub_id();
  inline void set_has_trading_session_sub_id_sfixed64();
  inline void clear_has_trading_session_sub_id_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 trading_session_sub_id_sfixed64_;
  int trading_session_sub_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TradingSessionSubIdUnion* default_instance_;
};
// -------------------------------------------------------------------

class TrdgSesGrp : public ::google::protobuf::Message {
 public:
  TrdgSesGrp();
  virtual ~TrdgSesGrp();

  TrdgSesGrp(const TrdgSesGrp& from);

  inline TrdgSesGrp& operator=(const TrdgSesGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrdgSesGrp& default_instance();

  void Swap(TrdgSesGrp* other);

  // implements Message ----------------------------------------------

  TrdgSesGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrdgSesGrp& from);
  void MergeFrom(const TrdgSesGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.TradingSessionIdEnum trading_session_id = 1;
  inline bool has_trading_session_id() const;
  inline void clear_trading_session_id();
  static const int kTradingSessionIdFieldNumber = 1;
  inline ::Common::TradingSessionIdEnum trading_session_id() const;
  inline void set_trading_session_id(::Common::TradingSessionIdEnum value);

  // optional .Common.TradingSessionSubIdEnum trading_session_sub_id = 2;
  inline bool has_trading_session_sub_id() const;
  inline void clear_trading_session_sub_id();
  static const int kTradingSessionSubIdFieldNumber = 2;
  inline ::Common::TradingSessionSubIdEnum trading_session_sub_id() const;
  inline void set_trading_session_sub_id(::Common::TradingSessionSubIdEnum value);

  // @@protoc_insertion_point(class_scope:Common.TrdgSesGrp)
 private:
  inline void set_has_trading_session_id();
  inline void clear_has_trading_session_id();
  inline void set_has_trading_session_sub_id();
  inline void clear_has_trading_session_sub_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int trading_session_id_;
  int trading_session_sub_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TrdgSesGrp* default_instance_;
};
// -------------------------------------------------------------------

class SecAltIdGrp : public ::google::protobuf::Message {
 public:
  SecAltIdGrp();
  virtual ~SecAltIdGrp();

  SecAltIdGrp(const SecAltIdGrp& from);

  inline SecAltIdGrp& operator=(const SecAltIdGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecAltIdGrp& default_instance();

  void Swap(SecAltIdGrp* other);

  // implements Message ----------------------------------------------

  SecAltIdGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecAltIdGrp& from);
  void MergeFrom(const SecAltIdGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string security_alt_id = 1;
  inline bool has_security_alt_id() const;
  inline void clear_security_alt_id();
  static const int kSecurityAltIdFieldNumber = 1;
  inline const ::std::string& security_alt_id() const;
  inline void set_security_alt_id(const ::std::string& value);
  inline void set_security_alt_id(const char* value);
  inline void set_security_alt_id(const char* value, size_t size);
  inline ::std::string* mutable_security_alt_id();
  inline ::std::string* release_security_alt_id();
  inline void set_allocated_security_alt_id(::std::string* security_alt_id);

  // optional string security_alt_id_source = 2;
  inline bool has_security_alt_id_source() const;
  inline void clear_security_alt_id_source();
  static const int kSecurityAltIdSourceFieldNumber = 2;
  inline const ::std::string& security_alt_id_source() const;
  inline void set_security_alt_id_source(const ::std::string& value);
  inline void set_security_alt_id_source(const char* value);
  inline void set_security_alt_id_source(const char* value, size_t size);
  inline ::std::string* mutable_security_alt_id_source();
  inline ::std::string* release_security_alt_id_source();
  inline void set_allocated_security_alt_id_source(::std::string* security_alt_id_source);

  // @@protoc_insertion_point(class_scope:Common.SecAltIdGrp)
 private:
  inline void set_has_security_alt_id();
  inline void clear_has_security_alt_id();
  inline void set_has_security_alt_id_source();
  inline void clear_has_security_alt_id_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* security_alt_id_;
  ::std::string* security_alt_id_source_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static SecAltIdGrp* default_instance_;
};
// -------------------------------------------------------------------

class SecurityXml : public ::google::protobuf::Message {
 public:
  SecurityXml();
  virtual ~SecurityXml();

  SecurityXml(const SecurityXml& from);

  inline SecurityXml& operator=(const SecurityXml& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityXml& default_instance();

  void Swap(SecurityXml* other);

  // implements Message ----------------------------------------------

  SecurityXml* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityXml& from);
  void MergeFrom(const SecurityXml& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string security_xml = 1;
  inline bool has_security_xml() const;
  inline void clear_security_xml();
  static const int kSecurityXmlFieldNumber = 1;
  inline const ::std::string& security_xml() const;
  inline void set_security_xml(const ::std::string& value);
  inline void set_security_xml(const char* value);
  inline void set_security_xml(const char* value, size_t size);
  inline ::std::string* mutable_security_xml();
  inline ::std::string* release_security_xml();
  inline void set_allocated_security_xml(::std::string* security_xml);

  // optional fixed32 security_xml_len = 2;
  inline bool has_security_xml_len() const;
  inline void clear_security_xml_len();
  static const int kSecurityXmlLenFieldNumber = 2;
  inline ::google::protobuf::uint32 security_xml_len() const;
  inline void set_security_xml_len(::google::protobuf::uint32 value);

  // optional string security_xml_schema = 3;
  inline bool has_security_xml_schema() const;
  inline void clear_security_xml_schema();
  static const int kSecurityXmlSchemaFieldNumber = 3;
  inline const ::std::string& security_xml_schema() const;
  inline void set_security_xml_schema(const ::std::string& value);
  inline void set_security_xml_schema(const char* value);
  inline void set_security_xml_schema(const char* value, size_t size);
  inline ::std::string* mutable_security_xml_schema();
  inline ::std::string* release_security_xml_schema();
  inline void set_allocated_security_xml_schema(::std::string* security_xml_schema);

  // @@protoc_insertion_point(class_scope:Common.SecurityXml)
 private:
  inline void set_has_security_xml();
  inline void clear_has_security_xml();
  inline void set_has_security_xml_len();
  inline void clear_has_security_xml_len();
  inline void set_has_security_xml_schema();
  inline void clear_has_security_xml_schema();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* security_xml_;
  ::std::string* security_xml_schema_;
  ::google::protobuf::uint32 security_xml_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static SecurityXml* default_instance_;
};
// -------------------------------------------------------------------

class EventTypeUnion : public ::google::protobuf::Message {
 public:
  EventTypeUnion();
  virtual ~EventTypeUnion();

  EventTypeUnion(const EventTypeUnion& from);

  inline EventTypeUnion& operator=(const EventTypeUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventTypeUnion& default_instance();

  void Swap(EventTypeUnion* other);

  // implements Message ----------------------------------------------

  EventTypeUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventTypeUnion& from);
  void MergeFrom(const EventTypeUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.EventTypeEnum event_type = 1;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 1;
  inline ::Common::EventTypeEnum event_type() const;
  inline void set_event_type(::Common::EventTypeEnum value);

  // optional sfixed64 event_type_sfixed64 = 2;
  inline bool has_event_type_sfixed64() const;
  inline void clear_event_type_sfixed64();
  static const int kEventTypeSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 event_type_sfixed64() const;
  inline void set_event_type_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.EventTypeUnion)
 private:
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_event_type_sfixed64();
  inline void clear_has_event_type_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 event_type_sfixed64_;
  int event_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static EventTypeUnion* default_instance_;
};
// -------------------------------------------------------------------

class EvntGrp : public ::google::protobuf::Message {
 public:
  EvntGrp();
  virtual ~EvntGrp();

  EvntGrp(const EvntGrp& from);

  inline EvntGrp& operator=(const EvntGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EvntGrp& default_instance();

  void Swap(EvntGrp* other);

  // implements Message ----------------------------------------------

  EvntGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EvntGrp& from);
  void MergeFrom(const EvntGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed32 event_date = 1;
  inline bool has_event_date() const;
  inline void clear_event_date();
  static const int kEventDateFieldNumber = 1;
  inline ::google::protobuf::int32 event_date() const;
  inline void set_event_date(::google::protobuf::int32 value);

  // optional sfixed64 event_px = 2;
  inline bool has_event_px() const;
  inline void clear_event_px();
  static const int kEventPxFieldNumber = 2;
  inline ::google::protobuf::int64 event_px() const;
  inline void set_event_px(::google::protobuf::int64 value);

  // optional sfixed32 event_px_exponent = 3;
  inline bool has_event_px_exponent() const;
  inline void clear_event_px_exponent();
  static const int kEventPxExponentFieldNumber = 3;
  inline ::google::protobuf::int32 event_px_exponent() const;
  inline void set_event_px_exponent(::google::protobuf::int32 value);

  // optional string event_text = 4;
  inline bool has_event_text() const;
  inline void clear_event_text();
  static const int kEventTextFieldNumber = 4;
  inline const ::std::string& event_text() const;
  inline void set_event_text(const ::std::string& value);
  inline void set_event_text(const char* value);
  inline void set_event_text(const char* value, size_t size);
  inline ::std::string* mutable_event_text();
  inline ::std::string* release_event_text();
  inline void set_allocated_event_text(::std::string* event_text);

  // optional .Common.EventTypeEnum event_type = 5;
  inline bool has_event_type() const;
  inline void clear_event_type();
  static const int kEventTypeFieldNumber = 5;
  inline ::Common::EventTypeEnum event_type() const;
  inline void set_event_type(::Common::EventTypeEnum value);

  // optional sfixed64 event_time = 6;
  inline bool has_event_time() const;
  inline void clear_event_time();
  static const int kEventTimeFieldNumber = 6;
  inline ::google::protobuf::int64 event_time() const;
  inline void set_event_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.EvntGrp)
 private:
  inline void set_has_event_date();
  inline void clear_has_event_date();
  inline void set_has_event_px();
  inline void clear_has_event_px();
  inline void set_has_event_px_exponent();
  inline void clear_has_event_px_exponent();
  inline void set_has_event_text();
  inline void clear_has_event_text();
  inline void set_has_event_type();
  inline void clear_has_event_type();
  inline void set_has_event_time();
  inline void clear_has_event_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 event_px_;
  ::google::protobuf::int32 event_date_;
  ::google::protobuf::int32 event_px_exponent_;
  ::std::string* event_text_;
  ::google::protobuf::int64 event_time_;
  int event_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static EvntGrp* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentPtysSubGrp : public ::google::protobuf::Message {
 public:
  InstrumentPtysSubGrp();
  virtual ~InstrumentPtysSubGrp();

  InstrumentPtysSubGrp(const InstrumentPtysSubGrp& from);

  inline InstrumentPtysSubGrp& operator=(const InstrumentPtysSubGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrumentPtysSubGrp& default_instance();

  void Swap(InstrumentPtysSubGrp* other);

  // implements Message ----------------------------------------------

  InstrumentPtysSubGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrumentPtysSubGrp& from);
  void MergeFrom(const InstrumentPtysSubGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string instrument_party_sub_id = 1;
  inline bool has_instrument_party_sub_id() const;
  inline void clear_instrument_party_sub_id();
  static const int kInstrumentPartySubIdFieldNumber = 1;
  inline const ::std::string& instrument_party_sub_id() const;
  inline void set_instrument_party_sub_id(const ::std::string& value);
  inline void set_instrument_party_sub_id(const char* value);
  inline void set_instrument_party_sub_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_party_sub_id();
  inline ::std::string* release_instrument_party_sub_id();
  inline void set_allocated_instrument_party_sub_id(::std::string* instrument_party_sub_id);

  // optional sfixed64 instrument_party_sub_id_type = 2;
  inline bool has_instrument_party_sub_id_type() const;
  inline void clear_instrument_party_sub_id_type();
  static const int kInstrumentPartySubIdTypeFieldNumber = 2;
  inline ::google::protobuf::int64 instrument_party_sub_id_type() const;
  inline void set_instrument_party_sub_id_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.InstrumentPtysSubGrp)
 private:
  inline void set_has_instrument_party_sub_id();
  inline void clear_has_instrument_party_sub_id();
  inline void set_has_instrument_party_sub_id_type();
  inline void clear_has_instrument_party_sub_id_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* instrument_party_sub_id_;
  ::google::protobuf::int64 instrument_party_sub_id_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static InstrumentPtysSubGrp* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentParties : public ::google::protobuf::Message {
 public:
  InstrumentParties();
  virtual ~InstrumentParties();

  InstrumentParties(const InstrumentParties& from);

  inline InstrumentParties& operator=(const InstrumentParties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrumentParties& default_instance();

  void Swap(InstrumentParties* other);

  // implements Message ----------------------------------------------

  InstrumentParties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrumentParties& from);
  void MergeFrom(const InstrumentParties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string instrument_party_id = 1;
  inline bool has_instrument_party_id() const;
  inline void clear_instrument_party_id();
  static const int kInstrumentPartyIdFieldNumber = 1;
  inline const ::std::string& instrument_party_id() const;
  inline void set_instrument_party_id(const ::std::string& value);
  inline void set_instrument_party_id(const char* value);
  inline void set_instrument_party_id(const char* value, size_t size);
  inline ::std::string* mutable_instrument_party_id();
  inline ::std::string* release_instrument_party_id();
  inline void set_allocated_instrument_party_id(::std::string* instrument_party_id);

  // optional string instrument_party_id_source = 2;
  inline bool has_instrument_party_id_source() const;
  inline void clear_instrument_party_id_source();
  static const int kInstrumentPartyIdSourceFieldNumber = 2;
  inline const ::std::string& instrument_party_id_source() const;
  inline void set_instrument_party_id_source(const ::std::string& value);
  inline void set_instrument_party_id_source(const char* value);
  inline void set_instrument_party_id_source(const char* value, size_t size);
  inline ::std::string* mutable_instrument_party_id_source();
  inline ::std::string* release_instrument_party_id_source();
  inline void set_allocated_instrument_party_id_source(::std::string* instrument_party_id_source);

  // optional sfixed64 instrument_party_role = 3;
  inline bool has_instrument_party_role() const;
  inline void clear_instrument_party_role();
  static const int kInstrumentPartyRoleFieldNumber = 3;
  inline ::google::protobuf::int64 instrument_party_role() const;
  inline void set_instrument_party_role(::google::protobuf::int64 value);

  // repeated .Common.InstrumentPtysSubGrp instrument_ptys_sub_grp = 4;
  inline int instrument_ptys_sub_grp_size() const;
  inline void clear_instrument_ptys_sub_grp();
  static const int kInstrumentPtysSubGrpFieldNumber = 4;
  inline const ::Common::InstrumentPtysSubGrp& instrument_ptys_sub_grp(int index) const;
  inline ::Common::InstrumentPtysSubGrp* mutable_instrument_ptys_sub_grp(int index);
  inline ::Common::InstrumentPtysSubGrp* add_instrument_ptys_sub_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrumentPtysSubGrp >&
      instrument_ptys_sub_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrumentPtysSubGrp >*
      mutable_instrument_ptys_sub_grp();

  // @@protoc_insertion_point(class_scope:Common.InstrumentParties)
 private:
  inline void set_has_instrument_party_id();
  inline void clear_has_instrument_party_id();
  inline void set_has_instrument_party_id_source();
  inline void clear_has_instrument_party_id_source();
  inline void set_has_instrument_party_role();
  inline void clear_has_instrument_party_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* instrument_party_id_;
  ::std::string* instrument_party_id_source_;
  ::google::protobuf::int64 instrument_party_role_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrumentPtysSubGrp > instrument_ptys_sub_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static InstrumentParties* default_instance_;
};
// -------------------------------------------------------------------

class ComplexEventTimes : public ::google::protobuf::Message {
 public:
  ComplexEventTimes();
  virtual ~ComplexEventTimes();

  ComplexEventTimes(const ComplexEventTimes& from);

  inline ComplexEventTimes& operator=(const ComplexEventTimes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComplexEventTimes& default_instance();

  void Swap(ComplexEventTimes* other);

  // implements Message ----------------------------------------------

  ComplexEventTimes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComplexEventTimes& from);
  void MergeFrom(const ComplexEventTimes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 complex_event_end_time = 1;
  inline bool has_complex_event_end_time() const;
  inline void clear_complex_event_end_time();
  static const int kComplexEventEndTimeFieldNumber = 1;
  inline ::google::protobuf::int64 complex_event_end_time() const;
  inline void set_complex_event_end_time(::google::protobuf::int64 value);

  // optional sfixed64 complex_event_start_time = 2;
  inline bool has_complex_event_start_time() const;
  inline void clear_complex_event_start_time();
  static const int kComplexEventStartTimeFieldNumber = 2;
  inline ::google::protobuf::int64 complex_event_start_time() const;
  inline void set_complex_event_start_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.ComplexEventTimes)
 private:
  inline void set_has_complex_event_end_time();
  inline void clear_has_complex_event_end_time();
  inline void set_has_complex_event_start_time();
  inline void clear_has_complex_event_start_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 complex_event_end_time_;
  ::google::protobuf::int64 complex_event_start_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ComplexEventTimes* default_instance_;
};
// -------------------------------------------------------------------

class ComplexEventDates : public ::google::protobuf::Message {
 public:
  ComplexEventDates();
  virtual ~ComplexEventDates();

  ComplexEventDates(const ComplexEventDates& from);

  inline ComplexEventDates& operator=(const ComplexEventDates& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComplexEventDates& default_instance();

  void Swap(ComplexEventDates* other);

  // implements Message ----------------------------------------------

  ComplexEventDates* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComplexEventDates& from);
  void MergeFrom(const ComplexEventDates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 complex_event_end_date = 1;
  inline bool has_complex_event_end_date() const;
  inline void clear_complex_event_end_date();
  static const int kComplexEventEndDateFieldNumber = 1;
  inline ::google::protobuf::int64 complex_event_end_date() const;
  inline void set_complex_event_end_date(::google::protobuf::int64 value);

  // optional sfixed64 complex_event_start_date = 2;
  inline bool has_complex_event_start_date() const;
  inline void clear_complex_event_start_date();
  static const int kComplexEventStartDateFieldNumber = 2;
  inline ::google::protobuf::int64 complex_event_start_date() const;
  inline void set_complex_event_start_date(::google::protobuf::int64 value);

  // repeated .Common.ComplexEventTimes complex_event_times = 3;
  inline int complex_event_times_size() const;
  inline void clear_complex_event_times();
  static const int kComplexEventTimesFieldNumber = 3;
  inline const ::Common::ComplexEventTimes& complex_event_times(int index) const;
  inline ::Common::ComplexEventTimes* mutable_complex_event_times(int index);
  inline ::Common::ComplexEventTimes* add_complex_event_times();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventTimes >&
      complex_event_times() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventTimes >*
      mutable_complex_event_times();

  // @@protoc_insertion_point(class_scope:Common.ComplexEventDates)
 private:
  inline void set_has_complex_event_end_date();
  inline void clear_has_complex_event_end_date();
  inline void set_has_complex_event_start_date();
  inline void clear_has_complex_event_start_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 complex_event_end_date_;
  ::google::protobuf::int64 complex_event_start_date_;
  ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventTimes > complex_event_times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ComplexEventDates* default_instance_;
};
// -------------------------------------------------------------------

class ComplexEvents : public ::google::protobuf::Message {
 public:
  ComplexEvents();
  virtual ~ComplexEvents();

  ComplexEvents(const ComplexEvents& from);

  inline ComplexEvents& operator=(const ComplexEvents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ComplexEvents& default_instance();

  void Swap(ComplexEvents* other);

  // implements Message ----------------------------------------------

  ComplexEvents* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ComplexEvents& from);
  void MergeFrom(const ComplexEvents& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.ComplexEventConditionEnum complex_event_condition = 1;
  inline bool has_complex_event_condition() const;
  inline void clear_complex_event_condition();
  static const int kComplexEventConditionFieldNumber = 1;
  inline ::Common::ComplexEventConditionEnum complex_event_condition() const;
  inline void set_complex_event_condition(::Common::ComplexEventConditionEnum value);

  // repeated .Common.ComplexEventDates complex_event_dates = 2;
  inline int complex_event_dates_size() const;
  inline void clear_complex_event_dates();
  static const int kComplexEventDatesFieldNumber = 2;
  inline const ::Common::ComplexEventDates& complex_event_dates(int index) const;
  inline ::Common::ComplexEventDates* mutable_complex_event_dates(int index);
  inline ::Common::ComplexEventDates* add_complex_event_dates();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventDates >&
      complex_event_dates() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventDates >*
      mutable_complex_event_dates();

  // optional sfixed64 complex_event_price = 3;
  inline bool has_complex_event_price() const;
  inline void clear_complex_event_price();
  static const int kComplexEventPriceFieldNumber = 3;
  inline ::google::protobuf::int64 complex_event_price() const;
  inline void set_complex_event_price(::google::protobuf::int64 value);

  // optional sfixed32 complex_event_price_exponent = 4;
  inline bool has_complex_event_price_exponent() const;
  inline void clear_complex_event_price_exponent();
  static const int kComplexEventPriceExponentFieldNumber = 4;
  inline ::google::protobuf::int32 complex_event_price_exponent() const;
  inline void set_complex_event_price_exponent(::google::protobuf::int32 value);

  // optional .Common.ComplexEventPriceBoundaryMethodEnum complex_event_price_boundary_method = 5;
  inline bool has_complex_event_price_boundary_method() const;
  inline void clear_complex_event_price_boundary_method();
  static const int kComplexEventPriceBoundaryMethodFieldNumber = 5;
  inline ::Common::ComplexEventPriceBoundaryMethodEnum complex_event_price_boundary_method() const;
  inline void set_complex_event_price_boundary_method(::Common::ComplexEventPriceBoundaryMethodEnum value);

  // optional sfixed64 complex_event_price_boundary_precision = 6;
  inline bool has_complex_event_price_boundary_precision() const;
  inline void clear_complex_event_price_boundary_precision();
  static const int kComplexEventPriceBoundaryPrecisionFieldNumber = 6;
  inline ::google::protobuf::int64 complex_event_price_boundary_precision() const;
  inline void set_complex_event_price_boundary_precision(::google::protobuf::int64 value);

  // optional sfixed32 complex_event_price_boundary_precision_exponent = 7;
  inline bool has_complex_event_price_boundary_precision_exponent() const;
  inline void clear_complex_event_price_boundary_precision_exponent();
  static const int kComplexEventPriceBoundaryPrecisionExponentFieldNumber = 7;
  inline ::google::protobuf::int32 complex_event_price_boundary_precision_exponent() const;
  inline void set_complex_event_price_boundary_precision_exponent(::google::protobuf::int32 value);

  // optional .Common.ComplexEventPriceTimeTypeEnum complex_event_price_time_type = 8;
  inline bool has_complex_event_price_time_type() const;
  inline void clear_complex_event_price_time_type();
  static const int kComplexEventPriceTimeTypeFieldNumber = 8;
  inline ::Common::ComplexEventPriceTimeTypeEnum complex_event_price_time_type() const;
  inline void set_complex_event_price_time_type(::Common::ComplexEventPriceTimeTypeEnum value);

  // optional .Common.ComplexEventTypeEnum complex_event_type = 9;
  inline bool has_complex_event_type() const;
  inline void clear_complex_event_type();
  static const int kComplexEventTypeFieldNumber = 9;
  inline ::Common::ComplexEventTypeEnum complex_event_type() const;
  inline void set_complex_event_type(::Common::ComplexEventTypeEnum value);

  // optional sfixed64 complex_opt_payout_amount = 10;
  inline bool has_complex_opt_payout_amount() const;
  inline void clear_complex_opt_payout_amount();
  static const int kComplexOptPayoutAmountFieldNumber = 10;
  inline ::google::protobuf::int64 complex_opt_payout_amount() const;
  inline void set_complex_opt_payout_amount(::google::protobuf::int64 value);

  // optional sfixed32 complex_opt_payout_amount_exponent = 11;
  inline bool has_complex_opt_payout_amount_exponent() const;
  inline void clear_complex_opt_payout_amount_exponent();
  static const int kComplexOptPayoutAmountExponentFieldNumber = 11;
  inline ::google::protobuf::int32 complex_opt_payout_amount_exponent() const;
  inline void set_complex_opt_payout_amount_exponent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Common.ComplexEvents)
 private:
  inline void set_has_complex_event_condition();
  inline void clear_has_complex_event_condition();
  inline void set_has_complex_event_price();
  inline void clear_has_complex_event_price();
  inline void set_has_complex_event_price_exponent();
  inline void clear_has_complex_event_price_exponent();
  inline void set_has_complex_event_price_boundary_method();
  inline void clear_has_complex_event_price_boundary_method();
  inline void set_has_complex_event_price_boundary_precision();
  inline void clear_has_complex_event_price_boundary_precision();
  inline void set_has_complex_event_price_boundary_precision_exponent();
  inline void clear_has_complex_event_price_boundary_precision_exponent();
  inline void set_has_complex_event_price_time_type();
  inline void clear_has_complex_event_price_time_type();
  inline void set_has_complex_event_type();
  inline void clear_has_complex_event_type();
  inline void set_has_complex_opt_payout_amount();
  inline void clear_has_complex_opt_payout_amount();
  inline void set_has_complex_opt_payout_amount_exponent();
  inline void clear_has_complex_opt_payout_amount_exponent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventDates > complex_event_dates_;
  int complex_event_condition_;
  ::google::protobuf::int32 complex_event_price_exponent_;
  ::google::protobuf::int64 complex_event_price_;
  ::google::protobuf::int64 complex_event_price_boundary_precision_;
  int complex_event_price_boundary_method_;
  ::google::protobuf::int32 complex_event_price_boundary_precision_exponent_;
  int complex_event_price_time_type_;
  int complex_event_type_;
  ::google::protobuf::int64 complex_opt_payout_amount_;
  ::google::protobuf::int32 complex_opt_payout_amount_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ComplexEvents* default_instance_;
};
// -------------------------------------------------------------------

class StrikePriceDeterminationMethodUnion : public ::google::protobuf::Message {
 public:
  StrikePriceDeterminationMethodUnion();
  virtual ~StrikePriceDeterminationMethodUnion();

  StrikePriceDeterminationMethodUnion(const StrikePriceDeterminationMethodUnion& from);

  inline StrikePriceDeterminationMethodUnion& operator=(const StrikePriceDeterminationMethodUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StrikePriceDeterminationMethodUnion& default_instance();

  void Swap(StrikePriceDeterminationMethodUnion* other);

  // implements Message ----------------------------------------------

  StrikePriceDeterminationMethodUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrikePriceDeterminationMethodUnion& from);
  void MergeFrom(const StrikePriceDeterminationMethodUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.StrikePriceDeterminationMethodEnum strike_price_determination_method = 1;
  inline bool has_strike_price_determination_method() const;
  inline void clear_strike_price_determination_method();
  static const int kStrikePriceDeterminationMethodFieldNumber = 1;
  inline ::Common::StrikePriceDeterminationMethodEnum strike_price_determination_method() const;
  inline void set_strike_price_determination_method(::Common::StrikePriceDeterminationMethodEnum value);

  // optional sfixed64 strike_price_determination_method_sfixed64 = 2;
  inline bool has_strike_price_determination_method_sfixed64() const;
  inline void clear_strike_price_determination_method_sfixed64();
  static const int kStrikePriceDeterminationMethodSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 strike_price_determination_method_sfixed64() const;
  inline void set_strike_price_determination_method_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.StrikePriceDeterminationMethodUnion)
 private:
  inline void set_has_strike_price_determination_method();
  inline void clear_has_strike_price_determination_method();
  inline void set_has_strike_price_determination_method_sfixed64();
  inline void clear_has_strike_price_determination_method_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 strike_price_determination_method_sfixed64_;
  int strike_price_determination_method_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static StrikePriceDeterminationMethodUnion* default_instance_;
};
// -------------------------------------------------------------------

class FlowScheduleTypeUnion : public ::google::protobuf::Message {
 public:
  FlowScheduleTypeUnion();
  virtual ~FlowScheduleTypeUnion();

  FlowScheduleTypeUnion(const FlowScheduleTypeUnion& from);

  inline FlowScheduleTypeUnion& operator=(const FlowScheduleTypeUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FlowScheduleTypeUnion& default_instance();

  void Swap(FlowScheduleTypeUnion* other);

  // implements Message ----------------------------------------------

  FlowScheduleTypeUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FlowScheduleTypeUnion& from);
  void MergeFrom(const FlowScheduleTypeUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.FlowScheduleTypeEnum flow_schedule_type = 1;
  inline bool has_flow_schedule_type() const;
  inline void clear_flow_schedule_type();
  static const int kFlowScheduleTypeFieldNumber = 1;
  inline ::Common::FlowScheduleTypeEnum flow_schedule_type() const;
  inline void set_flow_schedule_type(::Common::FlowScheduleTypeEnum value);

  // optional sfixed64 flow_schedule_type_sfixed64 = 2;
  inline bool has_flow_schedule_type_sfixed64() const;
  inline void clear_flow_schedule_type_sfixed64();
  static const int kFlowScheduleTypeSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 flow_schedule_type_sfixed64() const;
  inline void set_flow_schedule_type_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.FlowScheduleTypeUnion)
 private:
  inline void set_has_flow_schedule_type();
  inline void clear_has_flow_schedule_type();
  inline void set_has_flow_schedule_type_sfixed64();
  inline void clear_has_flow_schedule_type_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 flow_schedule_type_sfixed64_;
  int flow_schedule_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static FlowScheduleTypeUnion* default_instance_;
};
// -------------------------------------------------------------------

class CpProgramUnion : public ::google::protobuf::Message {
 public:
  CpProgramUnion();
  virtual ~CpProgramUnion();

  CpProgramUnion(const CpProgramUnion& from);

  inline CpProgramUnion& operator=(const CpProgramUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CpProgramUnion& default_instance();

  void Swap(CpProgramUnion* other);

  // implements Message ----------------------------------------------

  CpProgramUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CpProgramUnion& from);
  void MergeFrom(const CpProgramUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.CpProgramEnum cp_program = 1;
  inline bool has_cp_program() const;
  inline void clear_cp_program();
  static const int kCpProgramFieldNumber = 1;
  inline ::Common::CpProgramEnum cp_program() const;
  inline void set_cp_program(::Common::CpProgramEnum value);

  // optional sfixed64 cp_program_sfixed64 = 2;
  inline bool has_cp_program_sfixed64() const;
  inline void clear_cp_program_sfixed64();
  static const int kCpProgramSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 cp_program_sfixed64() const;
  inline void set_cp_program_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.CpProgramUnion)
 private:
  inline void set_has_cp_program();
  inline void clear_has_cp_program();
  inline void set_has_cp_program_sfixed64();
  inline void clear_has_cp_program_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 cp_program_sfixed64_;
  int cp_program_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static CpProgramUnion* default_instance_;
};
// -------------------------------------------------------------------

class Instrument : public ::google::protobuf::Message {
 public:
  Instrument();
  virtual ~Instrument();

  Instrument(const Instrument& from);

  inline Instrument& operator=(const Instrument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Instrument& default_instance();

  void Swap(Instrument* other);

  // implements Message ----------------------------------------------

  Instrument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Instrument& from);
  void MergeFrom(const Instrument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cfi_code = 1;
  inline bool has_cfi_code() const;
  inline void clear_cfi_code();
  static const int kCfiCodeFieldNumber = 1;
  inline const ::std::string& cfi_code() const;
  inline void set_cfi_code(const ::std::string& value);
  inline void set_cfi_code(const char* value);
  inline void set_cfi_code(const char* value, size_t size);
  inline ::std::string* mutable_cfi_code();
  inline ::std::string* release_cfi_code();
  inline void set_allocated_cfi_code(::std::string* cfi_code);

  // optional double contract_multiplier = 2;
  inline bool has_contract_multiplier() const;
  inline void clear_contract_multiplier();
  static const int kContractMultiplierFieldNumber = 2;
  inline double contract_multiplier() const;
  inline void set_contract_multiplier(double value);

  // optional string country_of_issue = 3;
  inline bool has_country_of_issue() const;
  inline void clear_country_of_issue();
  static const int kCountryOfIssueFieldNumber = 3;
  inline const ::std::string& country_of_issue() const;
  inline void set_country_of_issue(const ::std::string& value);
  inline void set_country_of_issue(const char* value);
  inline void set_country_of_issue(const char* value, size_t size);
  inline ::std::string* mutable_country_of_issue();
  inline ::std::string* release_country_of_issue();
  inline void set_allocated_country_of_issue(::std::string* country_of_issue);

  // optional sfixed32 coupon_payment_date = 4;
  inline bool has_coupon_payment_date() const;
  inline void clear_coupon_payment_date();
  static const int kCouponPaymentDateFieldNumber = 4;
  inline ::google::protobuf::int32 coupon_payment_date() const;
  inline void set_coupon_payment_date(::google::protobuf::int32 value);

  // optional sfixed64 coupon_rate = 5;
  inline bool has_coupon_rate() const;
  inline void clear_coupon_rate();
  static const int kCouponRateFieldNumber = 5;
  inline ::google::protobuf::int64 coupon_rate() const;
  inline void set_coupon_rate(::google::protobuf::int64 value);

  // optional sfixed32 coupon_rate_exponent = 6;
  inline bool has_coupon_rate_exponent() const;
  inline void clear_coupon_rate_exponent();
  static const int kCouponRateExponentFieldNumber = 6;
  inline ::google::protobuf::int32 coupon_rate_exponent() const;
  inline void set_coupon_rate_exponent(::google::protobuf::int32 value);

  // optional string credit_rating = 7;
  inline bool has_credit_rating() const;
  inline void clear_credit_rating();
  static const int kCreditRatingFieldNumber = 7;
  inline const ::std::string& credit_rating() const;
  inline void set_credit_rating(const ::std::string& value);
  inline void set_credit_rating(const char* value);
  inline void set_credit_rating(const char* value, size_t size);
  inline ::std::string* mutable_credit_rating();
  inline ::std::string* release_credit_rating();
  inline void set_allocated_credit_rating(::std::string* credit_rating);

  // optional bytes encoded_issuer = 8;
  inline bool has_encoded_issuer() const;
  inline void clear_encoded_issuer();
  static const int kEncodedIssuerFieldNumber = 8;
  inline const ::std::string& encoded_issuer() const;
  inline void set_encoded_issuer(const ::std::string& value);
  inline void set_encoded_issuer(const char* value);
  inline void set_encoded_issuer(const void* value, size_t size);
  inline ::std::string* mutable_encoded_issuer();
  inline ::std::string* release_encoded_issuer();
  inline void set_allocated_encoded_issuer(::std::string* encoded_issuer);

  // optional fixed32 encoded_issuer_len = 9;
  inline bool has_encoded_issuer_len() const;
  inline void clear_encoded_issuer_len();
  static const int kEncodedIssuerLenFieldNumber = 9;
  inline ::google::protobuf::uint32 encoded_issuer_len() const;
  inline void set_encoded_issuer_len(::google::protobuf::uint32 value);

  // optional bytes encoded_security_desc = 10;
  inline bool has_encoded_security_desc() const;
  inline void clear_encoded_security_desc();
  static const int kEncodedSecurityDescFieldNumber = 10;
  inline const ::std::string& encoded_security_desc() const;
  inline void set_encoded_security_desc(const ::std::string& value);
  inline void set_encoded_security_desc(const char* value);
  inline void set_encoded_security_desc(const void* value, size_t size);
  inline ::std::string* mutable_encoded_security_desc();
  inline ::std::string* release_encoded_security_desc();
  inline void set_allocated_encoded_security_desc(::std::string* encoded_security_desc);

  // optional fixed32 encoded_security_desc_len = 11;
  inline bool has_encoded_security_desc_len() const;
  inline void clear_encoded_security_desc_len();
  static const int kEncodedSecurityDescLenFieldNumber = 11;
  inline ::google::protobuf::uint32 encoded_security_desc_len() const;
  inline void set_encoded_security_desc_len(::google::protobuf::uint32 value);

  // optional double factor = 12;
  inline bool has_factor() const;
  inline void clear_factor();
  static const int kFactorFieldNumber = 12;
  inline double factor() const;
  inline void set_factor(double value);

  // optional string instr_registry = 13;
  inline bool has_instr_registry() const;
  inline void clear_instr_registry();
  static const int kInstrRegistryFieldNumber = 13;
  inline const ::std::string& instr_registry() const;
  inline void set_instr_registry(const ::std::string& value);
  inline void set_instr_registry(const char* value);
  inline void set_instr_registry(const char* value, size_t size);
  inline ::std::string* mutable_instr_registry();
  inline ::std::string* release_instr_registry();
  inline void set_allocated_instr_registry(::std::string* instr_registry);

  // optional sfixed32 issue_date = 14;
  inline bool has_issue_date() const;
  inline void clear_issue_date();
  static const int kIssueDateFieldNumber = 14;
  inline ::google::protobuf::int32 issue_date() const;
  inline void set_issue_date(::google::protobuf::int32 value);

  // optional string issuer = 15;
  inline bool has_issuer() const;
  inline void clear_issuer();
  static const int kIssuerFieldNumber = 15;
  inline const ::std::string& issuer() const;
  inline void set_issuer(const ::std::string& value);
  inline void set_issuer(const char* value);
  inline void set_issuer(const char* value, size_t size);
  inline ::std::string* mutable_issuer();
  inline ::std::string* release_issuer();
  inline void set_allocated_issuer(::std::string* issuer);

  // optional string locale_of_issue = 16;
  inline bool has_locale_of_issue() const;
  inline void clear_locale_of_issue();
  static const int kLocaleOfIssueFieldNumber = 16;
  inline const ::std::string& locale_of_issue() const;
  inline void set_locale_of_issue(const ::std::string& value);
  inline void set_locale_of_issue(const char* value);
  inline void set_locale_of_issue(const char* value, size_t size);
  inline ::std::string* mutable_locale_of_issue();
  inline ::std::string* release_locale_of_issue();
  inline void set_allocated_locale_of_issue(::std::string* locale_of_issue);

  // optional sfixed32 maturity_date = 17;
  inline bool has_maturity_date() const;
  inline void clear_maturity_date();
  static const int kMaturityDateFieldNumber = 17;
  inline ::google::protobuf::int32 maturity_date() const;
  inline void set_maturity_date(::google::protobuf::int32 value);

  // optional sfixed32 maturity_month_year = 18;
  inline bool has_maturity_month_year() const;
  inline void clear_maturity_month_year();
  static const int kMaturityMonthYearFieldNumber = 18;
  inline ::google::protobuf::int32 maturity_month_year() const;
  inline void set_maturity_month_year(::google::protobuf::int32 value);

  // optional string opt_attribute = 19;
  inline bool has_opt_attribute() const;
  inline void clear_opt_attribute();
  static const int kOptAttributeFieldNumber = 19;
  inline const ::std::string& opt_attribute() const;
  inline void set_opt_attribute(const ::std::string& value);
  inline void set_opt_attribute(const char* value);
  inline void set_opt_attribute(const char* value, size_t size);
  inline ::std::string* mutable_opt_attribute();
  inline ::std::string* release_opt_attribute();
  inline void set_allocated_opt_attribute(::std::string* opt_attribute);

  // optional .Common.ProductEnum product = 20;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 20;
  inline ::Common::ProductEnum product() const;
  inline void set_product(::Common::ProductEnum value);

  // optional sfixed32 redemption_date = 21;
  inline bool has_redemption_date() const;
  inline void clear_redemption_date();
  static const int kRedemptionDateFieldNumber = 21;
  inline ::google::protobuf::int32 redemption_date() const;
  inline void set_redemption_date(::google::protobuf::int32 value);

  // optional string repo_collateral_security_type = 22;
  inline bool has_repo_collateral_security_type() const;
  inline void clear_repo_collateral_security_type();
  static const int kRepoCollateralSecurityTypeFieldNumber = 22;
  inline const ::std::string& repo_collateral_security_type() const;
  inline void set_repo_collateral_security_type(const ::std::string& value);
  inline void set_repo_collateral_security_type(const char* value);
  inline void set_repo_collateral_security_type(const char* value, size_t size);
  inline ::std::string* mutable_repo_collateral_security_type();
  inline ::std::string* release_repo_collateral_security_type();
  inline void set_allocated_repo_collateral_security_type(::std::string* repo_collateral_security_type);

  // optional sfixed64 repurchase_rate = 23;
  inline bool has_repurchase_rate() const;
  inline void clear_repurchase_rate();
  static const int kRepurchaseRateFieldNumber = 23;
  inline ::google::protobuf::int64 repurchase_rate() const;
  inline void set_repurchase_rate(::google::protobuf::int64 value);

  // optional sfixed32 repurchase_rate_exponent = 24;
  inline bool has_repurchase_rate_exponent() const;
  inline void clear_repurchase_rate_exponent();
  static const int kRepurchaseRateExponentFieldNumber = 24;
  inline ::google::protobuf::int32 repurchase_rate_exponent() const;
  inline void set_repurchase_rate_exponent(::google::protobuf::int32 value);

  // optional sfixed64 repurchase_term = 25;
  inline bool has_repurchase_term() const;
  inline void clear_repurchase_term();
  static const int kRepurchaseTermFieldNumber = 25;
  inline ::google::protobuf::int64 repurchase_term() const;
  inline void set_repurchase_term(::google::protobuf::int64 value);

  // optional string security_desc = 26;
  inline bool has_security_desc() const;
  inline void clear_security_desc();
  static const int kSecurityDescFieldNumber = 26;
  inline const ::std::string& security_desc() const;
  inline void set_security_desc(const ::std::string& value);
  inline void set_security_desc(const char* value);
  inline void set_security_desc(const char* value, size_t size);
  inline ::std::string* mutable_security_desc();
  inline ::std::string* release_security_desc();
  inline void set_allocated_security_desc(::std::string* security_desc);

  // optional string security_exchange = 27;
  inline bool has_security_exchange() const;
  inline void clear_security_exchange();
  static const int kSecurityExchangeFieldNumber = 27;
  inline const ::std::string& security_exchange() const;
  inline void set_security_exchange(const ::std::string& value);
  inline void set_security_exchange(const char* value);
  inline void set_security_exchange(const char* value, size_t size);
  inline ::std::string* mutable_security_exchange();
  inline ::std::string* release_security_exchange();
  inline void set_allocated_security_exchange(::std::string* security_exchange);

  // optional string security_id = 28;
  inline bool has_security_id() const;
  inline void clear_security_id();
  static const int kSecurityIdFieldNumber = 28;
  inline const ::std::string& security_id() const;
  inline void set_security_id(const ::std::string& value);
  inline void set_security_id(const char* value);
  inline void set_security_id(const char* value, size_t size);
  inline ::std::string* mutable_security_id();
  inline ::std::string* release_security_id();
  inline void set_allocated_security_id(::std::string* security_id);

  // optional .Common.SecurityIdSourceEnum security_id_source = 29;
  inline bool has_security_id_source() const;
  inline void clear_security_id_source();
  static const int kSecurityIdSourceFieldNumber = 29;
  inline ::Common::SecurityIdSourceEnum security_id_source() const;
  inline void set_security_id_source(::Common::SecurityIdSourceEnum value);

  // optional .Common.SecurityTypeEnum security_type = 30;
  inline bool has_security_type() const;
  inline void clear_security_type();
  static const int kSecurityTypeFieldNumber = 30;
  inline ::Common::SecurityTypeEnum security_type() const;
  inline void set_security_type(::Common::SecurityTypeEnum value);

  // optional string state_or_province_of_issue = 31;
  inline bool has_state_or_province_of_issue() const;
  inline void clear_state_or_province_of_issue();
  static const int kStateOrProvinceOfIssueFieldNumber = 31;
  inline const ::std::string& state_or_province_of_issue() const;
  inline void set_state_or_province_of_issue(const ::std::string& value);
  inline void set_state_or_province_of_issue(const char* value);
  inline void set_state_or_province_of_issue(const char* value, size_t size);
  inline ::std::string* mutable_state_or_province_of_issue();
  inline ::std::string* release_state_or_province_of_issue();
  inline void set_allocated_state_or_province_of_issue(::std::string* state_or_province_of_issue);

  // optional sfixed64 strike_price = 32;
  inline bool has_strike_price() const;
  inline void clear_strike_price();
  static const int kStrikePriceFieldNumber = 32;
  inline ::google::protobuf::int64 strike_price() const;
  inline void set_strike_price(::google::protobuf::int64 value);

  // optional sfixed32 strike_price_exponent = 33;
  inline bool has_strike_price_exponent() const;
  inline void clear_strike_price_exponent();
  static const int kStrikePriceExponentFieldNumber = 33;
  inline ::google::protobuf::int32 strike_price_exponent() const;
  inline void set_strike_price_exponent(::google::protobuf::int32 value);

  // optional string symbol = 34;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 34;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // optional .Common.SymbolSfxEnum symbol_sfx = 35;
  inline bool has_symbol_sfx() const;
  inline void clear_symbol_sfx();
  static const int kSymbolSfxFieldNumber = 35;
  inline ::Common::SymbolSfxEnum symbol_sfx() const;
  inline void set_symbol_sfx(::Common::SymbolSfxEnum value);

  // optional .Common.CpProgramEnum cp_program = 36;
  inline bool has_cp_program() const;
  inline void clear_cp_program();
  static const int kCpProgramFieldNumber = 36;
  inline ::Common::CpProgramEnum cp_program() const;
  inline void set_cp_program(::Common::CpProgramEnum value);

  // optional string cp_reg_type = 37;
  inline bool has_cp_reg_type() const;
  inline void clear_cp_reg_type();
  static const int kCpRegTypeFieldNumber = 37;
  inline const ::std::string& cp_reg_type() const;
  inline void set_cp_reg_type(const ::std::string& value);
  inline void set_cp_reg_type(const char* value);
  inline void set_cp_reg_type(const char* value, size_t size);
  inline ::std::string* mutable_cp_reg_type();
  inline ::std::string* release_cp_reg_type();
  inline void set_allocated_cp_reg_type(::std::string* cp_reg_type);

  // optional sfixed32 contract_settl_month = 38;
  inline bool has_contract_settl_month() const;
  inline void clear_contract_settl_month();
  static const int kContractSettlMonthFieldNumber = 38;
  inline ::google::protobuf::int32 contract_settl_month() const;
  inline void set_contract_settl_month(::google::protobuf::int32 value);

  // optional sfixed32 dated_date = 39;
  inline bool has_dated_date() const;
  inline void clear_dated_date();
  static const int kDatedDateFieldNumber = 39;
  inline ::google::protobuf::int32 dated_date() const;
  inline void set_dated_date(::google::protobuf::int32 value);

  // repeated .Common.EvntGrp evnt_grp = 40;
  inline int evnt_grp_size() const;
  inline void clear_evnt_grp();
  static const int kEvntGrpFieldNumber = 40;
  inline const ::Common::EvntGrp& evnt_grp(int index) const;
  inline ::Common::EvntGrp* mutable_evnt_grp(int index);
  inline ::Common::EvntGrp* add_evnt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::EvntGrp >&
      evnt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::EvntGrp >*
      mutable_evnt_grp();

  // optional string instrmt_assignment_method = 41;
  inline bool has_instrmt_assignment_method() const;
  inline void clear_instrmt_assignment_method();
  static const int kInstrmtAssignmentMethodFieldNumber = 41;
  inline const ::std::string& instrmt_assignment_method() const;
  inline void set_instrmt_assignment_method(const ::std::string& value);
  inline void set_instrmt_assignment_method(const char* value);
  inline void set_instrmt_assignment_method(const char* value, size_t size);
  inline ::std::string* mutable_instrmt_assignment_method();
  inline ::std::string* release_instrmt_assignment_method();
  inline void set_allocated_instrmt_assignment_method(::std::string* instrmt_assignment_method);

  // repeated .Common.InstrumentParties instrument_parties = 42;
  inline int instrument_parties_size() const;
  inline void clear_instrument_parties();
  static const int kInstrumentPartiesFieldNumber = 42;
  inline const ::Common::InstrumentParties& instrument_parties(int index) const;
  inline ::Common::InstrumentParties* mutable_instrument_parties(int index);
  inline ::Common::InstrumentParties* add_instrument_parties();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrumentParties >&
      instrument_parties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrumentParties >*
      mutable_instrument_parties();

  // optional sfixed32 interest_accrual_date = 43;
  inline bool has_interest_accrual_date() const;
  inline void clear_interest_accrual_date();
  static const int kInterestAccrualDateFieldNumber = 43;
  inline ::google::protobuf::int32 interest_accrual_date() const;
  inline void set_interest_accrual_date(::google::protobuf::int32 value);

  // optional string maturity_time = 44;
  inline bool has_maturity_time() const;
  inline void clear_maturity_time();
  static const int kMaturityTimeFieldNumber = 44;
  inline const ::std::string& maturity_time() const;
  inline void set_maturity_time(const ::std::string& value);
  inline void set_maturity_time(const char* value);
  inline void set_maturity_time(const char* value, size_t size);
  inline ::std::string* mutable_maturity_time();
  inline ::std::string* release_maturity_time();
  inline void set_allocated_maturity_time(::std::string* maturity_time);

  // optional double min_price_increment = 45;
  inline bool has_min_price_increment() const;
  inline void clear_min_price_increment();
  static const int kMinPriceIncrementFieldNumber = 45;
  inline double min_price_increment() const;
  inline void set_min_price_increment(double value);

  // optional sfixed64 nt_position_limit = 46;
  inline bool has_nt_position_limit() const;
  inline void clear_nt_position_limit();
  static const int kNtPositionLimitFieldNumber = 46;
  inline ::google::protobuf::int64 nt_position_limit() const;
  inline void set_nt_position_limit(::google::protobuf::int64 value);

  // optional string pool = 47;
  inline bool has_pool() const;
  inline void clear_pool();
  static const int kPoolFieldNumber = 47;
  inline const ::std::string& pool() const;
  inline void set_pool(const ::std::string& value);
  inline void set_pool(const char* value);
  inline void set_pool(const char* value, size_t size);
  inline ::std::string* mutable_pool();
  inline ::std::string* release_pool();
  inline void set_allocated_pool(::std::string* pool);

  // optional sfixed64 position_limit = 48;
  inline bool has_position_limit() const;
  inline void clear_position_limit();
  static const int kPositionLimitFieldNumber = 48;
  inline ::google::protobuf::int64 position_limit() const;
  inline void set_position_limit(::google::protobuf::int64 value);

  // optional .Common.PutOrCallEnum put_or_call = 49;
  inline bool has_put_or_call() const;
  inline void clear_put_or_call();
  static const int kPutOrCallFieldNumber = 49;
  inline ::Common::PutOrCallEnum put_or_call() const;
  inline void set_put_or_call(::Common::PutOrCallEnum value);

  // repeated .Common.SecAltIdGrp sec_alt_id_grp = 50;
  inline int sec_alt_id_grp_size() const;
  inline void clear_sec_alt_id_grp();
  static const int kSecAltIdGrpFieldNumber = 50;
  inline const ::Common::SecAltIdGrp& sec_alt_id_grp(int index) const;
  inline ::Common::SecAltIdGrp* mutable_sec_alt_id_grp(int index);
  inline ::Common::SecAltIdGrp* add_sec_alt_id_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::SecAltIdGrp >&
      sec_alt_id_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::SecAltIdGrp >*
      mutable_sec_alt_id_grp();

  // optional .Common.SecurityStatusEnum security_status = 51;
  inline bool has_security_status() const;
  inline void clear_security_status();
  static const int kSecurityStatusFieldNumber = 51;
  inline ::Common::SecurityStatusEnum security_status() const;
  inline void set_security_status(::Common::SecurityStatusEnum value);

  // optional string security_sub_type = 52;
  inline bool has_security_sub_type() const;
  inline void clear_security_sub_type();
  static const int kSecuritySubTypeFieldNumber = 52;
  inline const ::std::string& security_sub_type() const;
  inline void set_security_sub_type(const ::std::string& value);
  inline void set_security_sub_type(const char* value);
  inline void set_security_sub_type(const char* value, size_t size);
  inline ::std::string* mutable_security_sub_type();
  inline ::std::string* release_security_sub_type();
  inline void set_allocated_security_sub_type(::std::string* security_sub_type);

  // optional string settle_on_open_flag = 53;
  inline bool has_settle_on_open_flag() const;
  inline void clear_settle_on_open_flag();
  static const int kSettleOnOpenFlagFieldNumber = 53;
  inline const ::std::string& settle_on_open_flag() const;
  inline void set_settle_on_open_flag(const ::std::string& value);
  inline void set_settle_on_open_flag(const char* value);
  inline void set_settle_on_open_flag(const char* value, size_t size);
  inline ::std::string* mutable_settle_on_open_flag();
  inline ::std::string* release_settle_on_open_flag();
  inline void set_allocated_settle_on_open_flag(::std::string* settle_on_open_flag);

  // optional string strike_currency = 54;
  inline bool has_strike_currency() const;
  inline void clear_strike_currency();
  static const int kStrikeCurrencyFieldNumber = 54;
  inline const ::std::string& strike_currency() const;
  inline void set_strike_currency(const ::std::string& value);
  inline void set_strike_currency(const char* value);
  inline void set_strike_currency(const char* value, size_t size);
  inline ::std::string* mutable_strike_currency();
  inline ::std::string* release_strike_currency();
  inline void set_allocated_strike_currency(::std::string* strike_currency);

  // optional double strike_multiplier = 55;
  inline bool has_strike_multiplier() const;
  inline void clear_strike_multiplier();
  static const int kStrikeMultiplierFieldNumber = 55;
  inline double strike_multiplier() const;
  inline void set_strike_multiplier(double value);

  // optional double strike_value = 56;
  inline bool has_strike_value() const;
  inline void clear_strike_value();
  static const int kStrikeValueFieldNumber = 56;
  inline double strike_value() const;
  inline void set_strike_value(double value);

  // optional .Common.TimeUnitEnum time_unit = 57;
  inline bool has_time_unit() const;
  inline void clear_time_unit();
  static const int kTimeUnitFieldNumber = 57;
  inline ::Common::TimeUnitEnum time_unit() const;
  inline void set_time_unit(::Common::TimeUnitEnum value);

  // optional .Common.UnitOfMeasureEnum unit_of_measure = 58;
  inline bool has_unit_of_measure() const;
  inline void clear_unit_of_measure();
  static const int kUnitOfMeasureFieldNumber = 58;
  inline ::Common::UnitOfMeasureEnum unit_of_measure() const;
  inline void set_unit_of_measure(::Common::UnitOfMeasureEnum value);

  // optional sfixed64 cap_price = 59;
  inline bool has_cap_price() const;
  inline void clear_cap_price();
  static const int kCapPriceFieldNumber = 59;
  inline ::google::protobuf::int64 cap_price() const;
  inline void set_cap_price(::google::protobuf::int64 value);

  // optional sfixed32 cap_price_exponent = 60;
  inline bool has_cap_price_exponent() const;
  inline void clear_cap_price_exponent();
  static const int kCapPriceExponentFieldNumber = 60;
  inline ::google::protobuf::int32 cap_price_exponent() const;
  inline void set_cap_price_exponent(::google::protobuf::int32 value);

  // optional .Common.ExerciseStyleEnum exercise_style = 61;
  inline bool has_exercise_style() const;
  inline void clear_exercise_style();
  static const int kExerciseStyleFieldNumber = 61;
  inline ::Common::ExerciseStyleEnum exercise_style() const;
  inline void set_exercise_style(::Common::ExerciseStyleEnum value);

  // optional bool flex_product_eligibility_indicator = 62;
  inline bool has_flex_product_eligibility_indicator() const;
  inline void clear_flex_product_eligibility_indicator();
  static const int kFlexProductEligibilityIndicatorFieldNumber = 62;
  inline bool flex_product_eligibility_indicator() const;
  inline void set_flex_product_eligibility_indicator(bool value);

  // optional bool flexible_indicator = 63;
  inline bool has_flexible_indicator() const;
  inline void clear_flexible_indicator();
  static const int kFlexibleIndicatorFieldNumber = 63;
  inline bool flexible_indicator() const;
  inline void set_flexible_indicator(bool value);

  // optional sfixed64 floor_price = 64;
  inline bool has_floor_price() const;
  inline void clear_floor_price();
  static const int kFloorPriceFieldNumber = 64;
  inline ::google::protobuf::int64 floor_price() const;
  inline void set_floor_price(::google::protobuf::int64 value);

  // optional sfixed32 floor_price_exponent = 65;
  inline bool has_floor_price_exponent() const;
  inline void clear_floor_price_exponent();
  static const int kFloorPriceExponentFieldNumber = 65;
  inline ::google::protobuf::int32 floor_price_exponent() const;
  inline void set_floor_price_exponent(::google::protobuf::int32 value);

  // optional .Common.ListMethodEnum list_method = 66;
  inline bool has_list_method() const;
  inline void clear_list_method();
  static const int kListMethodFieldNumber = 66;
  inline ::Common::ListMethodEnum list_method() const;
  inline void set_list_method(::Common::ListMethodEnum value);

  // optional sfixed64 min_price_increment_amount = 67;
  inline bool has_min_price_increment_amount() const;
  inline void clear_min_price_increment_amount();
  static const int kMinPriceIncrementAmountFieldNumber = 67;
  inline ::google::protobuf::int64 min_price_increment_amount() const;
  inline void set_min_price_increment_amount(::google::protobuf::int64 value);

  // optional sfixed32 min_price_increment_amount_exponent = 68;
  inline bool has_min_price_increment_amount_exponent() const;
  inline void clear_min_price_increment_amount_exponent();
  static const int kMinPriceIncrementAmountExponentFieldNumber = 68;
  inline ::google::protobuf::int32 min_price_increment_amount_exponent() const;
  inline void set_min_price_increment_amount_exponent(::google::protobuf::int32 value);

  // optional sfixed64 opt_payout_amount = 69;
  inline bool has_opt_payout_amount() const;
  inline void clear_opt_payout_amount();
  static const int kOptPayoutAmountFieldNumber = 69;
  inline ::google::protobuf::int64 opt_payout_amount() const;
  inline void set_opt_payout_amount(::google::protobuf::int64 value);

  // optional sfixed32 opt_payout_amount_exponent = 70;
  inline bool has_opt_payout_amount_exponent() const;
  inline void clear_opt_payout_amount_exponent();
  static const int kOptPayoutAmountExponentFieldNumber = 70;
  inline ::google::protobuf::int32 opt_payout_amount_exponent() const;
  inline void set_opt_payout_amount_exponent(::google::protobuf::int32 value);

  // optional .Common.PriceQuoteMethodEnum price_quote_method = 71;
  inline bool has_price_quote_method() const;
  inline void clear_price_quote_method();
  static const int kPriceQuoteMethodFieldNumber = 71;
  inline ::Common::PriceQuoteMethodEnum price_quote_method() const;
  inline void set_price_quote_method(::Common::PriceQuoteMethodEnum value);

  // optional string price_unit_of_measure = 72;
  inline bool has_price_unit_of_measure() const;
  inline void clear_price_unit_of_measure();
  static const int kPriceUnitOfMeasureFieldNumber = 72;
  inline const ::std::string& price_unit_of_measure() const;
  inline void set_price_unit_of_measure(const ::std::string& value);
  inline void set_price_unit_of_measure(const char* value);
  inline void set_price_unit_of_measure(const char* value, size_t size);
  inline ::std::string* mutable_price_unit_of_measure();
  inline ::std::string* release_price_unit_of_measure();
  inline void set_allocated_price_unit_of_measure(::std::string* price_unit_of_measure);

  // optional sfixed64 price_unit_of_measure_qty = 73;
  inline bool has_price_unit_of_measure_qty() const;
  inline void clear_price_unit_of_measure_qty();
  static const int kPriceUnitOfMeasureQtyFieldNumber = 73;
  inline ::google::protobuf::int64 price_unit_of_measure_qty() const;
  inline void set_price_unit_of_measure_qty(::google::protobuf::int64 value);

  // optional sfixed32 price_unit_of_measure_qty_exponent = 74;
  inline bool has_price_unit_of_measure_qty_exponent() const;
  inline void clear_price_unit_of_measure_qty_exponent();
  static const int kPriceUnitOfMeasureQtyExponentFieldNumber = 74;
  inline ::google::protobuf::int32 price_unit_of_measure_qty_exponent() const;
  inline void set_price_unit_of_measure_qty_exponent(::google::protobuf::int32 value);

  // optional string product_complex = 75;
  inline bool has_product_complex() const;
  inline void clear_product_complex();
  static const int kProductComplexFieldNumber = 75;
  inline const ::std::string& product_complex() const;
  inline void set_product_complex(const ::std::string& value);
  inline void set_product_complex(const char* value);
  inline void set_product_complex(const char* value, size_t size);
  inline ::std::string* mutable_product_complex();
  inline ::std::string* release_product_complex();
  inline void set_allocated_product_complex(::std::string* product_complex);

  // optional string security_group = 76;
  inline bool has_security_group() const;
  inline void clear_security_group();
  static const int kSecurityGroupFieldNumber = 76;
  inline const ::std::string& security_group() const;
  inline void set_security_group(const ::std::string& value);
  inline void set_security_group(const char* value);
  inline void set_security_group(const char* value, size_t size);
  inline ::std::string* mutable_security_group();
  inline ::std::string* release_security_group();
  inline void set_allocated_security_group(::std::string* security_group);

  // optional .Common.SecurityXml security_xml = 77;
  inline bool has_security_xml() const;
  inline void clear_security_xml();
  static const int kSecurityXmlFieldNumber = 77;
  inline const ::Common::SecurityXml& security_xml() const;
  inline ::Common::SecurityXml* mutable_security_xml();
  inline ::Common::SecurityXml* release_security_xml();
  inline void set_allocated_security_xml(::Common::SecurityXml* security_xml);

  // optional .Common.SettlMethodEnum settl_method = 78;
  inline bool has_settl_method() const;
  inline void clear_settl_method();
  static const int kSettlMethodFieldNumber = 78;
  inline ::Common::SettlMethodEnum settl_method() const;
  inline void set_settl_method(::Common::SettlMethodEnum value);

  // optional sfixed64 unit_of_measure_qty = 79;
  inline bool has_unit_of_measure_qty() const;
  inline void clear_unit_of_measure_qty();
  static const int kUnitOfMeasureQtyFieldNumber = 79;
  inline ::google::protobuf::int64 unit_of_measure_qty() const;
  inline void set_unit_of_measure_qty(::google::protobuf::int64 value);

  // optional sfixed32 unit_of_measure_qty_exponent = 80;
  inline bool has_unit_of_measure_qty_exponent() const;
  inline void clear_unit_of_measure_qty_exponent();
  static const int kUnitOfMeasureQtyExponentFieldNumber = 80;
  inline ::google::protobuf::int32 unit_of_measure_qty_exponent() const;
  inline void set_unit_of_measure_qty_exponent(::google::protobuf::int32 value);

  // optional .Common.ValuationMethodEnum valuation_method = 81;
  inline bool has_valuation_method() const;
  inline void clear_valuation_method();
  static const int kValuationMethodFieldNumber = 81;
  inline ::Common::ValuationMethodEnum valuation_method() const;
  inline void set_valuation_method(::Common::ValuationMethodEnum value);

  // optional .Common.ContractMultiplierUnitEnum contract_multiplier_unit = 82;
  inline bool has_contract_multiplier_unit() const;
  inline void clear_contract_multiplier_unit();
  static const int kContractMultiplierUnitFieldNumber = 82;
  inline ::Common::ContractMultiplierUnitEnum contract_multiplier_unit() const;
  inline void set_contract_multiplier_unit(::Common::ContractMultiplierUnitEnum value);

  // optional .Common.FlowScheduleTypeEnum flow_schedule_type = 83;
  inline bool has_flow_schedule_type() const;
  inline void clear_flow_schedule_type();
  static const int kFlowScheduleTypeFieldNumber = 83;
  inline ::Common::FlowScheduleTypeEnum flow_schedule_type() const;
  inline void set_flow_schedule_type(::Common::FlowScheduleTypeEnum value);

  // optional sfixed64 attachment_point = 84;
  inline bool has_attachment_point() const;
  inline void clear_attachment_point();
  static const int kAttachmentPointFieldNumber = 84;
  inline ::google::protobuf::int64 attachment_point() const;
  inline void set_attachment_point(::google::protobuf::int64 value);

  // optional sfixed32 attachment_point_exponent = 85;
  inline bool has_attachment_point_exponent() const;
  inline void clear_attachment_point_exponent();
  static const int kAttachmentPointExponentFieldNumber = 85;
  inline ::google::protobuf::int32 attachment_point_exponent() const;
  inline void set_attachment_point_exponent(::google::protobuf::int32 value);

  // optional sfixed64 detachment_point = 86;
  inline bool has_detachment_point() const;
  inline void clear_detachment_point();
  static const int kDetachmentPointFieldNumber = 86;
  inline ::google::protobuf::int64 detachment_point() const;
  inline void set_detachment_point(::google::protobuf::int64 value);

  // optional sfixed32 detachment_point_exponent = 87;
  inline bool has_detachment_point_exponent() const;
  inline void clear_detachment_point_exponent();
  static const int kDetachmentPointExponentFieldNumber = 87;
  inline ::google::protobuf::int32 detachment_point_exponent() const;
  inline void set_detachment_point_exponent(::google::protobuf::int32 value);

  // optional sfixed64 notional_percentage_outstanding = 88;
  inline bool has_notional_percentage_outstanding() const;
  inline void clear_notional_percentage_outstanding();
  static const int kNotionalPercentageOutstandingFieldNumber = 88;
  inline ::google::protobuf::int64 notional_percentage_outstanding() const;
  inline void set_notional_percentage_outstanding(::google::protobuf::int64 value);

  // optional sfixed32 notional_percentage_outstanding_exponent = 89;
  inline bool has_notional_percentage_outstanding_exponent() const;
  inline void clear_notional_percentage_outstanding_exponent();
  static const int kNotionalPercentageOutstandingExponentFieldNumber = 89;
  inline ::google::protobuf::int32 notional_percentage_outstanding_exponent() const;
  inline void set_notional_percentage_outstanding_exponent(::google::protobuf::int32 value);

  // optional sfixed64 original_notional_percentage_outstanding = 90;
  inline bool has_original_notional_percentage_outstanding() const;
  inline void clear_original_notional_percentage_outstanding();
  static const int kOriginalNotionalPercentageOutstandingFieldNumber = 90;
  inline ::google::protobuf::int64 original_notional_percentage_outstanding() const;
  inline void set_original_notional_percentage_outstanding(::google::protobuf::int64 value);

  // optional sfixed32 original_notional_percentage_outstanding_exponent = 91;
  inline bool has_original_notional_percentage_outstanding_exponent() const;
  inline void clear_original_notional_percentage_outstanding_exponent();
  static const int kOriginalNotionalPercentageOutstandingExponentFieldNumber = 91;
  inline ::google::protobuf::int32 original_notional_percentage_outstanding_exponent() const;
  inline void set_original_notional_percentage_outstanding_exponent(::google::protobuf::int32 value);

  // optional .Common.RestructuringTypeEnum restructuring_type = 92;
  inline bool has_restructuring_type() const;
  inline void clear_restructuring_type();
  static const int kRestructuringTypeFieldNumber = 92;
  inline ::Common::RestructuringTypeEnum restructuring_type() const;
  inline void set_restructuring_type(::Common::RestructuringTypeEnum value);

  // optional .Common.SeniorityEnum seniority = 93;
  inline bool has_seniority() const;
  inline void clear_seniority();
  static const int kSeniorityFieldNumber = 93;
  inline ::Common::SeniorityEnum seniority() const;
  inline void set_seniority(::Common::SeniorityEnum value);

  // repeated .Common.ComplexEvents complex_events = 94;
  inline int complex_events_size() const;
  inline void clear_complex_events();
  static const int kComplexEventsFieldNumber = 94;
  inline const ::Common::ComplexEvents& complex_events(int index) const;
  inline ::Common::ComplexEvents* mutable_complex_events(int index);
  inline ::Common::ComplexEvents* add_complex_events();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::ComplexEvents >&
      complex_events() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::ComplexEvents >*
      mutable_complex_events();

  // optional .Common.OptPayoutTypeEnum opt_payout_type = 95;
  inline bool has_opt_payout_type() const;
  inline void clear_opt_payout_type();
  static const int kOptPayoutTypeFieldNumber = 95;
  inline ::Common::OptPayoutTypeEnum opt_payout_type() const;
  inline void set_opt_payout_type(::Common::OptPayoutTypeEnum value);

  // optional .Common.StrikePriceBoundaryMethodEnum strike_price_boundary_method = 96;
  inline bool has_strike_price_boundary_method() const;
  inline void clear_strike_price_boundary_method();
  static const int kStrikePriceBoundaryMethodFieldNumber = 96;
  inline ::Common::StrikePriceBoundaryMethodEnum strike_price_boundary_method() const;
  inline void set_strike_price_boundary_method(::Common::StrikePriceBoundaryMethodEnum value);

  // optional sfixed64 strike_price_boundary_precision = 97;
  inline bool has_strike_price_boundary_precision() const;
  inline void clear_strike_price_boundary_precision();
  static const int kStrikePriceBoundaryPrecisionFieldNumber = 97;
  inline ::google::protobuf::int64 strike_price_boundary_precision() const;
  inline void set_strike_price_boundary_precision(::google::protobuf::int64 value);

  // optional sfixed32 strike_price_boundary_precision_exponent = 98;
  inline bool has_strike_price_boundary_precision_exponent() const;
  inline void clear_strike_price_boundary_precision_exponent();
  static const int kStrikePriceBoundaryPrecisionExponentFieldNumber = 98;
  inline ::google::protobuf::int32 strike_price_boundary_precision_exponent() const;
  inline void set_strike_price_boundary_precision_exponent(::google::protobuf::int32 value);

  // optional .Common.StrikePriceDeterminationMethodEnum strike_price_determination_method = 99;
  inline bool has_strike_price_determination_method() const;
  inline void clear_strike_price_determination_method();
  static const int kStrikePriceDeterminationMethodFieldNumber = 99;
  inline ::Common::StrikePriceDeterminationMethodEnum strike_price_determination_method() const;
  inline void set_strike_price_determination_method(::Common::StrikePriceDeterminationMethodEnum value);

  // optional .Common.UnderlyingPriceDeterminationMethodEnum underlying_price_determination_method = 100;
  inline bool has_underlying_price_determination_method() const;
  inline void clear_underlying_price_determination_method();
  static const int kUnderlyingPriceDeterminationMethodFieldNumber = 100;
  inline ::Common::UnderlyingPriceDeterminationMethodEnum underlying_price_determination_method() const;
  inline void set_underlying_price_determination_method(::Common::UnderlyingPriceDeterminationMethodEnum value);

  // @@protoc_insertion_point(class_scope:Common.Instrument)
 private:
  inline void set_has_cfi_code();
  inline void clear_has_cfi_code();
  inline void set_has_contract_multiplier();
  inline void clear_has_contract_multiplier();
  inline void set_has_country_of_issue();
  inline void clear_has_country_of_issue();
  inline void set_has_coupon_payment_date();
  inline void clear_has_coupon_payment_date();
  inline void set_has_coupon_rate();
  inline void clear_has_coupon_rate();
  inline void set_has_coupon_rate_exponent();
  inline void clear_has_coupon_rate_exponent();
  inline void set_has_credit_rating();
  inline void clear_has_credit_rating();
  inline void set_has_encoded_issuer();
  inline void clear_has_encoded_issuer();
  inline void set_has_encoded_issuer_len();
  inline void clear_has_encoded_issuer_len();
  inline void set_has_encoded_security_desc();
  inline void clear_has_encoded_security_desc();
  inline void set_has_encoded_security_desc_len();
  inline void clear_has_encoded_security_desc_len();
  inline void set_has_factor();
  inline void clear_has_factor();
  inline void set_has_instr_registry();
  inline void clear_has_instr_registry();
  inline void set_has_issue_date();
  inline void clear_has_issue_date();
  inline void set_has_issuer();
  inline void clear_has_issuer();
  inline void set_has_locale_of_issue();
  inline void clear_has_locale_of_issue();
  inline void set_has_maturity_date();
  inline void clear_has_maturity_date();
  inline void set_has_maturity_month_year();
  inline void clear_has_maturity_month_year();
  inline void set_has_opt_attribute();
  inline void clear_has_opt_attribute();
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_redemption_date();
  inline void clear_has_redemption_date();
  inline void set_has_repo_collateral_security_type();
  inline void clear_has_repo_collateral_security_type();
  inline void set_has_repurchase_rate();
  inline void clear_has_repurchase_rate();
  inline void set_has_repurchase_rate_exponent();
  inline void clear_has_repurchase_rate_exponent();
  inline void set_has_repurchase_term();
  inline void clear_has_repurchase_term();
  inline void set_has_security_desc();
  inline void clear_has_security_desc();
  inline void set_has_security_exchange();
  inline void clear_has_security_exchange();
  inline void set_has_security_id();
  inline void clear_has_security_id();
  inline void set_has_security_id_source();
  inline void clear_has_security_id_source();
  inline void set_has_security_type();
  inline void clear_has_security_type();
  inline void set_has_state_or_province_of_issue();
  inline void clear_has_state_or_province_of_issue();
  inline void set_has_strike_price();
  inline void clear_has_strike_price();
  inline void set_has_strike_price_exponent();
  inline void clear_has_strike_price_exponent();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_symbol_sfx();
  inline void clear_has_symbol_sfx();
  inline void set_has_cp_program();
  inline void clear_has_cp_program();
  inline void set_has_cp_reg_type();
  inline void clear_has_cp_reg_type();
  inline void set_has_contract_settl_month();
  inline void clear_has_contract_settl_month();
  inline void set_has_dated_date();
  inline void clear_has_dated_date();
  inline void set_has_instrmt_assignment_method();
  inline void clear_has_instrmt_assignment_method();
  inline void set_has_interest_accrual_date();
  inline void clear_has_interest_accrual_date();
  inline void set_has_maturity_time();
  inline void clear_has_maturity_time();
  inline void set_has_min_price_increment();
  inline void clear_has_min_price_increment();
  inline void set_has_nt_position_limit();
  inline void clear_has_nt_position_limit();
  inline void set_has_pool();
  inline void clear_has_pool();
  inline void set_has_position_limit();
  inline void clear_has_position_limit();
  inline void set_has_put_or_call();
  inline void clear_has_put_or_call();
  inline void set_has_security_status();
  inline void clear_has_security_status();
  inline void set_has_security_sub_type();
  inline void clear_has_security_sub_type();
  inline void set_has_settle_on_open_flag();
  inline void clear_has_settle_on_open_flag();
  inline void set_has_strike_currency();
  inline void clear_has_strike_currency();
  inline void set_has_strike_multiplier();
  inline void clear_has_strike_multiplier();
  inline void set_has_strike_value();
  inline void clear_has_strike_value();
  inline void set_has_time_unit();
  inline void clear_has_time_unit();
  inline void set_has_unit_of_measure();
  inline void clear_has_unit_of_measure();
  inline void set_has_cap_price();
  inline void clear_has_cap_price();
  inline void set_has_cap_price_exponent();
  inline void clear_has_cap_price_exponent();
  inline void set_has_exercise_style();
  inline void clear_has_exercise_style();
  inline void set_has_flex_product_eligibility_indicator();
  inline void clear_has_flex_product_eligibility_indicator();
  inline void set_has_flexible_indicator();
  inline void clear_has_flexible_indicator();
  inline void set_has_floor_price();
  inline void clear_has_floor_price();
  inline void set_has_floor_price_exponent();
  inline void clear_has_floor_price_exponent();
  inline void set_has_list_method();
  inline void clear_has_list_method();
  inline void set_has_min_price_increment_amount();
  inline void clear_has_min_price_increment_amount();
  inline void set_has_min_price_increment_amount_exponent();
  inline void clear_has_min_price_increment_amount_exponent();
  inline void set_has_opt_payout_amount();
  inline void clear_has_opt_payout_amount();
  inline void set_has_opt_payout_amount_exponent();
  inline void clear_has_opt_payout_amount_exponent();
  inline void set_has_price_quote_method();
  inline void clear_has_price_quote_method();
  inline void set_has_price_unit_of_measure();
  inline void clear_has_price_unit_of_measure();
  inline void set_has_price_unit_of_measure_qty();
  inline void clear_has_price_unit_of_measure_qty();
  inline void set_has_price_unit_of_measure_qty_exponent();
  inline void clear_has_price_unit_of_measure_qty_exponent();
  inline void set_has_product_complex();
  inline void clear_has_product_complex();
  inline void set_has_security_group();
  inline void clear_has_security_group();
  inline void set_has_security_xml();
  inline void clear_has_security_xml();
  inline void set_has_settl_method();
  inline void clear_has_settl_method();
  inline void set_has_unit_of_measure_qty();
  inline void clear_has_unit_of_measure_qty();
  inline void set_has_unit_of_measure_qty_exponent();
  inline void clear_has_unit_of_measure_qty_exponent();
  inline void set_has_valuation_method();
  inline void clear_has_valuation_method();
  inline void set_has_contract_multiplier_unit();
  inline void clear_has_contract_multiplier_unit();
  inline void set_has_flow_schedule_type();
  inline void clear_has_flow_schedule_type();
  inline void set_has_attachment_point();
  inline void clear_has_attachment_point();
  inline void set_has_attachment_point_exponent();
  inline void clear_has_attachment_point_exponent();
  inline void set_has_detachment_point();
  inline void clear_has_detachment_point();
  inline void set_has_detachment_point_exponent();
  inline void clear_has_detachment_point_exponent();
  inline void set_has_notional_percentage_outstanding();
  inline void clear_has_notional_percentage_outstanding();
  inline void set_has_notional_percentage_outstanding_exponent();
  inline void clear_has_notional_percentage_outstanding_exponent();
  inline void set_has_original_notional_percentage_outstanding();
  inline void clear_has_original_notional_percentage_outstanding();
  inline void set_has_original_notional_percentage_outstanding_exponent();
  inline void clear_has_original_notional_percentage_outstanding_exponent();
  inline void set_has_restructuring_type();
  inline void clear_has_restructuring_type();
  inline void set_has_seniority();
  inline void clear_has_seniority();
  inline void set_has_opt_payout_type();
  inline void clear_has_opt_payout_type();
  inline void set_has_strike_price_boundary_method();
  inline void clear_has_strike_price_boundary_method();
  inline void set_has_strike_price_boundary_precision();
  inline void clear_has_strike_price_boundary_precision();
  inline void set_has_strike_price_boundary_precision_exponent();
  inline void clear_has_strike_price_boundary_precision_exponent();
  inline void set_has_strike_price_determination_method();
  inline void clear_has_strike_price_determination_method();
  inline void set_has_underlying_price_determination_method();
  inline void clear_has_underlying_price_determination_method();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cfi_code_;
  double contract_multiplier_;
  ::std::string* country_of_issue_;
  ::google::protobuf::int64 coupon_rate_;
  ::google::protobuf::int32 coupon_payment_date_;
  ::google::protobuf::int32 coupon_rate_exponent_;
  ::std::string* credit_rating_;
  ::std::string* encoded_issuer_;
  ::std::string* encoded_security_desc_;
  ::google::protobuf::uint32 encoded_issuer_len_;
  ::google::protobuf::uint32 encoded_security_desc_len_;
  double factor_;
  ::std::string* instr_registry_;
  ::std::string* issuer_;
  ::google::protobuf::int32 issue_date_;
  ::google::protobuf::int32 maturity_date_;
  ::std::string* locale_of_issue_;
  ::std::string* opt_attribute_;
  ::google::protobuf::int32 maturity_month_year_;
  int product_;
  ::std::string* repo_collateral_security_type_;
  ::google::protobuf::int32 redemption_date_;
  ::google::protobuf::int32 repurchase_rate_exponent_;
  ::google::protobuf::int64 repurchase_rate_;
  ::google::protobuf::int64 repurchase_term_;
  ::std::string* security_desc_;
  ::std::string* security_exchange_;
  ::std::string* security_id_;
  int security_id_source_;
  int security_type_;
  ::std::string* state_or_province_of_issue_;
  ::google::protobuf::int64 strike_price_;
  ::std::string* symbol_;
  ::google::protobuf::int32 strike_price_exponent_;
  int symbol_sfx_;
  ::std::string* cp_reg_type_;
  int cp_program_;
  ::google::protobuf::int32 contract_settl_month_;
  ::google::protobuf::RepeatedPtrField< ::Common::EvntGrp > evnt_grp_;
  ::std::string* instrmt_assignment_method_;
  ::google::protobuf::int32 dated_date_;
  ::google::protobuf::int32 interest_accrual_date_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrumentParties > instrument_parties_;
  ::std::string* maturity_time_;
  double min_price_increment_;
  ::google::protobuf::int64 nt_position_limit_;
  ::std::string* pool_;
  ::google::protobuf::int64 position_limit_;
  ::google::protobuf::RepeatedPtrField< ::Common::SecAltIdGrp > sec_alt_id_grp_;
  int put_or_call_;
  int security_status_;
  ::std::string* security_sub_type_;
  ::std::string* settle_on_open_flag_;
  ::std::string* strike_currency_;
  double strike_multiplier_;
  double strike_value_;
  int time_unit_;
  int unit_of_measure_;
  ::google::protobuf::int64 cap_price_;
  ::google::protobuf::int32 cap_price_exponent_;
  int exercise_style_;
  bool flex_product_eligibility_indicator_;
  bool flexible_indicator_;
  ::google::protobuf::int32 floor_price_exponent_;
  ::google::protobuf::int64 floor_price_;
  int list_method_;
  ::google::protobuf::int32 min_price_increment_amount_exponent_;
  ::google::protobuf::int64 min_price_increment_amount_;
  ::google::protobuf::int64 opt_payout_amount_;
  ::google::protobuf::int32 opt_payout_amount_exponent_;
  int price_quote_method_;
  ::std::string* price_unit_of_measure_;
  ::google::protobuf::int64 price_unit_of_measure_qty_;
  ::std::string* product_complex_;
  ::google::protobuf::int32 price_unit_of_measure_qty_exponent_;
  int settl_method_;
  ::std::string* security_group_;
  ::Common::SecurityXml* security_xml_;
  ::google::protobuf::int64 unit_of_measure_qty_;
  ::google::protobuf::int32 unit_of_measure_qty_exponent_;
  int valuation_method_;
  int contract_multiplier_unit_;
  int flow_schedule_type_;
  ::google::protobuf::int64 attachment_point_;
  ::google::protobuf::int32 attachment_point_exponent_;
  ::google::protobuf::int32 detachment_point_exponent_;
  ::google::protobuf::int64 detachment_point_;
  ::google::protobuf::int64 notional_percentage_outstanding_;
  ::google::protobuf::int64 original_notional_percentage_outstanding_;
  ::google::protobuf::int32 notional_percentage_outstanding_exponent_;
  ::google::protobuf::int32 original_notional_percentage_outstanding_exponent_;
  int restructuring_type_;
  int seniority_;
  ::google::protobuf::RepeatedPtrField< ::Common::ComplexEvents > complex_events_;
  int opt_payout_type_;
  int strike_price_boundary_method_;
  ::google::protobuf::int64 strike_price_boundary_precision_;
  ::google::protobuf::int32 strike_price_boundary_precision_exponent_;
  int strike_price_determination_method_;
  int underlying_price_determination_method_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(100 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Instrument* default_instance_;
};
// -------------------------------------------------------------------

class FinancingDetails : public ::google::protobuf::Message {
 public:
  FinancingDetails();
  virtual ~FinancingDetails();

  FinancingDetails(const FinancingDetails& from);

  inline FinancingDetails& operator=(const FinancingDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FinancingDetails& default_instance();

  void Swap(FinancingDetails* other);

  // implements Message ----------------------------------------------

  FinancingDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FinancingDetails& from);
  void MergeFrom(const FinancingDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string agreement_currency = 1;
  inline bool has_agreement_currency() const;
  inline void clear_agreement_currency();
  static const int kAgreementCurrencyFieldNumber = 1;
  inline const ::std::string& agreement_currency() const;
  inline void set_agreement_currency(const ::std::string& value);
  inline void set_agreement_currency(const char* value);
  inline void set_agreement_currency(const char* value, size_t size);
  inline ::std::string* mutable_agreement_currency();
  inline ::std::string* release_agreement_currency();
  inline void set_allocated_agreement_currency(::std::string* agreement_currency);

  // optional sfixed32 agreement_date = 2;
  inline bool has_agreement_date() const;
  inline void clear_agreement_date();
  static const int kAgreementDateFieldNumber = 2;
  inline ::google::protobuf::int32 agreement_date() const;
  inline void set_agreement_date(::google::protobuf::int32 value);

  // optional string agreement_desc = 3;
  inline bool has_agreement_desc() const;
  inline void clear_agreement_desc();
  static const int kAgreementDescFieldNumber = 3;
  inline const ::std::string& agreement_desc() const;
  inline void set_agreement_desc(const ::std::string& value);
  inline void set_agreement_desc(const char* value);
  inline void set_agreement_desc(const char* value, size_t size);
  inline ::std::string* mutable_agreement_desc();
  inline ::std::string* release_agreement_desc();
  inline void set_allocated_agreement_desc(::std::string* agreement_desc);

  // optional string agreement_id = 4;
  inline bool has_agreement_id() const;
  inline void clear_agreement_id();
  static const int kAgreementIdFieldNumber = 4;
  inline const ::std::string& agreement_id() const;
  inline void set_agreement_id(const ::std::string& value);
  inline void set_agreement_id(const char* value);
  inline void set_agreement_id(const char* value, size_t size);
  inline ::std::string* mutable_agreement_id();
  inline ::std::string* release_agreement_id();
  inline void set_allocated_agreement_id(::std::string* agreement_id);

  // optional .Common.DeliveryTypeEnum delivery_type = 5;
  inline bool has_delivery_type() const;
  inline void clear_delivery_type();
  static const int kDeliveryTypeFieldNumber = 5;
  inline ::Common::DeliveryTypeEnum delivery_type() const;
  inline void set_delivery_type(::Common::DeliveryTypeEnum value);

  // optional sfixed32 end_date = 6;
  inline bool has_end_date() const;
  inline void clear_end_date();
  static const int kEndDateFieldNumber = 6;
  inline ::google::protobuf::int32 end_date() const;
  inline void set_end_date(::google::protobuf::int32 value);

  // optional sfixed64 margin_ratio = 7;
  inline bool has_margin_ratio() const;
  inline void clear_margin_ratio();
  static const int kMarginRatioFieldNumber = 7;
  inline ::google::protobuf::int64 margin_ratio() const;
  inline void set_margin_ratio(::google::protobuf::int64 value);

  // optional sfixed32 margin_ratio_exponent = 8;
  inline bool has_margin_ratio_exponent() const;
  inline void clear_margin_ratio_exponent();
  static const int kMarginRatioExponentFieldNumber = 8;
  inline ::google::protobuf::int32 margin_ratio_exponent() const;
  inline void set_margin_ratio_exponent(::google::protobuf::int32 value);

  // optional sfixed32 start_date = 9;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 9;
  inline ::google::protobuf::int32 start_date() const;
  inline void set_start_date(::google::protobuf::int32 value);

  // optional .Common.TerminationTypeEnum termination_type = 10;
  inline bool has_termination_type() const;
  inline void clear_termination_type();
  static const int kTerminationTypeFieldNumber = 10;
  inline ::Common::TerminationTypeEnum termination_type() const;
  inline void set_termination_type(::Common::TerminationTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.FinancingDetails)
 private:
  inline void set_has_agreement_currency();
  inline void clear_has_agreement_currency();
  inline void set_has_agreement_date();
  inline void clear_has_agreement_date();
  inline void set_has_agreement_desc();
  inline void clear_has_agreement_desc();
  inline void set_has_agreement_id();
  inline void clear_has_agreement_id();
  inline void set_has_delivery_type();
  inline void clear_has_delivery_type();
  inline void set_has_end_date();
  inline void clear_has_end_date();
  inline void set_has_margin_ratio();
  inline void clear_has_margin_ratio();
  inline void set_has_margin_ratio_exponent();
  inline void clear_has_margin_ratio_exponent();
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_termination_type();
  inline void clear_has_termination_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* agreement_currency_;
  ::std::string* agreement_desc_;
  ::google::protobuf::int32 agreement_date_;
  int delivery_type_;
  ::std::string* agreement_id_;
  ::google::protobuf::int64 margin_ratio_;
  ::google::protobuf::int32 end_date_;
  ::google::protobuf::int32 margin_ratio_exponent_;
  ::google::protobuf::int32 start_date_;
  int termination_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static FinancingDetails* default_instance_;
};
// -------------------------------------------------------------------

class UndSecAltIdGrp : public ::google::protobuf::Message {
 public:
  UndSecAltIdGrp();
  virtual ~UndSecAltIdGrp();

  UndSecAltIdGrp(const UndSecAltIdGrp& from);

  inline UndSecAltIdGrp& operator=(const UndSecAltIdGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndSecAltIdGrp& default_instance();

  void Swap(UndSecAltIdGrp* other);

  // implements Message ----------------------------------------------

  UndSecAltIdGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndSecAltIdGrp& from);
  void MergeFrom(const UndSecAltIdGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string underlying_security_alt_id = 1;
  inline bool has_underlying_security_alt_id() const;
  inline void clear_underlying_security_alt_id();
  static const int kUnderlyingSecurityAltIdFieldNumber = 1;
  inline const ::std::string& underlying_security_alt_id() const;
  inline void set_underlying_security_alt_id(const ::std::string& value);
  inline void set_underlying_security_alt_id(const char* value);
  inline void set_underlying_security_alt_id(const char* value, size_t size);
  inline ::std::string* mutable_underlying_security_alt_id();
  inline ::std::string* release_underlying_security_alt_id();
  inline void set_allocated_underlying_security_alt_id(::std::string* underlying_security_alt_id);

  // optional string underlying_security_alt_id_source = 2;
  inline bool has_underlying_security_alt_id_source() const;
  inline void clear_underlying_security_alt_id_source();
  static const int kUnderlyingSecurityAltIdSourceFieldNumber = 2;
  inline const ::std::string& underlying_security_alt_id_source() const;
  inline void set_underlying_security_alt_id_source(const ::std::string& value);
  inline void set_underlying_security_alt_id_source(const char* value);
  inline void set_underlying_security_alt_id_source(const char* value, size_t size);
  inline ::std::string* mutable_underlying_security_alt_id_source();
  inline ::std::string* release_underlying_security_alt_id_source();
  inline void set_allocated_underlying_security_alt_id_source(::std::string* underlying_security_alt_id_source);

  // @@protoc_insertion_point(class_scope:Common.UndSecAltIdGrp)
 private:
  inline void set_has_underlying_security_alt_id();
  inline void clear_has_underlying_security_alt_id();
  inline void set_has_underlying_security_alt_id_source();
  inline void clear_has_underlying_security_alt_id_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* underlying_security_alt_id_;
  ::std::string* underlying_security_alt_id_source_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static UndSecAltIdGrp* default_instance_;
};
// -------------------------------------------------------------------

class UnderlyingStipulations : public ::google::protobuf::Message {
 public:
  UnderlyingStipulations();
  virtual ~UnderlyingStipulations();

  UnderlyingStipulations(const UnderlyingStipulations& from);

  inline UnderlyingStipulations& operator=(const UnderlyingStipulations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnderlyingStipulations& default_instance();

  void Swap(UnderlyingStipulations* other);

  // implements Message ----------------------------------------------

  UnderlyingStipulations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnderlyingStipulations& from);
  void MergeFrom(const UnderlyingStipulations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string underlying_stip_type = 1;
  inline bool has_underlying_stip_type() const;
  inline void clear_underlying_stip_type();
  static const int kUnderlyingStipTypeFieldNumber = 1;
  inline const ::std::string& underlying_stip_type() const;
  inline void set_underlying_stip_type(const ::std::string& value);
  inline void set_underlying_stip_type(const char* value);
  inline void set_underlying_stip_type(const char* value, size_t size);
  inline ::std::string* mutable_underlying_stip_type();
  inline ::std::string* release_underlying_stip_type();
  inline void set_allocated_underlying_stip_type(::std::string* underlying_stip_type);

  // optional string underlying_stip_value = 2;
  inline bool has_underlying_stip_value() const;
  inline void clear_underlying_stip_value();
  static const int kUnderlyingStipValueFieldNumber = 2;
  inline const ::std::string& underlying_stip_value() const;
  inline void set_underlying_stip_value(const ::std::string& value);
  inline void set_underlying_stip_value(const char* value);
  inline void set_underlying_stip_value(const char* value, size_t size);
  inline ::std::string* mutable_underlying_stip_value();
  inline ::std::string* release_underlying_stip_value();
  inline void set_allocated_underlying_stip_value(::std::string* underlying_stip_value);

  // @@protoc_insertion_point(class_scope:Common.UnderlyingStipulations)
 private:
  inline void set_has_underlying_stip_type();
  inline void clear_has_underlying_stip_type();
  inline void set_has_underlying_stip_value();
  inline void clear_has_underlying_stip_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* underlying_stip_type_;
  ::std::string* underlying_stip_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static UnderlyingStipulations* default_instance_;
};
// -------------------------------------------------------------------

class UndlyInstrumentPtysSubGrp : public ::google::protobuf::Message {
 public:
  UndlyInstrumentPtysSubGrp();
  virtual ~UndlyInstrumentPtysSubGrp();

  UndlyInstrumentPtysSubGrp(const UndlyInstrumentPtysSubGrp& from);

  inline UndlyInstrumentPtysSubGrp& operator=(const UndlyInstrumentPtysSubGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndlyInstrumentPtysSubGrp& default_instance();

  void Swap(UndlyInstrumentPtysSubGrp* other);

  // implements Message ----------------------------------------------

  UndlyInstrumentPtysSubGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndlyInstrumentPtysSubGrp& from);
  void MergeFrom(const UndlyInstrumentPtysSubGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string underlying_instrument_party_sub_id = 1;
  inline bool has_underlying_instrument_party_sub_id() const;
  inline void clear_underlying_instrument_party_sub_id();
  static const int kUnderlyingInstrumentPartySubIdFieldNumber = 1;
  inline const ::std::string& underlying_instrument_party_sub_id() const;
  inline void set_underlying_instrument_party_sub_id(const ::std::string& value);
  inline void set_underlying_instrument_party_sub_id(const char* value);
  inline void set_underlying_instrument_party_sub_id(const char* value, size_t size);
  inline ::std::string* mutable_underlying_instrument_party_sub_id();
  inline ::std::string* release_underlying_instrument_party_sub_id();
  inline void set_allocated_underlying_instrument_party_sub_id(::std::string* underlying_instrument_party_sub_id);

  // optional sfixed64 underlying_instrument_party_sub_id_type = 2;
  inline bool has_underlying_instrument_party_sub_id_type() const;
  inline void clear_underlying_instrument_party_sub_id_type();
  static const int kUnderlyingInstrumentPartySubIdTypeFieldNumber = 2;
  inline ::google::protobuf::int64 underlying_instrument_party_sub_id_type() const;
  inline void set_underlying_instrument_party_sub_id_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.UndlyInstrumentPtysSubGrp)
 private:
  inline void set_has_underlying_instrument_party_sub_id();
  inline void clear_has_underlying_instrument_party_sub_id();
  inline void set_has_underlying_instrument_party_sub_id_type();
  inline void clear_has_underlying_instrument_party_sub_id_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* underlying_instrument_party_sub_id_;
  ::google::protobuf::int64 underlying_instrument_party_sub_id_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static UndlyInstrumentPtysSubGrp* default_instance_;
};
// -------------------------------------------------------------------

class UndlyInstrumentParties : public ::google::protobuf::Message {
 public:
  UndlyInstrumentParties();
  virtual ~UndlyInstrumentParties();

  UndlyInstrumentParties(const UndlyInstrumentParties& from);

  inline UndlyInstrumentParties& operator=(const UndlyInstrumentParties& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndlyInstrumentParties& default_instance();

  void Swap(UndlyInstrumentParties* other);

  // implements Message ----------------------------------------------

  UndlyInstrumentParties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndlyInstrumentParties& from);
  void MergeFrom(const UndlyInstrumentParties& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string underlying_instrument_party_id = 1;
  inline bool has_underlying_instrument_party_id() const;
  inline void clear_underlying_instrument_party_id();
  static const int kUnderlyingInstrumentPartyIdFieldNumber = 1;
  inline const ::std::string& underlying_instrument_party_id() const;
  inline void set_underlying_instrument_party_id(const ::std::string& value);
  inline void set_underlying_instrument_party_id(const char* value);
  inline void set_underlying_instrument_party_id(const char* value, size_t size);
  inline ::std::string* mutable_underlying_instrument_party_id();
  inline ::std::string* release_underlying_instrument_party_id();
  inline void set_allocated_underlying_instrument_party_id(::std::string* underlying_instrument_party_id);

  // optional string underlying_instrument_party_id_source = 2;
  inline bool has_underlying_instrument_party_id_source() const;
  inline void clear_underlying_instrument_party_id_source();
  static const int kUnderlyingInstrumentPartyIdSourceFieldNumber = 2;
  inline const ::std::string& underlying_instrument_party_id_source() const;
  inline void set_underlying_instrument_party_id_source(const ::std::string& value);
  inline void set_underlying_instrument_party_id_source(const char* value);
  inline void set_underlying_instrument_party_id_source(const char* value, size_t size);
  inline ::std::string* mutable_underlying_instrument_party_id_source();
  inline ::std::string* release_underlying_instrument_party_id_source();
  inline void set_allocated_underlying_instrument_party_id_source(::std::string* underlying_instrument_party_id_source);

  // optional sfixed64 underlying_instrument_party_role = 3;
  inline bool has_underlying_instrument_party_role() const;
  inline void clear_underlying_instrument_party_role();
  static const int kUnderlyingInstrumentPartyRoleFieldNumber = 3;
  inline ::google::protobuf::int64 underlying_instrument_party_role() const;
  inline void set_underlying_instrument_party_role(::google::protobuf::int64 value);

  // repeated .Common.UndlyInstrumentPtysSubGrp undly_instrument_ptys_sub_grp = 4;
  inline int undly_instrument_ptys_sub_grp_size() const;
  inline void clear_undly_instrument_ptys_sub_grp();
  static const int kUndlyInstrumentPtysSubGrpFieldNumber = 4;
  inline const ::Common::UndlyInstrumentPtysSubGrp& undly_instrument_ptys_sub_grp(int index) const;
  inline ::Common::UndlyInstrumentPtysSubGrp* mutable_undly_instrument_ptys_sub_grp(int index);
  inline ::Common::UndlyInstrumentPtysSubGrp* add_undly_instrument_ptys_sub_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentPtysSubGrp >&
      undly_instrument_ptys_sub_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentPtysSubGrp >*
      mutable_undly_instrument_ptys_sub_grp();

  // @@protoc_insertion_point(class_scope:Common.UndlyInstrumentParties)
 private:
  inline void set_has_underlying_instrument_party_id();
  inline void clear_has_underlying_instrument_party_id();
  inline void set_has_underlying_instrument_party_id_source();
  inline void clear_has_underlying_instrument_party_id_source();
  inline void set_has_underlying_instrument_party_role();
  inline void clear_has_underlying_instrument_party_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* underlying_instrument_party_id_;
  ::std::string* underlying_instrument_party_id_source_;
  ::google::protobuf::int64 underlying_instrument_party_role_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentPtysSubGrp > undly_instrument_ptys_sub_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static UndlyInstrumentParties* default_instance_;
};
// -------------------------------------------------------------------

class UnderlyingFlowScheduleTypeUnion : public ::google::protobuf::Message {
 public:
  UnderlyingFlowScheduleTypeUnion();
  virtual ~UnderlyingFlowScheduleTypeUnion();

  UnderlyingFlowScheduleTypeUnion(const UnderlyingFlowScheduleTypeUnion& from);

  inline UnderlyingFlowScheduleTypeUnion& operator=(const UnderlyingFlowScheduleTypeUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnderlyingFlowScheduleTypeUnion& default_instance();

  void Swap(UnderlyingFlowScheduleTypeUnion* other);

  // implements Message ----------------------------------------------

  UnderlyingFlowScheduleTypeUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnderlyingFlowScheduleTypeUnion& from);
  void MergeFrom(const UnderlyingFlowScheduleTypeUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 underlying_flow_schedule_type = 1;
  inline bool has_underlying_flow_schedule_type() const;
  inline void clear_underlying_flow_schedule_type();
  static const int kUnderlyingFlowScheduleTypeFieldNumber = 1;
  inline ::google::protobuf::int64 underlying_flow_schedule_type() const;
  inline void set_underlying_flow_schedule_type(::google::protobuf::int64 value);

  // optional sfixed64 underlying_flow_schedule_type_sfixed64 = 2;
  inline bool has_underlying_flow_schedule_type_sfixed64() const;
  inline void clear_underlying_flow_schedule_type_sfixed64();
  static const int kUnderlyingFlowScheduleTypeSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 underlying_flow_schedule_type_sfixed64() const;
  inline void set_underlying_flow_schedule_type_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.UnderlyingFlowScheduleTypeUnion)
 private:
  inline void set_has_underlying_flow_schedule_type();
  inline void clear_has_underlying_flow_schedule_type();
  inline void set_has_underlying_flow_schedule_type_sfixed64();
  inline void clear_has_underlying_flow_schedule_type_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 underlying_flow_schedule_type_;
  ::google::protobuf::int64 underlying_flow_schedule_type_sfixed64_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static UnderlyingFlowScheduleTypeUnion* default_instance_;
};
// -------------------------------------------------------------------

class UnderlyingInstrument : public ::google::protobuf::Message {
 public:
  UnderlyingInstrument();
  virtual ~UnderlyingInstrument();

  UnderlyingInstrument(const UnderlyingInstrument& from);

  inline UnderlyingInstrument& operator=(const UnderlyingInstrument& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnderlyingInstrument& default_instance();

  void Swap(UnderlyingInstrument* other);

  // implements Message ----------------------------------------------

  UnderlyingInstrument* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UnderlyingInstrument& from);
  void MergeFrom(const UnderlyingInstrument& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes encoded_underlying_issuer = 1;
  inline bool has_encoded_underlying_issuer() const;
  inline void clear_encoded_underlying_issuer();
  static const int kEncodedUnderlyingIssuerFieldNumber = 1;
  inline const ::std::string& encoded_underlying_issuer() const;
  inline void set_encoded_underlying_issuer(const ::std::string& value);
  inline void set_encoded_underlying_issuer(const char* value);
  inline void set_encoded_underlying_issuer(const void* value, size_t size);
  inline ::std::string* mutable_encoded_underlying_issuer();
  inline ::std::string* release_encoded_underlying_issuer();
  inline void set_allocated_encoded_underlying_issuer(::std::string* encoded_underlying_issuer);

  // optional fixed32 encoded_underlying_issuer_len = 2;
  inline bool has_encoded_underlying_issuer_len() const;
  inline void clear_encoded_underlying_issuer_len();
  static const int kEncodedUnderlyingIssuerLenFieldNumber = 2;
  inline ::google::protobuf::uint32 encoded_underlying_issuer_len() const;
  inline void set_encoded_underlying_issuer_len(::google::protobuf::uint32 value);

  // optional bytes encoded_underlying_security_desc = 3;
  inline bool has_encoded_underlying_security_desc() const;
  inline void clear_encoded_underlying_security_desc();
  static const int kEncodedUnderlyingSecurityDescFieldNumber = 3;
  inline const ::std::string& encoded_underlying_security_desc() const;
  inline void set_encoded_underlying_security_desc(const ::std::string& value);
  inline void set_encoded_underlying_security_desc(const char* value);
  inline void set_encoded_underlying_security_desc(const void* value, size_t size);
  inline ::std::string* mutable_encoded_underlying_security_desc();
  inline ::std::string* release_encoded_underlying_security_desc();
  inline void set_allocated_encoded_underlying_security_desc(::std::string* encoded_underlying_security_desc);

  // optional fixed32 encoded_underlying_security_desc_len = 4;
  inline bool has_encoded_underlying_security_desc_len() const;
  inline void clear_encoded_underlying_security_desc_len();
  static const int kEncodedUnderlyingSecurityDescLenFieldNumber = 4;
  inline ::google::protobuf::uint32 encoded_underlying_security_desc_len() const;
  inline void set_encoded_underlying_security_desc_len(::google::protobuf::uint32 value);

  // optional string underlying_cfi_code = 5;
  inline bool has_underlying_cfi_code() const;
  inline void clear_underlying_cfi_code();
  static const int kUnderlyingCfiCodeFieldNumber = 5;
  inline const ::std::string& underlying_cfi_code() const;
  inline void set_underlying_cfi_code(const ::std::string& value);
  inline void set_underlying_cfi_code(const char* value);
  inline void set_underlying_cfi_code(const char* value, size_t size);
  inline ::std::string* mutable_underlying_cfi_code();
  inline ::std::string* release_underlying_cfi_code();
  inline void set_allocated_underlying_cfi_code(::std::string* underlying_cfi_code);

  // optional double underlying_contract_multiplier = 6;
  inline bool has_underlying_contract_multiplier() const;
  inline void clear_underlying_contract_multiplier();
  static const int kUnderlyingContractMultiplierFieldNumber = 6;
  inline double underlying_contract_multiplier() const;
  inline void set_underlying_contract_multiplier(double value);

  // optional string underlying_country_of_issue = 7;
  inline bool has_underlying_country_of_issue() const;
  inline void clear_underlying_country_of_issue();
  static const int kUnderlyingCountryOfIssueFieldNumber = 7;
  inline const ::std::string& underlying_country_of_issue() const;
  inline void set_underlying_country_of_issue(const ::std::string& value);
  inline void set_underlying_country_of_issue(const char* value);
  inline void set_underlying_country_of_issue(const char* value, size_t size);
  inline ::std::string* mutable_underlying_country_of_issue();
  inline ::std::string* release_underlying_country_of_issue();
  inline void set_allocated_underlying_country_of_issue(::std::string* underlying_country_of_issue);

  // optional sfixed32 underlying_coupon_payment_date = 8;
  inline bool has_underlying_coupon_payment_date() const;
  inline void clear_underlying_coupon_payment_date();
  static const int kUnderlyingCouponPaymentDateFieldNumber = 8;
  inline ::google::protobuf::int32 underlying_coupon_payment_date() const;
  inline void set_underlying_coupon_payment_date(::google::protobuf::int32 value);

  // optional sfixed64 underlying_coupon_rate = 9;
  inline bool has_underlying_coupon_rate() const;
  inline void clear_underlying_coupon_rate();
  static const int kUnderlyingCouponRateFieldNumber = 9;
  inline ::google::protobuf::int64 underlying_coupon_rate() const;
  inline void set_underlying_coupon_rate(::google::protobuf::int64 value);

  // optional sfixed32 underlying_coupon_rate_exponent = 10;
  inline bool has_underlying_coupon_rate_exponent() const;
  inline void clear_underlying_coupon_rate_exponent();
  static const int kUnderlyingCouponRateExponentFieldNumber = 10;
  inline ::google::protobuf::int32 underlying_coupon_rate_exponent() const;
  inline void set_underlying_coupon_rate_exponent(::google::protobuf::int32 value);

  // optional string underlying_credit_rating = 11;
  inline bool has_underlying_credit_rating() const;
  inline void clear_underlying_credit_rating();
  static const int kUnderlyingCreditRatingFieldNumber = 11;
  inline const ::std::string& underlying_credit_rating() const;
  inline void set_underlying_credit_rating(const ::std::string& value);
  inline void set_underlying_credit_rating(const char* value);
  inline void set_underlying_credit_rating(const char* value, size_t size);
  inline ::std::string* mutable_underlying_credit_rating();
  inline ::std::string* release_underlying_credit_rating();
  inline void set_allocated_underlying_credit_rating(::std::string* underlying_credit_rating);

  // optional double underlying_factor = 12;
  inline bool has_underlying_factor() const;
  inline void clear_underlying_factor();
  static const int kUnderlyingFactorFieldNumber = 12;
  inline double underlying_factor() const;
  inline void set_underlying_factor(double value);

  // optional string underlying_instr_registry = 13;
  inline bool has_underlying_instr_registry() const;
  inline void clear_underlying_instr_registry();
  static const int kUnderlyingInstrRegistryFieldNumber = 13;
  inline const ::std::string& underlying_instr_registry() const;
  inline void set_underlying_instr_registry(const ::std::string& value);
  inline void set_underlying_instr_registry(const char* value);
  inline void set_underlying_instr_registry(const char* value, size_t size);
  inline ::std::string* mutable_underlying_instr_registry();
  inline ::std::string* release_underlying_instr_registry();
  inline void set_allocated_underlying_instr_registry(::std::string* underlying_instr_registry);

  // optional sfixed32 underlying_issue_date = 14;
  inline bool has_underlying_issue_date() const;
  inline void clear_underlying_issue_date();
  static const int kUnderlyingIssueDateFieldNumber = 14;
  inline ::google::protobuf::int32 underlying_issue_date() const;
  inline void set_underlying_issue_date(::google::protobuf::int32 value);

  // optional string underlying_issuer = 15;
  inline bool has_underlying_issuer() const;
  inline void clear_underlying_issuer();
  static const int kUnderlyingIssuerFieldNumber = 15;
  inline const ::std::string& underlying_issuer() const;
  inline void set_underlying_issuer(const ::std::string& value);
  inline void set_underlying_issuer(const char* value);
  inline void set_underlying_issuer(const char* value, size_t size);
  inline ::std::string* mutable_underlying_issuer();
  inline ::std::string* release_underlying_issuer();
  inline void set_allocated_underlying_issuer(::std::string* underlying_issuer);

  // optional string underlying_locale_of_issue = 16;
  inline bool has_underlying_locale_of_issue() const;
  inline void clear_underlying_locale_of_issue();
  static const int kUnderlyingLocaleOfIssueFieldNumber = 16;
  inline const ::std::string& underlying_locale_of_issue() const;
  inline void set_underlying_locale_of_issue(const ::std::string& value);
  inline void set_underlying_locale_of_issue(const char* value);
  inline void set_underlying_locale_of_issue(const char* value, size_t size);
  inline ::std::string* mutable_underlying_locale_of_issue();
  inline ::std::string* release_underlying_locale_of_issue();
  inline void set_allocated_underlying_locale_of_issue(::std::string* underlying_locale_of_issue);

  // optional sfixed32 underlying_maturity_date = 17;
  inline bool has_underlying_maturity_date() const;
  inline void clear_underlying_maturity_date();
  static const int kUnderlyingMaturityDateFieldNumber = 17;
  inline ::google::protobuf::int32 underlying_maturity_date() const;
  inline void set_underlying_maturity_date(::google::protobuf::int32 value);

  // optional sfixed32 underlying_maturity_month_year = 18;
  inline bool has_underlying_maturity_month_year() const;
  inline void clear_underlying_maturity_month_year();
  static const int kUnderlyingMaturityMonthYearFieldNumber = 18;
  inline ::google::protobuf::int32 underlying_maturity_month_year() const;
  inline void set_underlying_maturity_month_year(::google::protobuf::int32 value);

  // optional string underlying_opt_attribute = 19;
  inline bool has_underlying_opt_attribute() const;
  inline void clear_underlying_opt_attribute();
  static const int kUnderlyingOptAttributeFieldNumber = 19;
  inline const ::std::string& underlying_opt_attribute() const;
  inline void set_underlying_opt_attribute(const ::std::string& value);
  inline void set_underlying_opt_attribute(const char* value);
  inline void set_underlying_opt_attribute(const char* value, size_t size);
  inline ::std::string* mutable_underlying_opt_attribute();
  inline ::std::string* release_underlying_opt_attribute();
  inline void set_allocated_underlying_opt_attribute(::std::string* underlying_opt_attribute);

  // optional sfixed64 underlying_product = 20;
  inline bool has_underlying_product() const;
  inline void clear_underlying_product();
  static const int kUnderlyingProductFieldNumber = 20;
  inline ::google::protobuf::int64 underlying_product() const;
  inline void set_underlying_product(::google::protobuf::int64 value);

  // optional sfixed64 underlying_put_or_call = 21;
  inline bool has_underlying_put_or_call() const;
  inline void clear_underlying_put_or_call();
  static const int kUnderlyingPutOrCallFieldNumber = 21;
  inline ::google::protobuf::int64 underlying_put_or_call() const;
  inline void set_underlying_put_or_call(::google::protobuf::int64 value);

  // optional sfixed32 underlying_redemption_date = 22;
  inline bool has_underlying_redemption_date() const;
  inline void clear_underlying_redemption_date();
  static const int kUnderlyingRedemptionDateFieldNumber = 22;
  inline ::google::protobuf::int32 underlying_redemption_date() const;
  inline void set_underlying_redemption_date(::google::protobuf::int32 value);

  // optional string underlying_repo_collateral_security_type = 23;
  inline bool has_underlying_repo_collateral_security_type() const;
  inline void clear_underlying_repo_collateral_security_type();
  static const int kUnderlyingRepoCollateralSecurityTypeFieldNumber = 23;
  inline const ::std::string& underlying_repo_collateral_security_type() const;
  inline void set_underlying_repo_collateral_security_type(const ::std::string& value);
  inline void set_underlying_repo_collateral_security_type(const char* value);
  inline void set_underlying_repo_collateral_security_type(const char* value, size_t size);
  inline ::std::string* mutable_underlying_repo_collateral_security_type();
  inline ::std::string* release_underlying_repo_collateral_security_type();
  inline void set_allocated_underlying_repo_collateral_security_type(::std::string* underlying_repo_collateral_security_type);

  // optional sfixed64 underlying_repurchase_rate = 24;
  inline bool has_underlying_repurchase_rate() const;
  inline void clear_underlying_repurchase_rate();
  static const int kUnderlyingRepurchaseRateFieldNumber = 24;
  inline ::google::protobuf::int64 underlying_repurchase_rate() const;
  inline void set_underlying_repurchase_rate(::google::protobuf::int64 value);

  // optional sfixed32 underlying_repurchase_rate_exponent = 25;
  inline bool has_underlying_repurchase_rate_exponent() const;
  inline void clear_underlying_repurchase_rate_exponent();
  static const int kUnderlyingRepurchaseRateExponentFieldNumber = 25;
  inline ::google::protobuf::int32 underlying_repurchase_rate_exponent() const;
  inline void set_underlying_repurchase_rate_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_repurchase_term = 26;
  inline bool has_underlying_repurchase_term() const;
  inline void clear_underlying_repurchase_term();
  static const int kUnderlyingRepurchaseTermFieldNumber = 26;
  inline ::google::protobuf::int64 underlying_repurchase_term() const;
  inline void set_underlying_repurchase_term(::google::protobuf::int64 value);

  // optional string underlying_security_desc = 27;
  inline bool has_underlying_security_desc() const;
  inline void clear_underlying_security_desc();
  static const int kUnderlyingSecurityDescFieldNumber = 27;
  inline const ::std::string& underlying_security_desc() const;
  inline void set_underlying_security_desc(const ::std::string& value);
  inline void set_underlying_security_desc(const char* value);
  inline void set_underlying_security_desc(const char* value, size_t size);
  inline ::std::string* mutable_underlying_security_desc();
  inline ::std::string* release_underlying_security_desc();
  inline void set_allocated_underlying_security_desc(::std::string* underlying_security_desc);

  // optional string underlying_security_exchange = 28;
  inline bool has_underlying_security_exchange() const;
  inline void clear_underlying_security_exchange();
  static const int kUnderlyingSecurityExchangeFieldNumber = 28;
  inline const ::std::string& underlying_security_exchange() const;
  inline void set_underlying_security_exchange(const ::std::string& value);
  inline void set_underlying_security_exchange(const char* value);
  inline void set_underlying_security_exchange(const char* value, size_t size);
  inline ::std::string* mutable_underlying_security_exchange();
  inline ::std::string* release_underlying_security_exchange();
  inline void set_allocated_underlying_security_exchange(::std::string* underlying_security_exchange);

  // optional string underlying_security_id = 29;
  inline bool has_underlying_security_id() const;
  inline void clear_underlying_security_id();
  static const int kUnderlyingSecurityIdFieldNumber = 29;
  inline const ::std::string& underlying_security_id() const;
  inline void set_underlying_security_id(const ::std::string& value);
  inline void set_underlying_security_id(const char* value);
  inline void set_underlying_security_id(const char* value, size_t size);
  inline ::std::string* mutable_underlying_security_id();
  inline ::std::string* release_underlying_security_id();
  inline void set_allocated_underlying_security_id(::std::string* underlying_security_id);

  // optional string underlying_security_id_source = 30;
  inline bool has_underlying_security_id_source() const;
  inline void clear_underlying_security_id_source();
  static const int kUnderlyingSecurityIdSourceFieldNumber = 30;
  inline const ::std::string& underlying_security_id_source() const;
  inline void set_underlying_security_id_source(const ::std::string& value);
  inline void set_underlying_security_id_source(const char* value);
  inline void set_underlying_security_id_source(const char* value, size_t size);
  inline ::std::string* mutable_underlying_security_id_source();
  inline ::std::string* release_underlying_security_id_source();
  inline void set_allocated_underlying_security_id_source(::std::string* underlying_security_id_source);

  // optional string underlying_security_type = 31;
  inline bool has_underlying_security_type() const;
  inline void clear_underlying_security_type();
  static const int kUnderlyingSecurityTypeFieldNumber = 31;
  inline const ::std::string& underlying_security_type() const;
  inline void set_underlying_security_type(const ::std::string& value);
  inline void set_underlying_security_type(const char* value);
  inline void set_underlying_security_type(const char* value, size_t size);
  inline ::std::string* mutable_underlying_security_type();
  inline ::std::string* release_underlying_security_type();
  inline void set_allocated_underlying_security_type(::std::string* underlying_security_type);

  // optional string underlying_state_or_province_of_issue = 32;
  inline bool has_underlying_state_or_province_of_issue() const;
  inline void clear_underlying_state_or_province_of_issue();
  static const int kUnderlyingStateOrProvinceOfIssueFieldNumber = 32;
  inline const ::std::string& underlying_state_or_province_of_issue() const;
  inline void set_underlying_state_or_province_of_issue(const ::std::string& value);
  inline void set_underlying_state_or_province_of_issue(const char* value);
  inline void set_underlying_state_or_province_of_issue(const char* value, size_t size);
  inline ::std::string* mutable_underlying_state_or_province_of_issue();
  inline ::std::string* release_underlying_state_or_province_of_issue();
  inline void set_allocated_underlying_state_or_province_of_issue(::std::string* underlying_state_or_province_of_issue);

  // optional sfixed64 underlying_strike_price = 33;
  inline bool has_underlying_strike_price() const;
  inline void clear_underlying_strike_price();
  static const int kUnderlyingStrikePriceFieldNumber = 33;
  inline ::google::protobuf::int64 underlying_strike_price() const;
  inline void set_underlying_strike_price(::google::protobuf::int64 value);

  // optional sfixed32 underlying_strike_price_exponent = 34;
  inline bool has_underlying_strike_price_exponent() const;
  inline void clear_underlying_strike_price_exponent();
  static const int kUnderlyingStrikePriceExponentFieldNumber = 34;
  inline ::google::protobuf::int32 underlying_strike_price_exponent() const;
  inline void set_underlying_strike_price_exponent(::google::protobuf::int32 value);

  // optional string underlying_symbol = 35;
  inline bool has_underlying_symbol() const;
  inline void clear_underlying_symbol();
  static const int kUnderlyingSymbolFieldNumber = 35;
  inline const ::std::string& underlying_symbol() const;
  inline void set_underlying_symbol(const ::std::string& value);
  inline void set_underlying_symbol(const char* value);
  inline void set_underlying_symbol(const char* value, size_t size);
  inline ::std::string* mutable_underlying_symbol();
  inline ::std::string* release_underlying_symbol();
  inline void set_allocated_underlying_symbol(::std::string* underlying_symbol);

  // optional string underlying_symbol_sfx = 36;
  inline bool has_underlying_symbol_sfx() const;
  inline void clear_underlying_symbol_sfx();
  static const int kUnderlyingSymbolSfxFieldNumber = 36;
  inline const ::std::string& underlying_symbol_sfx() const;
  inline void set_underlying_symbol_sfx(const ::std::string& value);
  inline void set_underlying_symbol_sfx(const char* value);
  inline void set_underlying_symbol_sfx(const char* value, size_t size);
  inline ::std::string* mutable_underlying_symbol_sfx();
  inline ::std::string* release_underlying_symbol_sfx();
  inline void set_allocated_underlying_symbol_sfx(::std::string* underlying_symbol_sfx);

  // repeated .Common.UndSecAltIdGrp und_sec_alt_id_grp = 37;
  inline int und_sec_alt_id_grp_size() const;
  inline void clear_und_sec_alt_id_grp();
  static const int kUndSecAltIdGrpFieldNumber = 37;
  inline const ::Common::UndSecAltIdGrp& und_sec_alt_id_grp(int index) const;
  inline ::Common::UndSecAltIdGrp* mutable_und_sec_alt_id_grp(int index);
  inline ::Common::UndSecAltIdGrp* add_und_sec_alt_id_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndSecAltIdGrp >&
      und_sec_alt_id_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndSecAltIdGrp >*
      mutable_und_sec_alt_id_grp();

  // optional sfixed64 underlying_adjusted_quantity = 38;
  inline bool has_underlying_adjusted_quantity() const;
  inline void clear_underlying_adjusted_quantity();
  static const int kUnderlyingAdjustedQuantityFieldNumber = 38;
  inline ::google::protobuf::int64 underlying_adjusted_quantity() const;
  inline void set_underlying_adjusted_quantity(::google::protobuf::int64 value);

  // optional sfixed32 underlying_adjusted_quantity_exponent = 39;
  inline bool has_underlying_adjusted_quantity_exponent() const;
  inline void clear_underlying_adjusted_quantity_exponent();
  static const int kUnderlyingAdjustedQuantityExponentFieldNumber = 39;
  inline ::google::protobuf::int32 underlying_adjusted_quantity_exponent() const;
  inline void set_underlying_adjusted_quantity_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_allocation_percent = 40;
  inline bool has_underlying_allocation_percent() const;
  inline void clear_underlying_allocation_percent();
  static const int kUnderlyingAllocationPercentFieldNumber = 40;
  inline ::google::protobuf::int64 underlying_allocation_percent() const;
  inline void set_underlying_allocation_percent(::google::protobuf::int64 value);

  // optional sfixed32 underlying_allocation_percent_exponent = 41;
  inline bool has_underlying_allocation_percent_exponent() const;
  inline void clear_underlying_allocation_percent_exponent();
  static const int kUnderlyingAllocationPercentExponentFieldNumber = 41;
  inline ::google::protobuf::int32 underlying_allocation_percent_exponent() const;
  inline void set_underlying_allocation_percent_exponent(::google::protobuf::int32 value);

  // optional string underlying_cp_program = 42;
  inline bool has_underlying_cp_program() const;
  inline void clear_underlying_cp_program();
  static const int kUnderlyingCpProgramFieldNumber = 42;
  inline const ::std::string& underlying_cp_program() const;
  inline void set_underlying_cp_program(const ::std::string& value);
  inline void set_underlying_cp_program(const char* value);
  inline void set_underlying_cp_program(const char* value, size_t size);
  inline ::std::string* mutable_underlying_cp_program();
  inline ::std::string* release_underlying_cp_program();
  inline void set_allocated_underlying_cp_program(::std::string* underlying_cp_program);

  // optional string underlying_cp_reg_type = 43;
  inline bool has_underlying_cp_reg_type() const;
  inline void clear_underlying_cp_reg_type();
  static const int kUnderlyingCpRegTypeFieldNumber = 43;
  inline const ::std::string& underlying_cp_reg_type() const;
  inline void set_underlying_cp_reg_type(const ::std::string& value);
  inline void set_underlying_cp_reg_type(const char* value);
  inline void set_underlying_cp_reg_type(const char* value, size_t size);
  inline ::std::string* mutable_underlying_cp_reg_type();
  inline ::std::string* release_underlying_cp_reg_type();
  inline void set_allocated_underlying_cp_reg_type(::std::string* underlying_cp_reg_type);

  // optional sfixed64 underlying_cap_value = 44;
  inline bool has_underlying_cap_value() const;
  inline void clear_underlying_cap_value();
  static const int kUnderlyingCapValueFieldNumber = 44;
  inline ::google::protobuf::int64 underlying_cap_value() const;
  inline void set_underlying_cap_value(::google::protobuf::int64 value);

  // optional sfixed32 underlying_cap_value_exponent = 45;
  inline bool has_underlying_cap_value_exponent() const;
  inline void clear_underlying_cap_value_exponent();
  static const int kUnderlyingCapValueExponentFieldNumber = 45;
  inline ::google::protobuf::int32 underlying_cap_value_exponent() const;
  inline void set_underlying_cap_value_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_cash_amount = 46;
  inline bool has_underlying_cash_amount() const;
  inline void clear_underlying_cash_amount();
  static const int kUnderlyingCashAmountFieldNumber = 46;
  inline ::google::protobuf::int64 underlying_cash_amount() const;
  inline void set_underlying_cash_amount(::google::protobuf::int64 value);

  // optional sfixed32 underlying_cash_amount_exponent = 47;
  inline bool has_underlying_cash_amount_exponent() const;
  inline void clear_underlying_cash_amount_exponent();
  static const int kUnderlyingCashAmountExponentFieldNumber = 47;
  inline ::google::protobuf::int32 underlying_cash_amount_exponent() const;
  inline void set_underlying_cash_amount_exponent(::google::protobuf::int32 value);

  // optional .Common.UnderlyingCashTypeEnum underlying_cash_type = 48;
  inline bool has_underlying_cash_type() const;
  inline void clear_underlying_cash_type();
  static const int kUnderlyingCashTypeFieldNumber = 48;
  inline ::Common::UnderlyingCashTypeEnum underlying_cash_type() const;
  inline void set_underlying_cash_type(::Common::UnderlyingCashTypeEnum value);

  // optional string underlying_currency = 49;
  inline bool has_underlying_currency() const;
  inline void clear_underlying_currency();
  static const int kUnderlyingCurrencyFieldNumber = 49;
  inline const ::std::string& underlying_currency() const;
  inline void set_underlying_currency(const ::std::string& value);
  inline void set_underlying_currency(const char* value);
  inline void set_underlying_currency(const char* value, size_t size);
  inline ::std::string* mutable_underlying_currency();
  inline ::std::string* release_underlying_currency();
  inline void set_allocated_underlying_currency(::std::string* underlying_currency);

  // optional sfixed64 underlying_current_value = 50;
  inline bool has_underlying_current_value() const;
  inline void clear_underlying_current_value();
  static const int kUnderlyingCurrentValueFieldNumber = 50;
  inline ::google::protobuf::int64 underlying_current_value() const;
  inline void set_underlying_current_value(::google::protobuf::int64 value);

  // optional sfixed32 underlying_current_value_exponent = 51;
  inline bool has_underlying_current_value_exponent() const;
  inline void clear_underlying_current_value_exponent();
  static const int kUnderlyingCurrentValueExponentFieldNumber = 51;
  inline ::google::protobuf::int32 underlying_current_value_exponent() const;
  inline void set_underlying_current_value_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_dirty_price = 52;
  inline bool has_underlying_dirty_price() const;
  inline void clear_underlying_dirty_price();
  static const int kUnderlyingDirtyPriceFieldNumber = 52;
  inline ::google::protobuf::int64 underlying_dirty_price() const;
  inline void set_underlying_dirty_price(::google::protobuf::int64 value);

  // optional sfixed32 underlying_dirty_price_exponent = 53;
  inline bool has_underlying_dirty_price_exponent() const;
  inline void clear_underlying_dirty_price_exponent();
  static const int kUnderlyingDirtyPriceExponentFieldNumber = 53;
  inline ::google::protobuf::int32 underlying_dirty_price_exponent() const;
  inline void set_underlying_dirty_price_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_end_price = 54;
  inline bool has_underlying_end_price() const;
  inline void clear_underlying_end_price();
  static const int kUnderlyingEndPriceFieldNumber = 54;
  inline ::google::protobuf::int64 underlying_end_price() const;
  inline void set_underlying_end_price(::google::protobuf::int64 value);

  // optional sfixed32 underlying_end_price_exponent = 55;
  inline bool has_underlying_end_price_exponent() const;
  inline void clear_underlying_end_price_exponent();
  static const int kUnderlyingEndPriceExponentFieldNumber = 55;
  inline ::google::protobuf::int32 underlying_end_price_exponent() const;
  inline void set_underlying_end_price_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_end_value = 56;
  inline bool has_underlying_end_value() const;
  inline void clear_underlying_end_value();
  static const int kUnderlyingEndValueFieldNumber = 56;
  inline ::google::protobuf::int64 underlying_end_value() const;
  inline void set_underlying_end_value(::google::protobuf::int64 value);

  // optional sfixed32 underlying_end_value_exponent = 57;
  inline bool has_underlying_end_value_exponent() const;
  inline void clear_underlying_end_value_exponent();
  static const int kUnderlyingEndValueExponentFieldNumber = 57;
  inline ::google::protobuf::int32 underlying_end_value_exponent() const;
  inline void set_underlying_end_value_exponent(::google::protobuf::int32 value);

  // optional double underlying_fx_rate = 58;
  inline bool has_underlying_fx_rate() const;
  inline void clear_underlying_fx_rate();
  static const int kUnderlyingFxRateFieldNumber = 58;
  inline double underlying_fx_rate() const;
  inline void set_underlying_fx_rate(double value);

  // optional .Common.UnderlyingFxRateCalcEnum underlying_fx_rate_calc = 59;
  inline bool has_underlying_fx_rate_calc() const;
  inline void clear_underlying_fx_rate_calc();
  static const int kUnderlyingFxRateCalcFieldNumber = 59;
  inline ::Common::UnderlyingFxRateCalcEnum underlying_fx_rate_calc() const;
  inline void set_underlying_fx_rate_calc(::Common::UnderlyingFxRateCalcEnum value);

  // optional sfixed64 underlying_px = 60;
  inline bool has_underlying_px() const;
  inline void clear_underlying_px();
  static const int kUnderlyingPxFieldNumber = 60;
  inline ::google::protobuf::int64 underlying_px() const;
  inline void set_underlying_px(::google::protobuf::int64 value);

  // optional sfixed32 underlying_px_exponent = 61;
  inline bool has_underlying_px_exponent() const;
  inline void clear_underlying_px_exponent();
  static const int kUnderlyingPxExponentFieldNumber = 61;
  inline ::google::protobuf::int32 underlying_px_exponent() const;
  inline void set_underlying_px_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_qty = 62;
  inline bool has_underlying_qty() const;
  inline void clear_underlying_qty();
  static const int kUnderlyingQtyFieldNumber = 62;
  inline ::google::protobuf::int64 underlying_qty() const;
  inline void set_underlying_qty(::google::protobuf::int64 value);

  // optional sfixed32 underlying_qty_exponent = 63;
  inline bool has_underlying_qty_exponent() const;
  inline void clear_underlying_qty_exponent();
  static const int kUnderlyingQtyExponentFieldNumber = 63;
  inline ::google::protobuf::int32 underlying_qty_exponent() const;
  inline void set_underlying_qty_exponent(::google::protobuf::int32 value);

  // optional string underlying_security_sub_type = 64;
  inline bool has_underlying_security_sub_type() const;
  inline void clear_underlying_security_sub_type();
  static const int kUnderlyingSecuritySubTypeFieldNumber = 64;
  inline const ::std::string& underlying_security_sub_type() const;
  inline void set_underlying_security_sub_type(const ::std::string& value);
  inline void set_underlying_security_sub_type(const char* value);
  inline void set_underlying_security_sub_type(const char* value, size_t size);
  inline ::std::string* mutable_underlying_security_sub_type();
  inline ::std::string* release_underlying_security_sub_type();
  inline void set_allocated_underlying_security_sub_type(::std::string* underlying_security_sub_type);

  // optional string underlying_settl_method = 65;
  inline bool has_underlying_settl_method() const;
  inline void clear_underlying_settl_method();
  static const int kUnderlyingSettlMethodFieldNumber = 65;
  inline const ::std::string& underlying_settl_method() const;
  inline void set_underlying_settl_method(const ::std::string& value);
  inline void set_underlying_settl_method(const char* value);
  inline void set_underlying_settl_method(const char* value, size_t size);
  inline ::std::string* mutable_underlying_settl_method();
  inline ::std::string* release_underlying_settl_method();
  inline void set_allocated_underlying_settl_method(::std::string* underlying_settl_method);

  // optional .Common.UnderlyingSettlementTypeEnum underlying_settlement_type = 66;
  inline bool has_underlying_settlement_type() const;
  inline void clear_underlying_settlement_type();
  static const int kUnderlyingSettlementTypeFieldNumber = 66;
  inline ::Common::UnderlyingSettlementTypeEnum underlying_settlement_type() const;
  inline void set_underlying_settlement_type(::Common::UnderlyingSettlementTypeEnum value);

  // optional sfixed64 underlying_start_value = 67;
  inline bool has_underlying_start_value() const;
  inline void clear_underlying_start_value();
  static const int kUnderlyingStartValueFieldNumber = 67;
  inline ::google::protobuf::int64 underlying_start_value() const;
  inline void set_underlying_start_value(::google::protobuf::int64 value);

  // optional sfixed32 underlying_start_value_exponent = 68;
  inline bool has_underlying_start_value_exponent() const;
  inline void clear_underlying_start_value_exponent();
  static const int kUnderlyingStartValueExponentFieldNumber = 68;
  inline ::google::protobuf::int32 underlying_start_value_exponent() const;
  inline void set_underlying_start_value_exponent(::google::protobuf::int32 value);

  // repeated .Common.UnderlyingStipulations underlying_stipulations = 69;
  inline int underlying_stipulations_size() const;
  inline void clear_underlying_stipulations();
  static const int kUnderlyingStipulationsFieldNumber = 69;
  inline const ::Common::UnderlyingStipulations& underlying_stipulations(int index) const;
  inline ::Common::UnderlyingStipulations* mutable_underlying_stipulations(int index);
  inline ::Common::UnderlyingStipulations* add_underlying_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UnderlyingStipulations >&
      underlying_stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UnderlyingStipulations >*
      mutable_underlying_stipulations();

  // optional string underlying_strike_currency = 70;
  inline bool has_underlying_strike_currency() const;
  inline void clear_underlying_strike_currency();
  static const int kUnderlyingStrikeCurrencyFieldNumber = 70;
  inline const ::std::string& underlying_strike_currency() const;
  inline void set_underlying_strike_currency(const ::std::string& value);
  inline void set_underlying_strike_currency(const char* value);
  inline void set_underlying_strike_currency(const char* value, size_t size);
  inline ::std::string* mutable_underlying_strike_currency();
  inline ::std::string* release_underlying_strike_currency();
  inline void set_allocated_underlying_strike_currency(::std::string* underlying_strike_currency);

  // optional string underlying_time_unit = 71;
  inline bool has_underlying_time_unit() const;
  inline void clear_underlying_time_unit();
  static const int kUnderlyingTimeUnitFieldNumber = 71;
  inline const ::std::string& underlying_time_unit() const;
  inline void set_underlying_time_unit(const ::std::string& value);
  inline void set_underlying_time_unit(const char* value);
  inline void set_underlying_time_unit(const char* value, size_t size);
  inline ::std::string* mutable_underlying_time_unit();
  inline ::std::string* release_underlying_time_unit();
  inline void set_allocated_underlying_time_unit(::std::string* underlying_time_unit);

  // optional string underlying_unit_of_measure = 72;
  inline bool has_underlying_unit_of_measure() const;
  inline void clear_underlying_unit_of_measure();
  static const int kUnderlyingUnitOfMeasureFieldNumber = 72;
  inline const ::std::string& underlying_unit_of_measure() const;
  inline void set_underlying_unit_of_measure(const ::std::string& value);
  inline void set_underlying_unit_of_measure(const char* value);
  inline void set_underlying_unit_of_measure(const char* value, size_t size);
  inline ::std::string* mutable_underlying_unit_of_measure();
  inline ::std::string* release_underlying_unit_of_measure();
  inline void set_allocated_underlying_unit_of_measure(::std::string* underlying_unit_of_measure);

  // repeated .Common.UndlyInstrumentParties undly_instrument_parties = 73;
  inline int undly_instrument_parties_size() const;
  inline void clear_undly_instrument_parties();
  static const int kUndlyInstrumentPartiesFieldNumber = 73;
  inline const ::Common::UndlyInstrumentParties& undly_instrument_parties(int index) const;
  inline ::Common::UndlyInstrumentParties* mutable_undly_instrument_parties(int index);
  inline ::Common::UndlyInstrumentParties* add_undly_instrument_parties();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentParties >&
      undly_instrument_parties() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentParties >*
      mutable_undly_instrument_parties();

  // optional sfixed64 underlying_exercise_style = 74;
  inline bool has_underlying_exercise_style() const;
  inline void clear_underlying_exercise_style();
  static const int kUnderlyingExerciseStyleFieldNumber = 74;
  inline ::google::protobuf::int64 underlying_exercise_style() const;
  inline void set_underlying_exercise_style(::google::protobuf::int64 value);

  // optional string underlying_maturity_time = 75;
  inline bool has_underlying_maturity_time() const;
  inline void clear_underlying_maturity_time();
  static const int kUnderlyingMaturityTimeFieldNumber = 75;
  inline const ::std::string& underlying_maturity_time() const;
  inline void set_underlying_maturity_time(const ::std::string& value);
  inline void set_underlying_maturity_time(const char* value);
  inline void set_underlying_maturity_time(const char* value, size_t size);
  inline ::std::string* mutable_underlying_maturity_time();
  inline ::std::string* release_underlying_maturity_time();
  inline void set_allocated_underlying_maturity_time(::std::string* underlying_maturity_time);

  // optional string underlying_price_unit_of_measure = 76;
  inline bool has_underlying_price_unit_of_measure() const;
  inline void clear_underlying_price_unit_of_measure();
  static const int kUnderlyingPriceUnitOfMeasureFieldNumber = 76;
  inline const ::std::string& underlying_price_unit_of_measure() const;
  inline void set_underlying_price_unit_of_measure(const ::std::string& value);
  inline void set_underlying_price_unit_of_measure(const char* value);
  inline void set_underlying_price_unit_of_measure(const char* value, size_t size);
  inline ::std::string* mutable_underlying_price_unit_of_measure();
  inline ::std::string* release_underlying_price_unit_of_measure();
  inline void set_allocated_underlying_price_unit_of_measure(::std::string* underlying_price_unit_of_measure);

  // optional sfixed64 underlying_price_unit_of_measure_qty = 77;
  inline bool has_underlying_price_unit_of_measure_qty() const;
  inline void clear_underlying_price_unit_of_measure_qty();
  static const int kUnderlyingPriceUnitOfMeasureQtyFieldNumber = 77;
  inline ::google::protobuf::int64 underlying_price_unit_of_measure_qty() const;
  inline void set_underlying_price_unit_of_measure_qty(::google::protobuf::int64 value);

  // optional sfixed32 underlying_price_unit_of_measure_qty_exponent = 78;
  inline bool has_underlying_price_unit_of_measure_qty_exponent() const;
  inline void clear_underlying_price_unit_of_measure_qty_exponent();
  static const int kUnderlyingPriceUnitOfMeasureQtyExponentFieldNumber = 78;
  inline ::google::protobuf::int32 underlying_price_unit_of_measure_qty_exponent() const;
  inline void set_underlying_price_unit_of_measure_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_unit_of_measure_qty = 79;
  inline bool has_underlying_unit_of_measure_qty() const;
  inline void clear_underlying_unit_of_measure_qty();
  static const int kUnderlyingUnitOfMeasureQtyFieldNumber = 79;
  inline ::google::protobuf::int64 underlying_unit_of_measure_qty() const;
  inline void set_underlying_unit_of_measure_qty(::google::protobuf::int64 value);

  // optional sfixed32 underlying_unit_of_measure_qty_exponent = 80;
  inline bool has_underlying_unit_of_measure_qty_exponent() const;
  inline void clear_underlying_unit_of_measure_qty_exponent();
  static const int kUnderlyingUnitOfMeasureQtyExponentFieldNumber = 80;
  inline ::google::protobuf::int32 underlying_unit_of_measure_qty_exponent() const;
  inline void set_underlying_unit_of_measure_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_contract_multiplier_unit = 81;
  inline bool has_underlying_contract_multiplier_unit() const;
  inline void clear_underlying_contract_multiplier_unit();
  static const int kUnderlyingContractMultiplierUnitFieldNumber = 81;
  inline ::google::protobuf::int64 underlying_contract_multiplier_unit() const;
  inline void set_underlying_contract_multiplier_unit(::google::protobuf::int64 value);

  // optional sfixed64 underlying_flow_schedule_type = 82;
  inline bool has_underlying_flow_schedule_type() const;
  inline void clear_underlying_flow_schedule_type();
  static const int kUnderlyingFlowScheduleTypeFieldNumber = 82;
  inline ::google::protobuf::int64 underlying_flow_schedule_type() const;
  inline void set_underlying_flow_schedule_type(::google::protobuf::int64 value);

  // optional sfixed64 underlying_attachment_point = 83;
  inline bool has_underlying_attachment_point() const;
  inline void clear_underlying_attachment_point();
  static const int kUnderlyingAttachmentPointFieldNumber = 83;
  inline ::google::protobuf::int64 underlying_attachment_point() const;
  inline void set_underlying_attachment_point(::google::protobuf::int64 value);

  // optional sfixed32 underlying_attachment_point_exponent = 84;
  inline bool has_underlying_attachment_point_exponent() const;
  inline void clear_underlying_attachment_point_exponent();
  static const int kUnderlyingAttachmentPointExponentFieldNumber = 84;
  inline ::google::protobuf::int32 underlying_attachment_point_exponent() const;
  inline void set_underlying_attachment_point_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_detachment_point = 85;
  inline bool has_underlying_detachment_point() const;
  inline void clear_underlying_detachment_point();
  static const int kUnderlyingDetachmentPointFieldNumber = 85;
  inline ::google::protobuf::int64 underlying_detachment_point() const;
  inline void set_underlying_detachment_point(::google::protobuf::int64 value);

  // optional sfixed32 underlying_detachment_point_exponent = 86;
  inline bool has_underlying_detachment_point_exponent() const;
  inline void clear_underlying_detachment_point_exponent();
  static const int kUnderlyingDetachmentPointExponentFieldNumber = 86;
  inline ::google::protobuf::int32 underlying_detachment_point_exponent() const;
  inline void set_underlying_detachment_point_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_notional_percentage_outstanding = 87;
  inline bool has_underlying_notional_percentage_outstanding() const;
  inline void clear_underlying_notional_percentage_outstanding();
  static const int kUnderlyingNotionalPercentageOutstandingFieldNumber = 87;
  inline ::google::protobuf::int64 underlying_notional_percentage_outstanding() const;
  inline void set_underlying_notional_percentage_outstanding(::google::protobuf::int64 value);

  // optional sfixed32 underlying_notional_percentage_outstanding_exponent = 88;
  inline bool has_underlying_notional_percentage_outstanding_exponent() const;
  inline void clear_underlying_notional_percentage_outstanding_exponent();
  static const int kUnderlyingNotionalPercentageOutstandingExponentFieldNumber = 88;
  inline ::google::protobuf::int32 underlying_notional_percentage_outstanding_exponent() const;
  inline void set_underlying_notional_percentage_outstanding_exponent(::google::protobuf::int32 value);

  // optional sfixed64 underlying_original_notional_percentage_outstanding = 89;
  inline bool has_underlying_original_notional_percentage_outstanding() const;
  inline void clear_underlying_original_notional_percentage_outstanding();
  static const int kUnderlyingOriginalNotionalPercentageOutstandingFieldNumber = 89;
  inline ::google::protobuf::int64 underlying_original_notional_percentage_outstanding() const;
  inline void set_underlying_original_notional_percentage_outstanding(::google::protobuf::int64 value);

  // optional sfixed32 underlying_original_notional_percentage_outstanding_exponent = 90;
  inline bool has_underlying_original_notional_percentage_outstanding_exponent() const;
  inline void clear_underlying_original_notional_percentage_outstanding_exponent();
  static const int kUnderlyingOriginalNotionalPercentageOutstandingExponentFieldNumber = 90;
  inline ::google::protobuf::int32 underlying_original_notional_percentage_outstanding_exponent() const;
  inline void set_underlying_original_notional_percentage_outstanding_exponent(::google::protobuf::int32 value);

  // optional string underlying_restructuring_type = 91;
  inline bool has_underlying_restructuring_type() const;
  inline void clear_underlying_restructuring_type();
  static const int kUnderlyingRestructuringTypeFieldNumber = 91;
  inline const ::std::string& underlying_restructuring_type() const;
  inline void set_underlying_restructuring_type(const ::std::string& value);
  inline void set_underlying_restructuring_type(const char* value);
  inline void set_underlying_restructuring_type(const char* value, size_t size);
  inline ::std::string* mutable_underlying_restructuring_type();
  inline ::std::string* release_underlying_restructuring_type();
  inline void set_allocated_underlying_restructuring_type(::std::string* underlying_restructuring_type);

  // optional string underlying_seniority = 92;
  inline bool has_underlying_seniority() const;
  inline void clear_underlying_seniority();
  static const int kUnderlyingSeniorityFieldNumber = 92;
  inline const ::std::string& underlying_seniority() const;
  inline void set_underlying_seniority(const ::std::string& value);
  inline void set_underlying_seniority(const char* value);
  inline void set_underlying_seniority(const char* value, size_t size);
  inline ::std::string* mutable_underlying_seniority();
  inline ::std::string* release_underlying_seniority();
  inline void set_allocated_underlying_seniority(::std::string* underlying_seniority);

  // @@protoc_insertion_point(class_scope:Common.UnderlyingInstrument)
 private:
  inline void set_has_encoded_underlying_issuer();
  inline void clear_has_encoded_underlying_issuer();
  inline void set_has_encoded_underlying_issuer_len();
  inline void clear_has_encoded_underlying_issuer_len();
  inline void set_has_encoded_underlying_security_desc();
  inline void clear_has_encoded_underlying_security_desc();
  inline void set_has_encoded_underlying_security_desc_len();
  inline void clear_has_encoded_underlying_security_desc_len();
  inline void set_has_underlying_cfi_code();
  inline void clear_has_underlying_cfi_code();
  inline void set_has_underlying_contract_multiplier();
  inline void clear_has_underlying_contract_multiplier();
  inline void set_has_underlying_country_of_issue();
  inline void clear_has_underlying_country_of_issue();
  inline void set_has_underlying_coupon_payment_date();
  inline void clear_has_underlying_coupon_payment_date();
  inline void set_has_underlying_coupon_rate();
  inline void clear_has_underlying_coupon_rate();
  inline void set_has_underlying_coupon_rate_exponent();
  inline void clear_has_underlying_coupon_rate_exponent();
  inline void set_has_underlying_credit_rating();
  inline void clear_has_underlying_credit_rating();
  inline void set_has_underlying_factor();
  inline void clear_has_underlying_factor();
  inline void set_has_underlying_instr_registry();
  inline void clear_has_underlying_instr_registry();
  inline void set_has_underlying_issue_date();
  inline void clear_has_underlying_issue_date();
  inline void set_has_underlying_issuer();
  inline void clear_has_underlying_issuer();
  inline void set_has_underlying_locale_of_issue();
  inline void clear_has_underlying_locale_of_issue();
  inline void set_has_underlying_maturity_date();
  inline void clear_has_underlying_maturity_date();
  inline void set_has_underlying_maturity_month_year();
  inline void clear_has_underlying_maturity_month_year();
  inline void set_has_underlying_opt_attribute();
  inline void clear_has_underlying_opt_attribute();
  inline void set_has_underlying_product();
  inline void clear_has_underlying_product();
  inline void set_has_underlying_put_or_call();
  inline void clear_has_underlying_put_or_call();
  inline void set_has_underlying_redemption_date();
  inline void clear_has_underlying_redemption_date();
  inline void set_has_underlying_repo_collateral_security_type();
  inline void clear_has_underlying_repo_collateral_security_type();
  inline void set_has_underlying_repurchase_rate();
  inline void clear_has_underlying_repurchase_rate();
  inline void set_has_underlying_repurchase_rate_exponent();
  inline void clear_has_underlying_repurchase_rate_exponent();
  inline void set_has_underlying_repurchase_term();
  inline void clear_has_underlying_repurchase_term();
  inline void set_has_underlying_security_desc();
  inline void clear_has_underlying_security_desc();
  inline void set_has_underlying_security_exchange();
  inline void clear_has_underlying_security_exchange();
  inline void set_has_underlying_security_id();
  inline void clear_has_underlying_security_id();
  inline void set_has_underlying_security_id_source();
  inline void clear_has_underlying_security_id_source();
  inline void set_has_underlying_security_type();
  inline void clear_has_underlying_security_type();
  inline void set_has_underlying_state_or_province_of_issue();
  inline void clear_has_underlying_state_or_province_of_issue();
  inline void set_has_underlying_strike_price();
  inline void clear_has_underlying_strike_price();
  inline void set_has_underlying_strike_price_exponent();
  inline void clear_has_underlying_strike_price_exponent();
  inline void set_has_underlying_symbol();
  inline void clear_has_underlying_symbol();
  inline void set_has_underlying_symbol_sfx();
  inline void clear_has_underlying_symbol_sfx();
  inline void set_has_underlying_adjusted_quantity();
  inline void clear_has_underlying_adjusted_quantity();
  inline void set_has_underlying_adjusted_quantity_exponent();
  inline void clear_has_underlying_adjusted_quantity_exponent();
  inline void set_has_underlying_allocation_percent();
  inline void clear_has_underlying_allocation_percent();
  inline void set_has_underlying_allocation_percent_exponent();
  inline void clear_has_underlying_allocation_percent_exponent();
  inline void set_has_underlying_cp_program();
  inline void clear_has_underlying_cp_program();
  inline void set_has_underlying_cp_reg_type();
  inline void clear_has_underlying_cp_reg_type();
  inline void set_has_underlying_cap_value();
  inline void clear_has_underlying_cap_value();
  inline void set_has_underlying_cap_value_exponent();
  inline void clear_has_underlying_cap_value_exponent();
  inline void set_has_underlying_cash_amount();
  inline void clear_has_underlying_cash_amount();
  inline void set_has_underlying_cash_amount_exponent();
  inline void clear_has_underlying_cash_amount_exponent();
  inline void set_has_underlying_cash_type();
  inline void clear_has_underlying_cash_type();
  inline void set_has_underlying_currency();
  inline void clear_has_underlying_currency();
  inline void set_has_underlying_current_value();
  inline void clear_has_underlying_current_value();
  inline void set_has_underlying_current_value_exponent();
  inline void clear_has_underlying_current_value_exponent();
  inline void set_has_underlying_dirty_price();
  inline void clear_has_underlying_dirty_price();
  inline void set_has_underlying_dirty_price_exponent();
  inline void clear_has_underlying_dirty_price_exponent();
  inline void set_has_underlying_end_price();
  inline void clear_has_underlying_end_price();
  inline void set_has_underlying_end_price_exponent();
  inline void clear_has_underlying_end_price_exponent();
  inline void set_has_underlying_end_value();
  inline void clear_has_underlying_end_value();
  inline void set_has_underlying_end_value_exponent();
  inline void clear_has_underlying_end_value_exponent();
  inline void set_has_underlying_fx_rate();
  inline void clear_has_underlying_fx_rate();
  inline void set_has_underlying_fx_rate_calc();
  inline void clear_has_underlying_fx_rate_calc();
  inline void set_has_underlying_px();
  inline void clear_has_underlying_px();
  inline void set_has_underlying_px_exponent();
  inline void clear_has_underlying_px_exponent();
  inline void set_has_underlying_qty();
  inline void clear_has_underlying_qty();
  inline void set_has_underlying_qty_exponent();
  inline void clear_has_underlying_qty_exponent();
  inline void set_has_underlying_security_sub_type();
  inline void clear_has_underlying_security_sub_type();
  inline void set_has_underlying_settl_method();
  inline void clear_has_underlying_settl_method();
  inline void set_has_underlying_settlement_type();
  inline void clear_has_underlying_settlement_type();
  inline void set_has_underlying_start_value();
  inline void clear_has_underlying_start_value();
  inline void set_has_underlying_start_value_exponent();
  inline void clear_has_underlying_start_value_exponent();
  inline void set_has_underlying_strike_currency();
  inline void clear_has_underlying_strike_currency();
  inline void set_has_underlying_time_unit();
  inline void clear_has_underlying_time_unit();
  inline void set_has_underlying_unit_of_measure();
  inline void clear_has_underlying_unit_of_measure();
  inline void set_has_underlying_exercise_style();
  inline void clear_has_underlying_exercise_style();
  inline void set_has_underlying_maturity_time();
  inline void clear_has_underlying_maturity_time();
  inline void set_has_underlying_price_unit_of_measure();
  inline void clear_has_underlying_price_unit_of_measure();
  inline void set_has_underlying_price_unit_of_measure_qty();
  inline void clear_has_underlying_price_unit_of_measure_qty();
  inline void set_has_underlying_price_unit_of_measure_qty_exponent();
  inline void clear_has_underlying_price_unit_of_measure_qty_exponent();
  inline void set_has_underlying_unit_of_measure_qty();
  inline void clear_has_underlying_unit_of_measure_qty();
  inline void set_has_underlying_unit_of_measure_qty_exponent();
  inline void clear_has_underlying_unit_of_measure_qty_exponent();
  inline void set_has_underlying_contract_multiplier_unit();
  inline void clear_has_underlying_contract_multiplier_unit();
  inline void set_has_underlying_flow_schedule_type();
  inline void clear_has_underlying_flow_schedule_type();
  inline void set_has_underlying_attachment_point();
  inline void clear_has_underlying_attachment_point();
  inline void set_has_underlying_attachment_point_exponent();
  inline void clear_has_underlying_attachment_point_exponent();
  inline void set_has_underlying_detachment_point();
  inline void clear_has_underlying_detachment_point();
  inline void set_has_underlying_detachment_point_exponent();
  inline void clear_has_underlying_detachment_point_exponent();
  inline void set_has_underlying_notional_percentage_outstanding();
  inline void clear_has_underlying_notional_percentage_outstanding();
  inline void set_has_underlying_notional_percentage_outstanding_exponent();
  inline void clear_has_underlying_notional_percentage_outstanding_exponent();
  inline void set_has_underlying_original_notional_percentage_outstanding();
  inline void clear_has_underlying_original_notional_percentage_outstanding();
  inline void set_has_underlying_original_notional_percentage_outstanding_exponent();
  inline void clear_has_underlying_original_notional_percentage_outstanding_exponent();
  inline void set_has_underlying_restructuring_type();
  inline void clear_has_underlying_restructuring_type();
  inline void set_has_underlying_seniority();
  inline void clear_has_underlying_seniority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encoded_underlying_issuer_;
  ::std::string* encoded_underlying_security_desc_;
  ::google::protobuf::uint32 encoded_underlying_issuer_len_;
  ::google::protobuf::uint32 encoded_underlying_security_desc_len_;
  ::std::string* underlying_cfi_code_;
  double underlying_contract_multiplier_;
  ::std::string* underlying_country_of_issue_;
  ::google::protobuf::int64 underlying_coupon_rate_;
  ::google::protobuf::int32 underlying_coupon_payment_date_;
  ::google::protobuf::int32 underlying_coupon_rate_exponent_;
  ::std::string* underlying_credit_rating_;
  double underlying_factor_;
  ::std::string* underlying_instr_registry_;
  ::std::string* underlying_issuer_;
  ::google::protobuf::int32 underlying_issue_date_;
  ::google::protobuf::int32 underlying_maturity_date_;
  ::std::string* underlying_locale_of_issue_;
  ::std::string* underlying_opt_attribute_;
  ::google::protobuf::int32 underlying_maturity_month_year_;
  ::google::protobuf::int32 underlying_redemption_date_;
  ::google::protobuf::int64 underlying_product_;
  ::google::protobuf::int64 underlying_put_or_call_;
  ::std::string* underlying_repo_collateral_security_type_;
  ::google::protobuf::int64 underlying_repurchase_rate_;
  ::google::protobuf::int64 underlying_repurchase_term_;
  ::std::string* underlying_security_desc_;
  ::std::string* underlying_security_exchange_;
  ::std::string* underlying_security_id_;
  ::google::protobuf::int32 underlying_repurchase_rate_exponent_;
  ::google::protobuf::int32 underlying_strike_price_exponent_;
  ::std::string* underlying_security_id_source_;
  ::std::string* underlying_security_type_;
  ::std::string* underlying_state_or_province_of_issue_;
  ::google::protobuf::int64 underlying_strike_price_;
  ::std::string* underlying_symbol_;
  ::std::string* underlying_symbol_sfx_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndSecAltIdGrp > und_sec_alt_id_grp_;
  ::google::protobuf::int64 underlying_adjusted_quantity_;
  ::google::protobuf::int64 underlying_allocation_percent_;
  ::google::protobuf::int32 underlying_adjusted_quantity_exponent_;
  ::google::protobuf::int32 underlying_allocation_percent_exponent_;
  ::std::string* underlying_cp_program_;
  ::std::string* underlying_cp_reg_type_;
  ::google::protobuf::int64 underlying_cap_value_;
  ::google::protobuf::int32 underlying_cap_value_exponent_;
  ::google::protobuf::int32 underlying_cash_amount_exponent_;
  ::google::protobuf::int64 underlying_cash_amount_;
  ::std::string* underlying_currency_;
  int underlying_cash_type_;
  ::google::protobuf::int32 underlying_current_value_exponent_;
  ::google::protobuf::int64 underlying_current_value_;
  ::google::protobuf::int64 underlying_dirty_price_;
  ::google::protobuf::int64 underlying_end_price_;
  ::google::protobuf::int32 underlying_dirty_price_exponent_;
  ::google::protobuf::int32 underlying_end_price_exponent_;
  ::google::protobuf::int64 underlying_end_value_;
  double underlying_fx_rate_;
  ::google::protobuf::int32 underlying_end_value_exponent_;
  int underlying_fx_rate_calc_;
  ::google::protobuf::int64 underlying_px_;
  ::google::protobuf::int32 underlying_px_exponent_;
  ::google::protobuf::int32 underlying_qty_exponent_;
  ::google::protobuf::int64 underlying_qty_;
  ::std::string* underlying_security_sub_type_;
  ::std::string* underlying_settl_method_;
  int underlying_settlement_type_;
  ::google::protobuf::int32 underlying_start_value_exponent_;
  ::google::protobuf::int64 underlying_start_value_;
  ::google::protobuf::RepeatedPtrField< ::Common::UnderlyingStipulations > underlying_stipulations_;
  ::std::string* underlying_strike_currency_;
  ::std::string* underlying_time_unit_;
  ::std::string* underlying_unit_of_measure_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentParties > undly_instrument_parties_;
  ::google::protobuf::int64 underlying_exercise_style_;
  ::std::string* underlying_maturity_time_;
  ::std::string* underlying_price_unit_of_measure_;
  ::google::protobuf::int64 underlying_price_unit_of_measure_qty_;
  ::google::protobuf::int64 underlying_unit_of_measure_qty_;
  ::google::protobuf::int32 underlying_price_unit_of_measure_qty_exponent_;
  ::google::protobuf::int32 underlying_unit_of_measure_qty_exponent_;
  ::google::protobuf::int64 underlying_contract_multiplier_unit_;
  ::google::protobuf::int64 underlying_flow_schedule_type_;
  ::google::protobuf::int64 underlying_attachment_point_;
  ::google::protobuf::int64 underlying_detachment_point_;
  ::google::protobuf::int32 underlying_attachment_point_exponent_;
  ::google::protobuf::int32 underlying_detachment_point_exponent_;
  ::google::protobuf::int64 underlying_notional_percentage_outstanding_;
  ::google::protobuf::int64 underlying_original_notional_percentage_outstanding_;
  ::google::protobuf::int32 underlying_notional_percentage_outstanding_exponent_;
  ::google::protobuf::int32 underlying_original_notional_percentage_outstanding_exponent_;
  ::std::string* underlying_restructuring_type_;
  ::std::string* underlying_seniority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(92 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static UnderlyingInstrument* default_instance_;
};
// -------------------------------------------------------------------

class UndInstrmtGrp : public ::google::protobuf::Message {
 public:
  UndInstrmtGrp();
  virtual ~UndInstrmtGrp();

  UndInstrmtGrp(const UndInstrmtGrp& from);

  inline UndInstrmtGrp& operator=(const UndInstrmtGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UndInstrmtGrp& default_instance();

  void Swap(UndInstrmtGrp* other);

  // implements Message ----------------------------------------------

  UndInstrmtGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UndInstrmtGrp& from);
  void MergeFrom(const UndInstrmtGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.UnderlyingInstrument underlying_instrument = 1;
  inline bool has_underlying_instrument() const;
  inline void clear_underlying_instrument();
  static const int kUnderlyingInstrumentFieldNumber = 1;
  inline const ::Common::UnderlyingInstrument& underlying_instrument() const;
  inline ::Common::UnderlyingInstrument* mutable_underlying_instrument();
  inline ::Common::UnderlyingInstrument* release_underlying_instrument();
  inline void set_allocated_underlying_instrument(::Common::UnderlyingInstrument* underlying_instrument);

  // @@protoc_insertion_point(class_scope:Common.UndInstrmtGrp)
 private:
  inline void set_has_underlying_instrument();
  inline void clear_has_underlying_instrument();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Common::UnderlyingInstrument* underlying_instrument_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static UndInstrmtGrp* default_instance_;
};
// -------------------------------------------------------------------

class Stipulations : public ::google::protobuf::Message {
 public:
  Stipulations();
  virtual ~Stipulations();

  Stipulations(const Stipulations& from);

  inline Stipulations& operator=(const Stipulations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stipulations& default_instance();

  void Swap(Stipulations* other);

  // implements Message ----------------------------------------------

  Stipulations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stipulations& from);
  void MergeFrom(const Stipulations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.StipulationTypeEnum stipulation_type = 1;
  inline bool has_stipulation_type() const;
  inline void clear_stipulation_type();
  static const int kStipulationTypeFieldNumber = 1;
  inline ::Common::StipulationTypeEnum stipulation_type() const;
  inline void set_stipulation_type(::Common::StipulationTypeEnum value);

  // optional string stipulation_value = 2;
  inline bool has_stipulation_value() const;
  inline void clear_stipulation_value();
  static const int kStipulationValueFieldNumber = 2;
  inline const ::std::string& stipulation_value() const;
  inline void set_stipulation_value(const ::std::string& value);
  inline void set_stipulation_value(const char* value);
  inline void set_stipulation_value(const char* value, size_t size);
  inline ::std::string* mutable_stipulation_value();
  inline ::std::string* release_stipulation_value();
  inline void set_allocated_stipulation_value(::std::string* stipulation_value);

  // @@protoc_insertion_point(class_scope:Common.Stipulations)
 private:
  inline void set_has_stipulation_type();
  inline void clear_has_stipulation_type();
  inline void set_has_stipulation_value();
  inline void clear_has_stipulation_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stipulation_value_;
  int stipulation_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static Stipulations* default_instance_;
};
// -------------------------------------------------------------------

class OrderQtyData : public ::google::protobuf::Message {
 public:
  OrderQtyData();
  virtual ~OrderQtyData();

  OrderQtyData(const OrderQtyData& from);

  inline OrderQtyData& operator=(const OrderQtyData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderQtyData& default_instance();

  void Swap(OrderQtyData* other);

  // implements Message ----------------------------------------------

  OrderQtyData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrderQtyData& from);
  void MergeFrom(const OrderQtyData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 cash_order_qty = 1;
  inline bool has_cash_order_qty() const;
  inline void clear_cash_order_qty();
  static const int kCashOrderQtyFieldNumber = 1;
  inline ::google::protobuf::int64 cash_order_qty() const;
  inline void set_cash_order_qty(::google::protobuf::int64 value);

  // optional sfixed32 cash_order_qty_exponent = 2;
  inline bool has_cash_order_qty_exponent() const;
  inline void clear_cash_order_qty_exponent();
  static const int kCashOrderQtyExponentFieldNumber = 2;
  inline ::google::protobuf::int32 cash_order_qty_exponent() const;
  inline void set_cash_order_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 order_percent = 3;
  inline bool has_order_percent() const;
  inline void clear_order_percent();
  static const int kOrderPercentFieldNumber = 3;
  inline ::google::protobuf::int64 order_percent() const;
  inline void set_order_percent(::google::protobuf::int64 value);

  // optional sfixed32 order_percent_exponent = 4;
  inline bool has_order_percent_exponent() const;
  inline void clear_order_percent_exponent();
  static const int kOrderPercentExponentFieldNumber = 4;
  inline ::google::protobuf::int32 order_percent_exponent() const;
  inline void set_order_percent_exponent(::google::protobuf::int32 value);

  // optional sfixed64 order_qty = 5;
  inline bool has_order_qty() const;
  inline void clear_order_qty();
  static const int kOrderQtyFieldNumber = 5;
  inline ::google::protobuf::int64 order_qty() const;
  inline void set_order_qty(::google::protobuf::int64 value);

  // optional sfixed32 order_qty_exponent = 6;
  inline bool has_order_qty_exponent() const;
  inline void clear_order_qty_exponent();
  static const int kOrderQtyExponentFieldNumber = 6;
  inline ::google::protobuf::int32 order_qty_exponent() const;
  inline void set_order_qty_exponent(::google::protobuf::int32 value);

  // optional .Common.RoundingDirectionEnum rounding_direction = 7;
  inline bool has_rounding_direction() const;
  inline void clear_rounding_direction();
  static const int kRoundingDirectionFieldNumber = 7;
  inline ::Common::RoundingDirectionEnum rounding_direction() const;
  inline void set_rounding_direction(::Common::RoundingDirectionEnum value);

  // optional double rounding_modulus = 8;
  inline bool has_rounding_modulus() const;
  inline void clear_rounding_modulus();
  static const int kRoundingModulusFieldNumber = 8;
  inline double rounding_modulus() const;
  inline void set_rounding_modulus(double value);

  // @@protoc_insertion_point(class_scope:Common.OrderQtyData)
 private:
  inline void set_has_cash_order_qty();
  inline void clear_has_cash_order_qty();
  inline void set_has_cash_order_qty_exponent();
  inline void clear_has_cash_order_qty_exponent();
  inline void set_has_order_percent();
  inline void clear_has_order_percent();
  inline void set_has_order_percent_exponent();
  inline void clear_has_order_percent_exponent();
  inline void set_has_order_qty();
  inline void clear_has_order_qty();
  inline void set_has_order_qty_exponent();
  inline void clear_has_order_qty_exponent();
  inline void set_has_rounding_direction();
  inline void clear_has_rounding_direction();
  inline void set_has_rounding_modulus();
  inline void clear_has_rounding_modulus();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 cash_order_qty_;
  ::google::protobuf::int64 order_percent_;
  ::google::protobuf::int32 cash_order_qty_exponent_;
  ::google::protobuf::int32 order_percent_exponent_;
  ::google::protobuf::int64 order_qty_;
  ::google::protobuf::int32 order_qty_exponent_;
  int rounding_direction_;
  double rounding_modulus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static OrderQtyData* default_instance_;
};
// -------------------------------------------------------------------

class TriggeringInstruction : public ::google::protobuf::Message {
 public:
  TriggeringInstruction();
  virtual ~TriggeringInstruction();

  TriggeringInstruction(const TriggeringInstruction& from);

  inline TriggeringInstruction& operator=(const TriggeringInstruction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TriggeringInstruction& default_instance();

  void Swap(TriggeringInstruction* other);

  // implements Message ----------------------------------------------

  TriggeringInstruction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TriggeringInstruction& from);
  void MergeFrom(const TriggeringInstruction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.TriggerActionEnum trigger_action = 1;
  inline bool has_trigger_action() const;
  inline void clear_trigger_action();
  static const int kTriggerActionFieldNumber = 1;
  inline ::Common::TriggerActionEnum trigger_action() const;
  inline void set_trigger_action(::Common::TriggerActionEnum value);

  // optional sfixed64 trigger_new_price = 2;
  inline bool has_trigger_new_price() const;
  inline void clear_trigger_new_price();
  static const int kTriggerNewPriceFieldNumber = 2;
  inline ::google::protobuf::int64 trigger_new_price() const;
  inline void set_trigger_new_price(::google::protobuf::int64 value);

  // optional sfixed32 trigger_new_price_exponent = 3;
  inline bool has_trigger_new_price_exponent() const;
  inline void clear_trigger_new_price_exponent();
  static const int kTriggerNewPriceExponentFieldNumber = 3;
  inline ::google::protobuf::int32 trigger_new_price_exponent() const;
  inline void set_trigger_new_price_exponent(::google::protobuf::int32 value);

  // optional sfixed64 trigger_new_qty = 4;
  inline bool has_trigger_new_qty() const;
  inline void clear_trigger_new_qty();
  static const int kTriggerNewQtyFieldNumber = 4;
  inline ::google::protobuf::int64 trigger_new_qty() const;
  inline void set_trigger_new_qty(::google::protobuf::int64 value);

  // optional sfixed32 trigger_new_qty_exponent = 5;
  inline bool has_trigger_new_qty_exponent() const;
  inline void clear_trigger_new_qty_exponent();
  static const int kTriggerNewQtyExponentFieldNumber = 5;
  inline ::google::protobuf::int32 trigger_new_qty_exponent() const;
  inline void set_trigger_new_qty_exponent(::google::protobuf::int32 value);

  // optional .Common.TriggerOrderTypeEnum trigger_order_type = 6;
  inline bool has_trigger_order_type() const;
  inline void clear_trigger_order_type();
  static const int kTriggerOrderTypeFieldNumber = 6;
  inline ::Common::TriggerOrderTypeEnum trigger_order_type() const;
  inline void set_trigger_order_type(::Common::TriggerOrderTypeEnum value);

  // optional sfixed64 trigger_price = 7;
  inline bool has_trigger_price() const;
  inline void clear_trigger_price();
  static const int kTriggerPriceFieldNumber = 7;
  inline ::google::protobuf::int64 trigger_price() const;
  inline void set_trigger_price(::google::protobuf::int64 value);

  // optional sfixed32 trigger_price_exponent = 8;
  inline bool has_trigger_price_exponent() const;
  inline void clear_trigger_price_exponent();
  static const int kTriggerPriceExponentFieldNumber = 8;
  inline ::google::protobuf::int32 trigger_price_exponent() const;
  inline void set_trigger_price_exponent(::google::protobuf::int32 value);

  // optional .Common.TriggerPriceDirectionEnum trigger_price_direction = 9;
  inline bool has_trigger_price_direction() const;
  inline void clear_trigger_price_direction();
  static const int kTriggerPriceDirectionFieldNumber = 9;
  inline ::Common::TriggerPriceDirectionEnum trigger_price_direction() const;
  inline void set_trigger_price_direction(::Common::TriggerPriceDirectionEnum value);

  // optional .Common.TriggerPriceTypeEnum trigger_price_type = 10;
  inline bool has_trigger_price_type() const;
  inline void clear_trigger_price_type();
  static const int kTriggerPriceTypeFieldNumber = 10;
  inline ::Common::TriggerPriceTypeEnum trigger_price_type() const;
  inline void set_trigger_price_type(::Common::TriggerPriceTypeEnum value);

  // optional .Common.TriggerPriceTypeScopeEnum trigger_price_type_scope = 11;
  inline bool has_trigger_price_type_scope() const;
  inline void clear_trigger_price_type_scope();
  static const int kTriggerPriceTypeScopeFieldNumber = 11;
  inline ::Common::TriggerPriceTypeScopeEnum trigger_price_type_scope() const;
  inline void set_trigger_price_type_scope(::Common::TriggerPriceTypeScopeEnum value);

  // optional string trigger_security_desc = 12;
  inline bool has_trigger_security_desc() const;
  inline void clear_trigger_security_desc();
  static const int kTriggerSecurityDescFieldNumber = 12;
  inline const ::std::string& trigger_security_desc() const;
  inline void set_trigger_security_desc(const ::std::string& value);
  inline void set_trigger_security_desc(const char* value);
  inline void set_trigger_security_desc(const char* value, size_t size);
  inline ::std::string* mutable_trigger_security_desc();
  inline ::std::string* release_trigger_security_desc();
  inline void set_allocated_trigger_security_desc(::std::string* trigger_security_desc);

  // optional string trigger_security_id = 13;
  inline bool has_trigger_security_id() const;
  inline void clear_trigger_security_id();
  static const int kTriggerSecurityIdFieldNumber = 13;
  inline const ::std::string& trigger_security_id() const;
  inline void set_trigger_security_id(const ::std::string& value);
  inline void set_trigger_security_id(const char* value);
  inline void set_trigger_security_id(const char* value, size_t size);
  inline ::std::string* mutable_trigger_security_id();
  inline ::std::string* release_trigger_security_id();
  inline void set_allocated_trigger_security_id(::std::string* trigger_security_id);

  // optional string trigger_security_id_source = 14;
  inline bool has_trigger_security_id_source() const;
  inline void clear_trigger_security_id_source();
  static const int kTriggerSecurityIdSourceFieldNumber = 14;
  inline const ::std::string& trigger_security_id_source() const;
  inline void set_trigger_security_id_source(const ::std::string& value);
  inline void set_trigger_security_id_source(const char* value);
  inline void set_trigger_security_id_source(const char* value, size_t size);
  inline ::std::string* mutable_trigger_security_id_source();
  inline ::std::string* release_trigger_security_id_source();
  inline void set_allocated_trigger_security_id_source(::std::string* trigger_security_id_source);

  // optional string trigger_symbol = 15;
  inline bool has_trigger_symbol() const;
  inline void clear_trigger_symbol();
  static const int kTriggerSymbolFieldNumber = 15;
  inline const ::std::string& trigger_symbol() const;
  inline void set_trigger_symbol(const ::std::string& value);
  inline void set_trigger_symbol(const char* value);
  inline void set_trigger_symbol(const char* value, size_t size);
  inline ::std::string* mutable_trigger_symbol();
  inline ::std::string* release_trigger_symbol();
  inline void set_allocated_trigger_symbol(::std::string* trigger_symbol);

  // optional string trigger_trading_session_id = 16;
  inline bool has_trigger_trading_session_id() const;
  inline void clear_trigger_trading_session_id();
  static const int kTriggerTradingSessionIdFieldNumber = 16;
  inline const ::std::string& trigger_trading_session_id() const;
  inline void set_trigger_trading_session_id(const ::std::string& value);
  inline void set_trigger_trading_session_id(const char* value);
  inline void set_trigger_trading_session_id(const char* value, size_t size);
  inline ::std::string* mutable_trigger_trading_session_id();
  inline ::std::string* release_trigger_trading_session_id();
  inline void set_allocated_trigger_trading_session_id(::std::string* trigger_trading_session_id);

  // optional string trigger_trading_session_sub_id = 17;
  inline bool has_trigger_trading_session_sub_id() const;
  inline void clear_trigger_trading_session_sub_id();
  static const int kTriggerTradingSessionSubIdFieldNumber = 17;
  inline const ::std::string& trigger_trading_session_sub_id() const;
  inline void set_trigger_trading_session_sub_id(const ::std::string& value);
  inline void set_trigger_trading_session_sub_id(const char* value);
  inline void set_trigger_trading_session_sub_id(const char* value, size_t size);
  inline ::std::string* mutable_trigger_trading_session_sub_id();
  inline ::std::string* release_trigger_trading_session_sub_id();
  inline void set_allocated_trigger_trading_session_sub_id(::std::string* trigger_trading_session_sub_id);

  // optional .Common.TriggerTypeEnum trigger_type = 18;
  inline bool has_trigger_type() const;
  inline void clear_trigger_type();
  static const int kTriggerTypeFieldNumber = 18;
  inline ::Common::TriggerTypeEnum trigger_type() const;
  inline void set_trigger_type(::Common::TriggerTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.TriggeringInstruction)
 private:
  inline void set_has_trigger_action();
  inline void clear_has_trigger_action();
  inline void set_has_trigger_new_price();
  inline void clear_has_trigger_new_price();
  inline void set_has_trigger_new_price_exponent();
  inline void clear_has_trigger_new_price_exponent();
  inline void set_has_trigger_new_qty();
  inline void clear_has_trigger_new_qty();
  inline void set_has_trigger_new_qty_exponent();
  inline void clear_has_trigger_new_qty_exponent();
  inline void set_has_trigger_order_type();
  inline void clear_has_trigger_order_type();
  inline void set_has_trigger_price();
  inline void clear_has_trigger_price();
  inline void set_has_trigger_price_exponent();
  inline void clear_has_trigger_price_exponent();
  inline void set_has_trigger_price_direction();
  inline void clear_has_trigger_price_direction();
  inline void set_has_trigger_price_type();
  inline void clear_has_trigger_price_type();
  inline void set_has_trigger_price_type_scope();
  inline void clear_has_trigger_price_type_scope();
  inline void set_has_trigger_security_desc();
  inline void clear_has_trigger_security_desc();
  inline void set_has_trigger_security_id();
  inline void clear_has_trigger_security_id();
  inline void set_has_trigger_security_id_source();
  inline void clear_has_trigger_security_id_source();
  inline void set_has_trigger_symbol();
  inline void clear_has_trigger_symbol();
  inline void set_has_trigger_trading_session_id();
  inline void clear_has_trigger_trading_session_id();
  inline void set_has_trigger_trading_session_sub_id();
  inline void clear_has_trigger_trading_session_sub_id();
  inline void set_has_trigger_type();
  inline void clear_has_trigger_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 trigger_new_price_;
  int trigger_action_;
  ::google::protobuf::int32 trigger_new_price_exponent_;
  ::google::protobuf::int64 trigger_new_qty_;
  ::google::protobuf::int32 trigger_new_qty_exponent_;
  int trigger_order_type_;
  ::google::protobuf::int64 trigger_price_;
  ::google::protobuf::int32 trigger_price_exponent_;
  int trigger_price_direction_;
  int trigger_price_type_;
  int trigger_price_type_scope_;
  ::std::string* trigger_security_desc_;
  ::std::string* trigger_security_id_;
  ::std::string* trigger_security_id_source_;
  ::std::string* trigger_symbol_;
  ::std::string* trigger_trading_session_id_;
  ::std::string* trigger_trading_session_sub_id_;
  int trigger_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TriggeringInstruction* default_instance_;
};
// -------------------------------------------------------------------

class SpreadOrBenchmarkCurveData : public ::google::protobuf::Message {
 public:
  SpreadOrBenchmarkCurveData();
  virtual ~SpreadOrBenchmarkCurveData();

  SpreadOrBenchmarkCurveData(const SpreadOrBenchmarkCurveData& from);

  inline SpreadOrBenchmarkCurveData& operator=(const SpreadOrBenchmarkCurveData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpreadOrBenchmarkCurveData& default_instance();

  void Swap(SpreadOrBenchmarkCurveData* other);

  // implements Message ----------------------------------------------

  SpreadOrBenchmarkCurveData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpreadOrBenchmarkCurveData& from);
  void MergeFrom(const SpreadOrBenchmarkCurveData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string benchmark_curve_currency = 1;
  inline bool has_benchmark_curve_currency() const;
  inline void clear_benchmark_curve_currency();
  static const int kBenchmarkCurveCurrencyFieldNumber = 1;
  inline const ::std::string& benchmark_curve_currency() const;
  inline void set_benchmark_curve_currency(const ::std::string& value);
  inline void set_benchmark_curve_currency(const char* value);
  inline void set_benchmark_curve_currency(const char* value, size_t size);
  inline ::std::string* mutable_benchmark_curve_currency();
  inline ::std::string* release_benchmark_curve_currency();
  inline void set_allocated_benchmark_curve_currency(::std::string* benchmark_curve_currency);

  // optional .Common.BenchmarkCurveNameEnum benchmark_curve_name = 2;
  inline bool has_benchmark_curve_name() const;
  inline void clear_benchmark_curve_name();
  static const int kBenchmarkCurveNameFieldNumber = 2;
  inline ::Common::BenchmarkCurveNameEnum benchmark_curve_name() const;
  inline void set_benchmark_curve_name(::Common::BenchmarkCurveNameEnum value);

  // optional string benchmark_curve_point = 3;
  inline bool has_benchmark_curve_point() const;
  inline void clear_benchmark_curve_point();
  static const int kBenchmarkCurvePointFieldNumber = 3;
  inline const ::std::string& benchmark_curve_point() const;
  inline void set_benchmark_curve_point(const ::std::string& value);
  inline void set_benchmark_curve_point(const char* value);
  inline void set_benchmark_curve_point(const char* value, size_t size);
  inline ::std::string* mutable_benchmark_curve_point();
  inline ::std::string* release_benchmark_curve_point();
  inline void set_allocated_benchmark_curve_point(::std::string* benchmark_curve_point);

  // optional sfixed64 spread = 4;
  inline bool has_spread() const;
  inline void clear_spread();
  static const int kSpreadFieldNumber = 4;
  inline ::google::protobuf::int64 spread() const;
  inline void set_spread(::google::protobuf::int64 value);

  // optional sfixed32 spread_exponent = 5;
  inline bool has_spread_exponent() const;
  inline void clear_spread_exponent();
  static const int kSpreadExponentFieldNumber = 5;
  inline ::google::protobuf::int32 spread_exponent() const;
  inline void set_spread_exponent(::google::protobuf::int32 value);

  // optional sfixed64 benchmark_price = 6;
  inline bool has_benchmark_price() const;
  inline void clear_benchmark_price();
  static const int kBenchmarkPriceFieldNumber = 6;
  inline ::google::protobuf::int64 benchmark_price() const;
  inline void set_benchmark_price(::google::protobuf::int64 value);

  // optional sfixed32 benchmark_price_exponent = 7;
  inline bool has_benchmark_price_exponent() const;
  inline void clear_benchmark_price_exponent();
  static const int kBenchmarkPriceExponentFieldNumber = 7;
  inline ::google::protobuf::int32 benchmark_price_exponent() const;
  inline void set_benchmark_price_exponent(::google::protobuf::int32 value);

  // optional sfixed64 benchmark_price_type = 8;
  inline bool has_benchmark_price_type() const;
  inline void clear_benchmark_price_type();
  static const int kBenchmarkPriceTypeFieldNumber = 8;
  inline ::google::protobuf::int64 benchmark_price_type() const;
  inline void set_benchmark_price_type(::google::protobuf::int64 value);

  // optional string benchmark_security_id = 9;
  inline bool has_benchmark_security_id() const;
  inline void clear_benchmark_security_id();
  static const int kBenchmarkSecurityIdFieldNumber = 9;
  inline const ::std::string& benchmark_security_id() const;
  inline void set_benchmark_security_id(const ::std::string& value);
  inline void set_benchmark_security_id(const char* value);
  inline void set_benchmark_security_id(const char* value, size_t size);
  inline ::std::string* mutable_benchmark_security_id();
  inline ::std::string* release_benchmark_security_id();
  inline void set_allocated_benchmark_security_id(::std::string* benchmark_security_id);

  // optional string benchmark_security_id_source = 10;
  inline bool has_benchmark_security_id_source() const;
  inline void clear_benchmark_security_id_source();
  static const int kBenchmarkSecurityIdSourceFieldNumber = 10;
  inline const ::std::string& benchmark_security_id_source() const;
  inline void set_benchmark_security_id_source(const ::std::string& value);
  inline void set_benchmark_security_id_source(const char* value);
  inline void set_benchmark_security_id_source(const char* value, size_t size);
  inline ::std::string* mutable_benchmark_security_id_source();
  inline ::std::string* release_benchmark_security_id_source();
  inline void set_allocated_benchmark_security_id_source(::std::string* benchmark_security_id_source);

  // @@protoc_insertion_point(class_scope:Common.SpreadOrBenchmarkCurveData)
 private:
  inline void set_has_benchmark_curve_currency();
  inline void clear_has_benchmark_curve_currency();
  inline void set_has_benchmark_curve_name();
  inline void clear_has_benchmark_curve_name();
  inline void set_has_benchmark_curve_point();
  inline void clear_has_benchmark_curve_point();
  inline void set_has_spread();
  inline void clear_has_spread();
  inline void set_has_spread_exponent();
  inline void clear_has_spread_exponent();
  inline void set_has_benchmark_price();
  inline void clear_has_benchmark_price();
  inline void set_has_benchmark_price_exponent();
  inline void clear_has_benchmark_price_exponent();
  inline void set_has_benchmark_price_type();
  inline void clear_has_benchmark_price_type();
  inline void set_has_benchmark_security_id();
  inline void clear_has_benchmark_security_id();
  inline void set_has_benchmark_security_id_source();
  inline void clear_has_benchmark_security_id_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* benchmark_curve_currency_;
  ::std::string* benchmark_curve_point_;
  int benchmark_curve_name_;
  ::google::protobuf::int32 spread_exponent_;
  ::google::protobuf::int64 spread_;
  ::google::protobuf::int64 benchmark_price_;
  ::google::protobuf::int64 benchmark_price_type_;
  ::std::string* benchmark_security_id_;
  ::std::string* benchmark_security_id_source_;
  ::google::protobuf::int32 benchmark_price_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static SpreadOrBenchmarkCurveData* default_instance_;
};
// -------------------------------------------------------------------

class YieldData : public ::google::protobuf::Message {
 public:
  YieldData();
  virtual ~YieldData();

  YieldData(const YieldData& from);

  inline YieldData& operator=(const YieldData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YieldData& default_instance();

  void Swap(YieldData* other);

  // implements Message ----------------------------------------------

  YieldData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YieldData& from);
  void MergeFrom(const YieldData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 yield = 1;
  inline bool has_yield() const;
  inline void clear_yield();
  static const int kYieldFieldNumber = 1;
  inline ::google::protobuf::int64 yield() const;
  inline void set_yield(::google::protobuf::int64 value);

  // optional sfixed32 yield_exponent = 2;
  inline bool has_yield_exponent() const;
  inline void clear_yield_exponent();
  static const int kYieldExponentFieldNumber = 2;
  inline ::google::protobuf::int32 yield_exponent() const;
  inline void set_yield_exponent(::google::protobuf::int32 value);

  // optional .Common.YieldTypeEnum yield_type = 3;
  inline bool has_yield_type() const;
  inline void clear_yield_type();
  static const int kYieldTypeFieldNumber = 3;
  inline ::Common::YieldTypeEnum yield_type() const;
  inline void set_yield_type(::Common::YieldTypeEnum value);

  // optional sfixed32 yield_calc_date = 4;
  inline bool has_yield_calc_date() const;
  inline void clear_yield_calc_date();
  static const int kYieldCalcDateFieldNumber = 4;
  inline ::google::protobuf::int32 yield_calc_date() const;
  inline void set_yield_calc_date(::google::protobuf::int32 value);

  // optional sfixed32 yield_redemption_date = 5;
  inline bool has_yield_redemption_date() const;
  inline void clear_yield_redemption_date();
  static const int kYieldRedemptionDateFieldNumber = 5;
  inline ::google::protobuf::int32 yield_redemption_date() const;
  inline void set_yield_redemption_date(::google::protobuf::int32 value);

  // optional sfixed64 yield_redemption_price = 6;
  inline bool has_yield_redemption_price() const;
  inline void clear_yield_redemption_price();
  static const int kYieldRedemptionPriceFieldNumber = 6;
  inline ::google::protobuf::int64 yield_redemption_price() const;
  inline void set_yield_redemption_price(::google::protobuf::int64 value);

  // optional sfixed32 yield_redemption_price_exponent = 7;
  inline bool has_yield_redemption_price_exponent() const;
  inline void clear_yield_redemption_price_exponent();
  static const int kYieldRedemptionPriceExponentFieldNumber = 7;
  inline ::google::protobuf::int32 yield_redemption_price_exponent() const;
  inline void set_yield_redemption_price_exponent(::google::protobuf::int32 value);

  // optional sfixed64 yield_redemption_price_type = 8;
  inline bool has_yield_redemption_price_type() const;
  inline void clear_yield_redemption_price_type();
  static const int kYieldRedemptionPriceTypeFieldNumber = 8;
  inline ::google::protobuf::int64 yield_redemption_price_type() const;
  inline void set_yield_redemption_price_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.YieldData)
 private:
  inline void set_has_yield();
  inline void clear_has_yield();
  inline void set_has_yield_exponent();
  inline void clear_has_yield_exponent();
  inline void set_has_yield_type();
  inline void clear_has_yield_type();
  inline void set_has_yield_calc_date();
  inline void clear_has_yield_calc_date();
  inline void set_has_yield_redemption_date();
  inline void clear_has_yield_redemption_date();
  inline void set_has_yield_redemption_price();
  inline void clear_has_yield_redemption_price();
  inline void set_has_yield_redemption_price_exponent();
  inline void clear_has_yield_redemption_price_exponent();
  inline void set_has_yield_redemption_price_type();
  inline void clear_has_yield_redemption_price_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 yield_;
  ::google::protobuf::int32 yield_exponent_;
  int yield_type_;
  ::google::protobuf::int32 yield_calc_date_;
  ::google::protobuf::int32 yield_redemption_date_;
  ::google::protobuf::int64 yield_redemption_price_;
  ::google::protobuf::int64 yield_redemption_price_type_;
  ::google::protobuf::int32 yield_redemption_price_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static YieldData* default_instance_;
};
// -------------------------------------------------------------------

class CommissionData : public ::google::protobuf::Message {
 public:
  CommissionData();
  virtual ~CommissionData();

  CommissionData(const CommissionData& from);

  inline CommissionData& operator=(const CommissionData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CommissionData& default_instance();

  void Swap(CommissionData* other);

  // implements Message ----------------------------------------------

  CommissionData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommissionData& from);
  void MergeFrom(const CommissionData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string comm_currency = 1;
  inline bool has_comm_currency() const;
  inline void clear_comm_currency();
  static const int kCommCurrencyFieldNumber = 1;
  inline const ::std::string& comm_currency() const;
  inline void set_comm_currency(const ::std::string& value);
  inline void set_comm_currency(const char* value);
  inline void set_comm_currency(const char* value, size_t size);
  inline ::std::string* mutable_comm_currency();
  inline ::std::string* release_comm_currency();
  inline void set_allocated_comm_currency(::std::string* comm_currency);

  // optional .Common.CommTypeEnum comm_type = 2;
  inline bool has_comm_type() const;
  inline void clear_comm_type();
  static const int kCommTypeFieldNumber = 2;
  inline ::Common::CommTypeEnum comm_type() const;
  inline void set_comm_type(::Common::CommTypeEnum value);

  // optional sfixed64 commission = 3;
  inline bool has_commission() const;
  inline void clear_commission();
  static const int kCommissionFieldNumber = 3;
  inline ::google::protobuf::int64 commission() const;
  inline void set_commission(::google::protobuf::int64 value);

  // optional sfixed32 commission_exponent = 4;
  inline bool has_commission_exponent() const;
  inline void clear_commission_exponent();
  static const int kCommissionExponentFieldNumber = 4;
  inline ::google::protobuf::int32 commission_exponent() const;
  inline void set_commission_exponent(::google::protobuf::int32 value);

  // optional .Common.FundRenewWaivEnum fund_renew_waiv = 5;
  inline bool has_fund_renew_waiv() const;
  inline void clear_fund_renew_waiv();
  static const int kFundRenewWaivFieldNumber = 5;
  inline ::Common::FundRenewWaivEnum fund_renew_waiv() const;
  inline void set_fund_renew_waiv(::Common::FundRenewWaivEnum value);

  // @@protoc_insertion_point(class_scope:Common.CommissionData)
 private:
  inline void set_has_comm_currency();
  inline void clear_has_comm_currency();
  inline void set_has_comm_type();
  inline void clear_has_comm_type();
  inline void set_has_commission();
  inline void clear_has_commission();
  inline void set_has_commission_exponent();
  inline void clear_has_commission_exponent();
  inline void set_has_fund_renew_waiv();
  inline void clear_has_fund_renew_waiv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* comm_currency_;
  ::google::protobuf::int64 commission_;
  int comm_type_;
  ::google::protobuf::int32 commission_exponent_;
  int fund_renew_waiv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static CommissionData* default_instance_;
};
// -------------------------------------------------------------------

class PegInstructions : public ::google::protobuf::Message {
 public:
  PegInstructions();
  virtual ~PegInstructions();

  PegInstructions(const PegInstructions& from);

  inline PegInstructions& operator=(const PegInstructions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PegInstructions& default_instance();

  void Swap(PegInstructions* other);

  // implements Message ----------------------------------------------

  PegInstructions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PegInstructions& from);
  void MergeFrom(const PegInstructions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.PegLimitTypeEnum peg_limit_type = 1;
  inline bool has_peg_limit_type() const;
  inline void clear_peg_limit_type();
  static const int kPegLimitTypeFieldNumber = 1;
  inline ::Common::PegLimitTypeEnum peg_limit_type() const;
  inline void set_peg_limit_type(::Common::PegLimitTypeEnum value);

  // optional .Common.PegMoveTypeEnum peg_move_type = 2;
  inline bool has_peg_move_type() const;
  inline void clear_peg_move_type();
  static const int kPegMoveTypeFieldNumber = 2;
  inline ::Common::PegMoveTypeEnum peg_move_type() const;
  inline void set_peg_move_type(::Common::PegMoveTypeEnum value);

  // optional .Common.PegOffsetTypeEnum peg_offset_type = 3;
  inline bool has_peg_offset_type() const;
  inline void clear_peg_offset_type();
  static const int kPegOffsetTypeFieldNumber = 3;
  inline ::Common::PegOffsetTypeEnum peg_offset_type() const;
  inline void set_peg_offset_type(::Common::PegOffsetTypeEnum value);

  // optional double peg_offset_value = 4;
  inline bool has_peg_offset_value() const;
  inline void clear_peg_offset_value();
  static const int kPegOffsetValueFieldNumber = 4;
  inline double peg_offset_value() const;
  inline void set_peg_offset_value(double value);

  // optional .Common.PegPriceTypeEnum peg_price_type = 5;
  inline bool has_peg_price_type() const;
  inline void clear_peg_price_type();
  static const int kPegPriceTypeFieldNumber = 5;
  inline ::Common::PegPriceTypeEnum peg_price_type() const;
  inline void set_peg_price_type(::Common::PegPriceTypeEnum value);

  // optional .Common.PegRoundDirectionEnum peg_round_direction = 6;
  inline bool has_peg_round_direction() const;
  inline void clear_peg_round_direction();
  static const int kPegRoundDirectionFieldNumber = 6;
  inline ::Common::PegRoundDirectionEnum peg_round_direction() const;
  inline void set_peg_round_direction(::Common::PegRoundDirectionEnum value);

  // optional .Common.PegScopeEnum peg_scope = 7;
  inline bool has_peg_scope() const;
  inline void clear_peg_scope();
  static const int kPegScopeFieldNumber = 7;
  inline ::Common::PegScopeEnum peg_scope() const;
  inline void set_peg_scope(::Common::PegScopeEnum value);

  // optional string peg_security_desc = 8;
  inline bool has_peg_security_desc() const;
  inline void clear_peg_security_desc();
  static const int kPegSecurityDescFieldNumber = 8;
  inline const ::std::string& peg_security_desc() const;
  inline void set_peg_security_desc(const ::std::string& value);
  inline void set_peg_security_desc(const char* value);
  inline void set_peg_security_desc(const char* value, size_t size);
  inline ::std::string* mutable_peg_security_desc();
  inline ::std::string* release_peg_security_desc();
  inline void set_allocated_peg_security_desc(::std::string* peg_security_desc);

  // optional string peg_security_id = 9;
  inline bool has_peg_security_id() const;
  inline void clear_peg_security_id();
  static const int kPegSecurityIdFieldNumber = 9;
  inline const ::std::string& peg_security_id() const;
  inline void set_peg_security_id(const ::std::string& value);
  inline void set_peg_security_id(const char* value);
  inline void set_peg_security_id(const char* value, size_t size);
  inline ::std::string* mutable_peg_security_id();
  inline ::std::string* release_peg_security_id();
  inline void set_allocated_peg_security_id(::std::string* peg_security_id);

  // optional string peg_security_id_source = 10;
  inline bool has_peg_security_id_source() const;
  inline void clear_peg_security_id_source();
  static const int kPegSecurityIdSourceFieldNumber = 10;
  inline const ::std::string& peg_security_id_source() const;
  inline void set_peg_security_id_source(const ::std::string& value);
  inline void set_peg_security_id_source(const char* value);
  inline void set_peg_security_id_source(const char* value, size_t size);
  inline ::std::string* mutable_peg_security_id_source();
  inline ::std::string* release_peg_security_id_source();
  inline void set_allocated_peg_security_id_source(::std::string* peg_security_id_source);

  // optional string peg_symbol = 11;
  inline bool has_peg_symbol() const;
  inline void clear_peg_symbol();
  static const int kPegSymbolFieldNumber = 11;
  inline const ::std::string& peg_symbol() const;
  inline void set_peg_symbol(const ::std::string& value);
  inline void set_peg_symbol(const char* value);
  inline void set_peg_symbol(const char* value, size_t size);
  inline ::std::string* mutable_peg_symbol();
  inline ::std::string* release_peg_symbol();
  inline void set_allocated_peg_symbol(::std::string* peg_symbol);

  // @@protoc_insertion_point(class_scope:Common.PegInstructions)
 private:
  inline void set_has_peg_limit_type();
  inline void clear_has_peg_limit_type();
  inline void set_has_peg_move_type();
  inline void clear_has_peg_move_type();
  inline void set_has_peg_offset_type();
  inline void clear_has_peg_offset_type();
  inline void set_has_peg_offset_value();
  inline void clear_has_peg_offset_value();
  inline void set_has_peg_price_type();
  inline void clear_has_peg_price_type();
  inline void set_has_peg_round_direction();
  inline void clear_has_peg_round_direction();
  inline void set_has_peg_scope();
  inline void clear_has_peg_scope();
  inline void set_has_peg_security_desc();
  inline void clear_has_peg_security_desc();
  inline void set_has_peg_security_id();
  inline void clear_has_peg_security_id();
  inline void set_has_peg_security_id_source();
  inline void clear_has_peg_security_id_source();
  inline void set_has_peg_symbol();
  inline void clear_has_peg_symbol();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int peg_limit_type_;
  int peg_move_type_;
  double peg_offset_value_;
  int peg_offset_type_;
  int peg_price_type_;
  int peg_round_direction_;
  int peg_scope_;
  ::std::string* peg_security_desc_;
  ::std::string* peg_security_id_;
  ::std::string* peg_security_id_source_;
  ::std::string* peg_symbol_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static PegInstructions* default_instance_;
};
// -------------------------------------------------------------------

class DiscretionInstructions : public ::google::protobuf::Message {
 public:
  DiscretionInstructions();
  virtual ~DiscretionInstructions();

  DiscretionInstructions(const DiscretionInstructions& from);

  inline DiscretionInstructions& operator=(const DiscretionInstructions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscretionInstructions& default_instance();

  void Swap(DiscretionInstructions* other);

  // implements Message ----------------------------------------------

  DiscretionInstructions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DiscretionInstructions& from);
  void MergeFrom(const DiscretionInstructions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.DiscretionInstEnum discretion_inst = 1;
  inline bool has_discretion_inst() const;
  inline void clear_discretion_inst();
  static const int kDiscretionInstFieldNumber = 1;
  inline ::Common::DiscretionInstEnum discretion_inst() const;
  inline void set_discretion_inst(::Common::DiscretionInstEnum value);

  // optional .Common.DiscretionLimitTypeEnum discretion_limit_type = 2;
  inline bool has_discretion_limit_type() const;
  inline void clear_discretion_limit_type();
  static const int kDiscretionLimitTypeFieldNumber = 2;
  inline ::Common::DiscretionLimitTypeEnum discretion_limit_type() const;
  inline void set_discretion_limit_type(::Common::DiscretionLimitTypeEnum value);

  // optional .Common.DiscretionMoveTypeEnum discretion_move_type = 3;
  inline bool has_discretion_move_type() const;
  inline void clear_discretion_move_type();
  static const int kDiscretionMoveTypeFieldNumber = 3;
  inline ::Common::DiscretionMoveTypeEnum discretion_move_type() const;
  inline void set_discretion_move_type(::Common::DiscretionMoveTypeEnum value);

  // optional .Common.DiscretionOffsetTypeEnum discretion_offset_type = 4;
  inline bool has_discretion_offset_type() const;
  inline void clear_discretion_offset_type();
  static const int kDiscretionOffsetTypeFieldNumber = 4;
  inline ::Common::DiscretionOffsetTypeEnum discretion_offset_type() const;
  inline void set_discretion_offset_type(::Common::DiscretionOffsetTypeEnum value);

  // optional double discretion_offset_value = 5;
  inline bool has_discretion_offset_value() const;
  inline void clear_discretion_offset_value();
  static const int kDiscretionOffsetValueFieldNumber = 5;
  inline double discretion_offset_value() const;
  inline void set_discretion_offset_value(double value);

  // optional .Common.DiscretionRoundDirectionEnum discretion_round_direction = 6;
  inline bool has_discretion_round_direction() const;
  inline void clear_discretion_round_direction();
  static const int kDiscretionRoundDirectionFieldNumber = 6;
  inline ::Common::DiscretionRoundDirectionEnum discretion_round_direction() const;
  inline void set_discretion_round_direction(::Common::DiscretionRoundDirectionEnum value);

  // optional .Common.DiscretionScopeEnum discretion_scope = 7;
  inline bool has_discretion_scope() const;
  inline void clear_discretion_scope();
  static const int kDiscretionScopeFieldNumber = 7;
  inline ::Common::DiscretionScopeEnum discretion_scope() const;
  inline void set_discretion_scope(::Common::DiscretionScopeEnum value);

  // @@protoc_insertion_point(class_scope:Common.DiscretionInstructions)
 private:
  inline void set_has_discretion_inst();
  inline void clear_has_discretion_inst();
  inline void set_has_discretion_limit_type();
  inline void clear_has_discretion_limit_type();
  inline void set_has_discretion_move_type();
  inline void clear_has_discretion_move_type();
  inline void set_has_discretion_offset_type();
  inline void clear_has_discretion_offset_type();
  inline void set_has_discretion_offset_value();
  inline void clear_has_discretion_offset_value();
  inline void set_has_discretion_round_direction();
  inline void clear_has_discretion_round_direction();
  inline void set_has_discretion_scope();
  inline void clear_has_discretion_scope();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int discretion_inst_;
  int discretion_limit_type_;
  int discretion_move_type_;
  int discretion_offset_type_;
  double discretion_offset_value_;
  int discretion_round_direction_;
  int discretion_scope_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static DiscretionInstructions* default_instance_;
};
// -------------------------------------------------------------------

class StrategyParametersGrp : public ::google::protobuf::Message {
 public:
  StrategyParametersGrp();
  virtual ~StrategyParametersGrp();

  StrategyParametersGrp(const StrategyParametersGrp& from);

  inline StrategyParametersGrp& operator=(const StrategyParametersGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StrategyParametersGrp& default_instance();

  void Swap(StrategyParametersGrp* other);

  // implements Message ----------------------------------------------

  StrategyParametersGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrategyParametersGrp& from);
  void MergeFrom(const StrategyParametersGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string strategy_parameter_name = 1;
  inline bool has_strategy_parameter_name() const;
  inline void clear_strategy_parameter_name();
  static const int kStrategyParameterNameFieldNumber = 1;
  inline const ::std::string& strategy_parameter_name() const;
  inline void set_strategy_parameter_name(const ::std::string& value);
  inline void set_strategy_parameter_name(const char* value);
  inline void set_strategy_parameter_name(const char* value, size_t size);
  inline ::std::string* mutable_strategy_parameter_name();
  inline ::std::string* release_strategy_parameter_name();
  inline void set_allocated_strategy_parameter_name(::std::string* strategy_parameter_name);

  // optional .Common.StrategyParameterTypeEnum strategy_parameter_type = 2;
  inline bool has_strategy_parameter_type() const;
  inline void clear_strategy_parameter_type();
  static const int kStrategyParameterTypeFieldNumber = 2;
  inline ::Common::StrategyParameterTypeEnum strategy_parameter_type() const;
  inline void set_strategy_parameter_type(::Common::StrategyParameterTypeEnum value);

  // optional string strategy_parameter_value = 3;
  inline bool has_strategy_parameter_value() const;
  inline void clear_strategy_parameter_value();
  static const int kStrategyParameterValueFieldNumber = 3;
  inline const ::std::string& strategy_parameter_value() const;
  inline void set_strategy_parameter_value(const ::std::string& value);
  inline void set_strategy_parameter_value(const char* value);
  inline void set_strategy_parameter_value(const char* value, size_t size);
  inline ::std::string* mutable_strategy_parameter_value();
  inline ::std::string* release_strategy_parameter_value();
  inline void set_allocated_strategy_parameter_value(::std::string* strategy_parameter_value);

  // @@protoc_insertion_point(class_scope:Common.StrategyParametersGrp)
 private:
  inline void set_has_strategy_parameter_name();
  inline void clear_has_strategy_parameter_name();
  inline void set_has_strategy_parameter_type();
  inline void clear_has_strategy_parameter_type();
  inline void set_has_strategy_parameter_value();
  inline void clear_has_strategy_parameter_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* strategy_parameter_name_;
  ::std::string* strategy_parameter_value_;
  int strategy_parameter_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static StrategyParametersGrp* default_instance_;
};
// -------------------------------------------------------------------

class TrdRegTimestamps : public ::google::protobuf::Message {
 public:
  TrdRegTimestamps();
  virtual ~TrdRegTimestamps();

  TrdRegTimestamps(const TrdRegTimestamps& from);

  inline TrdRegTimestamps& operator=(const TrdRegTimestamps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrdRegTimestamps& default_instance();

  void Swap(TrdRegTimestamps* other);

  // implements Message ----------------------------------------------

  TrdRegTimestamps* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrdRegTimestamps& from);
  void MergeFrom(const TrdRegTimestamps& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.DeskOrderHandlingInstEnum desk_order_handling_inst = 1;
  inline bool has_desk_order_handling_inst() const;
  inline void clear_desk_order_handling_inst();
  static const int kDeskOrderHandlingInstFieldNumber = 1;
  inline ::Common::DeskOrderHandlingInstEnum desk_order_handling_inst() const;
  inline void set_desk_order_handling_inst(::Common::DeskOrderHandlingInstEnum value);

  // optional .Common.DeskTypeEnum desk_type = 2;
  inline bool has_desk_type() const;
  inline void clear_desk_type();
  static const int kDeskTypeFieldNumber = 2;
  inline ::Common::DeskTypeEnum desk_type() const;
  inline void set_desk_type(::Common::DeskTypeEnum value);

  // optional .Common.DeskTypeSourceEnum desk_type_source = 3;
  inline bool has_desk_type_source() const;
  inline void clear_desk_type_source();
  static const int kDeskTypeSourceFieldNumber = 3;
  inline ::Common::DeskTypeSourceEnum desk_type_source() const;
  inline void set_desk_type_source(::Common::DeskTypeSourceEnum value);

  // optional sfixed64 trd_reg_timestamp = 4;
  inline bool has_trd_reg_timestamp() const;
  inline void clear_trd_reg_timestamp();
  static const int kTrdRegTimestampFieldNumber = 4;
  inline ::google::protobuf::int64 trd_reg_timestamp() const;
  inline void set_trd_reg_timestamp(::google::protobuf::int64 value);

  // optional string trd_reg_timestamp_origin = 5;
  inline bool has_trd_reg_timestamp_origin() const;
  inline void clear_trd_reg_timestamp_origin();
  static const int kTrdRegTimestampOriginFieldNumber = 5;
  inline const ::std::string& trd_reg_timestamp_origin() const;
  inline void set_trd_reg_timestamp_origin(const ::std::string& value);
  inline void set_trd_reg_timestamp_origin(const char* value);
  inline void set_trd_reg_timestamp_origin(const char* value, size_t size);
  inline ::std::string* mutable_trd_reg_timestamp_origin();
  inline ::std::string* release_trd_reg_timestamp_origin();
  inline void set_allocated_trd_reg_timestamp_origin(::std::string* trd_reg_timestamp_origin);

  // optional .Common.TrdRegTimestampTypeEnum trd_reg_timestamp_type = 6;
  inline bool has_trd_reg_timestamp_type() const;
  inline void clear_trd_reg_timestamp_type();
  static const int kTrdRegTimestampTypeFieldNumber = 6;
  inline ::Common::TrdRegTimestampTypeEnum trd_reg_timestamp_type() const;
  inline void set_trd_reg_timestamp_type(::Common::TrdRegTimestampTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.TrdRegTimestamps)
 private:
  inline void set_has_desk_order_handling_inst();
  inline void clear_has_desk_order_handling_inst();
  inline void set_has_desk_type();
  inline void clear_has_desk_type();
  inline void set_has_desk_type_source();
  inline void clear_has_desk_type_source();
  inline void set_has_trd_reg_timestamp();
  inline void clear_has_trd_reg_timestamp();
  inline void set_has_trd_reg_timestamp_origin();
  inline void clear_has_trd_reg_timestamp_origin();
  inline void set_has_trd_reg_timestamp_type();
  inline void clear_has_trd_reg_timestamp_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int desk_order_handling_inst_;
  int desk_type_;
  ::google::protobuf::int64 trd_reg_timestamp_;
  int desk_type_source_;
  int trd_reg_timestamp_type_;
  ::std::string* trd_reg_timestamp_origin_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TrdRegTimestamps* default_instance_;
};
// -------------------------------------------------------------------

class ApplicationSequenceControl : public ::google::protobuf::Message {
 public:
  ApplicationSequenceControl();
  virtual ~ApplicationSequenceControl();

  ApplicationSequenceControl(const ApplicationSequenceControl& from);

  inline ApplicationSequenceControl& operator=(const ApplicationSequenceControl& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ApplicationSequenceControl& default_instance();

  void Swap(ApplicationSequenceControl* other);

  // implements Message ----------------------------------------------

  ApplicationSequenceControl* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ApplicationSequenceControl& from);
  void MergeFrom(const ApplicationSequenceControl& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string appl_id = 1;
  inline bool has_appl_id() const;
  inline void clear_appl_id();
  static const int kApplIdFieldNumber = 1;
  inline const ::std::string& appl_id() const;
  inline void set_appl_id(const ::std::string& value);
  inline void set_appl_id(const char* value);
  inline void set_appl_id(const char* value, size_t size);
  inline ::std::string* mutable_appl_id();
  inline ::std::string* release_appl_id();
  inline void set_allocated_appl_id(::std::string* appl_id);

  // optional fixed32 appl_last_seq_num = 2;
  inline bool has_appl_last_seq_num() const;
  inline void clear_appl_last_seq_num();
  static const int kApplLastSeqNumFieldNumber = 2;
  inline ::google::protobuf::uint32 appl_last_seq_num() const;
  inline void set_appl_last_seq_num(::google::protobuf::uint32 value);

  // optional bool appl_resend_flag = 3;
  inline bool has_appl_resend_flag() const;
  inline void clear_appl_resend_flag();
  static const int kApplResendFlagFieldNumber = 3;
  inline bool appl_resend_flag() const;
  inline void set_appl_resend_flag(bool value);

  // optional fixed32 appl_seq_num = 4;
  inline bool has_appl_seq_num() const;
  inline void clear_appl_seq_num();
  static const int kApplSeqNumFieldNumber = 4;
  inline ::google::protobuf::uint32 appl_seq_num() const;
  inline void set_appl_seq_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Common.ApplicationSequenceControl)
 private:
  inline void set_has_appl_id();
  inline void clear_has_appl_id();
  inline void set_has_appl_last_seq_num();
  inline void clear_has_appl_last_seq_num();
  inline void set_has_appl_resend_flag();
  inline void clear_has_appl_resend_flag();
  inline void set_has_appl_seq_num();
  inline void clear_has_appl_seq_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* appl_id_;
  ::google::protobuf::uint32 appl_last_seq_num_;
  bool appl_resend_flag_;
  ::google::protobuf::uint32 appl_seq_num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ApplicationSequenceControl* default_instance_;
};
// -------------------------------------------------------------------

class ContraGrp : public ::google::protobuf::Message {
 public:
  ContraGrp();
  virtual ~ContraGrp();

  ContraGrp(const ContraGrp& from);

  inline ContraGrp& operator=(const ContraGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContraGrp& default_instance();

  void Swap(ContraGrp* other);

  // implements Message ----------------------------------------------

  ContraGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContraGrp& from);
  void MergeFrom(const ContraGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string contra_broker = 1;
  inline bool has_contra_broker() const;
  inline void clear_contra_broker();
  static const int kContraBrokerFieldNumber = 1;
  inline const ::std::string& contra_broker() const;
  inline void set_contra_broker(const ::std::string& value);
  inline void set_contra_broker(const char* value);
  inline void set_contra_broker(const char* value, size_t size);
  inline ::std::string* mutable_contra_broker();
  inline ::std::string* release_contra_broker();
  inline void set_allocated_contra_broker(::std::string* contra_broker);

  // optional string contra_leg_ref_id = 2;
  inline bool has_contra_leg_ref_id() const;
  inline void clear_contra_leg_ref_id();
  static const int kContraLegRefIdFieldNumber = 2;
  inline const ::std::string& contra_leg_ref_id() const;
  inline void set_contra_leg_ref_id(const ::std::string& value);
  inline void set_contra_leg_ref_id(const char* value);
  inline void set_contra_leg_ref_id(const char* value, size_t size);
  inline ::std::string* mutable_contra_leg_ref_id();
  inline ::std::string* release_contra_leg_ref_id();
  inline void set_allocated_contra_leg_ref_id(::std::string* contra_leg_ref_id);

  // optional sfixed64 contra_trade_qty = 3;
  inline bool has_contra_trade_qty() const;
  inline void clear_contra_trade_qty();
  static const int kContraTradeQtyFieldNumber = 3;
  inline ::google::protobuf::int64 contra_trade_qty() const;
  inline void set_contra_trade_qty(::google::protobuf::int64 value);

  // optional sfixed32 contra_trade_qty_exponent = 4;
  inline bool has_contra_trade_qty_exponent() const;
  inline void clear_contra_trade_qty_exponent();
  static const int kContraTradeQtyExponentFieldNumber = 4;
  inline ::google::protobuf::int32 contra_trade_qty_exponent() const;
  inline void set_contra_trade_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 contra_trade_time = 5;
  inline bool has_contra_trade_time() const;
  inline void clear_contra_trade_time();
  static const int kContraTradeTimeFieldNumber = 5;
  inline ::google::protobuf::int64 contra_trade_time() const;
  inline void set_contra_trade_time(::google::protobuf::int64 value);

  // optional string contra_trader = 6;
  inline bool has_contra_trader() const;
  inline void clear_contra_trader();
  static const int kContraTraderFieldNumber = 6;
  inline const ::std::string& contra_trader() const;
  inline void set_contra_trader(const ::std::string& value);
  inline void set_contra_trader(const char* value);
  inline void set_contra_trader(const char* value, size_t size);
  inline ::std::string* mutable_contra_trader();
  inline ::std::string* release_contra_trader();
  inline void set_allocated_contra_trader(::std::string* contra_trader);

  // @@protoc_insertion_point(class_scope:Common.ContraGrp)
 private:
  inline void set_has_contra_broker();
  inline void clear_has_contra_broker();
  inline void set_has_contra_leg_ref_id();
  inline void clear_has_contra_leg_ref_id();
  inline void set_has_contra_trade_qty();
  inline void clear_has_contra_trade_qty();
  inline void set_has_contra_trade_qty_exponent();
  inline void clear_has_contra_trade_qty_exponent();
  inline void set_has_contra_trade_time();
  inline void clear_has_contra_trade_time();
  inline void set_has_contra_trader();
  inline void clear_has_contra_trader();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* contra_broker_;
  ::std::string* contra_leg_ref_id_;
  ::google::protobuf::int64 contra_trade_qty_;
  ::google::protobuf::int64 contra_trade_time_;
  ::std::string* contra_trader_;
  ::google::protobuf::int32 contra_trade_qty_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ContraGrp* default_instance_;
};
// -------------------------------------------------------------------

class NstdPtys4SubGrp : public ::google::protobuf::Message {
 public:
  NstdPtys4SubGrp();
  virtual ~NstdPtys4SubGrp();

  NstdPtys4SubGrp(const NstdPtys4SubGrp& from);

  inline NstdPtys4SubGrp& operator=(const NstdPtys4SubGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NstdPtys4SubGrp& default_instance();

  void Swap(NstdPtys4SubGrp* other);

  // implements Message ----------------------------------------------

  NstdPtys4SubGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NstdPtys4SubGrp& from);
  void MergeFrom(const NstdPtys4SubGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nested4party_sub_id = 1;
  inline bool has_nested4party_sub_id() const;
  inline void clear_nested4party_sub_id();
  static const int kNested4PartySubIdFieldNumber = 1;
  inline const ::std::string& nested4party_sub_id() const;
  inline void set_nested4party_sub_id(const ::std::string& value);
  inline void set_nested4party_sub_id(const char* value);
  inline void set_nested4party_sub_id(const char* value, size_t size);
  inline ::std::string* mutable_nested4party_sub_id();
  inline ::std::string* release_nested4party_sub_id();
  inline void set_allocated_nested4party_sub_id(::std::string* nested4party_sub_id);

  // optional sfixed64 nested4party_sub_id_type = 2;
  inline bool has_nested4party_sub_id_type() const;
  inline void clear_nested4party_sub_id_type();
  static const int kNested4PartySubIdTypeFieldNumber = 2;
  inline ::google::protobuf::int64 nested4party_sub_id_type() const;
  inline void set_nested4party_sub_id_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.NstdPtys4SubGrp)
 private:
  inline void set_has_nested4party_sub_id();
  inline void clear_has_nested4party_sub_id();
  inline void set_has_nested4party_sub_id_type();
  inline void clear_has_nested4party_sub_id_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nested4party_sub_id_;
  ::google::protobuf::int64 nested4party_sub_id_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NstdPtys4SubGrp* default_instance_;
};
// -------------------------------------------------------------------

class NestedParties4 : public ::google::protobuf::Message {
 public:
  NestedParties4();
  virtual ~NestedParties4();

  NestedParties4(const NestedParties4& from);

  inline NestedParties4& operator=(const NestedParties4& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NestedParties4& default_instance();

  void Swap(NestedParties4* other);

  // implements Message ----------------------------------------------

  NestedParties4* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NestedParties4& from);
  void MergeFrom(const NestedParties4& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nested4party_id = 1;
  inline bool has_nested4party_id() const;
  inline void clear_nested4party_id();
  static const int kNested4PartyIdFieldNumber = 1;
  inline const ::std::string& nested4party_id() const;
  inline void set_nested4party_id(const ::std::string& value);
  inline void set_nested4party_id(const char* value);
  inline void set_nested4party_id(const char* value, size_t size);
  inline ::std::string* mutable_nested4party_id();
  inline ::std::string* release_nested4party_id();
  inline void set_allocated_nested4party_id(::std::string* nested4party_id);

  // optional string nested4party_id_source = 2;
  inline bool has_nested4party_id_source() const;
  inline void clear_nested4party_id_source();
  static const int kNested4PartyIdSourceFieldNumber = 2;
  inline const ::std::string& nested4party_id_source() const;
  inline void set_nested4party_id_source(const ::std::string& value);
  inline void set_nested4party_id_source(const char* value);
  inline void set_nested4party_id_source(const char* value, size_t size);
  inline ::std::string* mutable_nested4party_id_source();
  inline ::std::string* release_nested4party_id_source();
  inline void set_allocated_nested4party_id_source(::std::string* nested4party_id_source);

  // optional sfixed64 nested4party_role = 3;
  inline bool has_nested4party_role() const;
  inline void clear_nested4party_role();
  static const int kNested4PartyRoleFieldNumber = 3;
  inline ::google::protobuf::int64 nested4party_role() const;
  inline void set_nested4party_role(::google::protobuf::int64 value);

  // repeated .Common.NstdPtys4SubGrp nstd_ptys4sub_grp = 4;
  inline int nstd_ptys4sub_grp_size() const;
  inline void clear_nstd_ptys4sub_grp();
  static const int kNstdPtys4SubGrpFieldNumber = 4;
  inline const ::Common::NstdPtys4SubGrp& nstd_ptys4sub_grp(int index) const;
  inline ::Common::NstdPtys4SubGrp* mutable_nstd_ptys4sub_grp(int index);
  inline ::Common::NstdPtys4SubGrp* add_nstd_ptys4sub_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys4SubGrp >&
      nstd_ptys4sub_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys4SubGrp >*
      mutable_nstd_ptys4sub_grp();

  // @@protoc_insertion_point(class_scope:Common.NestedParties4)
 private:
  inline void set_has_nested4party_id();
  inline void clear_has_nested4party_id();
  inline void set_has_nested4party_id_source();
  inline void clear_has_nested4party_id_source();
  inline void set_has_nested4party_role();
  inline void clear_has_nested4party_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nested4party_id_;
  ::std::string* nested4party_id_source_;
  ::google::protobuf::int64 nested4party_role_;
  ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys4SubGrp > nstd_ptys4sub_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NestedParties4* default_instance_;
};
// -------------------------------------------------------------------

class RateSource : public ::google::protobuf::Message {
 public:
  RateSource();
  virtual ~RateSource();

  RateSource(const RateSource& from);

  inline RateSource& operator=(const RateSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RateSource& default_instance();

  void Swap(RateSource* other);

  // implements Message ----------------------------------------------

  RateSource* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RateSource& from);
  void MergeFrom(const RateSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.RateSourceEnum rate_source = 1;
  inline bool has_rate_source() const;
  inline void clear_rate_source();
  static const int kRateSourceFieldNumber = 1;
  inline ::Common::RateSourceEnum rate_source() const;
  inline void set_rate_source(::Common::RateSourceEnum value);

  // optional .Common.RateSourceTypeEnum rate_source_type = 2;
  inline bool has_rate_source_type() const;
  inline void clear_rate_source_type();
  static const int kRateSourceTypeFieldNumber = 2;
  inline ::Common::RateSourceTypeEnum rate_source_type() const;
  inline void set_rate_source_type(::Common::RateSourceTypeEnum value);

  // optional string reference_page = 3;
  inline bool has_reference_page() const;
  inline void clear_reference_page();
  static const int kReferencePageFieldNumber = 3;
  inline const ::std::string& reference_page() const;
  inline void set_reference_page(const ::std::string& value);
  inline void set_reference_page(const char* value);
  inline void set_reference_page(const char* value, size_t size);
  inline ::std::string* mutable_reference_page();
  inline ::std::string* release_reference_page();
  inline void set_allocated_reference_page(::std::string* reference_page);

  // @@protoc_insertion_point(class_scope:Common.RateSource)
 private:
  inline void set_has_rate_source();
  inline void clear_has_rate_source();
  inline void set_has_rate_source_type();
  inline void clear_has_rate_source_type();
  inline void set_has_reference_page();
  inline void clear_has_reference_page();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int rate_source_;
  int rate_source_type_;
  ::std::string* reference_page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RateSource* default_instance_;
};
// -------------------------------------------------------------------

class ContAmtGrp : public ::google::protobuf::Message {
 public:
  ContAmtGrp();
  virtual ~ContAmtGrp();

  ContAmtGrp(const ContAmtGrp& from);

  inline ContAmtGrp& operator=(const ContAmtGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContAmtGrp& default_instance();

  void Swap(ContAmtGrp* other);

  // implements Message ----------------------------------------------

  ContAmtGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContAmtGrp& from);
  void MergeFrom(const ContAmtGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cont_amt_curr = 1;
  inline bool has_cont_amt_curr() const;
  inline void clear_cont_amt_curr();
  static const int kContAmtCurrFieldNumber = 1;
  inline const ::std::string& cont_amt_curr() const;
  inline void set_cont_amt_curr(const ::std::string& value);
  inline void set_cont_amt_curr(const char* value);
  inline void set_cont_amt_curr(const char* value, size_t size);
  inline ::std::string* mutable_cont_amt_curr();
  inline ::std::string* release_cont_amt_curr();
  inline void set_allocated_cont_amt_curr(::std::string* cont_amt_curr);

  // optional .Common.ContAmtTypeEnum cont_amt_type = 2;
  inline bool has_cont_amt_type() const;
  inline void clear_cont_amt_type();
  static const int kContAmtTypeFieldNumber = 2;
  inline ::Common::ContAmtTypeEnum cont_amt_type() const;
  inline void set_cont_amt_type(::Common::ContAmtTypeEnum value);

  // optional double cont_amt_value = 3;
  inline bool has_cont_amt_value() const;
  inline void clear_cont_amt_value();
  static const int kContAmtValueFieldNumber = 3;
  inline double cont_amt_value() const;
  inline void set_cont_amt_value(double value);

  // @@protoc_insertion_point(class_scope:Common.ContAmtGrp)
 private:
  inline void set_has_cont_amt_curr();
  inline void clear_has_cont_amt_curr();
  inline void set_has_cont_amt_type();
  inline void clear_has_cont_amt_type();
  inline void set_has_cont_amt_value();
  inline void clear_has_cont_amt_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cont_amt_curr_;
  double cont_amt_value_;
  int cont_amt_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ContAmtGrp* default_instance_;
};
// -------------------------------------------------------------------

class LegSecAltIdGrp : public ::google::protobuf::Message {
 public:
  LegSecAltIdGrp();
  virtual ~LegSecAltIdGrp();

  LegSecAltIdGrp(const LegSecAltIdGrp& from);

  inline LegSecAltIdGrp& operator=(const LegSecAltIdGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LegSecAltIdGrp& default_instance();

  void Swap(LegSecAltIdGrp* other);

  // implements Message ----------------------------------------------

  LegSecAltIdGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegSecAltIdGrp& from);
  void MergeFrom(const LegSecAltIdGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string leg_security_alt_id = 1;
  inline bool has_leg_security_alt_id() const;
  inline void clear_leg_security_alt_id();
  static const int kLegSecurityAltIdFieldNumber = 1;
  inline const ::std::string& leg_security_alt_id() const;
  inline void set_leg_security_alt_id(const ::std::string& value);
  inline void set_leg_security_alt_id(const char* value);
  inline void set_leg_security_alt_id(const char* value, size_t size);
  inline ::std::string* mutable_leg_security_alt_id();
  inline ::std::string* release_leg_security_alt_id();
  inline void set_allocated_leg_security_alt_id(::std::string* leg_security_alt_id);

  // optional string leg_security_alt_id_source = 2;
  inline bool has_leg_security_alt_id_source() const;
  inline void clear_leg_security_alt_id_source();
  static const int kLegSecurityAltIdSourceFieldNumber = 2;
  inline const ::std::string& leg_security_alt_id_source() const;
  inline void set_leg_security_alt_id_source(const ::std::string& value);
  inline void set_leg_security_alt_id_source(const char* value);
  inline void set_leg_security_alt_id_source(const char* value, size_t size);
  inline ::std::string* mutable_leg_security_alt_id_source();
  inline ::std::string* release_leg_security_alt_id_source();
  inline void set_allocated_leg_security_alt_id_source(::std::string* leg_security_alt_id_source);

  // @@protoc_insertion_point(class_scope:Common.LegSecAltIdGrp)
 private:
  inline void set_has_leg_security_alt_id();
  inline void clear_has_leg_security_alt_id();
  inline void set_has_leg_security_alt_id_source();
  inline void clear_has_leg_security_alt_id_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* leg_security_alt_id_;
  ::std::string* leg_security_alt_id_source_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LegSecAltIdGrp* default_instance_;
};
// -------------------------------------------------------------------

class LegFlowScheduleTypeUnion : public ::google::protobuf::Message {
 public:
  LegFlowScheduleTypeUnion();
  virtual ~LegFlowScheduleTypeUnion();

  LegFlowScheduleTypeUnion(const LegFlowScheduleTypeUnion& from);

  inline LegFlowScheduleTypeUnion& operator=(const LegFlowScheduleTypeUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LegFlowScheduleTypeUnion& default_instance();

  void Swap(LegFlowScheduleTypeUnion* other);

  // implements Message ----------------------------------------------

  LegFlowScheduleTypeUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegFlowScheduleTypeUnion& from);
  void MergeFrom(const LegFlowScheduleTypeUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 leg_flow_schedule_type = 1;
  inline bool has_leg_flow_schedule_type() const;
  inline void clear_leg_flow_schedule_type();
  static const int kLegFlowScheduleTypeFieldNumber = 1;
  inline ::google::protobuf::int64 leg_flow_schedule_type() const;
  inline void set_leg_flow_schedule_type(::google::protobuf::int64 value);

  // optional sfixed64 leg_flow_schedule_type_sfixed64 = 2;
  inline bool has_leg_flow_schedule_type_sfixed64() const;
  inline void clear_leg_flow_schedule_type_sfixed64();
  static const int kLegFlowScheduleTypeSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 leg_flow_schedule_type_sfixed64() const;
  inline void set_leg_flow_schedule_type_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.LegFlowScheduleTypeUnion)
 private:
  inline void set_has_leg_flow_schedule_type();
  inline void clear_has_leg_flow_schedule_type();
  inline void set_has_leg_flow_schedule_type_sfixed64();
  inline void clear_has_leg_flow_schedule_type_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 leg_flow_schedule_type_;
  ::google::protobuf::int64 leg_flow_schedule_type_sfixed64_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LegFlowScheduleTypeUnion* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentLeg : public ::google::protobuf::Message {
 public:
  InstrumentLeg();
  virtual ~InstrumentLeg();

  InstrumentLeg(const InstrumentLeg& from);

  inline InstrumentLeg& operator=(const InstrumentLeg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrumentLeg& default_instance();

  void Swap(InstrumentLeg* other);

  // implements Message ----------------------------------------------

  InstrumentLeg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrumentLeg& from);
  void MergeFrom(const InstrumentLeg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes encoded_leg_issuer = 1;
  inline bool has_encoded_leg_issuer() const;
  inline void clear_encoded_leg_issuer();
  static const int kEncodedLegIssuerFieldNumber = 1;
  inline const ::std::string& encoded_leg_issuer() const;
  inline void set_encoded_leg_issuer(const ::std::string& value);
  inline void set_encoded_leg_issuer(const char* value);
  inline void set_encoded_leg_issuer(const void* value, size_t size);
  inline ::std::string* mutable_encoded_leg_issuer();
  inline ::std::string* release_encoded_leg_issuer();
  inline void set_allocated_encoded_leg_issuer(::std::string* encoded_leg_issuer);

  // optional fixed32 encoded_leg_issuer_len = 2;
  inline bool has_encoded_leg_issuer_len() const;
  inline void clear_encoded_leg_issuer_len();
  static const int kEncodedLegIssuerLenFieldNumber = 2;
  inline ::google::protobuf::uint32 encoded_leg_issuer_len() const;
  inline void set_encoded_leg_issuer_len(::google::protobuf::uint32 value);

  // optional bytes encoded_leg_security_desc = 3;
  inline bool has_encoded_leg_security_desc() const;
  inline void clear_encoded_leg_security_desc();
  static const int kEncodedLegSecurityDescFieldNumber = 3;
  inline const ::std::string& encoded_leg_security_desc() const;
  inline void set_encoded_leg_security_desc(const ::std::string& value);
  inline void set_encoded_leg_security_desc(const char* value);
  inline void set_encoded_leg_security_desc(const void* value, size_t size);
  inline ::std::string* mutable_encoded_leg_security_desc();
  inline ::std::string* release_encoded_leg_security_desc();
  inline void set_allocated_encoded_leg_security_desc(::std::string* encoded_leg_security_desc);

  // optional fixed32 encoded_leg_security_desc_len = 4;
  inline bool has_encoded_leg_security_desc_len() const;
  inline void clear_encoded_leg_security_desc_len();
  static const int kEncodedLegSecurityDescLenFieldNumber = 4;
  inline ::google::protobuf::uint32 encoded_leg_security_desc_len() const;
  inline void set_encoded_leg_security_desc_len(::google::protobuf::uint32 value);

  // optional string leg_cfi_code = 5;
  inline bool has_leg_cfi_code() const;
  inline void clear_leg_cfi_code();
  static const int kLegCfiCodeFieldNumber = 5;
  inline const ::std::string& leg_cfi_code() const;
  inline void set_leg_cfi_code(const ::std::string& value);
  inline void set_leg_cfi_code(const char* value);
  inline void set_leg_cfi_code(const char* value, size_t size);
  inline ::std::string* mutable_leg_cfi_code();
  inline ::std::string* release_leg_cfi_code();
  inline void set_allocated_leg_cfi_code(::std::string* leg_cfi_code);

  // optional double leg_contract_multiplier = 6;
  inline bool has_leg_contract_multiplier() const;
  inline void clear_leg_contract_multiplier();
  static const int kLegContractMultiplierFieldNumber = 6;
  inline double leg_contract_multiplier() const;
  inline void set_leg_contract_multiplier(double value);

  // optional string leg_country_of_issue = 7;
  inline bool has_leg_country_of_issue() const;
  inline void clear_leg_country_of_issue();
  static const int kLegCountryOfIssueFieldNumber = 7;
  inline const ::std::string& leg_country_of_issue() const;
  inline void set_leg_country_of_issue(const ::std::string& value);
  inline void set_leg_country_of_issue(const char* value);
  inline void set_leg_country_of_issue(const char* value, size_t size);
  inline ::std::string* mutable_leg_country_of_issue();
  inline ::std::string* release_leg_country_of_issue();
  inline void set_allocated_leg_country_of_issue(::std::string* leg_country_of_issue);

  // optional sfixed32 leg_coupon_payment_date = 8;
  inline bool has_leg_coupon_payment_date() const;
  inline void clear_leg_coupon_payment_date();
  static const int kLegCouponPaymentDateFieldNumber = 8;
  inline ::google::protobuf::int32 leg_coupon_payment_date() const;
  inline void set_leg_coupon_payment_date(::google::protobuf::int32 value);

  // optional sfixed64 leg_coupon_rate = 9;
  inline bool has_leg_coupon_rate() const;
  inline void clear_leg_coupon_rate();
  static const int kLegCouponRateFieldNumber = 9;
  inline ::google::protobuf::int64 leg_coupon_rate() const;
  inline void set_leg_coupon_rate(::google::protobuf::int64 value);

  // optional sfixed32 leg_coupon_rate_exponent = 10;
  inline bool has_leg_coupon_rate_exponent() const;
  inline void clear_leg_coupon_rate_exponent();
  static const int kLegCouponRateExponentFieldNumber = 10;
  inline ::google::protobuf::int32 leg_coupon_rate_exponent() const;
  inline void set_leg_coupon_rate_exponent(::google::protobuf::int32 value);

  // optional string leg_credit_rating = 11;
  inline bool has_leg_credit_rating() const;
  inline void clear_leg_credit_rating();
  static const int kLegCreditRatingFieldNumber = 11;
  inline const ::std::string& leg_credit_rating() const;
  inline void set_leg_credit_rating(const ::std::string& value);
  inline void set_leg_credit_rating(const char* value);
  inline void set_leg_credit_rating(const char* value, size_t size);
  inline ::std::string* mutable_leg_credit_rating();
  inline ::std::string* release_leg_credit_rating();
  inline void set_allocated_leg_credit_rating(::std::string* leg_credit_rating);

  // optional double leg_factor = 12;
  inline bool has_leg_factor() const;
  inline void clear_leg_factor();
  static const int kLegFactorFieldNumber = 12;
  inline double leg_factor() const;
  inline void set_leg_factor(double value);

  // optional string leg_instr_registry = 13;
  inline bool has_leg_instr_registry() const;
  inline void clear_leg_instr_registry();
  static const int kLegInstrRegistryFieldNumber = 13;
  inline const ::std::string& leg_instr_registry() const;
  inline void set_leg_instr_registry(const ::std::string& value);
  inline void set_leg_instr_registry(const char* value);
  inline void set_leg_instr_registry(const char* value, size_t size);
  inline ::std::string* mutable_leg_instr_registry();
  inline ::std::string* release_leg_instr_registry();
  inline void set_allocated_leg_instr_registry(::std::string* leg_instr_registry);

  // optional sfixed32 leg_issue_date = 14;
  inline bool has_leg_issue_date() const;
  inline void clear_leg_issue_date();
  static const int kLegIssueDateFieldNumber = 14;
  inline ::google::protobuf::int32 leg_issue_date() const;
  inline void set_leg_issue_date(::google::protobuf::int32 value);

  // optional string leg_issuer = 15;
  inline bool has_leg_issuer() const;
  inline void clear_leg_issuer();
  static const int kLegIssuerFieldNumber = 15;
  inline const ::std::string& leg_issuer() const;
  inline void set_leg_issuer(const ::std::string& value);
  inline void set_leg_issuer(const char* value);
  inline void set_leg_issuer(const char* value, size_t size);
  inline ::std::string* mutable_leg_issuer();
  inline ::std::string* release_leg_issuer();
  inline void set_allocated_leg_issuer(::std::string* leg_issuer);

  // optional string leg_locale_of_issue = 16;
  inline bool has_leg_locale_of_issue() const;
  inline void clear_leg_locale_of_issue();
  static const int kLegLocaleOfIssueFieldNumber = 16;
  inline const ::std::string& leg_locale_of_issue() const;
  inline void set_leg_locale_of_issue(const ::std::string& value);
  inline void set_leg_locale_of_issue(const char* value);
  inline void set_leg_locale_of_issue(const char* value, size_t size);
  inline ::std::string* mutable_leg_locale_of_issue();
  inline ::std::string* release_leg_locale_of_issue();
  inline void set_allocated_leg_locale_of_issue(::std::string* leg_locale_of_issue);

  // optional sfixed32 leg_maturity_date = 17;
  inline bool has_leg_maturity_date() const;
  inline void clear_leg_maturity_date();
  static const int kLegMaturityDateFieldNumber = 17;
  inline ::google::protobuf::int32 leg_maturity_date() const;
  inline void set_leg_maturity_date(::google::protobuf::int32 value);

  // optional sfixed32 leg_maturity_month_year = 18;
  inline bool has_leg_maturity_month_year() const;
  inline void clear_leg_maturity_month_year();
  static const int kLegMaturityMonthYearFieldNumber = 18;
  inline ::google::protobuf::int32 leg_maturity_month_year() const;
  inline void set_leg_maturity_month_year(::google::protobuf::int32 value);

  // optional string leg_opt_attribute = 19;
  inline bool has_leg_opt_attribute() const;
  inline void clear_leg_opt_attribute();
  static const int kLegOptAttributeFieldNumber = 19;
  inline const ::std::string& leg_opt_attribute() const;
  inline void set_leg_opt_attribute(const ::std::string& value);
  inline void set_leg_opt_attribute(const char* value);
  inline void set_leg_opt_attribute(const char* value, size_t size);
  inline ::std::string* mutable_leg_opt_attribute();
  inline ::std::string* release_leg_opt_attribute();
  inline void set_allocated_leg_opt_attribute(::std::string* leg_opt_attribute);

  // optional sfixed64 leg_product = 20;
  inline bool has_leg_product() const;
  inline void clear_leg_product();
  static const int kLegProductFieldNumber = 20;
  inline ::google::protobuf::int64 leg_product() const;
  inline void set_leg_product(::google::protobuf::int64 value);

  // optional double leg_ratio_qty = 21;
  inline bool has_leg_ratio_qty() const;
  inline void clear_leg_ratio_qty();
  static const int kLegRatioQtyFieldNumber = 21;
  inline double leg_ratio_qty() const;
  inline void set_leg_ratio_qty(double value);

  // optional sfixed32 leg_redemption_date = 22;
  inline bool has_leg_redemption_date() const;
  inline void clear_leg_redemption_date();
  static const int kLegRedemptionDateFieldNumber = 22;
  inline ::google::protobuf::int32 leg_redemption_date() const;
  inline void set_leg_redemption_date(::google::protobuf::int32 value);

  // optional string leg_repo_collateral_security_type = 23;
  inline bool has_leg_repo_collateral_security_type() const;
  inline void clear_leg_repo_collateral_security_type();
  static const int kLegRepoCollateralSecurityTypeFieldNumber = 23;
  inline const ::std::string& leg_repo_collateral_security_type() const;
  inline void set_leg_repo_collateral_security_type(const ::std::string& value);
  inline void set_leg_repo_collateral_security_type(const char* value);
  inline void set_leg_repo_collateral_security_type(const char* value, size_t size);
  inline ::std::string* mutable_leg_repo_collateral_security_type();
  inline ::std::string* release_leg_repo_collateral_security_type();
  inline void set_allocated_leg_repo_collateral_security_type(::std::string* leg_repo_collateral_security_type);

  // optional sfixed64 leg_repurchase_rate = 24;
  inline bool has_leg_repurchase_rate() const;
  inline void clear_leg_repurchase_rate();
  static const int kLegRepurchaseRateFieldNumber = 24;
  inline ::google::protobuf::int64 leg_repurchase_rate() const;
  inline void set_leg_repurchase_rate(::google::protobuf::int64 value);

  // optional sfixed32 leg_repurchase_rate_exponent = 25;
  inline bool has_leg_repurchase_rate_exponent() const;
  inline void clear_leg_repurchase_rate_exponent();
  static const int kLegRepurchaseRateExponentFieldNumber = 25;
  inline ::google::protobuf::int32 leg_repurchase_rate_exponent() const;
  inline void set_leg_repurchase_rate_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leg_repurchase_term = 26;
  inline bool has_leg_repurchase_term() const;
  inline void clear_leg_repurchase_term();
  static const int kLegRepurchaseTermFieldNumber = 26;
  inline ::google::protobuf::int64 leg_repurchase_term() const;
  inline void set_leg_repurchase_term(::google::protobuf::int64 value);

  // optional string leg_security_desc = 27;
  inline bool has_leg_security_desc() const;
  inline void clear_leg_security_desc();
  static const int kLegSecurityDescFieldNumber = 27;
  inline const ::std::string& leg_security_desc() const;
  inline void set_leg_security_desc(const ::std::string& value);
  inline void set_leg_security_desc(const char* value);
  inline void set_leg_security_desc(const char* value, size_t size);
  inline ::std::string* mutable_leg_security_desc();
  inline ::std::string* release_leg_security_desc();
  inline void set_allocated_leg_security_desc(::std::string* leg_security_desc);

  // optional string leg_security_exchange = 28;
  inline bool has_leg_security_exchange() const;
  inline void clear_leg_security_exchange();
  static const int kLegSecurityExchangeFieldNumber = 28;
  inline const ::std::string& leg_security_exchange() const;
  inline void set_leg_security_exchange(const ::std::string& value);
  inline void set_leg_security_exchange(const char* value);
  inline void set_leg_security_exchange(const char* value, size_t size);
  inline ::std::string* mutable_leg_security_exchange();
  inline ::std::string* release_leg_security_exchange();
  inline void set_allocated_leg_security_exchange(::std::string* leg_security_exchange);

  // optional string leg_security_id = 29;
  inline bool has_leg_security_id() const;
  inline void clear_leg_security_id();
  static const int kLegSecurityIdFieldNumber = 29;
  inline const ::std::string& leg_security_id() const;
  inline void set_leg_security_id(const ::std::string& value);
  inline void set_leg_security_id(const char* value);
  inline void set_leg_security_id(const char* value, size_t size);
  inline ::std::string* mutable_leg_security_id();
  inline ::std::string* release_leg_security_id();
  inline void set_allocated_leg_security_id(::std::string* leg_security_id);

  // optional string leg_security_id_source = 30;
  inline bool has_leg_security_id_source() const;
  inline void clear_leg_security_id_source();
  static const int kLegSecurityIdSourceFieldNumber = 30;
  inline const ::std::string& leg_security_id_source() const;
  inline void set_leg_security_id_source(const ::std::string& value);
  inline void set_leg_security_id_source(const char* value);
  inline void set_leg_security_id_source(const char* value, size_t size);
  inline ::std::string* mutable_leg_security_id_source();
  inline ::std::string* release_leg_security_id_source();
  inline void set_allocated_leg_security_id_source(::std::string* leg_security_id_source);

  // optional string leg_security_type = 31;
  inline bool has_leg_security_type() const;
  inline void clear_leg_security_type();
  static const int kLegSecurityTypeFieldNumber = 31;
  inline const ::std::string& leg_security_type() const;
  inline void set_leg_security_type(const ::std::string& value);
  inline void set_leg_security_type(const char* value);
  inline void set_leg_security_type(const char* value, size_t size);
  inline ::std::string* mutable_leg_security_type();
  inline ::std::string* release_leg_security_type();
  inline void set_allocated_leg_security_type(::std::string* leg_security_type);

  // optional string leg_side = 32;
  inline bool has_leg_side() const;
  inline void clear_leg_side();
  static const int kLegSideFieldNumber = 32;
  inline const ::std::string& leg_side() const;
  inline void set_leg_side(const ::std::string& value);
  inline void set_leg_side(const char* value);
  inline void set_leg_side(const char* value, size_t size);
  inline ::std::string* mutable_leg_side();
  inline ::std::string* release_leg_side();
  inline void set_allocated_leg_side(::std::string* leg_side);

  // optional string leg_state_or_province_of_issue = 33;
  inline bool has_leg_state_or_province_of_issue() const;
  inline void clear_leg_state_or_province_of_issue();
  static const int kLegStateOrProvinceOfIssueFieldNumber = 33;
  inline const ::std::string& leg_state_or_province_of_issue() const;
  inline void set_leg_state_or_province_of_issue(const ::std::string& value);
  inline void set_leg_state_or_province_of_issue(const char* value);
  inline void set_leg_state_or_province_of_issue(const char* value, size_t size);
  inline ::std::string* mutable_leg_state_or_province_of_issue();
  inline ::std::string* release_leg_state_or_province_of_issue();
  inline void set_allocated_leg_state_or_province_of_issue(::std::string* leg_state_or_province_of_issue);

  // optional sfixed64 leg_strike_price = 34;
  inline bool has_leg_strike_price() const;
  inline void clear_leg_strike_price();
  static const int kLegStrikePriceFieldNumber = 34;
  inline ::google::protobuf::int64 leg_strike_price() const;
  inline void set_leg_strike_price(::google::protobuf::int64 value);

  // optional sfixed32 leg_strike_price_exponent = 35;
  inline bool has_leg_strike_price_exponent() const;
  inline void clear_leg_strike_price_exponent();
  static const int kLegStrikePriceExponentFieldNumber = 35;
  inline ::google::protobuf::int32 leg_strike_price_exponent() const;
  inline void set_leg_strike_price_exponent(::google::protobuf::int32 value);

  // optional string leg_symbol = 36;
  inline bool has_leg_symbol() const;
  inline void clear_leg_symbol();
  static const int kLegSymbolFieldNumber = 36;
  inline const ::std::string& leg_symbol() const;
  inline void set_leg_symbol(const ::std::string& value);
  inline void set_leg_symbol(const char* value);
  inline void set_leg_symbol(const char* value, size_t size);
  inline ::std::string* mutable_leg_symbol();
  inline ::std::string* release_leg_symbol();
  inline void set_allocated_leg_symbol(::std::string* leg_symbol);

  // optional string leg_symbol_sfx = 37;
  inline bool has_leg_symbol_sfx() const;
  inline void clear_leg_symbol_sfx();
  static const int kLegSymbolSfxFieldNumber = 37;
  inline const ::std::string& leg_symbol_sfx() const;
  inline void set_leg_symbol_sfx(const ::std::string& value);
  inline void set_leg_symbol_sfx(const char* value);
  inline void set_leg_symbol_sfx(const char* value, size_t size);
  inline ::std::string* mutable_leg_symbol_sfx();
  inline ::std::string* release_leg_symbol_sfx();
  inline void set_allocated_leg_symbol_sfx(::std::string* leg_symbol_sfx);

  // optional sfixed32 leg_contract_settl_month = 38;
  inline bool has_leg_contract_settl_month() const;
  inline void clear_leg_contract_settl_month();
  static const int kLegContractSettlMonthFieldNumber = 38;
  inline ::google::protobuf::int32 leg_contract_settl_month() const;
  inline void set_leg_contract_settl_month(::google::protobuf::int32 value);

  // optional string leg_currency = 39;
  inline bool has_leg_currency() const;
  inline void clear_leg_currency();
  static const int kLegCurrencyFieldNumber = 39;
  inline const ::std::string& leg_currency() const;
  inline void set_leg_currency(const ::std::string& value);
  inline void set_leg_currency(const char* value);
  inline void set_leg_currency(const char* value, size_t size);
  inline ::std::string* mutable_leg_currency();
  inline ::std::string* release_leg_currency();
  inline void set_allocated_leg_currency(::std::string* leg_currency);

  // optional sfixed32 leg_dated_date = 40;
  inline bool has_leg_dated_date() const;
  inline void clear_leg_dated_date();
  static const int kLegDatedDateFieldNumber = 40;
  inline ::google::protobuf::int32 leg_dated_date() const;
  inline void set_leg_dated_date(::google::protobuf::int32 value);

  // optional sfixed32 leg_interest_accrual_date = 41;
  inline bool has_leg_interest_accrual_date() const;
  inline void clear_leg_interest_accrual_date();
  static const int kLegInterestAccrualDateFieldNumber = 41;
  inline ::google::protobuf::int32 leg_interest_accrual_date() const;
  inline void set_leg_interest_accrual_date(::google::protobuf::int32 value);

  // optional double leg_option_ratio = 42;
  inline bool has_leg_option_ratio() const;
  inline void clear_leg_option_ratio();
  static const int kLegOptionRatioFieldNumber = 42;
  inline double leg_option_ratio() const;
  inline void set_leg_option_ratio(double value);

  // optional string leg_pool = 43;
  inline bool has_leg_pool() const;
  inline void clear_leg_pool();
  static const int kLegPoolFieldNumber = 43;
  inline const ::std::string& leg_pool() const;
  inline void set_leg_pool(const ::std::string& value);
  inline void set_leg_pool(const char* value);
  inline void set_leg_pool(const char* value, size_t size);
  inline ::std::string* mutable_leg_pool();
  inline ::std::string* release_leg_pool();
  inline void set_allocated_leg_pool(::std::string* leg_pool);

  // optional sfixed64 leg_price = 44;
  inline bool has_leg_price() const;
  inline void clear_leg_price();
  static const int kLegPriceFieldNumber = 44;
  inline ::google::protobuf::int64 leg_price() const;
  inline void set_leg_price(::google::protobuf::int64 value);

  // optional sfixed32 leg_price_exponent = 45;
  inline bool has_leg_price_exponent() const;
  inline void clear_leg_price_exponent();
  static const int kLegPriceExponentFieldNumber = 45;
  inline ::google::protobuf::int32 leg_price_exponent() const;
  inline void set_leg_price_exponent(::google::protobuf::int32 value);

  // repeated .Common.LegSecAltIdGrp leg_sec_alt_id_grp = 46;
  inline int leg_sec_alt_id_grp_size() const;
  inline void clear_leg_sec_alt_id_grp();
  static const int kLegSecAltIdGrpFieldNumber = 46;
  inline const ::Common::LegSecAltIdGrp& leg_sec_alt_id_grp(int index) const;
  inline ::Common::LegSecAltIdGrp* mutable_leg_sec_alt_id_grp(int index);
  inline ::Common::LegSecAltIdGrp* add_leg_sec_alt_id_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::LegSecAltIdGrp >&
      leg_sec_alt_id_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::LegSecAltIdGrp >*
      mutable_leg_sec_alt_id_grp();

  // optional string leg_security_sub_type = 47;
  inline bool has_leg_security_sub_type() const;
  inline void clear_leg_security_sub_type();
  static const int kLegSecuritySubTypeFieldNumber = 47;
  inline const ::std::string& leg_security_sub_type() const;
  inline void set_leg_security_sub_type(const ::std::string& value);
  inline void set_leg_security_sub_type(const char* value);
  inline void set_leg_security_sub_type(const char* value, size_t size);
  inline ::std::string* mutable_leg_security_sub_type();
  inline ::std::string* release_leg_security_sub_type();
  inline void set_allocated_leg_security_sub_type(::std::string* leg_security_sub_type);

  // optional string leg_strike_currency = 48;
  inline bool has_leg_strike_currency() const;
  inline void clear_leg_strike_currency();
  static const int kLegStrikeCurrencyFieldNumber = 48;
  inline const ::std::string& leg_strike_currency() const;
  inline void set_leg_strike_currency(const ::std::string& value);
  inline void set_leg_strike_currency(const char* value);
  inline void set_leg_strike_currency(const char* value, size_t size);
  inline ::std::string* mutable_leg_strike_currency();
  inline ::std::string* release_leg_strike_currency();
  inline void set_allocated_leg_strike_currency(::std::string* leg_strike_currency);

  // optional string leg_time_unit = 49;
  inline bool has_leg_time_unit() const;
  inline void clear_leg_time_unit();
  static const int kLegTimeUnitFieldNumber = 49;
  inline const ::std::string& leg_time_unit() const;
  inline void set_leg_time_unit(const ::std::string& value);
  inline void set_leg_time_unit(const char* value);
  inline void set_leg_time_unit(const char* value, size_t size);
  inline ::std::string* mutable_leg_time_unit();
  inline ::std::string* release_leg_time_unit();
  inline void set_allocated_leg_time_unit(::std::string* leg_time_unit);

  // optional string leg_unit_of_measure = 50;
  inline bool has_leg_unit_of_measure() const;
  inline void clear_leg_unit_of_measure();
  static const int kLegUnitOfMeasureFieldNumber = 50;
  inline const ::std::string& leg_unit_of_measure() const;
  inline void set_leg_unit_of_measure(const ::std::string& value);
  inline void set_leg_unit_of_measure(const char* value);
  inline void set_leg_unit_of_measure(const char* value, size_t size);
  inline ::std::string* mutable_leg_unit_of_measure();
  inline ::std::string* release_leg_unit_of_measure();
  inline void set_allocated_leg_unit_of_measure(::std::string* leg_unit_of_measure);

  // optional sfixed64 leg_exercise_style = 51;
  inline bool has_leg_exercise_style() const;
  inline void clear_leg_exercise_style();
  static const int kLegExerciseStyleFieldNumber = 51;
  inline ::google::protobuf::int64 leg_exercise_style() const;
  inline void set_leg_exercise_style(::google::protobuf::int64 value);

  // optional string leg_maturity_time = 52;
  inline bool has_leg_maturity_time() const;
  inline void clear_leg_maturity_time();
  static const int kLegMaturityTimeFieldNumber = 52;
  inline const ::std::string& leg_maturity_time() const;
  inline void set_leg_maturity_time(const ::std::string& value);
  inline void set_leg_maturity_time(const char* value);
  inline void set_leg_maturity_time(const char* value, size_t size);
  inline ::std::string* mutable_leg_maturity_time();
  inline ::std::string* release_leg_maturity_time();
  inline void set_allocated_leg_maturity_time(::std::string* leg_maturity_time);

  // optional string leg_price_unit_of_measure = 53;
  inline bool has_leg_price_unit_of_measure() const;
  inline void clear_leg_price_unit_of_measure();
  static const int kLegPriceUnitOfMeasureFieldNumber = 53;
  inline const ::std::string& leg_price_unit_of_measure() const;
  inline void set_leg_price_unit_of_measure(const ::std::string& value);
  inline void set_leg_price_unit_of_measure(const char* value);
  inline void set_leg_price_unit_of_measure(const char* value, size_t size);
  inline ::std::string* mutable_leg_price_unit_of_measure();
  inline ::std::string* release_leg_price_unit_of_measure();
  inline void set_allocated_leg_price_unit_of_measure(::std::string* leg_price_unit_of_measure);

  // optional sfixed64 leg_price_unit_of_measure_qty = 54;
  inline bool has_leg_price_unit_of_measure_qty() const;
  inline void clear_leg_price_unit_of_measure_qty();
  static const int kLegPriceUnitOfMeasureQtyFieldNumber = 54;
  inline ::google::protobuf::int64 leg_price_unit_of_measure_qty() const;
  inline void set_leg_price_unit_of_measure_qty(::google::protobuf::int64 value);

  // optional sfixed32 leg_price_unit_of_measure_qty_exponent = 55;
  inline bool has_leg_price_unit_of_measure_qty_exponent() const;
  inline void clear_leg_price_unit_of_measure_qty_exponent();
  static const int kLegPriceUnitOfMeasureQtyExponentFieldNumber = 55;
  inline ::google::protobuf::int32 leg_price_unit_of_measure_qty_exponent() const;
  inline void set_leg_price_unit_of_measure_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leg_put_or_call = 56;
  inline bool has_leg_put_or_call() const;
  inline void clear_leg_put_or_call();
  static const int kLegPutOrCallFieldNumber = 56;
  inline ::google::protobuf::int64 leg_put_or_call() const;
  inline void set_leg_put_or_call(::google::protobuf::int64 value);

  // optional sfixed64 leg_unit_of_measure_qty = 57;
  inline bool has_leg_unit_of_measure_qty() const;
  inline void clear_leg_unit_of_measure_qty();
  static const int kLegUnitOfMeasureQtyFieldNumber = 57;
  inline ::google::protobuf::int64 leg_unit_of_measure_qty() const;
  inline void set_leg_unit_of_measure_qty(::google::protobuf::int64 value);

  // optional sfixed32 leg_unit_of_measure_qty_exponent = 58;
  inline bool has_leg_unit_of_measure_qty_exponent() const;
  inline void clear_leg_unit_of_measure_qty_exponent();
  static const int kLegUnitOfMeasureQtyExponentFieldNumber = 58;
  inline ::google::protobuf::int32 leg_unit_of_measure_qty_exponent() const;
  inline void set_leg_unit_of_measure_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leg_contract_multiplier_unit = 59;
  inline bool has_leg_contract_multiplier_unit() const;
  inline void clear_leg_contract_multiplier_unit();
  static const int kLegContractMultiplierUnitFieldNumber = 59;
  inline ::google::protobuf::int64 leg_contract_multiplier_unit() const;
  inline void set_leg_contract_multiplier_unit(::google::protobuf::int64 value);

  // optional sfixed64 leg_flow_schedule_type = 60;
  inline bool has_leg_flow_schedule_type() const;
  inline void clear_leg_flow_schedule_type();
  static const int kLegFlowScheduleTypeFieldNumber = 60;
  inline ::google::protobuf::int64 leg_flow_schedule_type() const;
  inline void set_leg_flow_schedule_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.InstrumentLeg)
 private:
  inline void set_has_encoded_leg_issuer();
  inline void clear_has_encoded_leg_issuer();
  inline void set_has_encoded_leg_issuer_len();
  inline void clear_has_encoded_leg_issuer_len();
  inline void set_has_encoded_leg_security_desc();
  inline void clear_has_encoded_leg_security_desc();
  inline void set_has_encoded_leg_security_desc_len();
  inline void clear_has_encoded_leg_security_desc_len();
  inline void set_has_leg_cfi_code();
  inline void clear_has_leg_cfi_code();
  inline void set_has_leg_contract_multiplier();
  inline void clear_has_leg_contract_multiplier();
  inline void set_has_leg_country_of_issue();
  inline void clear_has_leg_country_of_issue();
  inline void set_has_leg_coupon_payment_date();
  inline void clear_has_leg_coupon_payment_date();
  inline void set_has_leg_coupon_rate();
  inline void clear_has_leg_coupon_rate();
  inline void set_has_leg_coupon_rate_exponent();
  inline void clear_has_leg_coupon_rate_exponent();
  inline void set_has_leg_credit_rating();
  inline void clear_has_leg_credit_rating();
  inline void set_has_leg_factor();
  inline void clear_has_leg_factor();
  inline void set_has_leg_instr_registry();
  inline void clear_has_leg_instr_registry();
  inline void set_has_leg_issue_date();
  inline void clear_has_leg_issue_date();
  inline void set_has_leg_issuer();
  inline void clear_has_leg_issuer();
  inline void set_has_leg_locale_of_issue();
  inline void clear_has_leg_locale_of_issue();
  inline void set_has_leg_maturity_date();
  inline void clear_has_leg_maturity_date();
  inline void set_has_leg_maturity_month_year();
  inline void clear_has_leg_maturity_month_year();
  inline void set_has_leg_opt_attribute();
  inline void clear_has_leg_opt_attribute();
  inline void set_has_leg_product();
  inline void clear_has_leg_product();
  inline void set_has_leg_ratio_qty();
  inline void clear_has_leg_ratio_qty();
  inline void set_has_leg_redemption_date();
  inline void clear_has_leg_redemption_date();
  inline void set_has_leg_repo_collateral_security_type();
  inline void clear_has_leg_repo_collateral_security_type();
  inline void set_has_leg_repurchase_rate();
  inline void clear_has_leg_repurchase_rate();
  inline void set_has_leg_repurchase_rate_exponent();
  inline void clear_has_leg_repurchase_rate_exponent();
  inline void set_has_leg_repurchase_term();
  inline void clear_has_leg_repurchase_term();
  inline void set_has_leg_security_desc();
  inline void clear_has_leg_security_desc();
  inline void set_has_leg_security_exchange();
  inline void clear_has_leg_security_exchange();
  inline void set_has_leg_security_id();
  inline void clear_has_leg_security_id();
  inline void set_has_leg_security_id_source();
  inline void clear_has_leg_security_id_source();
  inline void set_has_leg_security_type();
  inline void clear_has_leg_security_type();
  inline void set_has_leg_side();
  inline void clear_has_leg_side();
  inline void set_has_leg_state_or_province_of_issue();
  inline void clear_has_leg_state_or_province_of_issue();
  inline void set_has_leg_strike_price();
  inline void clear_has_leg_strike_price();
  inline void set_has_leg_strike_price_exponent();
  inline void clear_has_leg_strike_price_exponent();
  inline void set_has_leg_symbol();
  inline void clear_has_leg_symbol();
  inline void set_has_leg_symbol_sfx();
  inline void clear_has_leg_symbol_sfx();
  inline void set_has_leg_contract_settl_month();
  inline void clear_has_leg_contract_settl_month();
  inline void set_has_leg_currency();
  inline void clear_has_leg_currency();
  inline void set_has_leg_dated_date();
  inline void clear_has_leg_dated_date();
  inline void set_has_leg_interest_accrual_date();
  inline void clear_has_leg_interest_accrual_date();
  inline void set_has_leg_option_ratio();
  inline void clear_has_leg_option_ratio();
  inline void set_has_leg_pool();
  inline void clear_has_leg_pool();
  inline void set_has_leg_price();
  inline void clear_has_leg_price();
  inline void set_has_leg_price_exponent();
  inline void clear_has_leg_price_exponent();
  inline void set_has_leg_security_sub_type();
  inline void clear_has_leg_security_sub_type();
  inline void set_has_leg_strike_currency();
  inline void clear_has_leg_strike_currency();
  inline void set_has_leg_time_unit();
  inline void clear_has_leg_time_unit();
  inline void set_has_leg_unit_of_measure();
  inline void clear_has_leg_unit_of_measure();
  inline void set_has_leg_exercise_style();
  inline void clear_has_leg_exercise_style();
  inline void set_has_leg_maturity_time();
  inline void clear_has_leg_maturity_time();
  inline void set_has_leg_price_unit_of_measure();
  inline void clear_has_leg_price_unit_of_measure();
  inline void set_has_leg_price_unit_of_measure_qty();
  inline void clear_has_leg_price_unit_of_measure_qty();
  inline void set_has_leg_price_unit_of_measure_qty_exponent();
  inline void clear_has_leg_price_unit_of_measure_qty_exponent();
  inline void set_has_leg_put_or_call();
  inline void clear_has_leg_put_or_call();
  inline void set_has_leg_unit_of_measure_qty();
  inline void clear_has_leg_unit_of_measure_qty();
  inline void set_has_leg_unit_of_measure_qty_exponent();
  inline void clear_has_leg_unit_of_measure_qty_exponent();
  inline void set_has_leg_contract_multiplier_unit();
  inline void clear_has_leg_contract_multiplier_unit();
  inline void set_has_leg_flow_schedule_type();
  inline void clear_has_leg_flow_schedule_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* encoded_leg_issuer_;
  ::std::string* encoded_leg_security_desc_;
  ::google::protobuf::uint32 encoded_leg_issuer_len_;
  ::google::protobuf::uint32 encoded_leg_security_desc_len_;
  ::std::string* leg_cfi_code_;
  double leg_contract_multiplier_;
  ::std::string* leg_country_of_issue_;
  ::google::protobuf::int64 leg_coupon_rate_;
  ::google::protobuf::int32 leg_coupon_payment_date_;
  ::google::protobuf::int32 leg_coupon_rate_exponent_;
  ::std::string* leg_credit_rating_;
  double leg_factor_;
  ::std::string* leg_instr_registry_;
  ::std::string* leg_issuer_;
  ::google::protobuf::int32 leg_issue_date_;
  ::google::protobuf::int32 leg_maturity_date_;
  ::std::string* leg_locale_of_issue_;
  ::std::string* leg_opt_attribute_;
  ::google::protobuf::int64 leg_product_;
  ::google::protobuf::int32 leg_maturity_month_year_;
  ::google::protobuf::int32 leg_redemption_date_;
  double leg_ratio_qty_;
  ::std::string* leg_repo_collateral_security_type_;
  ::google::protobuf::int64 leg_repurchase_rate_;
  ::google::protobuf::int64 leg_repurchase_term_;
  ::std::string* leg_security_desc_;
  ::std::string* leg_security_exchange_;
  ::std::string* leg_security_id_;
  ::std::string* leg_security_id_source_;
  ::google::protobuf::int32 leg_repurchase_rate_exponent_;
  ::google::protobuf::int32 leg_strike_price_exponent_;
  ::std::string* leg_security_type_;
  ::std::string* leg_side_;
  ::std::string* leg_state_or_province_of_issue_;
  ::google::protobuf::int64 leg_strike_price_;
  ::std::string* leg_symbol_;
  ::std::string* leg_symbol_sfx_;
  ::std::string* leg_currency_;
  ::google::protobuf::int32 leg_contract_settl_month_;
  ::google::protobuf::int32 leg_dated_date_;
  double leg_option_ratio_;
  ::google::protobuf::int32 leg_interest_accrual_date_;
  ::google::protobuf::int32 leg_price_exponent_;
  ::std::string* leg_pool_;
  ::google::protobuf::int64 leg_price_;
  ::google::protobuf::RepeatedPtrField< ::Common::LegSecAltIdGrp > leg_sec_alt_id_grp_;
  ::std::string* leg_security_sub_type_;
  ::std::string* leg_strike_currency_;
  ::std::string* leg_time_unit_;
  ::std::string* leg_unit_of_measure_;
  ::google::protobuf::int64 leg_exercise_style_;
  ::std::string* leg_maturity_time_;
  ::std::string* leg_price_unit_of_measure_;
  ::google::protobuf::int64 leg_price_unit_of_measure_qty_;
  ::google::protobuf::int64 leg_put_or_call_;
  ::google::protobuf::int32 leg_price_unit_of_measure_qty_exponent_;
  ::google::protobuf::int32 leg_unit_of_measure_qty_exponent_;
  ::google::protobuf::int64 leg_unit_of_measure_qty_;
  ::google::protobuf::int64 leg_contract_multiplier_unit_;
  ::google::protobuf::int64 leg_flow_schedule_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(60 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static InstrumentLeg* default_instance_;
};
// -------------------------------------------------------------------

class LegStipulations : public ::google::protobuf::Message {
 public:
  LegStipulations();
  virtual ~LegStipulations();

  LegStipulations(const LegStipulations& from);

  inline LegStipulations& operator=(const LegStipulations& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LegStipulations& default_instance();

  void Swap(LegStipulations* other);

  // implements Message ----------------------------------------------

  LegStipulations* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegStipulations& from);
  void MergeFrom(const LegStipulations& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string leg_stipulation_type = 1;
  inline bool has_leg_stipulation_type() const;
  inline void clear_leg_stipulation_type();
  static const int kLegStipulationTypeFieldNumber = 1;
  inline const ::std::string& leg_stipulation_type() const;
  inline void set_leg_stipulation_type(const ::std::string& value);
  inline void set_leg_stipulation_type(const char* value);
  inline void set_leg_stipulation_type(const char* value, size_t size);
  inline ::std::string* mutable_leg_stipulation_type();
  inline ::std::string* release_leg_stipulation_type();
  inline void set_allocated_leg_stipulation_type(::std::string* leg_stipulation_type);

  // optional string leg_stipulation_value = 2;
  inline bool has_leg_stipulation_value() const;
  inline void clear_leg_stipulation_value();
  static const int kLegStipulationValueFieldNumber = 2;
  inline const ::std::string& leg_stipulation_value() const;
  inline void set_leg_stipulation_value(const ::std::string& value);
  inline void set_leg_stipulation_value(const char* value);
  inline void set_leg_stipulation_value(const char* value, size_t size);
  inline ::std::string* mutable_leg_stipulation_value();
  inline ::std::string* release_leg_stipulation_value();
  inline void set_allocated_leg_stipulation_value(::std::string* leg_stipulation_value);

  // @@protoc_insertion_point(class_scope:Common.LegStipulations)
 private:
  inline void set_has_leg_stipulation_type();
  inline void clear_has_leg_stipulation_type();
  inline void set_has_leg_stipulation_value();
  inline void clear_has_leg_stipulation_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* leg_stipulation_type_;
  ::std::string* leg_stipulation_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LegStipulations* default_instance_;
};
// -------------------------------------------------------------------

class NstdPtys2SubGrp : public ::google::protobuf::Message {
 public:
  NstdPtys2SubGrp();
  virtual ~NstdPtys2SubGrp();

  NstdPtys2SubGrp(const NstdPtys2SubGrp& from);

  inline NstdPtys2SubGrp& operator=(const NstdPtys2SubGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NstdPtys2SubGrp& default_instance();

  void Swap(NstdPtys2SubGrp* other);

  // implements Message ----------------------------------------------

  NstdPtys2SubGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NstdPtys2SubGrp& from);
  void MergeFrom(const NstdPtys2SubGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nested2party_sub_id = 1;
  inline bool has_nested2party_sub_id() const;
  inline void clear_nested2party_sub_id();
  static const int kNested2PartySubIdFieldNumber = 1;
  inline const ::std::string& nested2party_sub_id() const;
  inline void set_nested2party_sub_id(const ::std::string& value);
  inline void set_nested2party_sub_id(const char* value);
  inline void set_nested2party_sub_id(const char* value, size_t size);
  inline ::std::string* mutable_nested2party_sub_id();
  inline ::std::string* release_nested2party_sub_id();
  inline void set_allocated_nested2party_sub_id(::std::string* nested2party_sub_id);

  // optional sfixed64 nested2party_sub_id_type = 2;
  inline bool has_nested2party_sub_id_type() const;
  inline void clear_nested2party_sub_id_type();
  static const int kNested2PartySubIdTypeFieldNumber = 2;
  inline ::google::protobuf::int64 nested2party_sub_id_type() const;
  inline void set_nested2party_sub_id_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.NstdPtys2SubGrp)
 private:
  inline void set_has_nested2party_sub_id();
  inline void clear_has_nested2party_sub_id();
  inline void set_has_nested2party_sub_id_type();
  inline void clear_has_nested2party_sub_id_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nested2party_sub_id_;
  ::google::protobuf::int64 nested2party_sub_id_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NstdPtys2SubGrp* default_instance_;
};
// -------------------------------------------------------------------

class NestedParties2 : public ::google::protobuf::Message {
 public:
  NestedParties2();
  virtual ~NestedParties2();

  NestedParties2(const NestedParties2& from);

  inline NestedParties2& operator=(const NestedParties2& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NestedParties2& default_instance();

  void Swap(NestedParties2* other);

  // implements Message ----------------------------------------------

  NestedParties2* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NestedParties2& from);
  void MergeFrom(const NestedParties2& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nested2party_id = 1;
  inline bool has_nested2party_id() const;
  inline void clear_nested2party_id();
  static const int kNested2PartyIdFieldNumber = 1;
  inline const ::std::string& nested2party_id() const;
  inline void set_nested2party_id(const ::std::string& value);
  inline void set_nested2party_id(const char* value);
  inline void set_nested2party_id(const char* value, size_t size);
  inline ::std::string* mutable_nested2party_id();
  inline ::std::string* release_nested2party_id();
  inline void set_allocated_nested2party_id(::std::string* nested2party_id);

  // optional string nested2party_id_source = 2;
  inline bool has_nested2party_id_source() const;
  inline void clear_nested2party_id_source();
  static const int kNested2PartyIdSourceFieldNumber = 2;
  inline const ::std::string& nested2party_id_source() const;
  inline void set_nested2party_id_source(const ::std::string& value);
  inline void set_nested2party_id_source(const char* value);
  inline void set_nested2party_id_source(const char* value, size_t size);
  inline ::std::string* mutable_nested2party_id_source();
  inline ::std::string* release_nested2party_id_source();
  inline void set_allocated_nested2party_id_source(::std::string* nested2party_id_source);

  // optional sfixed64 nested2party_role = 3;
  inline bool has_nested2party_role() const;
  inline void clear_nested2party_role();
  static const int kNested2PartyRoleFieldNumber = 3;
  inline ::google::protobuf::int64 nested2party_role() const;
  inline void set_nested2party_role(::google::protobuf::int64 value);

  // repeated .Common.NstdPtys2SubGrp nstd_ptys2sub_grp = 4;
  inline int nstd_ptys2sub_grp_size() const;
  inline void clear_nstd_ptys2sub_grp();
  static const int kNstdPtys2SubGrpFieldNumber = 4;
  inline const ::Common::NstdPtys2SubGrp& nstd_ptys2sub_grp(int index) const;
  inline ::Common::NstdPtys2SubGrp* mutable_nstd_ptys2sub_grp(int index);
  inline ::Common::NstdPtys2SubGrp* add_nstd_ptys2sub_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys2SubGrp >&
      nstd_ptys2sub_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys2SubGrp >*
      mutable_nstd_ptys2sub_grp();

  // @@protoc_insertion_point(class_scope:Common.NestedParties2)
 private:
  inline void set_has_nested2party_id();
  inline void clear_has_nested2party_id();
  inline void set_has_nested2party_id_source();
  inline void clear_has_nested2party_id_source();
  inline void set_has_nested2party_role();
  inline void clear_has_nested2party_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nested2party_id_;
  ::std::string* nested2party_id_source_;
  ::google::protobuf::int64 nested2party_role_;
  ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys2SubGrp > nstd_ptys2sub_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NestedParties2* default_instance_;
};
// -------------------------------------------------------------------

class LegPreAllocGrp : public ::google::protobuf::Message {
 public:
  LegPreAllocGrp();
  virtual ~LegPreAllocGrp();

  LegPreAllocGrp(const LegPreAllocGrp& from);

  inline LegPreAllocGrp& operator=(const LegPreAllocGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LegPreAllocGrp& default_instance();

  void Swap(LegPreAllocGrp* other);

  // implements Message ----------------------------------------------

  LegPreAllocGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegPreAllocGrp& from);
  void MergeFrom(const LegPreAllocGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string leg_alloc_account = 1;
  inline bool has_leg_alloc_account() const;
  inline void clear_leg_alloc_account();
  static const int kLegAllocAccountFieldNumber = 1;
  inline const ::std::string& leg_alloc_account() const;
  inline void set_leg_alloc_account(const ::std::string& value);
  inline void set_leg_alloc_account(const char* value);
  inline void set_leg_alloc_account(const char* value, size_t size);
  inline ::std::string* mutable_leg_alloc_account();
  inline ::std::string* release_leg_alloc_account();
  inline void set_allocated_leg_alloc_account(::std::string* leg_alloc_account);

  // optional string leg_alloc_acct_id_source = 2;
  inline bool has_leg_alloc_acct_id_source() const;
  inline void clear_leg_alloc_acct_id_source();
  static const int kLegAllocAcctIdSourceFieldNumber = 2;
  inline const ::std::string& leg_alloc_acct_id_source() const;
  inline void set_leg_alloc_acct_id_source(const ::std::string& value);
  inline void set_leg_alloc_acct_id_source(const char* value);
  inline void set_leg_alloc_acct_id_source(const char* value, size_t size);
  inline ::std::string* mutable_leg_alloc_acct_id_source();
  inline ::std::string* release_leg_alloc_acct_id_source();
  inline void set_allocated_leg_alloc_acct_id_source(::std::string* leg_alloc_acct_id_source);

  // optional sfixed64 leg_alloc_qty = 3;
  inline bool has_leg_alloc_qty() const;
  inline void clear_leg_alloc_qty();
  static const int kLegAllocQtyFieldNumber = 3;
  inline ::google::protobuf::int64 leg_alloc_qty() const;
  inline void set_leg_alloc_qty(::google::protobuf::int64 value);

  // optional sfixed32 leg_alloc_qty_exponent = 4;
  inline bool has_leg_alloc_qty_exponent() const;
  inline void clear_leg_alloc_qty_exponent();
  static const int kLegAllocQtyExponentFieldNumber = 4;
  inline ::google::protobuf::int32 leg_alloc_qty_exponent() const;
  inline void set_leg_alloc_qty_exponent(::google::protobuf::int32 value);

  // optional string leg_individual_alloc_id = 5;
  inline bool has_leg_individual_alloc_id() const;
  inline void clear_leg_individual_alloc_id();
  static const int kLegIndividualAllocIdFieldNumber = 5;
  inline const ::std::string& leg_individual_alloc_id() const;
  inline void set_leg_individual_alloc_id(const ::std::string& value);
  inline void set_leg_individual_alloc_id(const char* value);
  inline void set_leg_individual_alloc_id(const char* value, size_t size);
  inline ::std::string* mutable_leg_individual_alloc_id();
  inline ::std::string* release_leg_individual_alloc_id();
  inline void set_allocated_leg_individual_alloc_id(::std::string* leg_individual_alloc_id);

  // repeated .Common.NestedParties2 nested_parties2 = 6;
  inline int nested_parties2_size() const;
  inline void clear_nested_parties2();
  static const int kNestedParties2FieldNumber = 6;
  inline const ::Common::NestedParties2& nested_parties2(int index) const;
  inline ::Common::NestedParties2* mutable_nested_parties2(int index);
  inline ::Common::NestedParties2* add_nested_parties2();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedParties2 >&
      nested_parties2() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NestedParties2 >*
      mutable_nested_parties2();

  // optional string leg_alloc_settl_currency = 7;
  inline bool has_leg_alloc_settl_currency() const;
  inline void clear_leg_alloc_settl_currency();
  static const int kLegAllocSettlCurrencyFieldNumber = 7;
  inline const ::std::string& leg_alloc_settl_currency() const;
  inline void set_leg_alloc_settl_currency(const ::std::string& value);
  inline void set_leg_alloc_settl_currency(const char* value);
  inline void set_leg_alloc_settl_currency(const char* value, size_t size);
  inline ::std::string* mutable_leg_alloc_settl_currency();
  inline ::std::string* release_leg_alloc_settl_currency();
  inline void set_allocated_leg_alloc_settl_currency(::std::string* leg_alloc_settl_currency);

  // @@protoc_insertion_point(class_scope:Common.LegPreAllocGrp)
 private:
  inline void set_has_leg_alloc_account();
  inline void clear_has_leg_alloc_account();
  inline void set_has_leg_alloc_acct_id_source();
  inline void clear_has_leg_alloc_acct_id_source();
  inline void set_has_leg_alloc_qty();
  inline void clear_has_leg_alloc_qty();
  inline void set_has_leg_alloc_qty_exponent();
  inline void clear_has_leg_alloc_qty_exponent();
  inline void set_has_leg_individual_alloc_id();
  inline void clear_has_leg_individual_alloc_id();
  inline void set_has_leg_alloc_settl_currency();
  inline void clear_has_leg_alloc_settl_currency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* leg_alloc_account_;
  ::std::string* leg_alloc_acct_id_source_;
  ::google::protobuf::int64 leg_alloc_qty_;
  ::std::string* leg_individual_alloc_id_;
  ::google::protobuf::RepeatedPtrField< ::Common::NestedParties2 > nested_parties2_;
  ::std::string* leg_alloc_settl_currency_;
  ::google::protobuf::int32 leg_alloc_qty_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LegPreAllocGrp* default_instance_;
};
// -------------------------------------------------------------------

class NstdPtys3SubGrp : public ::google::protobuf::Message {
 public:
  NstdPtys3SubGrp();
  virtual ~NstdPtys3SubGrp();

  NstdPtys3SubGrp(const NstdPtys3SubGrp& from);

  inline NstdPtys3SubGrp& operator=(const NstdPtys3SubGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NstdPtys3SubGrp& default_instance();

  void Swap(NstdPtys3SubGrp* other);

  // implements Message ----------------------------------------------

  NstdPtys3SubGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NstdPtys3SubGrp& from);
  void MergeFrom(const NstdPtys3SubGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nested3party_sub_id = 1;
  inline bool has_nested3party_sub_id() const;
  inline void clear_nested3party_sub_id();
  static const int kNested3PartySubIdFieldNumber = 1;
  inline const ::std::string& nested3party_sub_id() const;
  inline void set_nested3party_sub_id(const ::std::string& value);
  inline void set_nested3party_sub_id(const char* value);
  inline void set_nested3party_sub_id(const char* value, size_t size);
  inline ::std::string* mutable_nested3party_sub_id();
  inline ::std::string* release_nested3party_sub_id();
  inline void set_allocated_nested3party_sub_id(::std::string* nested3party_sub_id);

  // optional sfixed64 nested3party_sub_id_type = 2;
  inline bool has_nested3party_sub_id_type() const;
  inline void clear_nested3party_sub_id_type();
  static const int kNested3PartySubIdTypeFieldNumber = 2;
  inline ::google::protobuf::int64 nested3party_sub_id_type() const;
  inline void set_nested3party_sub_id_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.NstdPtys3SubGrp)
 private:
  inline void set_has_nested3party_sub_id();
  inline void clear_has_nested3party_sub_id();
  inline void set_has_nested3party_sub_id_type();
  inline void clear_has_nested3party_sub_id_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nested3party_sub_id_;
  ::google::protobuf::int64 nested3party_sub_id_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NstdPtys3SubGrp* default_instance_;
};
// -------------------------------------------------------------------

class NestedParties3 : public ::google::protobuf::Message {
 public:
  NestedParties3();
  virtual ~NestedParties3();

  NestedParties3(const NestedParties3& from);

  inline NestedParties3& operator=(const NestedParties3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NestedParties3& default_instance();

  void Swap(NestedParties3* other);

  // implements Message ----------------------------------------------

  NestedParties3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NestedParties3& from);
  void MergeFrom(const NestedParties3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nested3party_id = 1;
  inline bool has_nested3party_id() const;
  inline void clear_nested3party_id();
  static const int kNested3PartyIdFieldNumber = 1;
  inline const ::std::string& nested3party_id() const;
  inline void set_nested3party_id(const ::std::string& value);
  inline void set_nested3party_id(const char* value);
  inline void set_nested3party_id(const char* value, size_t size);
  inline ::std::string* mutable_nested3party_id();
  inline ::std::string* release_nested3party_id();
  inline void set_allocated_nested3party_id(::std::string* nested3party_id);

  // optional string nested3party_id_source = 2;
  inline bool has_nested3party_id_source() const;
  inline void clear_nested3party_id_source();
  static const int kNested3PartyIdSourceFieldNumber = 2;
  inline const ::std::string& nested3party_id_source() const;
  inline void set_nested3party_id_source(const ::std::string& value);
  inline void set_nested3party_id_source(const char* value);
  inline void set_nested3party_id_source(const char* value, size_t size);
  inline ::std::string* mutable_nested3party_id_source();
  inline ::std::string* release_nested3party_id_source();
  inline void set_allocated_nested3party_id_source(::std::string* nested3party_id_source);

  // optional sfixed64 nested3party_role = 3;
  inline bool has_nested3party_role() const;
  inline void clear_nested3party_role();
  static const int kNested3PartyRoleFieldNumber = 3;
  inline ::google::protobuf::int64 nested3party_role() const;
  inline void set_nested3party_role(::google::protobuf::int64 value);

  // repeated .Common.NstdPtys3SubGrp nstd_ptys3sub_grp = 4;
  inline int nstd_ptys3sub_grp_size() const;
  inline void clear_nstd_ptys3sub_grp();
  static const int kNstdPtys3SubGrpFieldNumber = 4;
  inline const ::Common::NstdPtys3SubGrp& nstd_ptys3sub_grp(int index) const;
  inline ::Common::NstdPtys3SubGrp* mutable_nstd_ptys3sub_grp(int index);
  inline ::Common::NstdPtys3SubGrp* add_nstd_ptys3sub_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys3SubGrp >&
      nstd_ptys3sub_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys3SubGrp >*
      mutable_nstd_ptys3sub_grp();

  // @@protoc_insertion_point(class_scope:Common.NestedParties3)
 private:
  inline void set_has_nested3party_id();
  inline void clear_has_nested3party_id();
  inline void set_has_nested3party_id_source();
  inline void clear_has_nested3party_id_source();
  inline void set_has_nested3party_role();
  inline void clear_has_nested3party_role();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nested3party_id_;
  ::std::string* nested3party_id_source_;
  ::google::protobuf::int64 nested3party_role_;
  ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys3SubGrp > nstd_ptys3sub_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NestedParties3* default_instance_;
};
// -------------------------------------------------------------------

class InstrmtLegExecGrp : public ::google::protobuf::Message {
 public:
  InstrmtLegExecGrp();
  virtual ~InstrmtLegExecGrp();

  InstrmtLegExecGrp(const InstrmtLegExecGrp& from);

  inline InstrmtLegExecGrp& operator=(const InstrmtLegExecGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrmtLegExecGrp& default_instance();

  void Swap(InstrmtLegExecGrp* other);

  // implements Message ----------------------------------------------

  InstrmtLegExecGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrmtLegExecGrp& from);
  void MergeFrom(const InstrmtLegExecGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.InstrumentLeg instrument_leg = 1;
  inline bool has_instrument_leg() const;
  inline void clear_instrument_leg();
  static const int kInstrumentLegFieldNumber = 1;
  inline const ::Common::InstrumentLeg& instrument_leg() const;
  inline ::Common::InstrumentLeg* mutable_instrument_leg();
  inline ::Common::InstrumentLeg* release_instrument_leg();
  inline void set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg);

  // optional sfixed64 leg_calculated_ccy_last_qty = 2;
  inline bool has_leg_calculated_ccy_last_qty() const;
  inline void clear_leg_calculated_ccy_last_qty();
  static const int kLegCalculatedCcyLastQtyFieldNumber = 2;
  inline ::google::protobuf::int64 leg_calculated_ccy_last_qty() const;
  inline void set_leg_calculated_ccy_last_qty(::google::protobuf::int64 value);

  // optional sfixed32 leg_calculated_ccy_last_qty_exponent = 3;
  inline bool has_leg_calculated_ccy_last_qty_exponent() const;
  inline void clear_leg_calculated_ccy_last_qty_exponent();
  static const int kLegCalculatedCcyLastQtyExponentFieldNumber = 3;
  inline ::google::protobuf::int32 leg_calculated_ccy_last_qty_exponent() const;
  inline void set_leg_calculated_ccy_last_qty_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leg_covered_or_uncovered = 4;
  inline bool has_leg_covered_or_uncovered() const;
  inline void clear_leg_covered_or_uncovered();
  static const int kLegCoveredOrUncoveredFieldNumber = 4;
  inline ::google::protobuf::int64 leg_covered_or_uncovered() const;
  inline void set_leg_covered_or_uncovered(::google::protobuf::int64 value);

  // optional sfixed64 leg_gross_trade_amt = 5;
  inline bool has_leg_gross_trade_amt() const;
  inline void clear_leg_gross_trade_amt();
  static const int kLegGrossTradeAmtFieldNumber = 5;
  inline ::google::protobuf::int64 leg_gross_trade_amt() const;
  inline void set_leg_gross_trade_amt(::google::protobuf::int64 value);

  // optional sfixed32 leg_gross_trade_amt_exponent = 6;
  inline bool has_leg_gross_trade_amt_exponent() const;
  inline void clear_leg_gross_trade_amt_exponent();
  static const int kLegGrossTradeAmtExponentFieldNumber = 6;
  inline ::google::protobuf::int32 leg_gross_trade_amt_exponent() const;
  inline void set_leg_gross_trade_amt_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leg_last_forward_points = 7;
  inline bool has_leg_last_forward_points() const;
  inline void clear_leg_last_forward_points();
  static const int kLegLastForwardPointsFieldNumber = 7;
  inline ::google::protobuf::int64 leg_last_forward_points() const;
  inline void set_leg_last_forward_points(::google::protobuf::int64 value);

  // optional sfixed32 leg_last_forward_points_exponent = 8;
  inline bool has_leg_last_forward_points_exponent() const;
  inline void clear_leg_last_forward_points_exponent();
  static const int kLegLastForwardPointsExponentFieldNumber = 8;
  inline ::google::protobuf::int32 leg_last_forward_points_exponent() const;
  inline void set_leg_last_forward_points_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leg_last_px = 9;
  inline bool has_leg_last_px() const;
  inline void clear_leg_last_px();
  static const int kLegLastPxFieldNumber = 9;
  inline ::google::protobuf::int64 leg_last_px() const;
  inline void set_leg_last_px(::google::protobuf::int64 value);

  // optional sfixed32 leg_last_px_exponent = 10;
  inline bool has_leg_last_px_exponent() const;
  inline void clear_leg_last_px_exponent();
  static const int kLegLastPxExponentFieldNumber = 10;
  inline ::google::protobuf::int32 leg_last_px_exponent() const;
  inline void set_leg_last_px_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leg_order_qty = 11;
  inline bool has_leg_order_qty() const;
  inline void clear_leg_order_qty();
  static const int kLegOrderQtyFieldNumber = 11;
  inline ::google::protobuf::int64 leg_order_qty() const;
  inline void set_leg_order_qty(::google::protobuf::int64 value);

  // optional sfixed32 leg_order_qty_exponent = 12;
  inline bool has_leg_order_qty_exponent() const;
  inline void clear_leg_order_qty_exponent();
  static const int kLegOrderQtyExponentFieldNumber = 12;
  inline ::google::protobuf::int32 leg_order_qty_exponent() const;
  inline void set_leg_order_qty_exponent(::google::protobuf::int32 value);

  // optional string leg_position_effect = 13;
  inline bool has_leg_position_effect() const;
  inline void clear_leg_position_effect();
  static const int kLegPositionEffectFieldNumber = 13;
  inline const ::std::string& leg_position_effect() const;
  inline void set_leg_position_effect(const ::std::string& value);
  inline void set_leg_position_effect(const char* value);
  inline void set_leg_position_effect(const char* value, size_t size);
  inline ::std::string* mutable_leg_position_effect();
  inline ::std::string* release_leg_position_effect();
  inline void set_allocated_leg_position_effect(::std::string* leg_position_effect);

  // optional sfixed64 leg_qty = 14;
  inline bool has_leg_qty() const;
  inline void clear_leg_qty();
  static const int kLegQtyFieldNumber = 14;
  inline ::google::protobuf::int64 leg_qty() const;
  inline void set_leg_qty(::google::protobuf::int64 value);

  // optional sfixed32 leg_qty_exponent = 15;
  inline bool has_leg_qty_exponent() const;
  inline void clear_leg_qty_exponent();
  static const int kLegQtyExponentFieldNumber = 15;
  inline ::google::protobuf::int32 leg_qty_exponent() const;
  inline void set_leg_qty_exponent(::google::protobuf::int32 value);

  // optional string leg_ref_id = 16;
  inline bool has_leg_ref_id() const;
  inline void clear_leg_ref_id();
  static const int kLegRefIdFieldNumber = 16;
  inline const ::std::string& leg_ref_id() const;
  inline void set_leg_ref_id(const ::std::string& value);
  inline void set_leg_ref_id(const char* value);
  inline void set_leg_ref_id(const char* value, size_t size);
  inline ::std::string* mutable_leg_ref_id();
  inline ::std::string* release_leg_ref_id();
  inline void set_allocated_leg_ref_id(::std::string* leg_ref_id);

  // optional string leg_settl_currency = 17;
  inline bool has_leg_settl_currency() const;
  inline void clear_leg_settl_currency();
  static const int kLegSettlCurrencyFieldNumber = 17;
  inline const ::std::string& leg_settl_currency() const;
  inline void set_leg_settl_currency(const ::std::string& value);
  inline void set_leg_settl_currency(const char* value);
  inline void set_leg_settl_currency(const char* value, size_t size);
  inline ::std::string* mutable_leg_settl_currency();
  inline ::std::string* release_leg_settl_currency();
  inline void set_allocated_leg_settl_currency(::std::string* leg_settl_currency);

  // optional sfixed32 leg_settl_date = 18;
  inline bool has_leg_settl_date() const;
  inline void clear_leg_settl_date();
  static const int kLegSettlDateFieldNumber = 18;
  inline ::google::protobuf::int32 leg_settl_date() const;
  inline void set_leg_settl_date(::google::protobuf::int32 value);

  // optional string leg_settl_type = 19;
  inline bool has_leg_settl_type() const;
  inline void clear_leg_settl_type();
  static const int kLegSettlTypeFieldNumber = 19;
  inline const ::std::string& leg_settl_type() const;
  inline void set_leg_settl_type(const ::std::string& value);
  inline void set_leg_settl_type(const char* value);
  inline void set_leg_settl_type(const char* value, size_t size);
  inline ::std::string* mutable_leg_settl_type();
  inline ::std::string* release_leg_settl_type();
  inline void set_allocated_leg_settl_type(::std::string* leg_settl_type);

  // repeated .Common.LegStipulations leg_stipulations = 20;
  inline int leg_stipulations_size() const;
  inline void clear_leg_stipulations();
  static const int kLegStipulationsFieldNumber = 20;
  inline const ::Common::LegStipulations& leg_stipulations(int index) const;
  inline ::Common::LegStipulations* mutable_leg_stipulations(int index);
  inline ::Common::LegStipulations* add_leg_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >&
      leg_stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >*
      mutable_leg_stipulations();

  // optional .Common.LegSwapTypeEnum leg_swap_type = 21;
  inline bool has_leg_swap_type() const;
  inline void clear_leg_swap_type();
  static const int kLegSwapTypeFieldNumber = 21;
  inline ::Common::LegSwapTypeEnum leg_swap_type() const;
  inline void set_leg_swap_type(::Common::LegSwapTypeEnum value);

  // optional string leg_alloc_id = 22;
  inline bool has_leg_alloc_id() const;
  inline void clear_leg_alloc_id();
  static const int kLegAllocIdFieldNumber = 22;
  inline const ::std::string& leg_alloc_id() const;
  inline void set_leg_alloc_id(const ::std::string& value);
  inline void set_leg_alloc_id(const char* value);
  inline void set_leg_alloc_id(const char* value, size_t size);
  inline ::std::string* mutable_leg_alloc_id();
  inline ::std::string* release_leg_alloc_id();
  inline void set_allocated_leg_alloc_id(::std::string* leg_alloc_id);

  // optional double leg_currency_ratio = 23;
  inline bool has_leg_currency_ratio() const;
  inline void clear_leg_currency_ratio();
  static const int kLegCurrencyRatioFieldNumber = 23;
  inline double leg_currency_ratio() const;
  inline void set_leg_currency_ratio(double value);

  // optional sfixed64 leg_dividend_yield = 24;
  inline bool has_leg_dividend_yield() const;
  inline void clear_leg_dividend_yield();
  static const int kLegDividendYieldFieldNumber = 24;
  inline ::google::protobuf::int64 leg_dividend_yield() const;
  inline void set_leg_dividend_yield(::google::protobuf::int64 value);

  // optional sfixed32 leg_dividend_yield_exponent = 25;
  inline bool has_leg_dividend_yield_exponent() const;
  inline void clear_leg_dividend_yield_exponent();
  static const int kLegDividendYieldExponentFieldNumber = 25;
  inline ::google::protobuf::int32 leg_dividend_yield_exponent() const;
  inline void set_leg_dividend_yield_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leg_last_qty = 26;
  inline bool has_leg_last_qty() const;
  inline void clear_leg_last_qty();
  static const int kLegLastQtyFieldNumber = 26;
  inline ::google::protobuf::int64 leg_last_qty() const;
  inline void set_leg_last_qty(::google::protobuf::int64 value);

  // optional sfixed32 leg_last_qty_exponent = 27;
  inline bool has_leg_last_qty_exponent() const;
  inline void clear_leg_last_qty_exponent();
  static const int kLegLastQtyExponentFieldNumber = 27;
  inline ::google::protobuf::int32 leg_last_qty_exponent() const;
  inline void set_leg_last_qty_exponent(::google::protobuf::int32 value);

  // repeated .Common.LegPreAllocGrp leg_pre_alloc_grp = 28;
  inline int leg_pre_alloc_grp_size() const;
  inline void clear_leg_pre_alloc_grp();
  static const int kLegPreAllocGrpFieldNumber = 28;
  inline const ::Common::LegPreAllocGrp& leg_pre_alloc_grp(int index) const;
  inline ::Common::LegPreAllocGrp* mutable_leg_pre_alloc_grp(int index);
  inline ::Common::LegPreAllocGrp* add_leg_pre_alloc_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::LegPreAllocGrp >&
      leg_pre_alloc_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::LegPreAllocGrp >*
      mutable_leg_pre_alloc_grp();

  // optional double leg_volatility = 29;
  inline bool has_leg_volatility() const;
  inline void clear_leg_volatility();
  static const int kLegVolatilityFieldNumber = 29;
  inline double leg_volatility() const;
  inline void set_leg_volatility(double value);

  // repeated .Common.NestedParties3 nested_parties3 = 30;
  inline int nested_parties3_size() const;
  inline void clear_nested_parties3();
  static const int kNestedParties3FieldNumber = 30;
  inline const ::Common::NestedParties3& nested_parties3(int index) const;
  inline ::Common::NestedParties3* mutable_nested_parties3(int index);
  inline ::Common::NestedParties3* add_nested_parties3();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedParties3 >&
      nested_parties3() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NestedParties3 >*
      mutable_nested_parties3();

  // @@protoc_insertion_point(class_scope:Common.InstrmtLegExecGrp)
 private:
  inline void set_has_instrument_leg();
  inline void clear_has_instrument_leg();
  inline void set_has_leg_calculated_ccy_last_qty();
  inline void clear_has_leg_calculated_ccy_last_qty();
  inline void set_has_leg_calculated_ccy_last_qty_exponent();
  inline void clear_has_leg_calculated_ccy_last_qty_exponent();
  inline void set_has_leg_covered_or_uncovered();
  inline void clear_has_leg_covered_or_uncovered();
  inline void set_has_leg_gross_trade_amt();
  inline void clear_has_leg_gross_trade_amt();
  inline void set_has_leg_gross_trade_amt_exponent();
  inline void clear_has_leg_gross_trade_amt_exponent();
  inline void set_has_leg_last_forward_points();
  inline void clear_has_leg_last_forward_points();
  inline void set_has_leg_last_forward_points_exponent();
  inline void clear_has_leg_last_forward_points_exponent();
  inline void set_has_leg_last_px();
  inline void clear_has_leg_last_px();
  inline void set_has_leg_last_px_exponent();
  inline void clear_has_leg_last_px_exponent();
  inline void set_has_leg_order_qty();
  inline void clear_has_leg_order_qty();
  inline void set_has_leg_order_qty_exponent();
  inline void clear_has_leg_order_qty_exponent();
  inline void set_has_leg_position_effect();
  inline void clear_has_leg_position_effect();
  inline void set_has_leg_qty();
  inline void clear_has_leg_qty();
  inline void set_has_leg_qty_exponent();
  inline void clear_has_leg_qty_exponent();
  inline void set_has_leg_ref_id();
  inline void clear_has_leg_ref_id();
  inline void set_has_leg_settl_currency();
  inline void clear_has_leg_settl_currency();
  inline void set_has_leg_settl_date();
  inline void clear_has_leg_settl_date();
  inline void set_has_leg_settl_type();
  inline void clear_has_leg_settl_type();
  inline void set_has_leg_swap_type();
  inline void clear_has_leg_swap_type();
  inline void set_has_leg_alloc_id();
  inline void clear_has_leg_alloc_id();
  inline void set_has_leg_currency_ratio();
  inline void clear_has_leg_currency_ratio();
  inline void set_has_leg_dividend_yield();
  inline void clear_has_leg_dividend_yield();
  inline void set_has_leg_dividend_yield_exponent();
  inline void clear_has_leg_dividend_yield_exponent();
  inline void set_has_leg_last_qty();
  inline void clear_has_leg_last_qty();
  inline void set_has_leg_last_qty_exponent();
  inline void clear_has_leg_last_qty_exponent();
  inline void set_has_leg_volatility();
  inline void clear_has_leg_volatility();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Common::InstrumentLeg* instrument_leg_;
  ::google::protobuf::int64 leg_calculated_ccy_last_qty_;
  ::google::protobuf::int64 leg_covered_or_uncovered_;
  ::google::protobuf::int32 leg_calculated_ccy_last_qty_exponent_;
  ::google::protobuf::int32 leg_gross_trade_amt_exponent_;
  ::google::protobuf::int64 leg_gross_trade_amt_;
  ::google::protobuf::int64 leg_last_forward_points_;
  ::google::protobuf::int64 leg_last_px_;
  ::google::protobuf::int32 leg_last_forward_points_exponent_;
  ::google::protobuf::int32 leg_last_px_exponent_;
  ::google::protobuf::int64 leg_order_qty_;
  ::std::string* leg_position_effect_;
  ::google::protobuf::int32 leg_order_qty_exponent_;
  ::google::protobuf::int32 leg_qty_exponent_;
  ::google::protobuf::int64 leg_qty_;
  ::std::string* leg_ref_id_;
  ::std::string* leg_settl_currency_;
  ::std::string* leg_settl_type_;
  ::google::protobuf::int32 leg_settl_date_;
  int leg_swap_type_;
  ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations > leg_stipulations_;
  ::std::string* leg_alloc_id_;
  double leg_currency_ratio_;
  ::google::protobuf::int64 leg_dividend_yield_;
  ::google::protobuf::int64 leg_last_qty_;
  ::google::protobuf::int32 leg_dividend_yield_exponent_;
  ::google::protobuf::int32 leg_last_qty_exponent_;
  ::google::protobuf::RepeatedPtrField< ::Common::LegPreAllocGrp > leg_pre_alloc_grp_;
  double leg_volatility_;
  ::google::protobuf::RepeatedPtrField< ::Common::NestedParties3 > nested_parties3_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static InstrmtLegExecGrp* default_instance_;
};
// -------------------------------------------------------------------

class MiscFeesGrp : public ::google::protobuf::Message {
 public:
  MiscFeesGrp();
  virtual ~MiscFeesGrp();

  MiscFeesGrp(const MiscFeesGrp& from);

  inline MiscFeesGrp& operator=(const MiscFeesGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MiscFeesGrp& default_instance();

  void Swap(MiscFeesGrp* other);

  // implements Message ----------------------------------------------

  MiscFeesGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MiscFeesGrp& from);
  void MergeFrom(const MiscFeesGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 misc_fee_amt = 1;
  inline bool has_misc_fee_amt() const;
  inline void clear_misc_fee_amt();
  static const int kMiscFeeAmtFieldNumber = 1;
  inline ::google::protobuf::int64 misc_fee_amt() const;
  inline void set_misc_fee_amt(::google::protobuf::int64 value);

  // optional sfixed32 misc_fee_amt_exponent = 2;
  inline bool has_misc_fee_amt_exponent() const;
  inline void clear_misc_fee_amt_exponent();
  static const int kMiscFeeAmtExponentFieldNumber = 2;
  inline ::google::protobuf::int32 misc_fee_amt_exponent() const;
  inline void set_misc_fee_amt_exponent(::google::protobuf::int32 value);

  // optional .Common.MiscFeeBasisEnum misc_fee_basis = 3;
  inline bool has_misc_fee_basis() const;
  inline void clear_misc_fee_basis();
  static const int kMiscFeeBasisFieldNumber = 3;
  inline ::Common::MiscFeeBasisEnum misc_fee_basis() const;
  inline void set_misc_fee_basis(::Common::MiscFeeBasisEnum value);

  // optional string misc_fee_curr = 4;
  inline bool has_misc_fee_curr() const;
  inline void clear_misc_fee_curr();
  static const int kMiscFeeCurrFieldNumber = 4;
  inline const ::std::string& misc_fee_curr() const;
  inline void set_misc_fee_curr(const ::std::string& value);
  inline void set_misc_fee_curr(const char* value);
  inline void set_misc_fee_curr(const char* value, size_t size);
  inline ::std::string* mutable_misc_fee_curr();
  inline ::std::string* release_misc_fee_curr();
  inline void set_allocated_misc_fee_curr(::std::string* misc_fee_curr);

  // optional .Common.MiscFeeTypeEnum misc_fee_type = 5;
  inline bool has_misc_fee_type() const;
  inline void clear_misc_fee_type();
  static const int kMiscFeeTypeFieldNumber = 5;
  inline ::Common::MiscFeeTypeEnum misc_fee_type() const;
  inline void set_misc_fee_type(::Common::MiscFeeTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.MiscFeesGrp)
 private:
  inline void set_has_misc_fee_amt();
  inline void clear_has_misc_fee_amt();
  inline void set_has_misc_fee_amt_exponent();
  inline void clear_has_misc_fee_amt_exponent();
  inline void set_has_misc_fee_basis();
  inline void clear_has_misc_fee_basis();
  inline void set_has_misc_fee_curr();
  inline void clear_has_misc_fee_curr();
  inline void set_has_misc_fee_type();
  inline void clear_has_misc_fee_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 misc_fee_amt_;
  ::google::protobuf::int32 misc_fee_amt_exponent_;
  int misc_fee_basis_;
  ::std::string* misc_fee_curr_;
  int misc_fee_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static MiscFeesGrp* default_instance_;
};
// -------------------------------------------------------------------

class InstrmtLegGrp : public ::google::protobuf::Message {
 public:
  InstrmtLegGrp();
  virtual ~InstrmtLegGrp();

  InstrmtLegGrp(const InstrmtLegGrp& from);

  inline InstrmtLegGrp& operator=(const InstrmtLegGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrmtLegGrp& default_instance();

  void Swap(InstrmtLegGrp* other);

  // implements Message ----------------------------------------------

  InstrmtLegGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrmtLegGrp& from);
  void MergeFrom(const InstrmtLegGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.InstrumentLeg instrument_leg = 1;
  inline bool has_instrument_leg() const;
  inline void clear_instrument_leg();
  static const int kInstrumentLegFieldNumber = 1;
  inline const ::Common::InstrumentLeg& instrument_leg() const;
  inline ::Common::InstrumentLeg* mutable_instrument_leg();
  inline ::Common::InstrumentLeg* release_instrument_leg();
  inline void set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg);

  // @@protoc_insertion_point(class_scope:Common.InstrmtLegGrp)
 private:
  inline void set_has_instrument_leg();
  inline void clear_has_instrument_leg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Common::InstrumentLeg* instrument_leg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static InstrmtLegGrp* default_instance_;
};
// -------------------------------------------------------------------

class InstrmtLegIoiGrp : public ::google::protobuf::Message {
 public:
  InstrmtLegIoiGrp();
  virtual ~InstrmtLegIoiGrp();

  InstrmtLegIoiGrp(const InstrmtLegIoiGrp& from);

  inline InstrmtLegIoiGrp& operator=(const InstrmtLegIoiGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrmtLegIoiGrp& default_instance();

  void Swap(InstrmtLegIoiGrp* other);

  // implements Message ----------------------------------------------

  InstrmtLegIoiGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrmtLegIoiGrp& from);
  void MergeFrom(const InstrmtLegIoiGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.InstrumentLeg instrument_leg = 1;
  inline bool has_instrument_leg() const;
  inline void clear_instrument_leg();
  static const int kInstrumentLegFieldNumber = 1;
  inline const ::Common::InstrumentLeg& instrument_leg() const;
  inline ::Common::InstrumentLeg* mutable_instrument_leg();
  inline ::Common::InstrumentLeg* release_instrument_leg();
  inline void set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg);

  // optional string leg_ioi_qty = 2;
  inline bool has_leg_ioi_qty() const;
  inline void clear_leg_ioi_qty();
  static const int kLegIoiQtyFieldNumber = 2;
  inline const ::std::string& leg_ioi_qty() const;
  inline void set_leg_ioi_qty(const ::std::string& value);
  inline void set_leg_ioi_qty(const char* value);
  inline void set_leg_ioi_qty(const char* value, size_t size);
  inline ::std::string* mutable_leg_ioi_qty();
  inline ::std::string* release_leg_ioi_qty();
  inline void set_allocated_leg_ioi_qty(::std::string* leg_ioi_qty);

  // repeated .Common.LegStipulations leg_stipulations = 3;
  inline int leg_stipulations_size() const;
  inline void clear_leg_stipulations();
  static const int kLegStipulationsFieldNumber = 3;
  inline const ::Common::LegStipulations& leg_stipulations(int index) const;
  inline ::Common::LegStipulations* mutable_leg_stipulations(int index);
  inline ::Common::LegStipulations* add_leg_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >&
      leg_stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >*
      mutable_leg_stipulations();

  // @@protoc_insertion_point(class_scope:Common.InstrmtLegIoiGrp)
 private:
  inline void set_has_instrument_leg();
  inline void clear_has_instrument_leg();
  inline void set_has_leg_ioi_qty();
  inline void clear_has_leg_ioi_qty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Common::InstrumentLeg* instrument_leg_;
  ::std::string* leg_ioi_qty_;
  ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations > leg_stipulations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static InstrmtLegIoiGrp* default_instance_;
};
// -------------------------------------------------------------------

class RoutingGrp : public ::google::protobuf::Message {
 public:
  RoutingGrp();
  virtual ~RoutingGrp();

  RoutingGrp(const RoutingGrp& from);

  inline RoutingGrp& operator=(const RoutingGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingGrp& default_instance();

  void Swap(RoutingGrp* other);

  // implements Message ----------------------------------------------

  RoutingGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoutingGrp& from);
  void MergeFrom(const RoutingGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string routing_id = 1;
  inline bool has_routing_id() const;
  inline void clear_routing_id();
  static const int kRoutingIdFieldNumber = 1;
  inline const ::std::string& routing_id() const;
  inline void set_routing_id(const ::std::string& value);
  inline void set_routing_id(const char* value);
  inline void set_routing_id(const char* value, size_t size);
  inline ::std::string* mutable_routing_id();
  inline ::std::string* release_routing_id();
  inline void set_allocated_routing_id(::std::string* routing_id);

  // optional .Common.RoutingTypeEnum routing_type = 2;
  inline bool has_routing_type() const;
  inline void clear_routing_type();
  static const int kRoutingTypeFieldNumber = 2;
  inline ::Common::RoutingTypeEnum routing_type() const;
  inline void set_routing_type(::Common::RoutingTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.RoutingGrp)
 private:
  inline void set_has_routing_id();
  inline void clear_has_routing_id();
  inline void set_has_routing_type();
  inline void clear_has_routing_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* routing_id_;
  int routing_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static RoutingGrp* default_instance_;
};
// -------------------------------------------------------------------

class InstrAttribTypeUnion : public ::google::protobuf::Message {
 public:
  InstrAttribTypeUnion();
  virtual ~InstrAttribTypeUnion();

  InstrAttribTypeUnion(const InstrAttribTypeUnion& from);

  inline InstrAttribTypeUnion& operator=(const InstrAttribTypeUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrAttribTypeUnion& default_instance();

  void Swap(InstrAttribTypeUnion* other);

  // implements Message ----------------------------------------------

  InstrAttribTypeUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrAttribTypeUnion& from);
  void MergeFrom(const InstrAttribTypeUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.InstrAttribTypeEnum instr_attrib_type = 1;
  inline bool has_instr_attrib_type() const;
  inline void clear_instr_attrib_type();
  static const int kInstrAttribTypeFieldNumber = 1;
  inline ::Common::InstrAttribTypeEnum instr_attrib_type() const;
  inline void set_instr_attrib_type(::Common::InstrAttribTypeEnum value);

  // optional sfixed64 instr_attrib_type_sfixed64 = 2;
  inline bool has_instr_attrib_type_sfixed64() const;
  inline void clear_instr_attrib_type_sfixed64();
  static const int kInstrAttribTypeSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 instr_attrib_type_sfixed64() const;
  inline void set_instr_attrib_type_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.InstrAttribTypeUnion)
 private:
  inline void set_has_instr_attrib_type();
  inline void clear_has_instr_attrib_type();
  inline void set_has_instr_attrib_type_sfixed64();
  inline void clear_has_instr_attrib_type_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 instr_attrib_type_sfixed64_;
  int instr_attrib_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static InstrAttribTypeUnion* default_instance_;
};
// -------------------------------------------------------------------

class AttrbGrp : public ::google::protobuf::Message {
 public:
  AttrbGrp();
  virtual ~AttrbGrp();

  AttrbGrp(const AttrbGrp& from);

  inline AttrbGrp& operator=(const AttrbGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AttrbGrp& default_instance();

  void Swap(AttrbGrp* other);

  // implements Message ----------------------------------------------

  AttrbGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AttrbGrp& from);
  void MergeFrom(const AttrbGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.InstrAttribTypeEnum instr_attrib_type = 1;
  inline bool has_instr_attrib_type() const;
  inline void clear_instr_attrib_type();
  static const int kInstrAttribTypeFieldNumber = 1;
  inline ::Common::InstrAttribTypeEnum instr_attrib_type() const;
  inline void set_instr_attrib_type(::Common::InstrAttribTypeEnum value);

  // optional string instr_attrib_value = 2;
  inline bool has_instr_attrib_value() const;
  inline void clear_instr_attrib_value();
  static const int kInstrAttribValueFieldNumber = 2;
  inline const ::std::string& instr_attrib_value() const;
  inline void set_instr_attrib_value(const ::std::string& value);
  inline void set_instr_attrib_value(const char* value);
  inline void set_instr_attrib_value(const char* value, size_t size);
  inline ::std::string* mutable_instr_attrib_value();
  inline ::std::string* release_instr_attrib_value();
  inline void set_allocated_instr_attrib_value(::std::string* instr_attrib_value);

  // @@protoc_insertion_point(class_scope:Common.AttrbGrp)
 private:
  inline void set_has_instr_attrib_type();
  inline void clear_has_instr_attrib_type();
  inline void set_has_instr_attrib_value();
  inline void clear_has_instr_attrib_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* instr_attrib_value_;
  int instr_attrib_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static AttrbGrp* default_instance_;
};
// -------------------------------------------------------------------

class InstrumentExtension : public ::google::protobuf::Message {
 public:
  InstrumentExtension();
  virtual ~InstrumentExtension();

  InstrumentExtension(const InstrumentExtension& from);

  inline InstrumentExtension& operator=(const InstrumentExtension& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrumentExtension& default_instance();

  void Swap(InstrumentExtension* other);

  // implements Message ----------------------------------------------

  InstrumentExtension* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrumentExtension& from);
  void MergeFrom(const InstrumentExtension& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Common.AttrbGrp attrb_grp = 1;
  inline int attrb_grp_size() const;
  inline void clear_attrb_grp();
  static const int kAttrbGrpFieldNumber = 1;
  inline const ::Common::AttrbGrp& attrb_grp(int index) const;
  inline ::Common::AttrbGrp* mutable_attrb_grp(int index);
  inline ::Common::AttrbGrp* add_attrb_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::AttrbGrp >&
      attrb_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::AttrbGrp >*
      mutable_attrb_grp();

  // optional .Common.DeliveryFormEnum delivery_form = 2;
  inline bool has_delivery_form() const;
  inline void clear_delivery_form();
  static const int kDeliveryFormFieldNumber = 2;
  inline ::Common::DeliveryFormEnum delivery_form() const;
  inline void set_delivery_form(::Common::DeliveryFormEnum value);

  // optional sfixed64 pct_at_risk = 3;
  inline bool has_pct_at_risk() const;
  inline void clear_pct_at_risk();
  static const int kPctAtRiskFieldNumber = 3;
  inline ::google::protobuf::int64 pct_at_risk() const;
  inline void set_pct_at_risk(::google::protobuf::int64 value);

  // optional sfixed32 pct_at_risk_exponent = 4;
  inline bool has_pct_at_risk_exponent() const;
  inline void clear_pct_at_risk_exponent();
  static const int kPctAtRiskExponentFieldNumber = 4;
  inline ::google::protobuf::int32 pct_at_risk_exponent() const;
  inline void set_pct_at_risk_exponent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Common.InstrumentExtension)
 private:
  inline void set_has_delivery_form();
  inline void clear_has_delivery_form();
  inline void set_has_pct_at_risk();
  inline void clear_has_pct_at_risk();
  inline void set_has_pct_at_risk_exponent();
  inline void clear_has_pct_at_risk_exponent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Common::AttrbGrp > attrb_grp_;
  ::google::protobuf::int64 pct_at_risk_;
  int delivery_form_;
  ::google::protobuf::int32 pct_at_risk_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static InstrumentExtension* default_instance_;
};
// -------------------------------------------------------------------

class TickRules : public ::google::protobuf::Message {
 public:
  TickRules();
  virtual ~TickRules();

  TickRules(const TickRules& from);

  inline TickRules& operator=(const TickRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TickRules& default_instance();

  void Swap(TickRules* other);

  // implements Message ----------------------------------------------

  TickRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TickRules& from);
  void MergeFrom(const TickRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 end_tick_price_range = 1;
  inline bool has_end_tick_price_range() const;
  inline void clear_end_tick_price_range();
  static const int kEndTickPriceRangeFieldNumber = 1;
  inline ::google::protobuf::int64 end_tick_price_range() const;
  inline void set_end_tick_price_range(::google::protobuf::int64 value);

  // optional sfixed32 end_tick_price_range_exponent = 2;
  inline bool has_end_tick_price_range_exponent() const;
  inline void clear_end_tick_price_range_exponent();
  static const int kEndTickPriceRangeExponentFieldNumber = 2;
  inline ::google::protobuf::int32 end_tick_price_range_exponent() const;
  inline void set_end_tick_price_range_exponent(::google::protobuf::int32 value);

  // optional sfixed64 start_tick_price_range = 3;
  inline bool has_start_tick_price_range() const;
  inline void clear_start_tick_price_range();
  static const int kStartTickPriceRangeFieldNumber = 3;
  inline ::google::protobuf::int64 start_tick_price_range() const;
  inline void set_start_tick_price_range(::google::protobuf::int64 value);

  // optional sfixed32 start_tick_price_range_exponent = 4;
  inline bool has_start_tick_price_range_exponent() const;
  inline void clear_start_tick_price_range_exponent();
  static const int kStartTickPriceRangeExponentFieldNumber = 4;
  inline ::google::protobuf::int32 start_tick_price_range_exponent() const;
  inline void set_start_tick_price_range_exponent(::google::protobuf::int32 value);

  // optional sfixed64 tick_increment = 5;
  inline bool has_tick_increment() const;
  inline void clear_tick_increment();
  static const int kTickIncrementFieldNumber = 5;
  inline ::google::protobuf::int64 tick_increment() const;
  inline void set_tick_increment(::google::protobuf::int64 value);

  // optional sfixed32 tick_increment_exponent = 6;
  inline bool has_tick_increment_exponent() const;
  inline void clear_tick_increment_exponent();
  static const int kTickIncrementExponentFieldNumber = 6;
  inline ::google::protobuf::int32 tick_increment_exponent() const;
  inline void set_tick_increment_exponent(::google::protobuf::int32 value);

  // optional .Common.TickRuleTypeEnum tick_rule_type = 7;
  inline bool has_tick_rule_type() const;
  inline void clear_tick_rule_type();
  static const int kTickRuleTypeFieldNumber = 7;
  inline ::Common::TickRuleTypeEnum tick_rule_type() const;
  inline void set_tick_rule_type(::Common::TickRuleTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.TickRules)
 private:
  inline void set_has_end_tick_price_range();
  inline void clear_has_end_tick_price_range();
  inline void set_has_end_tick_price_range_exponent();
  inline void clear_has_end_tick_price_range_exponent();
  inline void set_has_start_tick_price_range();
  inline void clear_has_start_tick_price_range();
  inline void set_has_start_tick_price_range_exponent();
  inline void clear_has_start_tick_price_range_exponent();
  inline void set_has_tick_increment();
  inline void clear_has_tick_increment();
  inline void set_has_tick_increment_exponent();
  inline void clear_has_tick_increment_exponent();
  inline void set_has_tick_rule_type();
  inline void clear_has_tick_rule_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 end_tick_price_range_;
  ::google::protobuf::int64 start_tick_price_range_;
  ::google::protobuf::int32 end_tick_price_range_exponent_;
  ::google::protobuf::int32 start_tick_price_range_exponent_;
  ::google::protobuf::int64 tick_increment_;
  ::google::protobuf::int32 tick_increment_exponent_;
  int tick_rule_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TickRules* default_instance_;
};
// -------------------------------------------------------------------

class LotTypeRules : public ::google::protobuf::Message {
 public:
  LotTypeRules();
  virtual ~LotTypeRules();

  LotTypeRules(const LotTypeRules& from);

  inline LotTypeRules& operator=(const LotTypeRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LotTypeRules& default_instance();

  void Swap(LotTypeRules* other);

  // implements Message ----------------------------------------------

  LotTypeRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LotTypeRules& from);
  void MergeFrom(const LotTypeRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.LotTypeEnum lot_type = 1;
  inline bool has_lot_type() const;
  inline void clear_lot_type();
  static const int kLotTypeFieldNumber = 1;
  inline ::Common::LotTypeEnum lot_type() const;
  inline void set_lot_type(::Common::LotTypeEnum value);

  // optional sfixed64 min_lot_size = 2;
  inline bool has_min_lot_size() const;
  inline void clear_min_lot_size();
  static const int kMinLotSizeFieldNumber = 2;
  inline ::google::protobuf::int64 min_lot_size() const;
  inline void set_min_lot_size(::google::protobuf::int64 value);

  // optional sfixed32 min_lot_size_exponent = 3;
  inline bool has_min_lot_size_exponent() const;
  inline void clear_min_lot_size_exponent();
  static const int kMinLotSizeExponentFieldNumber = 3;
  inline ::google::protobuf::int32 min_lot_size_exponent() const;
  inline void set_min_lot_size_exponent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Common.LotTypeRules)
 private:
  inline void set_has_lot_type();
  inline void clear_has_lot_type();
  inline void set_has_min_lot_size();
  inline void clear_has_min_lot_size();
  inline void set_has_min_lot_size_exponent();
  inline void clear_has_min_lot_size_exponent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 min_lot_size_;
  int lot_type_;
  ::google::protobuf::int32 min_lot_size_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LotTypeRules* default_instance_;
};
// -------------------------------------------------------------------

class PriceLimits : public ::google::protobuf::Message {
 public:
  PriceLimits();
  virtual ~PriceLimits();

  PriceLimits(const PriceLimits& from);

  inline PriceLimits& operator=(const PriceLimits& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PriceLimits& default_instance();

  void Swap(PriceLimits* other);

  // implements Message ----------------------------------------------

  PriceLimits* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PriceLimits& from);
  void MergeFrom(const PriceLimits& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 high_limit_price = 1;
  inline bool has_high_limit_price() const;
  inline void clear_high_limit_price();
  static const int kHighLimitPriceFieldNumber = 1;
  inline ::google::protobuf::int64 high_limit_price() const;
  inline void set_high_limit_price(::google::protobuf::int64 value);

  // optional sfixed32 high_limit_price_exponent = 2;
  inline bool has_high_limit_price_exponent() const;
  inline void clear_high_limit_price_exponent();
  static const int kHighLimitPriceExponentFieldNumber = 2;
  inline ::google::protobuf::int32 high_limit_price_exponent() const;
  inline void set_high_limit_price_exponent(::google::protobuf::int32 value);

  // optional sfixed64 low_limit_price = 3;
  inline bool has_low_limit_price() const;
  inline void clear_low_limit_price();
  static const int kLowLimitPriceFieldNumber = 3;
  inline ::google::protobuf::int64 low_limit_price() const;
  inline void set_low_limit_price(::google::protobuf::int64 value);

  // optional sfixed32 low_limit_price_exponent = 4;
  inline bool has_low_limit_price_exponent() const;
  inline void clear_low_limit_price_exponent();
  static const int kLowLimitPriceExponentFieldNumber = 4;
  inline ::google::protobuf::int32 low_limit_price_exponent() const;
  inline void set_low_limit_price_exponent(::google::protobuf::int32 value);

  // optional .Common.PriceLimitTypeEnum price_limit_type = 5;
  inline bool has_price_limit_type() const;
  inline void clear_price_limit_type();
  static const int kPriceLimitTypeFieldNumber = 5;
  inline ::Common::PriceLimitTypeEnum price_limit_type() const;
  inline void set_price_limit_type(::Common::PriceLimitTypeEnum value);

  // optional sfixed64 trading_reference_price = 6;
  inline bool has_trading_reference_price() const;
  inline void clear_trading_reference_price();
  static const int kTradingReferencePriceFieldNumber = 6;
  inline ::google::protobuf::int64 trading_reference_price() const;
  inline void set_trading_reference_price(::google::protobuf::int64 value);

  // optional sfixed32 trading_reference_price_exponent = 7;
  inline bool has_trading_reference_price_exponent() const;
  inline void clear_trading_reference_price_exponent();
  static const int kTradingReferencePriceExponentFieldNumber = 7;
  inline ::google::protobuf::int32 trading_reference_price_exponent() const;
  inline void set_trading_reference_price_exponent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Common.PriceLimits)
 private:
  inline void set_has_high_limit_price();
  inline void clear_has_high_limit_price();
  inline void set_has_high_limit_price_exponent();
  inline void clear_has_high_limit_price_exponent();
  inline void set_has_low_limit_price();
  inline void clear_has_low_limit_price();
  inline void set_has_low_limit_price_exponent();
  inline void clear_has_low_limit_price_exponent();
  inline void set_has_price_limit_type();
  inline void clear_has_price_limit_type();
  inline void set_has_trading_reference_price();
  inline void clear_has_trading_reference_price();
  inline void set_has_trading_reference_price_exponent();
  inline void clear_has_trading_reference_price_exponent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 high_limit_price_;
  ::google::protobuf::int64 low_limit_price_;
  ::google::protobuf::int32 high_limit_price_exponent_;
  ::google::protobuf::int32 low_limit_price_exponent_;
  ::google::protobuf::int64 trading_reference_price_;
  int price_limit_type_;
  ::google::protobuf::int32 trading_reference_price_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static PriceLimits* default_instance_;
};
// -------------------------------------------------------------------

class BaseTradingRules : public ::google::protobuf::Message {
 public:
  BaseTradingRules();
  virtual ~BaseTradingRules();

  BaseTradingRules(const BaseTradingRules& from);

  inline BaseTradingRules& operator=(const BaseTradingRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseTradingRules& default_instance();

  void Swap(BaseTradingRules* other);

  // implements Message ----------------------------------------------

  BaseTradingRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BaseTradingRules& from);
  void MergeFrom(const BaseTradingRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.ExpirationCycleEnum expiration_cycle = 1;
  inline bool has_expiration_cycle() const;
  inline void clear_expiration_cycle();
  static const int kExpirationCycleFieldNumber = 1;
  inline ::Common::ExpirationCycleEnum expiration_cycle() const;
  inline void set_expiration_cycle(::Common::ExpirationCycleEnum value);

  // optional .Common.ImpliedMarketIndicatorEnum implied_market_indicator = 2;
  inline bool has_implied_market_indicator() const;
  inline void clear_implied_market_indicator();
  static const int kImpliedMarketIndicatorFieldNumber = 2;
  inline ::Common::ImpliedMarketIndicatorEnum implied_market_indicator() const;
  inline void set_implied_market_indicator(::Common::ImpliedMarketIndicatorEnum value);

  // repeated .Common.LotTypeRules lot_type_rules = 3;
  inline int lot_type_rules_size() const;
  inline void clear_lot_type_rules();
  static const int kLotTypeRulesFieldNumber = 3;
  inline const ::Common::LotTypeRules& lot_type_rules(int index) const;
  inline ::Common::LotTypeRules* mutable_lot_type_rules(int index);
  inline ::Common::LotTypeRules* add_lot_type_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::LotTypeRules >&
      lot_type_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::LotTypeRules >*
      mutable_lot_type_rules();

  // optional double max_price_variation = 4;
  inline bool has_max_price_variation() const;
  inline void clear_max_price_variation();
  static const int kMaxPriceVariationFieldNumber = 4;
  inline double max_price_variation() const;
  inline void set_max_price_variation(double value);

  // optional sfixed64 max_trade_vol = 5;
  inline bool has_max_trade_vol() const;
  inline void clear_max_trade_vol();
  static const int kMaxTradeVolFieldNumber = 5;
  inline ::google::protobuf::int64 max_trade_vol() const;
  inline void set_max_trade_vol(::google::protobuf::int64 value);

  // optional sfixed32 max_trade_vol_exponent = 6;
  inline bool has_max_trade_vol_exponent() const;
  inline void clear_max_trade_vol_exponent();
  static const int kMaxTradeVolExponentFieldNumber = 6;
  inline ::google::protobuf::int32 max_trade_vol_exponent() const;
  inline void set_max_trade_vol_exponent(::google::protobuf::int32 value);

  // optional sfixed64 min_trade_vol = 7;
  inline bool has_min_trade_vol() const;
  inline void clear_min_trade_vol();
  static const int kMinTradeVolFieldNumber = 7;
  inline ::google::protobuf::int64 min_trade_vol() const;
  inline void set_min_trade_vol(::google::protobuf::int64 value);

  // optional sfixed32 min_trade_vol_exponent = 8;
  inline bool has_min_trade_vol_exponent() const;
  inline void clear_min_trade_vol_exponent();
  static const int kMinTradeVolExponentFieldNumber = 8;
  inline ::google::protobuf::int32 min_trade_vol_exponent() const;
  inline void set_min_trade_vol_exponent(::google::protobuf::int32 value);

  // optional .Common.MultilegModelEnum multileg_model = 9;
  inline bool has_multileg_model() const;
  inline void clear_multileg_model();
  static const int kMultilegModelFieldNumber = 9;
  inline ::Common::MultilegModelEnum multileg_model() const;
  inline void set_multileg_model(::Common::MultilegModelEnum value);

  // optional .Common.MultilegPriceMethodEnum multileg_price_method = 10;
  inline bool has_multileg_price_method() const;
  inline void clear_multileg_price_method();
  static const int kMultilegPriceMethodFieldNumber = 10;
  inline ::Common::MultilegPriceMethodEnum multileg_price_method() const;
  inline void set_multileg_price_method(::Common::MultilegPriceMethodEnum value);

  // optional .Common.PriceLimits price_limits = 11;
  inline bool has_price_limits() const;
  inline void clear_price_limits();
  static const int kPriceLimitsFieldNumber = 11;
  inline const ::Common::PriceLimits& price_limits() const;
  inline ::Common::PriceLimits* mutable_price_limits();
  inline ::Common::PriceLimits* release_price_limits();
  inline void set_allocated_price_limits(::Common::PriceLimits* price_limits);

  // optional .Common.PriceTypeEnum price_type = 12;
  inline bool has_price_type() const;
  inline void clear_price_type();
  static const int kPriceTypeFieldNumber = 12;
  inline ::Common::PriceTypeEnum price_type() const;
  inline void set_price_type(::Common::PriceTypeEnum value);

  // optional sfixed64 round_lot = 13;
  inline bool has_round_lot() const;
  inline void clear_round_lot();
  static const int kRoundLotFieldNumber = 13;
  inline ::google::protobuf::int64 round_lot() const;
  inline void set_round_lot(::google::protobuf::int64 value);

  // optional sfixed32 round_lot_exponent = 14;
  inline bool has_round_lot_exponent() const;
  inline void clear_round_lot_exponent();
  static const int kRoundLotExponentFieldNumber = 14;
  inline ::google::protobuf::int32 round_lot_exponent() const;
  inline void set_round_lot_exponent(::google::protobuf::int32 value);

  // repeated .Common.TickRules tick_rules = 15;
  inline int tick_rules_size() const;
  inline void clear_tick_rules();
  static const int kTickRulesFieldNumber = 15;
  inline const ::Common::TickRules& tick_rules(int index) const;
  inline ::Common::TickRules* mutable_tick_rules(int index);
  inline ::Common::TickRules* add_tick_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::TickRules >&
      tick_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::TickRules >*
      mutable_tick_rules();

  // optional string trading_currency = 16;
  inline bool has_trading_currency() const;
  inline void clear_trading_currency();
  static const int kTradingCurrencyFieldNumber = 16;
  inline const ::std::string& trading_currency() const;
  inline void set_trading_currency(const ::std::string& value);
  inline void set_trading_currency(const char* value);
  inline void set_trading_currency(const char* value, size_t size);
  inline ::std::string* mutable_trading_currency();
  inline ::std::string* release_trading_currency();
  inline void set_allocated_trading_currency(::std::string* trading_currency);

  // @@protoc_insertion_point(class_scope:Common.BaseTradingRules)
 private:
  inline void set_has_expiration_cycle();
  inline void clear_has_expiration_cycle();
  inline void set_has_implied_market_indicator();
  inline void clear_has_implied_market_indicator();
  inline void set_has_max_price_variation();
  inline void clear_has_max_price_variation();
  inline void set_has_max_trade_vol();
  inline void clear_has_max_trade_vol();
  inline void set_has_max_trade_vol_exponent();
  inline void clear_has_max_trade_vol_exponent();
  inline void set_has_min_trade_vol();
  inline void clear_has_min_trade_vol();
  inline void set_has_min_trade_vol_exponent();
  inline void clear_has_min_trade_vol_exponent();
  inline void set_has_multileg_model();
  inline void clear_has_multileg_model();
  inline void set_has_multileg_price_method();
  inline void clear_has_multileg_price_method();
  inline void set_has_price_limits();
  inline void clear_has_price_limits();
  inline void set_has_price_type();
  inline void clear_has_price_type();
  inline void set_has_round_lot();
  inline void clear_has_round_lot();
  inline void set_has_round_lot_exponent();
  inline void clear_has_round_lot_exponent();
  inline void set_has_trading_currency();
  inline void clear_has_trading_currency();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int expiration_cycle_;
  int implied_market_indicator_;
  ::google::protobuf::RepeatedPtrField< ::Common::LotTypeRules > lot_type_rules_;
  double max_price_variation_;
  ::google::protobuf::int64 max_trade_vol_;
  ::google::protobuf::int64 min_trade_vol_;
  ::google::protobuf::int32 max_trade_vol_exponent_;
  ::google::protobuf::int32 min_trade_vol_exponent_;
  int multileg_model_;
  int multileg_price_method_;
  ::Common::PriceLimits* price_limits_;
  ::google::protobuf::int64 round_lot_;
  int price_type_;
  ::google::protobuf::int32 round_lot_exponent_;
  ::google::protobuf::RepeatedPtrField< ::Common::TickRules > tick_rules_;
  ::std::string* trading_currency_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static BaseTradingRules* default_instance_;
};
// -------------------------------------------------------------------

class OrdTypeRules : public ::google::protobuf::Message {
 public:
  OrdTypeRules();
  virtual ~OrdTypeRules();

  OrdTypeRules(const OrdTypeRules& from);

  inline OrdTypeRules& operator=(const OrdTypeRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OrdTypeRules& default_instance();

  void Swap(OrdTypeRules* other);

  // implements Message ----------------------------------------------

  OrdTypeRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OrdTypeRules& from);
  void MergeFrom(const OrdTypeRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.OrdTypeEnum ord_type = 1;
  inline bool has_ord_type() const;
  inline void clear_ord_type();
  static const int kOrdTypeFieldNumber = 1;
  inline ::Common::OrdTypeEnum ord_type() const;
  inline void set_ord_type(::Common::OrdTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.OrdTypeRules)
 private:
  inline void set_has_ord_type();
  inline void clear_has_ord_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int ord_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static OrdTypeRules* default_instance_;
};
// -------------------------------------------------------------------

class TimeInForceRules : public ::google::protobuf::Message {
 public:
  TimeInForceRules();
  virtual ~TimeInForceRules();

  TimeInForceRules(const TimeInForceRules& from);

  inline TimeInForceRules& operator=(const TimeInForceRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeInForceRules& default_instance();

  void Swap(TimeInForceRules* other);

  // implements Message ----------------------------------------------

  TimeInForceRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeInForceRules& from);
  void MergeFrom(const TimeInForceRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.TimeInForceEnum time_in_force = 1;
  inline bool has_time_in_force() const;
  inline void clear_time_in_force();
  static const int kTimeInForceFieldNumber = 1;
  inline ::Common::TimeInForceEnum time_in_force() const;
  inline void set_time_in_force(::Common::TimeInForceEnum value);

  // @@protoc_insertion_point(class_scope:Common.TimeInForceRules)
 private:
  inline void set_has_time_in_force();
  inline void clear_has_time_in_force();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int time_in_force_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TimeInForceRules* default_instance_;
};
// -------------------------------------------------------------------

class ExecInstRules : public ::google::protobuf::Message {
 public:
  ExecInstRules();
  virtual ~ExecInstRules();

  ExecInstRules(const ExecInstRules& from);

  inline ExecInstRules& operator=(const ExecInstRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecInstRules& default_instance();

  void Swap(ExecInstRules* other);

  // implements Message ----------------------------------------------

  ExecInstRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecInstRules& from);
  void MergeFrom(const ExecInstRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string exec_inst_value = 1;
  inline bool has_exec_inst_value() const;
  inline void clear_exec_inst_value();
  static const int kExecInstValueFieldNumber = 1;
  inline const ::std::string& exec_inst_value() const;
  inline void set_exec_inst_value(const ::std::string& value);
  inline void set_exec_inst_value(const char* value);
  inline void set_exec_inst_value(const char* value, size_t size);
  inline ::std::string* mutable_exec_inst_value();
  inline ::std::string* release_exec_inst_value();
  inline void set_allocated_exec_inst_value(::std::string* exec_inst_value);

  // @@protoc_insertion_point(class_scope:Common.ExecInstRules)
 private:
  inline void set_has_exec_inst_value();
  inline void clear_has_exec_inst_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* exec_inst_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static ExecInstRules* default_instance_;
};
// -------------------------------------------------------------------

class MatchRules : public ::google::protobuf::Message {
 public:
  MatchRules();
  virtual ~MatchRules();

  MatchRules(const MatchRules& from);

  inline MatchRules& operator=(const MatchRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchRules& default_instance();

  void Swap(MatchRules* other);

  // implements Message ----------------------------------------------

  MatchRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchRules& from);
  void MergeFrom(const MatchRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string match_algorithm = 1;
  inline bool has_match_algorithm() const;
  inline void clear_match_algorithm();
  static const int kMatchAlgorithmFieldNumber = 1;
  inline const ::std::string& match_algorithm() const;
  inline void set_match_algorithm(const ::std::string& value);
  inline void set_match_algorithm(const char* value);
  inline void set_match_algorithm(const char* value, size_t size);
  inline ::std::string* mutable_match_algorithm();
  inline ::std::string* release_match_algorithm();
  inline void set_allocated_match_algorithm(::std::string* match_algorithm);

  // optional .Common.MatchTypeEnum match_type = 2;
  inline bool has_match_type() const;
  inline void clear_match_type();
  static const int kMatchTypeFieldNumber = 2;
  inline ::Common::MatchTypeEnum match_type() const;
  inline void set_match_type(::Common::MatchTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.MatchRules)
 private:
  inline void set_has_match_algorithm();
  inline void clear_has_match_algorithm();
  inline void set_has_match_type();
  inline void clear_has_match_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* match_algorithm_;
  int match_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static MatchRules* default_instance_;
};
// -------------------------------------------------------------------

class MarketDataFeedTypes : public ::google::protobuf::Message {
 public:
  MarketDataFeedTypes();
  virtual ~MarketDataFeedTypes();

  MarketDataFeedTypes(const MarketDataFeedTypes& from);

  inline MarketDataFeedTypes& operator=(const MarketDataFeedTypes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketDataFeedTypes& default_instance();

  void Swap(MarketDataFeedTypes* other);

  // implements Message ----------------------------------------------

  MarketDataFeedTypes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketDataFeedTypes& from);
  void MergeFrom(const MarketDataFeedTypes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.MdBookTypeEnum md_book_type = 1;
  inline bool has_md_book_type() const;
  inline void clear_md_book_type();
  static const int kMdBookTypeFieldNumber = 1;
  inline ::Common::MdBookTypeEnum md_book_type() const;
  inline void set_md_book_type(::Common::MdBookTypeEnum value);

  // optional string md_feed_type = 2;
  inline bool has_md_feed_type() const;
  inline void clear_md_feed_type();
  static const int kMdFeedTypeFieldNumber = 2;
  inline const ::std::string& md_feed_type() const;
  inline void set_md_feed_type(const ::std::string& value);
  inline void set_md_feed_type(const char* value);
  inline void set_md_feed_type(const char* value, size_t size);
  inline ::std::string* mutable_md_feed_type();
  inline ::std::string* release_md_feed_type();
  inline void set_allocated_md_feed_type(::std::string* md_feed_type);

  // optional sfixed64 market_depth = 3;
  inline bool has_market_depth() const;
  inline void clear_market_depth();
  static const int kMarketDepthFieldNumber = 3;
  inline ::google::protobuf::int64 market_depth() const;
  inline void set_market_depth(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.MarketDataFeedTypes)
 private:
  inline void set_has_md_book_type();
  inline void clear_has_md_book_type();
  inline void set_has_md_feed_type();
  inline void clear_has_md_feed_type();
  inline void set_has_market_depth();
  inline void clear_has_market_depth();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* md_feed_type_;
  ::google::protobuf::int64 market_depth_;
  int md_book_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static MarketDataFeedTypes* default_instance_;
};
// -------------------------------------------------------------------

class TradingSessionRules : public ::google::protobuf::Message {
 public:
  TradingSessionRules();
  virtual ~TradingSessionRules();

  TradingSessionRules(const TradingSessionRules& from);

  inline TradingSessionRules& operator=(const TradingSessionRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradingSessionRules& default_instance();

  void Swap(TradingSessionRules* other);

  // implements Message ----------------------------------------------

  TradingSessionRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradingSessionRules& from);
  void MergeFrom(const TradingSessionRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Common.ExecInstRules exec_inst_rules = 1;
  inline int exec_inst_rules_size() const;
  inline void clear_exec_inst_rules();
  static const int kExecInstRulesFieldNumber = 1;
  inline const ::Common::ExecInstRules& exec_inst_rules(int index) const;
  inline ::Common::ExecInstRules* mutable_exec_inst_rules(int index);
  inline ::Common::ExecInstRules* add_exec_inst_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::ExecInstRules >&
      exec_inst_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::ExecInstRules >*
      mutable_exec_inst_rules();

  // repeated .Common.MarketDataFeedTypes market_data_feed_types = 2;
  inline int market_data_feed_types_size() const;
  inline void clear_market_data_feed_types();
  static const int kMarketDataFeedTypesFieldNumber = 2;
  inline const ::Common::MarketDataFeedTypes& market_data_feed_types(int index) const;
  inline ::Common::MarketDataFeedTypes* mutable_market_data_feed_types(int index);
  inline ::Common::MarketDataFeedTypes* add_market_data_feed_types();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::MarketDataFeedTypes >&
      market_data_feed_types() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::MarketDataFeedTypes >*
      mutable_market_data_feed_types();

  // repeated .Common.MatchRules match_rules = 3;
  inline int match_rules_size() const;
  inline void clear_match_rules();
  static const int kMatchRulesFieldNumber = 3;
  inline const ::Common::MatchRules& match_rules(int index) const;
  inline ::Common::MatchRules* mutable_match_rules(int index);
  inline ::Common::MatchRules* add_match_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::MatchRules >&
      match_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::MatchRules >*
      mutable_match_rules();

  // repeated .Common.OrdTypeRules ord_type_rules = 4;
  inline int ord_type_rules_size() const;
  inline void clear_ord_type_rules();
  static const int kOrdTypeRulesFieldNumber = 4;
  inline const ::Common::OrdTypeRules& ord_type_rules(int index) const;
  inline ::Common::OrdTypeRules* mutable_ord_type_rules(int index);
  inline ::Common::OrdTypeRules* add_ord_type_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::OrdTypeRules >&
      ord_type_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::OrdTypeRules >*
      mutable_ord_type_rules();

  // repeated .Common.TimeInForceRules time_in_force_rules = 5;
  inline int time_in_force_rules_size() const;
  inline void clear_time_in_force_rules();
  static const int kTimeInForceRulesFieldNumber = 5;
  inline const ::Common::TimeInForceRules& time_in_force_rules(int index) const;
  inline ::Common::TimeInForceRules* mutable_time_in_force_rules(int index);
  inline ::Common::TimeInForceRules* add_time_in_force_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::TimeInForceRules >&
      time_in_force_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::TimeInForceRules >*
      mutable_time_in_force_rules();

  // @@protoc_insertion_point(class_scope:Common.TradingSessionRules)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Common::ExecInstRules > exec_inst_rules_;
  ::google::protobuf::RepeatedPtrField< ::Common::MarketDataFeedTypes > market_data_feed_types_;
  ::google::protobuf::RepeatedPtrField< ::Common::MatchRules > match_rules_;
  ::google::protobuf::RepeatedPtrField< ::Common::OrdTypeRules > ord_type_rules_;
  ::google::protobuf::RepeatedPtrField< ::Common::TimeInForceRules > time_in_force_rules_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TradingSessionRules* default_instance_;
};
// -------------------------------------------------------------------

class TradingSessionRulesGrp : public ::google::protobuf::Message {
 public:
  TradingSessionRulesGrp();
  virtual ~TradingSessionRulesGrp();

  TradingSessionRulesGrp(const TradingSessionRulesGrp& from);

  inline TradingSessionRulesGrp& operator=(const TradingSessionRulesGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradingSessionRulesGrp& default_instance();

  void Swap(TradingSessionRulesGrp* other);

  // implements Message ----------------------------------------------

  TradingSessionRulesGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TradingSessionRulesGrp& from);
  void MergeFrom(const TradingSessionRulesGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.TradingSessionIdEnum trading_session_id = 1;
  inline bool has_trading_session_id() const;
  inline void clear_trading_session_id();
  static const int kTradingSessionIdFieldNumber = 1;
  inline ::Common::TradingSessionIdEnum trading_session_id() const;
  inline void set_trading_session_id(::Common::TradingSessionIdEnum value);

  // optional .Common.TradingSessionRules trading_session_rules = 2;
  inline bool has_trading_session_rules() const;
  inline void clear_trading_session_rules();
  static const int kTradingSessionRulesFieldNumber = 2;
  inline const ::Common::TradingSessionRules& trading_session_rules() const;
  inline ::Common::TradingSessionRules* mutable_trading_session_rules();
  inline ::Common::TradingSessionRules* release_trading_session_rules();
  inline void set_allocated_trading_session_rules(::Common::TradingSessionRules* trading_session_rules);

  // optional .Common.TradingSessionSubIdEnum trading_session_sub_id = 3;
  inline bool has_trading_session_sub_id() const;
  inline void clear_trading_session_sub_id();
  static const int kTradingSessionSubIdFieldNumber = 3;
  inline ::Common::TradingSessionSubIdEnum trading_session_sub_id() const;
  inline void set_trading_session_sub_id(::Common::TradingSessionSubIdEnum value);

  // @@protoc_insertion_point(class_scope:Common.TradingSessionRulesGrp)
 private:
  inline void set_has_trading_session_id();
  inline void clear_has_trading_session_id();
  inline void set_has_trading_session_rules();
  inline void clear_has_trading_session_rules();
  inline void set_has_trading_session_sub_id();
  inline void clear_has_trading_session_sub_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Common::TradingSessionRules* trading_session_rules_;
  int trading_session_id_;
  int trading_session_sub_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static TradingSessionRulesGrp* default_instance_;
};
// -------------------------------------------------------------------

class NestedInstrumentAttribute : public ::google::protobuf::Message {
 public:
  NestedInstrumentAttribute();
  virtual ~NestedInstrumentAttribute();

  NestedInstrumentAttribute(const NestedInstrumentAttribute& from);

  inline NestedInstrumentAttribute& operator=(const NestedInstrumentAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NestedInstrumentAttribute& default_instance();

  void Swap(NestedInstrumentAttribute* other);

  // implements Message ----------------------------------------------

  NestedInstrumentAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NestedInstrumentAttribute& from);
  void MergeFrom(const NestedInstrumentAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 nested_instr_attrib_type = 1;
  inline bool has_nested_instr_attrib_type() const;
  inline void clear_nested_instr_attrib_type();
  static const int kNestedInstrAttribTypeFieldNumber = 1;
  inline ::google::protobuf::int64 nested_instr_attrib_type() const;
  inline void set_nested_instr_attrib_type(::google::protobuf::int64 value);

  // optional string nested_instr_attrib_value = 2;
  inline bool has_nested_instr_attrib_value() const;
  inline void clear_nested_instr_attrib_value();
  static const int kNestedInstrAttribValueFieldNumber = 2;
  inline const ::std::string& nested_instr_attrib_value() const;
  inline void set_nested_instr_attrib_value(const ::std::string& value);
  inline void set_nested_instr_attrib_value(const char* value);
  inline void set_nested_instr_attrib_value(const char* value, size_t size);
  inline ::std::string* mutable_nested_instr_attrib_value();
  inline ::std::string* release_nested_instr_attrib_value();
  inline void set_allocated_nested_instr_attrib_value(::std::string* nested_instr_attrib_value);

  // @@protoc_insertion_point(class_scope:Common.NestedInstrumentAttribute)
 private:
  inline void set_has_nested_instr_attrib_type();
  inline void clear_has_nested_instr_attrib_type();
  inline void set_has_nested_instr_attrib_value();
  inline void clear_has_nested_instr_attrib_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 nested_instr_attrib_type_;
  ::std::string* nested_instr_attrib_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static NestedInstrumentAttribute* default_instance_;
};
// -------------------------------------------------------------------

class SecurityTradingRules : public ::google::protobuf::Message {
 public:
  SecurityTradingRules();
  virtual ~SecurityTradingRules();

  SecurityTradingRules(const SecurityTradingRules& from);

  inline SecurityTradingRules& operator=(const SecurityTradingRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityTradingRules& default_instance();

  void Swap(SecurityTradingRules* other);

  // implements Message ----------------------------------------------

  SecurityTradingRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityTradingRules& from);
  void MergeFrom(const SecurityTradingRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.BaseTradingRules base_trading_rules = 1;
  inline bool has_base_trading_rules() const;
  inline void clear_base_trading_rules();
  static const int kBaseTradingRulesFieldNumber = 1;
  inline const ::Common::BaseTradingRules& base_trading_rules() const;
  inline ::Common::BaseTradingRules* mutable_base_trading_rules();
  inline ::Common::BaseTradingRules* release_base_trading_rules();
  inline void set_allocated_base_trading_rules(::Common::BaseTradingRules* base_trading_rules);

  // repeated .Common.NestedInstrumentAttribute nested_instrument_attribute = 2;
  inline int nested_instrument_attribute_size() const;
  inline void clear_nested_instrument_attribute();
  static const int kNestedInstrumentAttributeFieldNumber = 2;
  inline const ::Common::NestedInstrumentAttribute& nested_instrument_attribute(int index) const;
  inline ::Common::NestedInstrumentAttribute* mutable_nested_instrument_attribute(int index);
  inline ::Common::NestedInstrumentAttribute* add_nested_instrument_attribute();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedInstrumentAttribute >&
      nested_instrument_attribute() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::NestedInstrumentAttribute >*
      mutable_nested_instrument_attribute();

  // repeated .Common.TradingSessionRulesGrp trading_session_rules_grp = 3;
  inline int trading_session_rules_grp_size() const;
  inline void clear_trading_session_rules_grp();
  static const int kTradingSessionRulesGrpFieldNumber = 3;
  inline const ::Common::TradingSessionRulesGrp& trading_session_rules_grp(int index) const;
  inline ::Common::TradingSessionRulesGrp* mutable_trading_session_rules_grp(int index);
  inline ::Common::TradingSessionRulesGrp* add_trading_session_rules_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::TradingSessionRulesGrp >&
      trading_session_rules_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::TradingSessionRulesGrp >*
      mutable_trading_session_rules_grp();

  // @@protoc_insertion_point(class_scope:Common.SecurityTradingRules)
 private:
  inline void set_has_base_trading_rules();
  inline void clear_has_base_trading_rules();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Common::BaseTradingRules* base_trading_rules_;
  ::google::protobuf::RepeatedPtrField< ::Common::NestedInstrumentAttribute > nested_instrument_attribute_;
  ::google::protobuf::RepeatedPtrField< ::Common::TradingSessionRulesGrp > trading_session_rules_grp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static SecurityTradingRules* default_instance_;
};
// -------------------------------------------------------------------

class MaturityRules : public ::google::protobuf::Message {
 public:
  MaturityRules();
  virtual ~MaturityRules();

  MaturityRules(const MaturityRules& from);

  inline MaturityRules& operator=(const MaturityRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MaturityRules& default_instance();

  void Swap(MaturityRules* other);

  // implements Message ----------------------------------------------

  MaturityRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MaturityRules& from);
  void MergeFrom(const MaturityRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed32 end_maturity_month_year = 1;
  inline bool has_end_maturity_month_year() const;
  inline void clear_end_maturity_month_year();
  static const int kEndMaturityMonthYearFieldNumber = 1;
  inline ::google::protobuf::int32 end_maturity_month_year() const;
  inline void set_end_maturity_month_year(::google::protobuf::int32 value);

  // optional .Common.MaturityMonthYearFormatEnum maturity_month_year_format = 2;
  inline bool has_maturity_month_year_format() const;
  inline void clear_maturity_month_year_format();
  static const int kMaturityMonthYearFormatFieldNumber = 2;
  inline ::Common::MaturityMonthYearFormatEnum maturity_month_year_format() const;
  inline void set_maturity_month_year_format(::Common::MaturityMonthYearFormatEnum value);

  // optional sfixed64 maturity_month_year_increment = 3;
  inline bool has_maturity_month_year_increment() const;
  inline void clear_maturity_month_year_increment();
  static const int kMaturityMonthYearIncrementFieldNumber = 3;
  inline ::google::protobuf::int64 maturity_month_year_increment() const;
  inline void set_maturity_month_year_increment(::google::protobuf::int64 value);

  // optional .Common.MaturityMonthYearIncrementUnitsEnum maturity_month_year_increment_units = 4;
  inline bool has_maturity_month_year_increment_units() const;
  inline void clear_maturity_month_year_increment_units();
  static const int kMaturityMonthYearIncrementUnitsFieldNumber = 4;
  inline ::Common::MaturityMonthYearIncrementUnitsEnum maturity_month_year_increment_units() const;
  inline void set_maturity_month_year_increment_units(::Common::MaturityMonthYearIncrementUnitsEnum value);

  // optional string maturity_rule_id = 5;
  inline bool has_maturity_rule_id() const;
  inline void clear_maturity_rule_id();
  static const int kMaturityRuleIdFieldNumber = 5;
  inline const ::std::string& maturity_rule_id() const;
  inline void set_maturity_rule_id(const ::std::string& value);
  inline void set_maturity_rule_id(const char* value);
  inline void set_maturity_rule_id(const char* value, size_t size);
  inline ::std::string* mutable_maturity_rule_id();
  inline ::std::string* release_maturity_rule_id();
  inline void set_allocated_maturity_rule_id(::std::string* maturity_rule_id);

  // optional sfixed32 start_maturity_month_year = 6;
  inline bool has_start_maturity_month_year() const;
  inline void clear_start_maturity_month_year();
  static const int kStartMaturityMonthYearFieldNumber = 6;
  inline ::google::protobuf::int32 start_maturity_month_year() const;
  inline void set_start_maturity_month_year(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Common.MaturityRules)
 private:
  inline void set_has_end_maturity_month_year();
  inline void clear_has_end_maturity_month_year();
  inline void set_has_maturity_month_year_format();
  inline void clear_has_maturity_month_year_format();
  inline void set_has_maturity_month_year_increment();
  inline void clear_has_maturity_month_year_increment();
  inline void set_has_maturity_month_year_increment_units();
  inline void clear_has_maturity_month_year_increment_units();
  inline void set_has_maturity_rule_id();
  inline void clear_has_maturity_rule_id();
  inline void set_has_start_maturity_month_year();
  inline void clear_has_start_maturity_month_year();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 end_maturity_month_year_;
  int maturity_month_year_format_;
  ::google::protobuf::int64 maturity_month_year_increment_;
  ::std::string* maturity_rule_id_;
  int maturity_month_year_increment_units_;
  ::google::protobuf::int32 start_maturity_month_year_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static MaturityRules* default_instance_;
};
// -------------------------------------------------------------------

class StrikeRules : public ::google::protobuf::Message {
 public:
  StrikeRules();
  virtual ~StrikeRules();

  StrikeRules(const StrikeRules& from);

  inline StrikeRules& operator=(const StrikeRules& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StrikeRules& default_instance();

  void Swap(StrikeRules* other);

  // implements Message ----------------------------------------------

  StrikeRules* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StrikeRules& from);
  void MergeFrom(const StrikeRules& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed64 end_strike_px_range = 1;
  inline bool has_end_strike_px_range() const;
  inline void clear_end_strike_px_range();
  static const int kEndStrikePxRangeFieldNumber = 1;
  inline ::google::protobuf::int64 end_strike_px_range() const;
  inline void set_end_strike_px_range(::google::protobuf::int64 value);

  // optional sfixed32 end_strike_px_range_exponent = 2;
  inline bool has_end_strike_px_range_exponent() const;
  inline void clear_end_strike_px_range_exponent();
  static const int kEndStrikePxRangeExponentFieldNumber = 2;
  inline ::google::protobuf::int32 end_strike_px_range_exponent() const;
  inline void set_end_strike_px_range_exponent(::google::protobuf::int32 value);

  // repeated .Common.MaturityRules maturity_rules = 3;
  inline int maturity_rules_size() const;
  inline void clear_maturity_rules();
  static const int kMaturityRulesFieldNumber = 3;
  inline const ::Common::MaturityRules& maturity_rules(int index) const;
  inline ::Common::MaturityRules* mutable_maturity_rules(int index);
  inline ::Common::MaturityRules* add_maturity_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::MaturityRules >&
      maturity_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::MaturityRules >*
      mutable_maturity_rules();

  // optional sfixed64 start_strike_px_range = 4;
  inline bool has_start_strike_px_range() const;
  inline void clear_start_strike_px_range();
  static const int kStartStrikePxRangeFieldNumber = 4;
  inline ::google::protobuf::int64 start_strike_px_range() const;
  inline void set_start_strike_px_range(::google::protobuf::int64 value);

  // optional sfixed32 start_strike_px_range_exponent = 5;
  inline bool has_start_strike_px_range_exponent() const;
  inline void clear_start_strike_px_range_exponent();
  static const int kStartStrikePxRangeExponentFieldNumber = 5;
  inline ::google::protobuf::int32 start_strike_px_range_exponent() const;
  inline void set_start_strike_px_range_exponent(::google::protobuf::int32 value);

  // optional sfixed64 strike_exercise_style = 6;
  inline bool has_strike_exercise_style() const;
  inline void clear_strike_exercise_style();
  static const int kStrikeExerciseStyleFieldNumber = 6;
  inline ::google::protobuf::int64 strike_exercise_style() const;
  inline void set_strike_exercise_style(::google::protobuf::int64 value);

  // optional double strike_increment = 7;
  inline bool has_strike_increment() const;
  inline void clear_strike_increment();
  static const int kStrikeIncrementFieldNumber = 7;
  inline double strike_increment() const;
  inline void set_strike_increment(double value);

  // optional string strike_rule_id = 8;
  inline bool has_strike_rule_id() const;
  inline void clear_strike_rule_id();
  static const int kStrikeRuleIdFieldNumber = 8;
  inline const ::std::string& strike_rule_id() const;
  inline void set_strike_rule_id(const ::std::string& value);
  inline void set_strike_rule_id(const char* value);
  inline void set_strike_rule_id(const char* value, size_t size);
  inline ::std::string* mutable_strike_rule_id();
  inline ::std::string* release_strike_rule_id();
  inline void set_allocated_strike_rule_id(::std::string* strike_rule_id);

  // @@protoc_insertion_point(class_scope:Common.StrikeRules)
 private:
  inline void set_has_end_strike_px_range();
  inline void clear_has_end_strike_px_range();
  inline void set_has_end_strike_px_range_exponent();
  inline void clear_has_end_strike_px_range_exponent();
  inline void set_has_start_strike_px_range();
  inline void clear_has_start_strike_px_range();
  inline void set_has_start_strike_px_range_exponent();
  inline void clear_has_start_strike_px_range_exponent();
  inline void set_has_strike_exercise_style();
  inline void clear_has_strike_exercise_style();
  inline void set_has_strike_increment();
  inline void clear_has_strike_increment();
  inline void set_has_strike_rule_id();
  inline void clear_has_strike_rule_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 end_strike_px_range_;
  ::google::protobuf::RepeatedPtrField< ::Common::MaturityRules > maturity_rules_;
  ::google::protobuf::int32 end_strike_px_range_exponent_;
  ::google::protobuf::int32 start_strike_px_range_exponent_;
  ::google::protobuf::int64 start_strike_px_range_;
  ::google::protobuf::int64 strike_exercise_style_;
  double strike_increment_;
  ::std::string* strike_rule_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static StrikeRules* default_instance_;
};
// -------------------------------------------------------------------

class MarketSegmentGrp : public ::google::protobuf::Message {
 public:
  MarketSegmentGrp();
  virtual ~MarketSegmentGrp();

  MarketSegmentGrp(const MarketSegmentGrp& from);

  inline MarketSegmentGrp& operator=(const MarketSegmentGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketSegmentGrp& default_instance();

  void Swap(MarketSegmentGrp* other);

  // implements Message ----------------------------------------------

  MarketSegmentGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MarketSegmentGrp& from);
  void MergeFrom(const MarketSegmentGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string market_id = 1;
  inline bool has_market_id() const;
  inline void clear_market_id();
  static const int kMarketIdFieldNumber = 1;
  inline const ::std::string& market_id() const;
  inline void set_market_id(const ::std::string& value);
  inline void set_market_id(const char* value);
  inline void set_market_id(const char* value, size_t size);
  inline ::std::string* mutable_market_id();
  inline ::std::string* release_market_id();
  inline void set_allocated_market_id(::std::string* market_id);

  // optional string market_segment_id = 2;
  inline bool has_market_segment_id() const;
  inline void clear_market_segment_id();
  static const int kMarketSegmentIdFieldNumber = 2;
  inline const ::std::string& market_segment_id() const;
  inline void set_market_segment_id(const ::std::string& value);
  inline void set_market_segment_id(const char* value);
  inline void set_market_segment_id(const char* value, size_t size);
  inline ::std::string* mutable_market_segment_id();
  inline ::std::string* release_market_segment_id();
  inline void set_allocated_market_segment_id(::std::string* market_segment_id);

  // optional .Common.SecurityTradingRules security_trading_rules = 3;
  inline bool has_security_trading_rules() const;
  inline void clear_security_trading_rules();
  static const int kSecurityTradingRulesFieldNumber = 3;
  inline const ::Common::SecurityTradingRules& security_trading_rules() const;
  inline ::Common::SecurityTradingRules* mutable_security_trading_rules();
  inline ::Common::SecurityTradingRules* release_security_trading_rules();
  inline void set_allocated_security_trading_rules(::Common::SecurityTradingRules* security_trading_rules);

  // repeated .Common.StrikeRules strike_rules = 4;
  inline int strike_rules_size() const;
  inline void clear_strike_rules();
  static const int kStrikeRulesFieldNumber = 4;
  inline const ::Common::StrikeRules& strike_rules(int index) const;
  inline ::Common::StrikeRules* mutable_strike_rules(int index);
  inline ::Common::StrikeRules* add_strike_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >&
      strike_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >*
      mutable_strike_rules();

  // @@protoc_insertion_point(class_scope:Common.MarketSegmentGrp)
 private:
  inline void set_has_market_id();
  inline void clear_has_market_id();
  inline void set_has_market_segment_id();
  inline void clear_has_market_segment_id();
  inline void set_has_security_trading_rules();
  inline void clear_has_security_trading_rules();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* market_id_;
  ::std::string* market_segment_id_;
  ::Common::SecurityTradingRules* security_trading_rules_;
  ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules > strike_rules_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static MarketSegmentGrp* default_instance_;
};
// -------------------------------------------------------------------

class LegBenchmarkCurveData : public ::google::protobuf::Message {
 public:
  LegBenchmarkCurveData();
  virtual ~LegBenchmarkCurveData();

  LegBenchmarkCurveData(const LegBenchmarkCurveData& from);

  inline LegBenchmarkCurveData& operator=(const LegBenchmarkCurveData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LegBenchmarkCurveData& default_instance();

  void Swap(LegBenchmarkCurveData* other);

  // implements Message ----------------------------------------------

  LegBenchmarkCurveData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LegBenchmarkCurveData& from);
  void MergeFrom(const LegBenchmarkCurveData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string leg_benchmark_curve_currency = 1;
  inline bool has_leg_benchmark_curve_currency() const;
  inline void clear_leg_benchmark_curve_currency();
  static const int kLegBenchmarkCurveCurrencyFieldNumber = 1;
  inline const ::std::string& leg_benchmark_curve_currency() const;
  inline void set_leg_benchmark_curve_currency(const ::std::string& value);
  inline void set_leg_benchmark_curve_currency(const char* value);
  inline void set_leg_benchmark_curve_currency(const char* value, size_t size);
  inline ::std::string* mutable_leg_benchmark_curve_currency();
  inline ::std::string* release_leg_benchmark_curve_currency();
  inline void set_allocated_leg_benchmark_curve_currency(::std::string* leg_benchmark_curve_currency);

  // optional string leg_benchmark_curve_name = 2;
  inline bool has_leg_benchmark_curve_name() const;
  inline void clear_leg_benchmark_curve_name();
  static const int kLegBenchmarkCurveNameFieldNumber = 2;
  inline const ::std::string& leg_benchmark_curve_name() const;
  inline void set_leg_benchmark_curve_name(const ::std::string& value);
  inline void set_leg_benchmark_curve_name(const char* value);
  inline void set_leg_benchmark_curve_name(const char* value, size_t size);
  inline ::std::string* mutable_leg_benchmark_curve_name();
  inline ::std::string* release_leg_benchmark_curve_name();
  inline void set_allocated_leg_benchmark_curve_name(::std::string* leg_benchmark_curve_name);

  // optional string leg_benchmark_curve_point = 3;
  inline bool has_leg_benchmark_curve_point() const;
  inline void clear_leg_benchmark_curve_point();
  static const int kLegBenchmarkCurvePointFieldNumber = 3;
  inline const ::std::string& leg_benchmark_curve_point() const;
  inline void set_leg_benchmark_curve_point(const ::std::string& value);
  inline void set_leg_benchmark_curve_point(const char* value);
  inline void set_leg_benchmark_curve_point(const char* value, size_t size);
  inline ::std::string* mutable_leg_benchmark_curve_point();
  inline ::std::string* release_leg_benchmark_curve_point();
  inline void set_allocated_leg_benchmark_curve_point(::std::string* leg_benchmark_curve_point);

  // optional sfixed64 leg_benchmark_price = 4;
  inline bool has_leg_benchmark_price() const;
  inline void clear_leg_benchmark_price();
  static const int kLegBenchmarkPriceFieldNumber = 4;
  inline ::google::protobuf::int64 leg_benchmark_price() const;
  inline void set_leg_benchmark_price(::google::protobuf::int64 value);

  // optional sfixed32 leg_benchmark_price_exponent = 5;
  inline bool has_leg_benchmark_price_exponent() const;
  inline void clear_leg_benchmark_price_exponent();
  static const int kLegBenchmarkPriceExponentFieldNumber = 5;
  inline ::google::protobuf::int32 leg_benchmark_price_exponent() const;
  inline void set_leg_benchmark_price_exponent(::google::protobuf::int32 value);

  // optional sfixed64 leg_benchmark_price_type = 6;
  inline bool has_leg_benchmark_price_type() const;
  inline void clear_leg_benchmark_price_type();
  static const int kLegBenchmarkPriceTypeFieldNumber = 6;
  inline ::google::protobuf::int64 leg_benchmark_price_type() const;
  inline void set_leg_benchmark_price_type(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Common.LegBenchmarkCurveData)
 private:
  inline void set_has_leg_benchmark_curve_currency();
  inline void clear_has_leg_benchmark_curve_currency();
  inline void set_has_leg_benchmark_curve_name();
  inline void clear_has_leg_benchmark_curve_name();
  inline void set_has_leg_benchmark_curve_point();
  inline void clear_has_leg_benchmark_curve_point();
  inline void set_has_leg_benchmark_price();
  inline void clear_has_leg_benchmark_price();
  inline void set_has_leg_benchmark_price_exponent();
  inline void clear_has_leg_benchmark_price_exponent();
  inline void set_has_leg_benchmark_price_type();
  inline void clear_has_leg_benchmark_price_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* leg_benchmark_curve_currency_;
  ::std::string* leg_benchmark_curve_name_;
  ::std::string* leg_benchmark_curve_point_;
  ::google::protobuf::int64 leg_benchmark_price_;
  ::google::protobuf::int64 leg_benchmark_price_type_;
  ::google::protobuf::int32 leg_benchmark_price_exponent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static LegBenchmarkCurveData* default_instance_;
};
// -------------------------------------------------------------------

class InstrmtLegSecListGrp : public ::google::protobuf::Message {
 public:
  InstrmtLegSecListGrp();
  virtual ~InstrmtLegSecListGrp();

  InstrmtLegSecListGrp(const InstrmtLegSecListGrp& from);

  inline InstrmtLegSecListGrp& operator=(const InstrmtLegSecListGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstrmtLegSecListGrp& default_instance();

  void Swap(InstrmtLegSecListGrp* other);

  // implements Message ----------------------------------------------

  InstrmtLegSecListGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstrmtLegSecListGrp& from);
  void MergeFrom(const InstrmtLegSecListGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.InstrumentLeg instrument_leg = 1;
  inline bool has_instrument_leg() const;
  inline void clear_instrument_leg();
  static const int kInstrumentLegFieldNumber = 1;
  inline const ::Common::InstrumentLeg& instrument_leg() const;
  inline ::Common::InstrumentLeg* mutable_instrument_leg();
  inline ::Common::InstrumentLeg* release_instrument_leg();
  inline void set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg);

  // optional .Common.LegBenchmarkCurveData leg_benchmark_curve_data = 2;
  inline bool has_leg_benchmark_curve_data() const;
  inline void clear_leg_benchmark_curve_data();
  static const int kLegBenchmarkCurveDataFieldNumber = 2;
  inline const ::Common::LegBenchmarkCurveData& leg_benchmark_curve_data() const;
  inline ::Common::LegBenchmarkCurveData* mutable_leg_benchmark_curve_data();
  inline ::Common::LegBenchmarkCurveData* release_leg_benchmark_curve_data();
  inline void set_allocated_leg_benchmark_curve_data(::Common::LegBenchmarkCurveData* leg_benchmark_curve_data);

  // optional string leg_settl_type = 3;
  inline bool has_leg_settl_type() const;
  inline void clear_leg_settl_type();
  static const int kLegSettlTypeFieldNumber = 3;
  inline const ::std::string& leg_settl_type() const;
  inline void set_leg_settl_type(const ::std::string& value);
  inline void set_leg_settl_type(const char* value);
  inline void set_leg_settl_type(const char* value, size_t size);
  inline ::std::string* mutable_leg_settl_type();
  inline ::std::string* release_leg_settl_type();
  inline void set_allocated_leg_settl_type(::std::string* leg_settl_type);

  // repeated .Common.LegStipulations leg_stipulations = 4;
  inline int leg_stipulations_size() const;
  inline void clear_leg_stipulations();
  static const int kLegStipulationsFieldNumber = 4;
  inline const ::Common::LegStipulations& leg_stipulations(int index) const;
  inline ::Common::LegStipulations* mutable_leg_stipulations(int index);
  inline ::Common::LegStipulations* add_leg_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >&
      leg_stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >*
      mutable_leg_stipulations();

  // optional .Common.LegSwapTypeEnum leg_swap_type = 5;
  inline bool has_leg_swap_type() const;
  inline void clear_leg_swap_type();
  static const int kLegSwapTypeFieldNumber = 5;
  inline ::Common::LegSwapTypeEnum leg_swap_type() const;
  inline void set_leg_swap_type(::Common::LegSwapTypeEnum value);

  // @@protoc_insertion_point(class_scope:Common.InstrmtLegSecListGrp)
 private:
  inline void set_has_instrument_leg();
  inline void clear_has_instrument_leg();
  inline void set_has_leg_benchmark_curve_data();
  inline void clear_has_leg_benchmark_curve_data();
  inline void set_has_leg_settl_type();
  inline void clear_has_leg_settl_type();
  inline void set_has_leg_swap_type();
  inline void clear_has_leg_swap_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Common::InstrumentLeg* instrument_leg_;
  ::Common::LegBenchmarkCurveData* leg_benchmark_curve_data_;
  ::std::string* leg_settl_type_;
  ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations > leg_stipulations_;
  int leg_swap_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_common_2eproto();
  friend void protobuf_AssignDesc_common_2eproto();
  friend void protobuf_ShutdownFile_common_2eproto();

  void InitAsDefaultInstance();
  static InstrmtLegSecListGrp* default_instance_;
};
// ===================================================================


// ===================================================================

// PartySubIdTypeUnion

// optional .Common.PartySubIdTypeEnum party_sub_id_type = 1;
inline bool PartySubIdTypeUnion::has_party_sub_id_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartySubIdTypeUnion::set_has_party_sub_id_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartySubIdTypeUnion::clear_has_party_sub_id_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartySubIdTypeUnion::clear_party_sub_id_type() {
  party_sub_id_type_ = 0;
  clear_has_party_sub_id_type();
}
inline ::Common::PartySubIdTypeEnum PartySubIdTypeUnion::party_sub_id_type() const {
  return static_cast< ::Common::PartySubIdTypeEnum >(party_sub_id_type_);
}
inline void PartySubIdTypeUnion::set_party_sub_id_type(::Common::PartySubIdTypeEnum value) {
  assert(::Common::PartySubIdTypeEnum_IsValid(value));
  set_has_party_sub_id_type();
  party_sub_id_type_ = value;
}

// optional sfixed64 party_sub_id_type_sfixed64 = 2;
inline bool PartySubIdTypeUnion::has_party_sub_id_type_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartySubIdTypeUnion::set_has_party_sub_id_type_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartySubIdTypeUnion::clear_has_party_sub_id_type_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartySubIdTypeUnion::clear_party_sub_id_type_sfixed64() {
  party_sub_id_type_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_party_sub_id_type_sfixed64();
}
inline ::google::protobuf::int64 PartySubIdTypeUnion::party_sub_id_type_sfixed64() const {
  return party_sub_id_type_sfixed64_;
}
inline void PartySubIdTypeUnion::set_party_sub_id_type_sfixed64(::google::protobuf::int64 value) {
  set_has_party_sub_id_type_sfixed64();
  party_sub_id_type_sfixed64_ = value;
}

// -------------------------------------------------------------------

// PtysSubGrp

// optional string party_sub_id = 1;
inline bool PtysSubGrp::has_party_sub_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PtysSubGrp::set_has_party_sub_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PtysSubGrp::clear_has_party_sub_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PtysSubGrp::clear_party_sub_id() {
  if (party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    party_sub_id_->clear();
  }
  clear_has_party_sub_id();
}
inline const ::std::string& PtysSubGrp::party_sub_id() const {
  return *party_sub_id_;
}
inline void PtysSubGrp::set_party_sub_id(const ::std::string& value) {
  set_has_party_sub_id();
  if (party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    party_sub_id_ = new ::std::string;
  }
  party_sub_id_->assign(value);
}
inline void PtysSubGrp::set_party_sub_id(const char* value) {
  set_has_party_sub_id();
  if (party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    party_sub_id_ = new ::std::string;
  }
  party_sub_id_->assign(value);
}
inline void PtysSubGrp::set_party_sub_id(const char* value, size_t size) {
  set_has_party_sub_id();
  if (party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    party_sub_id_ = new ::std::string;
  }
  party_sub_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PtysSubGrp::mutable_party_sub_id() {
  set_has_party_sub_id();
  if (party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    party_sub_id_ = new ::std::string;
  }
  return party_sub_id_;
}
inline ::std::string* PtysSubGrp::release_party_sub_id() {
  clear_has_party_sub_id();
  if (party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = party_sub_id_;
    party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PtysSubGrp::set_allocated_party_sub_id(::std::string* party_sub_id) {
  if (party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    delete party_sub_id_;
  }
  if (party_sub_id) {
    set_has_party_sub_id();
    party_sub_id_ = party_sub_id;
  } else {
    clear_has_party_sub_id();
    party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.PartySubIdTypeEnum party_sub_id_type = 2;
inline bool PtysSubGrp::has_party_sub_id_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PtysSubGrp::set_has_party_sub_id_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PtysSubGrp::clear_has_party_sub_id_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PtysSubGrp::clear_party_sub_id_type() {
  party_sub_id_type_ = 0;
  clear_has_party_sub_id_type();
}
inline ::Common::PartySubIdTypeEnum PtysSubGrp::party_sub_id_type() const {
  return static_cast< ::Common::PartySubIdTypeEnum >(party_sub_id_type_);
}
inline void PtysSubGrp::set_party_sub_id_type(::Common::PartySubIdTypeEnum value) {
  assert(::Common::PartySubIdTypeEnum_IsValid(value));
  set_has_party_sub_id_type();
  party_sub_id_type_ = value;
}

// -------------------------------------------------------------------

// Parties

// optional string party_id = 1;
inline bool Parties::has_party_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Parties::set_has_party_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Parties::clear_has_party_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Parties::clear_party_id() {
  if (party_id_ != &::google::protobuf::internal::kEmptyString) {
    party_id_->clear();
  }
  clear_has_party_id();
}
inline const ::std::string& Parties::party_id() const {
  return *party_id_;
}
inline void Parties::set_party_id(const ::std::string& value) {
  set_has_party_id();
  if (party_id_ == &::google::protobuf::internal::kEmptyString) {
    party_id_ = new ::std::string;
  }
  party_id_->assign(value);
}
inline void Parties::set_party_id(const char* value) {
  set_has_party_id();
  if (party_id_ == &::google::protobuf::internal::kEmptyString) {
    party_id_ = new ::std::string;
  }
  party_id_->assign(value);
}
inline void Parties::set_party_id(const char* value, size_t size) {
  set_has_party_id();
  if (party_id_ == &::google::protobuf::internal::kEmptyString) {
    party_id_ = new ::std::string;
  }
  party_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Parties::mutable_party_id() {
  set_has_party_id();
  if (party_id_ == &::google::protobuf::internal::kEmptyString) {
    party_id_ = new ::std::string;
  }
  return party_id_;
}
inline ::std::string* Parties::release_party_id() {
  clear_has_party_id();
  if (party_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = party_id_;
    party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Parties::set_allocated_party_id(::std::string* party_id) {
  if (party_id_ != &::google::protobuf::internal::kEmptyString) {
    delete party_id_;
  }
  if (party_id) {
    set_has_party_id();
    party_id_ = party_id;
  } else {
    clear_has_party_id();
    party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.PartyIdSourceEnum party_id_source = 2;
inline bool Parties::has_party_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Parties::set_has_party_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Parties::clear_has_party_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Parties::clear_party_id_source() {
  party_id_source_ = 0;
  clear_has_party_id_source();
}
inline ::Common::PartyIdSourceEnum Parties::party_id_source() const {
  return static_cast< ::Common::PartyIdSourceEnum >(party_id_source_);
}
inline void Parties::set_party_id_source(::Common::PartyIdSourceEnum value) {
  assert(::Common::PartyIdSourceEnum_IsValid(value));
  set_has_party_id_source();
  party_id_source_ = value;
}

// optional .Common.PartyRoleEnum party_role = 3;
inline bool Parties::has_party_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Parties::set_has_party_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Parties::clear_has_party_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Parties::clear_party_role() {
  party_role_ = 0;
  clear_has_party_role();
}
inline ::Common::PartyRoleEnum Parties::party_role() const {
  return static_cast< ::Common::PartyRoleEnum >(party_role_);
}
inline void Parties::set_party_role(::Common::PartyRoleEnum value) {
  assert(::Common::PartyRoleEnum_IsValid(value));
  set_has_party_role();
  party_role_ = value;
}

// repeated .Common.PtysSubGrp ptys_sub_grp = 4;
inline int Parties::ptys_sub_grp_size() const {
  return ptys_sub_grp_.size();
}
inline void Parties::clear_ptys_sub_grp() {
  ptys_sub_grp_.Clear();
}
inline const ::Common::PtysSubGrp& Parties::ptys_sub_grp(int index) const {
  return ptys_sub_grp_.Get(index);
}
inline ::Common::PtysSubGrp* Parties::mutable_ptys_sub_grp(int index) {
  return ptys_sub_grp_.Mutable(index);
}
inline ::Common::PtysSubGrp* Parties::add_ptys_sub_grp() {
  return ptys_sub_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::PtysSubGrp >&
Parties::ptys_sub_grp() const {
  return ptys_sub_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::PtysSubGrp >*
Parties::mutable_ptys_sub_grp() {
  return &ptys_sub_grp_;
}

// -------------------------------------------------------------------

// NstdPtysSubGrp

// optional string nested_party_sub_id = 1;
inline bool NstdPtysSubGrp::has_nested_party_sub_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NstdPtysSubGrp::set_has_nested_party_sub_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NstdPtysSubGrp::clear_has_nested_party_sub_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NstdPtysSubGrp::clear_nested_party_sub_id() {
  if (nested_party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    nested_party_sub_id_->clear();
  }
  clear_has_nested_party_sub_id();
}
inline const ::std::string& NstdPtysSubGrp::nested_party_sub_id() const {
  return *nested_party_sub_id_;
}
inline void NstdPtysSubGrp::set_nested_party_sub_id(const ::std::string& value) {
  set_has_nested_party_sub_id();
  if (nested_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_sub_id_ = new ::std::string;
  }
  nested_party_sub_id_->assign(value);
}
inline void NstdPtysSubGrp::set_nested_party_sub_id(const char* value) {
  set_has_nested_party_sub_id();
  if (nested_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_sub_id_ = new ::std::string;
  }
  nested_party_sub_id_->assign(value);
}
inline void NstdPtysSubGrp::set_nested_party_sub_id(const char* value, size_t size) {
  set_has_nested_party_sub_id();
  if (nested_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_sub_id_ = new ::std::string;
  }
  nested_party_sub_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NstdPtysSubGrp::mutable_nested_party_sub_id() {
  set_has_nested_party_sub_id();
  if (nested_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_sub_id_ = new ::std::string;
  }
  return nested_party_sub_id_;
}
inline ::std::string* NstdPtysSubGrp::release_nested_party_sub_id() {
  clear_has_nested_party_sub_id();
  if (nested_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested_party_sub_id_;
    nested_party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NstdPtysSubGrp::set_allocated_nested_party_sub_id(::std::string* nested_party_sub_id) {
  if (nested_party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    delete nested_party_sub_id_;
  }
  if (nested_party_sub_id) {
    set_has_nested_party_sub_id();
    nested_party_sub_id_ = nested_party_sub_id;
  } else {
    clear_has_nested_party_sub_id();
    nested_party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 nested_party_sub_id_type = 2;
inline bool NstdPtysSubGrp::has_nested_party_sub_id_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NstdPtysSubGrp::set_has_nested_party_sub_id_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NstdPtysSubGrp::clear_has_nested_party_sub_id_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NstdPtysSubGrp::clear_nested_party_sub_id_type() {
  nested_party_sub_id_type_ = GOOGLE_LONGLONG(0);
  clear_has_nested_party_sub_id_type();
}
inline ::google::protobuf::int64 NstdPtysSubGrp::nested_party_sub_id_type() const {
  return nested_party_sub_id_type_;
}
inline void NstdPtysSubGrp::set_nested_party_sub_id_type(::google::protobuf::int64 value) {
  set_has_nested_party_sub_id_type();
  nested_party_sub_id_type_ = value;
}

// -------------------------------------------------------------------

// NestedParties

// optional string nested_party_id = 1;
inline bool NestedParties::has_nested_party_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NestedParties::set_has_nested_party_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NestedParties::clear_has_nested_party_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NestedParties::clear_nested_party_id() {
  if (nested_party_id_ != &::google::protobuf::internal::kEmptyString) {
    nested_party_id_->clear();
  }
  clear_has_nested_party_id();
}
inline const ::std::string& NestedParties::nested_party_id() const {
  return *nested_party_id_;
}
inline void NestedParties::set_nested_party_id(const ::std::string& value) {
  set_has_nested_party_id();
  if (nested_party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_id_ = new ::std::string;
  }
  nested_party_id_->assign(value);
}
inline void NestedParties::set_nested_party_id(const char* value) {
  set_has_nested_party_id();
  if (nested_party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_id_ = new ::std::string;
  }
  nested_party_id_->assign(value);
}
inline void NestedParties::set_nested_party_id(const char* value, size_t size) {
  set_has_nested_party_id();
  if (nested_party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_id_ = new ::std::string;
  }
  nested_party_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NestedParties::mutable_nested_party_id() {
  set_has_nested_party_id();
  if (nested_party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_id_ = new ::std::string;
  }
  return nested_party_id_;
}
inline ::std::string* NestedParties::release_nested_party_id() {
  clear_has_nested_party_id();
  if (nested_party_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested_party_id_;
    nested_party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NestedParties::set_allocated_nested_party_id(::std::string* nested_party_id) {
  if (nested_party_id_ != &::google::protobuf::internal::kEmptyString) {
    delete nested_party_id_;
  }
  if (nested_party_id) {
    set_has_nested_party_id();
    nested_party_id_ = nested_party_id;
  } else {
    clear_has_nested_party_id();
    nested_party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nested_party_id_source = 2;
inline bool NestedParties::has_nested_party_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NestedParties::set_has_nested_party_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NestedParties::clear_has_nested_party_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NestedParties::clear_nested_party_id_source() {
  if (nested_party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    nested_party_id_source_->clear();
  }
  clear_has_nested_party_id_source();
}
inline const ::std::string& NestedParties::nested_party_id_source() const {
  return *nested_party_id_source_;
}
inline void NestedParties::set_nested_party_id_source(const ::std::string& value) {
  set_has_nested_party_id_source();
  if (nested_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_id_source_ = new ::std::string;
  }
  nested_party_id_source_->assign(value);
}
inline void NestedParties::set_nested_party_id_source(const char* value) {
  set_has_nested_party_id_source();
  if (nested_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_id_source_ = new ::std::string;
  }
  nested_party_id_source_->assign(value);
}
inline void NestedParties::set_nested_party_id_source(const char* value, size_t size) {
  set_has_nested_party_id_source();
  if (nested_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_id_source_ = new ::std::string;
  }
  nested_party_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NestedParties::mutable_nested_party_id_source() {
  set_has_nested_party_id_source();
  if (nested_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested_party_id_source_ = new ::std::string;
  }
  return nested_party_id_source_;
}
inline ::std::string* NestedParties::release_nested_party_id_source() {
  clear_has_nested_party_id_source();
  if (nested_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested_party_id_source_;
    nested_party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NestedParties::set_allocated_nested_party_id_source(::std::string* nested_party_id_source) {
  if (nested_party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete nested_party_id_source_;
  }
  if (nested_party_id_source) {
    set_has_nested_party_id_source();
    nested_party_id_source_ = nested_party_id_source;
  } else {
    clear_has_nested_party_id_source();
    nested_party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 nested_party_role = 3;
inline bool NestedParties::has_nested_party_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NestedParties::set_has_nested_party_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NestedParties::clear_has_nested_party_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NestedParties::clear_nested_party_role() {
  nested_party_role_ = GOOGLE_LONGLONG(0);
  clear_has_nested_party_role();
}
inline ::google::protobuf::int64 NestedParties::nested_party_role() const {
  return nested_party_role_;
}
inline void NestedParties::set_nested_party_role(::google::protobuf::int64 value) {
  set_has_nested_party_role();
  nested_party_role_ = value;
}

// repeated .Common.NstdPtysSubGrp nstd_ptys_sub_grp = 4;
inline int NestedParties::nstd_ptys_sub_grp_size() const {
  return nstd_ptys_sub_grp_.size();
}
inline void NestedParties::clear_nstd_ptys_sub_grp() {
  nstd_ptys_sub_grp_.Clear();
}
inline const ::Common::NstdPtysSubGrp& NestedParties::nstd_ptys_sub_grp(int index) const {
  return nstd_ptys_sub_grp_.Get(index);
}
inline ::Common::NstdPtysSubGrp* NestedParties::mutable_nstd_ptys_sub_grp(int index) {
  return nstd_ptys_sub_grp_.Mutable(index);
}
inline ::Common::NstdPtysSubGrp* NestedParties::add_nstd_ptys_sub_grp() {
  return nstd_ptys_sub_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NstdPtysSubGrp >&
NestedParties::nstd_ptys_sub_grp() const {
  return nstd_ptys_sub_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NstdPtysSubGrp >*
NestedParties::mutable_nstd_ptys_sub_grp() {
  return &nstd_ptys_sub_grp_;
}

// -------------------------------------------------------------------

// PreAllocGrp

// optional string alloc_account = 1;
inline bool PreAllocGrp::has_alloc_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreAllocGrp::set_has_alloc_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreAllocGrp::clear_has_alloc_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreAllocGrp::clear_alloc_account() {
  if (alloc_account_ != &::google::protobuf::internal::kEmptyString) {
    alloc_account_->clear();
  }
  clear_has_alloc_account();
}
inline const ::std::string& PreAllocGrp::alloc_account() const {
  return *alloc_account_;
}
inline void PreAllocGrp::set_alloc_account(const ::std::string& value) {
  set_has_alloc_account();
  if (alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    alloc_account_ = new ::std::string;
  }
  alloc_account_->assign(value);
}
inline void PreAllocGrp::set_alloc_account(const char* value) {
  set_has_alloc_account();
  if (alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    alloc_account_ = new ::std::string;
  }
  alloc_account_->assign(value);
}
inline void PreAllocGrp::set_alloc_account(const char* value, size_t size) {
  set_has_alloc_account();
  if (alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    alloc_account_ = new ::std::string;
  }
  alloc_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreAllocGrp::mutable_alloc_account() {
  set_has_alloc_account();
  if (alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    alloc_account_ = new ::std::string;
  }
  return alloc_account_;
}
inline ::std::string* PreAllocGrp::release_alloc_account() {
  clear_has_alloc_account();
  if (alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alloc_account_;
    alloc_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreAllocGrp::set_allocated_alloc_account(::std::string* alloc_account) {
  if (alloc_account_ != &::google::protobuf::internal::kEmptyString) {
    delete alloc_account_;
  }
  if (alloc_account) {
    set_has_alloc_account();
    alloc_account_ = alloc_account;
  } else {
    clear_has_alloc_account();
    alloc_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 alloc_acct_id_source = 2;
inline bool PreAllocGrp::has_alloc_acct_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PreAllocGrp::set_has_alloc_acct_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PreAllocGrp::clear_has_alloc_acct_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PreAllocGrp::clear_alloc_acct_id_source() {
  alloc_acct_id_source_ = GOOGLE_LONGLONG(0);
  clear_has_alloc_acct_id_source();
}
inline ::google::protobuf::int64 PreAllocGrp::alloc_acct_id_source() const {
  return alloc_acct_id_source_;
}
inline void PreAllocGrp::set_alloc_acct_id_source(::google::protobuf::int64 value) {
  set_has_alloc_acct_id_source();
  alloc_acct_id_source_ = value;
}

// optional sfixed64 alloc_qty = 3;
inline bool PreAllocGrp::has_alloc_qty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PreAllocGrp::set_has_alloc_qty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PreAllocGrp::clear_has_alloc_qty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PreAllocGrp::clear_alloc_qty() {
  alloc_qty_ = GOOGLE_LONGLONG(0);
  clear_has_alloc_qty();
}
inline ::google::protobuf::int64 PreAllocGrp::alloc_qty() const {
  return alloc_qty_;
}
inline void PreAllocGrp::set_alloc_qty(::google::protobuf::int64 value) {
  set_has_alloc_qty();
  alloc_qty_ = value;
}

// optional sfixed32 alloc_qty_exponent = 4;
inline bool PreAllocGrp::has_alloc_qty_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PreAllocGrp::set_has_alloc_qty_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PreAllocGrp::clear_has_alloc_qty_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PreAllocGrp::clear_alloc_qty_exponent() {
  alloc_qty_exponent_ = 0;
  clear_has_alloc_qty_exponent();
}
inline ::google::protobuf::int32 PreAllocGrp::alloc_qty_exponent() const {
  return alloc_qty_exponent_;
}
inline void PreAllocGrp::set_alloc_qty_exponent(::google::protobuf::int32 value) {
  set_has_alloc_qty_exponent();
  alloc_qty_exponent_ = value;
}

// optional string alloc_settl_currency = 5;
inline bool PreAllocGrp::has_alloc_settl_currency() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PreAllocGrp::set_has_alloc_settl_currency() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PreAllocGrp::clear_has_alloc_settl_currency() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PreAllocGrp::clear_alloc_settl_currency() {
  if (alloc_settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    alloc_settl_currency_->clear();
  }
  clear_has_alloc_settl_currency();
}
inline const ::std::string& PreAllocGrp::alloc_settl_currency() const {
  return *alloc_settl_currency_;
}
inline void PreAllocGrp::set_alloc_settl_currency(const ::std::string& value) {
  set_has_alloc_settl_currency();
  if (alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    alloc_settl_currency_ = new ::std::string;
  }
  alloc_settl_currency_->assign(value);
}
inline void PreAllocGrp::set_alloc_settl_currency(const char* value) {
  set_has_alloc_settl_currency();
  if (alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    alloc_settl_currency_ = new ::std::string;
  }
  alloc_settl_currency_->assign(value);
}
inline void PreAllocGrp::set_alloc_settl_currency(const char* value, size_t size) {
  set_has_alloc_settl_currency();
  if (alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    alloc_settl_currency_ = new ::std::string;
  }
  alloc_settl_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreAllocGrp::mutable_alloc_settl_currency() {
  set_has_alloc_settl_currency();
  if (alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    alloc_settl_currency_ = new ::std::string;
  }
  return alloc_settl_currency_;
}
inline ::std::string* PreAllocGrp::release_alloc_settl_currency() {
  clear_has_alloc_settl_currency();
  if (alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = alloc_settl_currency_;
    alloc_settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreAllocGrp::set_allocated_alloc_settl_currency(::std::string* alloc_settl_currency) {
  if (alloc_settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete alloc_settl_currency_;
  }
  if (alloc_settl_currency) {
    set_has_alloc_settl_currency();
    alloc_settl_currency_ = alloc_settl_currency;
  } else {
    clear_has_alloc_settl_currency();
    alloc_settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string individual_alloc_id = 6;
inline bool PreAllocGrp::has_individual_alloc_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PreAllocGrp::set_has_individual_alloc_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PreAllocGrp::clear_has_individual_alloc_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PreAllocGrp::clear_individual_alloc_id() {
  if (individual_alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    individual_alloc_id_->clear();
  }
  clear_has_individual_alloc_id();
}
inline const ::std::string& PreAllocGrp::individual_alloc_id() const {
  return *individual_alloc_id_;
}
inline void PreAllocGrp::set_individual_alloc_id(const ::std::string& value) {
  set_has_individual_alloc_id();
  if (individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    individual_alloc_id_ = new ::std::string;
  }
  individual_alloc_id_->assign(value);
}
inline void PreAllocGrp::set_individual_alloc_id(const char* value) {
  set_has_individual_alloc_id();
  if (individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    individual_alloc_id_ = new ::std::string;
  }
  individual_alloc_id_->assign(value);
}
inline void PreAllocGrp::set_individual_alloc_id(const char* value, size_t size) {
  set_has_individual_alloc_id();
  if (individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    individual_alloc_id_ = new ::std::string;
  }
  individual_alloc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PreAllocGrp::mutable_individual_alloc_id() {
  set_has_individual_alloc_id();
  if (individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    individual_alloc_id_ = new ::std::string;
  }
  return individual_alloc_id_;
}
inline ::std::string* PreAllocGrp::release_individual_alloc_id() {
  clear_has_individual_alloc_id();
  if (individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = individual_alloc_id_;
    individual_alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PreAllocGrp::set_allocated_individual_alloc_id(::std::string* individual_alloc_id) {
  if (individual_alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    delete individual_alloc_id_;
  }
  if (individual_alloc_id) {
    set_has_individual_alloc_id();
    individual_alloc_id_ = individual_alloc_id;
  } else {
    clear_has_individual_alloc_id();
    individual_alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.NestedParties nested_parties = 7;
inline int PreAllocGrp::nested_parties_size() const {
  return nested_parties_.size();
}
inline void PreAllocGrp::clear_nested_parties() {
  nested_parties_.Clear();
}
inline const ::Common::NestedParties& PreAllocGrp::nested_parties(int index) const {
  return nested_parties_.Get(index);
}
inline ::Common::NestedParties* PreAllocGrp::mutable_nested_parties(int index) {
  return nested_parties_.Mutable(index);
}
inline ::Common::NestedParties* PreAllocGrp::add_nested_parties() {
  return nested_parties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedParties >&
PreAllocGrp::nested_parties() const {
  return nested_parties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NestedParties >*
PreAllocGrp::mutable_nested_parties() {
  return &nested_parties_;
}

// -------------------------------------------------------------------

// DisplayInstruction

// optional sfixed64 display_high_qty = 1;
inline bool DisplayInstruction::has_display_high_qty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DisplayInstruction::set_has_display_high_qty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DisplayInstruction::clear_has_display_high_qty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DisplayInstruction::clear_display_high_qty() {
  display_high_qty_ = GOOGLE_LONGLONG(0);
  clear_has_display_high_qty();
}
inline ::google::protobuf::int64 DisplayInstruction::display_high_qty() const {
  return display_high_qty_;
}
inline void DisplayInstruction::set_display_high_qty(::google::protobuf::int64 value) {
  set_has_display_high_qty();
  display_high_qty_ = value;
}

// optional sfixed32 display_high_qty_exponent = 2;
inline bool DisplayInstruction::has_display_high_qty_exponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DisplayInstruction::set_has_display_high_qty_exponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DisplayInstruction::clear_has_display_high_qty_exponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DisplayInstruction::clear_display_high_qty_exponent() {
  display_high_qty_exponent_ = 0;
  clear_has_display_high_qty_exponent();
}
inline ::google::protobuf::int32 DisplayInstruction::display_high_qty_exponent() const {
  return display_high_qty_exponent_;
}
inline void DisplayInstruction::set_display_high_qty_exponent(::google::protobuf::int32 value) {
  set_has_display_high_qty_exponent();
  display_high_qty_exponent_ = value;
}

// optional sfixed64 display_low_qty = 3;
inline bool DisplayInstruction::has_display_low_qty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DisplayInstruction::set_has_display_low_qty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DisplayInstruction::clear_has_display_low_qty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DisplayInstruction::clear_display_low_qty() {
  display_low_qty_ = GOOGLE_LONGLONG(0);
  clear_has_display_low_qty();
}
inline ::google::protobuf::int64 DisplayInstruction::display_low_qty() const {
  return display_low_qty_;
}
inline void DisplayInstruction::set_display_low_qty(::google::protobuf::int64 value) {
  set_has_display_low_qty();
  display_low_qty_ = value;
}

// optional sfixed32 display_low_qty_exponent = 4;
inline bool DisplayInstruction::has_display_low_qty_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DisplayInstruction::set_has_display_low_qty_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DisplayInstruction::clear_has_display_low_qty_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DisplayInstruction::clear_display_low_qty_exponent() {
  display_low_qty_exponent_ = 0;
  clear_has_display_low_qty_exponent();
}
inline ::google::protobuf::int32 DisplayInstruction::display_low_qty_exponent() const {
  return display_low_qty_exponent_;
}
inline void DisplayInstruction::set_display_low_qty_exponent(::google::protobuf::int32 value) {
  set_has_display_low_qty_exponent();
  display_low_qty_exponent_ = value;
}

// optional .Common.DisplayMethodEnum display_method = 5;
inline bool DisplayInstruction::has_display_method() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DisplayInstruction::set_has_display_method() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DisplayInstruction::clear_has_display_method() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DisplayInstruction::clear_display_method() {
  display_method_ = 0;
  clear_has_display_method();
}
inline ::Common::DisplayMethodEnum DisplayInstruction::display_method() const {
  return static_cast< ::Common::DisplayMethodEnum >(display_method_);
}
inline void DisplayInstruction::set_display_method(::Common::DisplayMethodEnum value) {
  assert(::Common::DisplayMethodEnum_IsValid(value));
  set_has_display_method();
  display_method_ = value;
}

// optional sfixed64 display_min_incr = 6;
inline bool DisplayInstruction::has_display_min_incr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DisplayInstruction::set_has_display_min_incr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DisplayInstruction::clear_has_display_min_incr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DisplayInstruction::clear_display_min_incr() {
  display_min_incr_ = GOOGLE_LONGLONG(0);
  clear_has_display_min_incr();
}
inline ::google::protobuf::int64 DisplayInstruction::display_min_incr() const {
  return display_min_incr_;
}
inline void DisplayInstruction::set_display_min_incr(::google::protobuf::int64 value) {
  set_has_display_min_incr();
  display_min_incr_ = value;
}

// optional sfixed32 display_min_incr_exponent = 7;
inline bool DisplayInstruction::has_display_min_incr_exponent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DisplayInstruction::set_has_display_min_incr_exponent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DisplayInstruction::clear_has_display_min_incr_exponent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DisplayInstruction::clear_display_min_incr_exponent() {
  display_min_incr_exponent_ = 0;
  clear_has_display_min_incr_exponent();
}
inline ::google::protobuf::int32 DisplayInstruction::display_min_incr_exponent() const {
  return display_min_incr_exponent_;
}
inline void DisplayInstruction::set_display_min_incr_exponent(::google::protobuf::int32 value) {
  set_has_display_min_incr_exponent();
  display_min_incr_exponent_ = value;
}

// optional sfixed64 display_qty = 8;
inline bool DisplayInstruction::has_display_qty() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DisplayInstruction::set_has_display_qty() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DisplayInstruction::clear_has_display_qty() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DisplayInstruction::clear_display_qty() {
  display_qty_ = GOOGLE_LONGLONG(0);
  clear_has_display_qty();
}
inline ::google::protobuf::int64 DisplayInstruction::display_qty() const {
  return display_qty_;
}
inline void DisplayInstruction::set_display_qty(::google::protobuf::int64 value) {
  set_has_display_qty();
  display_qty_ = value;
}

// optional sfixed32 display_qty_exponent = 9;
inline bool DisplayInstruction::has_display_qty_exponent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DisplayInstruction::set_has_display_qty_exponent() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DisplayInstruction::clear_has_display_qty_exponent() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DisplayInstruction::clear_display_qty_exponent() {
  display_qty_exponent_ = 0;
  clear_has_display_qty_exponent();
}
inline ::google::protobuf::int32 DisplayInstruction::display_qty_exponent() const {
  return display_qty_exponent_;
}
inline void DisplayInstruction::set_display_qty_exponent(::google::protobuf::int32 value) {
  set_has_display_qty_exponent();
  display_qty_exponent_ = value;
}

// optional .Common.DisplayWhenEnum display_when = 10;
inline bool DisplayInstruction::has_display_when() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DisplayInstruction::set_has_display_when() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DisplayInstruction::clear_has_display_when() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DisplayInstruction::clear_display_when() {
  display_when_ = 0;
  clear_has_display_when();
}
inline ::Common::DisplayWhenEnum DisplayInstruction::display_when() const {
  return static_cast< ::Common::DisplayWhenEnum >(display_when_);
}
inline void DisplayInstruction::set_display_when(::Common::DisplayWhenEnum value) {
  assert(::Common::DisplayWhenEnum_IsValid(value));
  set_has_display_when();
  display_when_ = value;
}

// optional sfixed64 refresh_qty = 11;
inline bool DisplayInstruction::has_refresh_qty() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DisplayInstruction::set_has_refresh_qty() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DisplayInstruction::clear_has_refresh_qty() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DisplayInstruction::clear_refresh_qty() {
  refresh_qty_ = GOOGLE_LONGLONG(0);
  clear_has_refresh_qty();
}
inline ::google::protobuf::int64 DisplayInstruction::refresh_qty() const {
  return refresh_qty_;
}
inline void DisplayInstruction::set_refresh_qty(::google::protobuf::int64 value) {
  set_has_refresh_qty();
  refresh_qty_ = value;
}

// optional sfixed32 refresh_qty_exponent = 12;
inline bool DisplayInstruction::has_refresh_qty_exponent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DisplayInstruction::set_has_refresh_qty_exponent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DisplayInstruction::clear_has_refresh_qty_exponent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DisplayInstruction::clear_refresh_qty_exponent() {
  refresh_qty_exponent_ = 0;
  clear_has_refresh_qty_exponent();
}
inline ::google::protobuf::int32 DisplayInstruction::refresh_qty_exponent() const {
  return refresh_qty_exponent_;
}
inline void DisplayInstruction::set_refresh_qty_exponent(::google::protobuf::int32 value) {
  set_has_refresh_qty_exponent();
  refresh_qty_exponent_ = value;
}

// optional sfixed64 secondary_display_qty = 13;
inline bool DisplayInstruction::has_secondary_display_qty() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void DisplayInstruction::set_has_secondary_display_qty() {
  _has_bits_[0] |= 0x00001000u;
}
inline void DisplayInstruction::clear_has_secondary_display_qty() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void DisplayInstruction::clear_secondary_display_qty() {
  secondary_display_qty_ = GOOGLE_LONGLONG(0);
  clear_has_secondary_display_qty();
}
inline ::google::protobuf::int64 DisplayInstruction::secondary_display_qty() const {
  return secondary_display_qty_;
}
inline void DisplayInstruction::set_secondary_display_qty(::google::protobuf::int64 value) {
  set_has_secondary_display_qty();
  secondary_display_qty_ = value;
}

// optional sfixed32 secondary_display_qty_exponent = 14;
inline bool DisplayInstruction::has_secondary_display_qty_exponent() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void DisplayInstruction::set_has_secondary_display_qty_exponent() {
  _has_bits_[0] |= 0x00002000u;
}
inline void DisplayInstruction::clear_has_secondary_display_qty_exponent() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void DisplayInstruction::clear_secondary_display_qty_exponent() {
  secondary_display_qty_exponent_ = 0;
  clear_has_secondary_display_qty_exponent();
}
inline ::google::protobuf::int32 DisplayInstruction::secondary_display_qty_exponent() const {
  return secondary_display_qty_exponent_;
}
inline void DisplayInstruction::set_secondary_display_qty_exponent(::google::protobuf::int32 value) {
  set_has_secondary_display_qty_exponent();
  secondary_display_qty_exponent_ = value;
}

// -------------------------------------------------------------------

// TradingSessionIdUnion

// optional .Common.TradingSessionIdEnum trading_session_id = 1;
inline bool TradingSessionIdUnion::has_trading_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradingSessionIdUnion::set_has_trading_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradingSessionIdUnion::clear_has_trading_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradingSessionIdUnion::clear_trading_session_id() {
  trading_session_id_ = 0;
  clear_has_trading_session_id();
}
inline ::Common::TradingSessionIdEnum TradingSessionIdUnion::trading_session_id() const {
  return static_cast< ::Common::TradingSessionIdEnum >(trading_session_id_);
}
inline void TradingSessionIdUnion::set_trading_session_id(::Common::TradingSessionIdEnum value) {
  assert(::Common::TradingSessionIdEnum_IsValid(value));
  set_has_trading_session_id();
  trading_session_id_ = value;
}

// optional sfixed64 trading_session_id_sfixed64 = 2;
inline bool TradingSessionIdUnion::has_trading_session_id_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradingSessionIdUnion::set_has_trading_session_id_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradingSessionIdUnion::clear_has_trading_session_id_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradingSessionIdUnion::clear_trading_session_id_sfixed64() {
  trading_session_id_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_trading_session_id_sfixed64();
}
inline ::google::protobuf::int64 TradingSessionIdUnion::trading_session_id_sfixed64() const {
  return trading_session_id_sfixed64_;
}
inline void TradingSessionIdUnion::set_trading_session_id_sfixed64(::google::protobuf::int64 value) {
  set_has_trading_session_id_sfixed64();
  trading_session_id_sfixed64_ = value;
}

// -------------------------------------------------------------------

// TradingSessionSubIdUnion

// optional .Common.TradingSessionSubIdEnum trading_session_sub_id = 1;
inline bool TradingSessionSubIdUnion::has_trading_session_sub_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradingSessionSubIdUnion::set_has_trading_session_sub_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradingSessionSubIdUnion::clear_has_trading_session_sub_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradingSessionSubIdUnion::clear_trading_session_sub_id() {
  trading_session_sub_id_ = 0;
  clear_has_trading_session_sub_id();
}
inline ::Common::TradingSessionSubIdEnum TradingSessionSubIdUnion::trading_session_sub_id() const {
  return static_cast< ::Common::TradingSessionSubIdEnum >(trading_session_sub_id_);
}
inline void TradingSessionSubIdUnion::set_trading_session_sub_id(::Common::TradingSessionSubIdEnum value) {
  assert(::Common::TradingSessionSubIdEnum_IsValid(value));
  set_has_trading_session_sub_id();
  trading_session_sub_id_ = value;
}

// optional sfixed64 trading_session_sub_id_sfixed64 = 2;
inline bool TradingSessionSubIdUnion::has_trading_session_sub_id_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradingSessionSubIdUnion::set_has_trading_session_sub_id_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradingSessionSubIdUnion::clear_has_trading_session_sub_id_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradingSessionSubIdUnion::clear_trading_session_sub_id_sfixed64() {
  trading_session_sub_id_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_trading_session_sub_id_sfixed64();
}
inline ::google::protobuf::int64 TradingSessionSubIdUnion::trading_session_sub_id_sfixed64() const {
  return trading_session_sub_id_sfixed64_;
}
inline void TradingSessionSubIdUnion::set_trading_session_sub_id_sfixed64(::google::protobuf::int64 value) {
  set_has_trading_session_sub_id_sfixed64();
  trading_session_sub_id_sfixed64_ = value;
}

// -------------------------------------------------------------------

// TrdgSesGrp

// optional .Common.TradingSessionIdEnum trading_session_id = 1;
inline bool TrdgSesGrp::has_trading_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrdgSesGrp::set_has_trading_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrdgSesGrp::clear_has_trading_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrdgSesGrp::clear_trading_session_id() {
  trading_session_id_ = 0;
  clear_has_trading_session_id();
}
inline ::Common::TradingSessionIdEnum TrdgSesGrp::trading_session_id() const {
  return static_cast< ::Common::TradingSessionIdEnum >(trading_session_id_);
}
inline void TrdgSesGrp::set_trading_session_id(::Common::TradingSessionIdEnum value) {
  assert(::Common::TradingSessionIdEnum_IsValid(value));
  set_has_trading_session_id();
  trading_session_id_ = value;
}

// optional .Common.TradingSessionSubIdEnum trading_session_sub_id = 2;
inline bool TrdgSesGrp::has_trading_session_sub_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrdgSesGrp::set_has_trading_session_sub_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrdgSesGrp::clear_has_trading_session_sub_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrdgSesGrp::clear_trading_session_sub_id() {
  trading_session_sub_id_ = 0;
  clear_has_trading_session_sub_id();
}
inline ::Common::TradingSessionSubIdEnum TrdgSesGrp::trading_session_sub_id() const {
  return static_cast< ::Common::TradingSessionSubIdEnum >(trading_session_sub_id_);
}
inline void TrdgSesGrp::set_trading_session_sub_id(::Common::TradingSessionSubIdEnum value) {
  assert(::Common::TradingSessionSubIdEnum_IsValid(value));
  set_has_trading_session_sub_id();
  trading_session_sub_id_ = value;
}

// -------------------------------------------------------------------

// SecAltIdGrp

// optional string security_alt_id = 1;
inline bool SecAltIdGrp::has_security_alt_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecAltIdGrp::set_has_security_alt_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecAltIdGrp::clear_has_security_alt_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecAltIdGrp::clear_security_alt_id() {
  if (security_alt_id_ != &::google::protobuf::internal::kEmptyString) {
    security_alt_id_->clear();
  }
  clear_has_security_alt_id();
}
inline const ::std::string& SecAltIdGrp::security_alt_id() const {
  return *security_alt_id_;
}
inline void SecAltIdGrp::set_security_alt_id(const ::std::string& value) {
  set_has_security_alt_id();
  if (security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    security_alt_id_ = new ::std::string;
  }
  security_alt_id_->assign(value);
}
inline void SecAltIdGrp::set_security_alt_id(const char* value) {
  set_has_security_alt_id();
  if (security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    security_alt_id_ = new ::std::string;
  }
  security_alt_id_->assign(value);
}
inline void SecAltIdGrp::set_security_alt_id(const char* value, size_t size) {
  set_has_security_alt_id();
  if (security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    security_alt_id_ = new ::std::string;
  }
  security_alt_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecAltIdGrp::mutable_security_alt_id() {
  set_has_security_alt_id();
  if (security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    security_alt_id_ = new ::std::string;
  }
  return security_alt_id_;
}
inline ::std::string* SecAltIdGrp::release_security_alt_id() {
  clear_has_security_alt_id();
  if (security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_alt_id_;
    security_alt_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecAltIdGrp::set_allocated_security_alt_id(::std::string* security_alt_id) {
  if (security_alt_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_alt_id_;
  }
  if (security_alt_id) {
    set_has_security_alt_id();
    security_alt_id_ = security_alt_id;
  } else {
    clear_has_security_alt_id();
    security_alt_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_alt_id_source = 2;
inline bool SecAltIdGrp::has_security_alt_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecAltIdGrp::set_has_security_alt_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecAltIdGrp::clear_has_security_alt_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecAltIdGrp::clear_security_alt_id_source() {
  if (security_alt_id_source_ != &::google::protobuf::internal::kEmptyString) {
    security_alt_id_source_->clear();
  }
  clear_has_security_alt_id_source();
}
inline const ::std::string& SecAltIdGrp::security_alt_id_source() const {
  return *security_alt_id_source_;
}
inline void SecAltIdGrp::set_security_alt_id_source(const ::std::string& value) {
  set_has_security_alt_id_source();
  if (security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    security_alt_id_source_ = new ::std::string;
  }
  security_alt_id_source_->assign(value);
}
inline void SecAltIdGrp::set_security_alt_id_source(const char* value) {
  set_has_security_alt_id_source();
  if (security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    security_alt_id_source_ = new ::std::string;
  }
  security_alt_id_source_->assign(value);
}
inline void SecAltIdGrp::set_security_alt_id_source(const char* value, size_t size) {
  set_has_security_alt_id_source();
  if (security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    security_alt_id_source_ = new ::std::string;
  }
  security_alt_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecAltIdGrp::mutable_security_alt_id_source() {
  set_has_security_alt_id_source();
  if (security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    security_alt_id_source_ = new ::std::string;
  }
  return security_alt_id_source_;
}
inline ::std::string* SecAltIdGrp::release_security_alt_id_source() {
  clear_has_security_alt_id_source();
  if (security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_alt_id_source_;
    security_alt_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecAltIdGrp::set_allocated_security_alt_id_source(::std::string* security_alt_id_source) {
  if (security_alt_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete security_alt_id_source_;
  }
  if (security_alt_id_source) {
    set_has_security_alt_id_source();
    security_alt_id_source_ = security_alt_id_source;
  } else {
    clear_has_security_alt_id_source();
    security_alt_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SecurityXml

// optional string security_xml = 1;
inline bool SecurityXml::has_security_xml() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityXml::set_has_security_xml() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityXml::clear_has_security_xml() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityXml::clear_security_xml() {
  if (security_xml_ != &::google::protobuf::internal::kEmptyString) {
    security_xml_->clear();
  }
  clear_has_security_xml();
}
inline const ::std::string& SecurityXml::security_xml() const {
  return *security_xml_;
}
inline void SecurityXml::set_security_xml(const ::std::string& value) {
  set_has_security_xml();
  if (security_xml_ == &::google::protobuf::internal::kEmptyString) {
    security_xml_ = new ::std::string;
  }
  security_xml_->assign(value);
}
inline void SecurityXml::set_security_xml(const char* value) {
  set_has_security_xml();
  if (security_xml_ == &::google::protobuf::internal::kEmptyString) {
    security_xml_ = new ::std::string;
  }
  security_xml_->assign(value);
}
inline void SecurityXml::set_security_xml(const char* value, size_t size) {
  set_has_security_xml();
  if (security_xml_ == &::google::protobuf::internal::kEmptyString) {
    security_xml_ = new ::std::string;
  }
  security_xml_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityXml::mutable_security_xml() {
  set_has_security_xml();
  if (security_xml_ == &::google::protobuf::internal::kEmptyString) {
    security_xml_ = new ::std::string;
  }
  return security_xml_;
}
inline ::std::string* SecurityXml::release_security_xml() {
  clear_has_security_xml();
  if (security_xml_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_xml_;
    security_xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityXml::set_allocated_security_xml(::std::string* security_xml) {
  if (security_xml_ != &::google::protobuf::internal::kEmptyString) {
    delete security_xml_;
  }
  if (security_xml) {
    set_has_security_xml();
    security_xml_ = security_xml;
  } else {
    clear_has_security_xml();
    security_xml_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 security_xml_len = 2;
inline bool SecurityXml::has_security_xml_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityXml::set_has_security_xml_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityXml::clear_has_security_xml_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityXml::clear_security_xml_len() {
  security_xml_len_ = 0u;
  clear_has_security_xml_len();
}
inline ::google::protobuf::uint32 SecurityXml::security_xml_len() const {
  return security_xml_len_;
}
inline void SecurityXml::set_security_xml_len(::google::protobuf::uint32 value) {
  set_has_security_xml_len();
  security_xml_len_ = value;
}

// optional string security_xml_schema = 3;
inline bool SecurityXml::has_security_xml_schema() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityXml::set_has_security_xml_schema() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityXml::clear_has_security_xml_schema() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityXml::clear_security_xml_schema() {
  if (security_xml_schema_ != &::google::protobuf::internal::kEmptyString) {
    security_xml_schema_->clear();
  }
  clear_has_security_xml_schema();
}
inline const ::std::string& SecurityXml::security_xml_schema() const {
  return *security_xml_schema_;
}
inline void SecurityXml::set_security_xml_schema(const ::std::string& value) {
  set_has_security_xml_schema();
  if (security_xml_schema_ == &::google::protobuf::internal::kEmptyString) {
    security_xml_schema_ = new ::std::string;
  }
  security_xml_schema_->assign(value);
}
inline void SecurityXml::set_security_xml_schema(const char* value) {
  set_has_security_xml_schema();
  if (security_xml_schema_ == &::google::protobuf::internal::kEmptyString) {
    security_xml_schema_ = new ::std::string;
  }
  security_xml_schema_->assign(value);
}
inline void SecurityXml::set_security_xml_schema(const char* value, size_t size) {
  set_has_security_xml_schema();
  if (security_xml_schema_ == &::google::protobuf::internal::kEmptyString) {
    security_xml_schema_ = new ::std::string;
  }
  security_xml_schema_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityXml::mutable_security_xml_schema() {
  set_has_security_xml_schema();
  if (security_xml_schema_ == &::google::protobuf::internal::kEmptyString) {
    security_xml_schema_ = new ::std::string;
  }
  return security_xml_schema_;
}
inline ::std::string* SecurityXml::release_security_xml_schema() {
  clear_has_security_xml_schema();
  if (security_xml_schema_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_xml_schema_;
    security_xml_schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityXml::set_allocated_security_xml_schema(::std::string* security_xml_schema) {
  if (security_xml_schema_ != &::google::protobuf::internal::kEmptyString) {
    delete security_xml_schema_;
  }
  if (security_xml_schema) {
    set_has_security_xml_schema();
    security_xml_schema_ = security_xml_schema;
  } else {
    clear_has_security_xml_schema();
    security_xml_schema_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EventTypeUnion

// optional .Common.EventTypeEnum event_type = 1;
inline bool EventTypeUnion::has_event_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventTypeUnion::set_has_event_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventTypeUnion::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventTypeUnion::clear_event_type() {
  event_type_ = 0;
  clear_has_event_type();
}
inline ::Common::EventTypeEnum EventTypeUnion::event_type() const {
  return static_cast< ::Common::EventTypeEnum >(event_type_);
}
inline void EventTypeUnion::set_event_type(::Common::EventTypeEnum value) {
  assert(::Common::EventTypeEnum_IsValid(value));
  set_has_event_type();
  event_type_ = value;
}

// optional sfixed64 event_type_sfixed64 = 2;
inline bool EventTypeUnion::has_event_type_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventTypeUnion::set_has_event_type_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventTypeUnion::clear_has_event_type_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventTypeUnion::clear_event_type_sfixed64() {
  event_type_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_event_type_sfixed64();
}
inline ::google::protobuf::int64 EventTypeUnion::event_type_sfixed64() const {
  return event_type_sfixed64_;
}
inline void EventTypeUnion::set_event_type_sfixed64(::google::protobuf::int64 value) {
  set_has_event_type_sfixed64();
  event_type_sfixed64_ = value;
}

// -------------------------------------------------------------------

// EvntGrp

// optional sfixed32 event_date = 1;
inline bool EvntGrp::has_event_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EvntGrp::set_has_event_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EvntGrp::clear_has_event_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EvntGrp::clear_event_date() {
  event_date_ = 0;
  clear_has_event_date();
}
inline ::google::protobuf::int32 EvntGrp::event_date() const {
  return event_date_;
}
inline void EvntGrp::set_event_date(::google::protobuf::int32 value) {
  set_has_event_date();
  event_date_ = value;
}

// optional sfixed64 event_px = 2;
inline bool EvntGrp::has_event_px() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EvntGrp::set_has_event_px() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EvntGrp::clear_has_event_px() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EvntGrp::clear_event_px() {
  event_px_ = GOOGLE_LONGLONG(0);
  clear_has_event_px();
}
inline ::google::protobuf::int64 EvntGrp::event_px() const {
  return event_px_;
}
inline void EvntGrp::set_event_px(::google::protobuf::int64 value) {
  set_has_event_px();
  event_px_ = value;
}

// optional sfixed32 event_px_exponent = 3;
inline bool EvntGrp::has_event_px_exponent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EvntGrp::set_has_event_px_exponent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EvntGrp::clear_has_event_px_exponent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EvntGrp::clear_event_px_exponent() {
  event_px_exponent_ = 0;
  clear_has_event_px_exponent();
}
inline ::google::protobuf::int32 EvntGrp::event_px_exponent() const {
  return event_px_exponent_;
}
inline void EvntGrp::set_event_px_exponent(::google::protobuf::int32 value) {
  set_has_event_px_exponent();
  event_px_exponent_ = value;
}

// optional string event_text = 4;
inline bool EvntGrp::has_event_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EvntGrp::set_has_event_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EvntGrp::clear_has_event_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EvntGrp::clear_event_text() {
  if (event_text_ != &::google::protobuf::internal::kEmptyString) {
    event_text_->clear();
  }
  clear_has_event_text();
}
inline const ::std::string& EvntGrp::event_text() const {
  return *event_text_;
}
inline void EvntGrp::set_event_text(const ::std::string& value) {
  set_has_event_text();
  if (event_text_ == &::google::protobuf::internal::kEmptyString) {
    event_text_ = new ::std::string;
  }
  event_text_->assign(value);
}
inline void EvntGrp::set_event_text(const char* value) {
  set_has_event_text();
  if (event_text_ == &::google::protobuf::internal::kEmptyString) {
    event_text_ = new ::std::string;
  }
  event_text_->assign(value);
}
inline void EvntGrp::set_event_text(const char* value, size_t size) {
  set_has_event_text();
  if (event_text_ == &::google::protobuf::internal::kEmptyString) {
    event_text_ = new ::std::string;
  }
  event_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EvntGrp::mutable_event_text() {
  set_has_event_text();
  if (event_text_ == &::google::protobuf::internal::kEmptyString) {
    event_text_ = new ::std::string;
  }
  return event_text_;
}
inline ::std::string* EvntGrp::release_event_text() {
  clear_has_event_text();
  if (event_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = event_text_;
    event_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EvntGrp::set_allocated_event_text(::std::string* event_text) {
  if (event_text_ != &::google::protobuf::internal::kEmptyString) {
    delete event_text_;
  }
  if (event_text) {
    set_has_event_text();
    event_text_ = event_text;
  } else {
    clear_has_event_text();
    event_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.EventTypeEnum event_type = 5;
inline bool EvntGrp::has_event_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EvntGrp::set_has_event_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EvntGrp::clear_has_event_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EvntGrp::clear_event_type() {
  event_type_ = 0;
  clear_has_event_type();
}
inline ::Common::EventTypeEnum EvntGrp::event_type() const {
  return static_cast< ::Common::EventTypeEnum >(event_type_);
}
inline void EvntGrp::set_event_type(::Common::EventTypeEnum value) {
  assert(::Common::EventTypeEnum_IsValid(value));
  set_has_event_type();
  event_type_ = value;
}

// optional sfixed64 event_time = 6;
inline bool EvntGrp::has_event_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EvntGrp::set_has_event_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EvntGrp::clear_has_event_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EvntGrp::clear_event_time() {
  event_time_ = GOOGLE_LONGLONG(0);
  clear_has_event_time();
}
inline ::google::protobuf::int64 EvntGrp::event_time() const {
  return event_time_;
}
inline void EvntGrp::set_event_time(::google::protobuf::int64 value) {
  set_has_event_time();
  event_time_ = value;
}

// -------------------------------------------------------------------

// InstrumentPtysSubGrp

// optional string instrument_party_sub_id = 1;
inline bool InstrumentPtysSubGrp::has_instrument_party_sub_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrumentPtysSubGrp::set_has_instrument_party_sub_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrumentPtysSubGrp::clear_has_instrument_party_sub_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrumentPtysSubGrp::clear_instrument_party_sub_id() {
  if (instrument_party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_party_sub_id_->clear();
  }
  clear_has_instrument_party_sub_id();
}
inline const ::std::string& InstrumentPtysSubGrp::instrument_party_sub_id() const {
  return *instrument_party_sub_id_;
}
inline void InstrumentPtysSubGrp::set_instrument_party_sub_id(const ::std::string& value) {
  set_has_instrument_party_sub_id();
  if (instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_sub_id_ = new ::std::string;
  }
  instrument_party_sub_id_->assign(value);
}
inline void InstrumentPtysSubGrp::set_instrument_party_sub_id(const char* value) {
  set_has_instrument_party_sub_id();
  if (instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_sub_id_ = new ::std::string;
  }
  instrument_party_sub_id_->assign(value);
}
inline void InstrumentPtysSubGrp::set_instrument_party_sub_id(const char* value, size_t size) {
  set_has_instrument_party_sub_id();
  if (instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_sub_id_ = new ::std::string;
  }
  instrument_party_sub_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentPtysSubGrp::mutable_instrument_party_sub_id() {
  set_has_instrument_party_sub_id();
  if (instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_sub_id_ = new ::std::string;
  }
  return instrument_party_sub_id_;
}
inline ::std::string* InstrumentPtysSubGrp::release_instrument_party_sub_id() {
  clear_has_instrument_party_sub_id();
  if (instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_party_sub_id_;
    instrument_party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentPtysSubGrp::set_allocated_instrument_party_sub_id(::std::string* instrument_party_sub_id) {
  if (instrument_party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    delete instrument_party_sub_id_;
  }
  if (instrument_party_sub_id) {
    set_has_instrument_party_sub_id();
    instrument_party_sub_id_ = instrument_party_sub_id;
  } else {
    clear_has_instrument_party_sub_id();
    instrument_party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 instrument_party_sub_id_type = 2;
inline bool InstrumentPtysSubGrp::has_instrument_party_sub_id_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrumentPtysSubGrp::set_has_instrument_party_sub_id_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrumentPtysSubGrp::clear_has_instrument_party_sub_id_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrumentPtysSubGrp::clear_instrument_party_sub_id_type() {
  instrument_party_sub_id_type_ = GOOGLE_LONGLONG(0);
  clear_has_instrument_party_sub_id_type();
}
inline ::google::protobuf::int64 InstrumentPtysSubGrp::instrument_party_sub_id_type() const {
  return instrument_party_sub_id_type_;
}
inline void InstrumentPtysSubGrp::set_instrument_party_sub_id_type(::google::protobuf::int64 value) {
  set_has_instrument_party_sub_id_type();
  instrument_party_sub_id_type_ = value;
}

// -------------------------------------------------------------------

// InstrumentParties

// optional string instrument_party_id = 1;
inline bool InstrumentParties::has_instrument_party_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrumentParties::set_has_instrument_party_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrumentParties::clear_has_instrument_party_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrumentParties::clear_instrument_party_id() {
  if (instrument_party_id_ != &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_->clear();
  }
  clear_has_instrument_party_id();
}
inline const ::std::string& InstrumentParties::instrument_party_id() const {
  return *instrument_party_id_;
}
inline void InstrumentParties::set_instrument_party_id(const ::std::string& value) {
  set_has_instrument_party_id();
  if (instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_ = new ::std::string;
  }
  instrument_party_id_->assign(value);
}
inline void InstrumentParties::set_instrument_party_id(const char* value) {
  set_has_instrument_party_id();
  if (instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_ = new ::std::string;
  }
  instrument_party_id_->assign(value);
}
inline void InstrumentParties::set_instrument_party_id(const char* value, size_t size) {
  set_has_instrument_party_id();
  if (instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_ = new ::std::string;
  }
  instrument_party_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentParties::mutable_instrument_party_id() {
  set_has_instrument_party_id();
  if (instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_ = new ::std::string;
  }
  return instrument_party_id_;
}
inline ::std::string* InstrumentParties::release_instrument_party_id() {
  clear_has_instrument_party_id();
  if (instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_party_id_;
    instrument_party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentParties::set_allocated_instrument_party_id(::std::string* instrument_party_id) {
  if (instrument_party_id_ != &::google::protobuf::internal::kEmptyString) {
    delete instrument_party_id_;
  }
  if (instrument_party_id) {
    set_has_instrument_party_id();
    instrument_party_id_ = instrument_party_id;
  } else {
    clear_has_instrument_party_id();
    instrument_party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string instrument_party_id_source = 2;
inline bool InstrumentParties::has_instrument_party_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrumentParties::set_has_instrument_party_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrumentParties::clear_has_instrument_party_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrumentParties::clear_instrument_party_id_source() {
  if (instrument_party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_source_->clear();
  }
  clear_has_instrument_party_id_source();
}
inline const ::std::string& InstrumentParties::instrument_party_id_source() const {
  return *instrument_party_id_source_;
}
inline void InstrumentParties::set_instrument_party_id_source(const ::std::string& value) {
  set_has_instrument_party_id_source();
  if (instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_source_ = new ::std::string;
  }
  instrument_party_id_source_->assign(value);
}
inline void InstrumentParties::set_instrument_party_id_source(const char* value) {
  set_has_instrument_party_id_source();
  if (instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_source_ = new ::std::string;
  }
  instrument_party_id_source_->assign(value);
}
inline void InstrumentParties::set_instrument_party_id_source(const char* value, size_t size) {
  set_has_instrument_party_id_source();
  if (instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_source_ = new ::std::string;
  }
  instrument_party_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentParties::mutable_instrument_party_id_source() {
  set_has_instrument_party_id_source();
  if (instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    instrument_party_id_source_ = new ::std::string;
  }
  return instrument_party_id_source_;
}
inline ::std::string* InstrumentParties::release_instrument_party_id_source() {
  clear_has_instrument_party_id_source();
  if (instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrument_party_id_source_;
    instrument_party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentParties::set_allocated_instrument_party_id_source(::std::string* instrument_party_id_source) {
  if (instrument_party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete instrument_party_id_source_;
  }
  if (instrument_party_id_source) {
    set_has_instrument_party_id_source();
    instrument_party_id_source_ = instrument_party_id_source;
  } else {
    clear_has_instrument_party_id_source();
    instrument_party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 instrument_party_role = 3;
inline bool InstrumentParties::has_instrument_party_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstrumentParties::set_has_instrument_party_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstrumentParties::clear_has_instrument_party_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstrumentParties::clear_instrument_party_role() {
  instrument_party_role_ = GOOGLE_LONGLONG(0);
  clear_has_instrument_party_role();
}
inline ::google::protobuf::int64 InstrumentParties::instrument_party_role() const {
  return instrument_party_role_;
}
inline void InstrumentParties::set_instrument_party_role(::google::protobuf::int64 value) {
  set_has_instrument_party_role();
  instrument_party_role_ = value;
}

// repeated .Common.InstrumentPtysSubGrp instrument_ptys_sub_grp = 4;
inline int InstrumentParties::instrument_ptys_sub_grp_size() const {
  return instrument_ptys_sub_grp_.size();
}
inline void InstrumentParties::clear_instrument_ptys_sub_grp() {
  instrument_ptys_sub_grp_.Clear();
}
inline const ::Common::InstrumentPtysSubGrp& InstrumentParties::instrument_ptys_sub_grp(int index) const {
  return instrument_ptys_sub_grp_.Get(index);
}
inline ::Common::InstrumentPtysSubGrp* InstrumentParties::mutable_instrument_ptys_sub_grp(int index) {
  return instrument_ptys_sub_grp_.Mutable(index);
}
inline ::Common::InstrumentPtysSubGrp* InstrumentParties::add_instrument_ptys_sub_grp() {
  return instrument_ptys_sub_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrumentPtysSubGrp >&
InstrumentParties::instrument_ptys_sub_grp() const {
  return instrument_ptys_sub_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrumentPtysSubGrp >*
InstrumentParties::mutable_instrument_ptys_sub_grp() {
  return &instrument_ptys_sub_grp_;
}

// -------------------------------------------------------------------

// ComplexEventTimes

// optional sfixed64 complex_event_end_time = 1;
inline bool ComplexEventTimes::has_complex_event_end_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComplexEventTimes::set_has_complex_event_end_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComplexEventTimes::clear_has_complex_event_end_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComplexEventTimes::clear_complex_event_end_time() {
  complex_event_end_time_ = GOOGLE_LONGLONG(0);
  clear_has_complex_event_end_time();
}
inline ::google::protobuf::int64 ComplexEventTimes::complex_event_end_time() const {
  return complex_event_end_time_;
}
inline void ComplexEventTimes::set_complex_event_end_time(::google::protobuf::int64 value) {
  set_has_complex_event_end_time();
  complex_event_end_time_ = value;
}

// optional sfixed64 complex_event_start_time = 2;
inline bool ComplexEventTimes::has_complex_event_start_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComplexEventTimes::set_has_complex_event_start_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComplexEventTimes::clear_has_complex_event_start_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComplexEventTimes::clear_complex_event_start_time() {
  complex_event_start_time_ = GOOGLE_LONGLONG(0);
  clear_has_complex_event_start_time();
}
inline ::google::protobuf::int64 ComplexEventTimes::complex_event_start_time() const {
  return complex_event_start_time_;
}
inline void ComplexEventTimes::set_complex_event_start_time(::google::protobuf::int64 value) {
  set_has_complex_event_start_time();
  complex_event_start_time_ = value;
}

// -------------------------------------------------------------------

// ComplexEventDates

// optional sfixed64 complex_event_end_date = 1;
inline bool ComplexEventDates::has_complex_event_end_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComplexEventDates::set_has_complex_event_end_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComplexEventDates::clear_has_complex_event_end_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComplexEventDates::clear_complex_event_end_date() {
  complex_event_end_date_ = GOOGLE_LONGLONG(0);
  clear_has_complex_event_end_date();
}
inline ::google::protobuf::int64 ComplexEventDates::complex_event_end_date() const {
  return complex_event_end_date_;
}
inline void ComplexEventDates::set_complex_event_end_date(::google::protobuf::int64 value) {
  set_has_complex_event_end_date();
  complex_event_end_date_ = value;
}

// optional sfixed64 complex_event_start_date = 2;
inline bool ComplexEventDates::has_complex_event_start_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComplexEventDates::set_has_complex_event_start_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComplexEventDates::clear_has_complex_event_start_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComplexEventDates::clear_complex_event_start_date() {
  complex_event_start_date_ = GOOGLE_LONGLONG(0);
  clear_has_complex_event_start_date();
}
inline ::google::protobuf::int64 ComplexEventDates::complex_event_start_date() const {
  return complex_event_start_date_;
}
inline void ComplexEventDates::set_complex_event_start_date(::google::protobuf::int64 value) {
  set_has_complex_event_start_date();
  complex_event_start_date_ = value;
}

// repeated .Common.ComplexEventTimes complex_event_times = 3;
inline int ComplexEventDates::complex_event_times_size() const {
  return complex_event_times_.size();
}
inline void ComplexEventDates::clear_complex_event_times() {
  complex_event_times_.Clear();
}
inline const ::Common::ComplexEventTimes& ComplexEventDates::complex_event_times(int index) const {
  return complex_event_times_.Get(index);
}
inline ::Common::ComplexEventTimes* ComplexEventDates::mutable_complex_event_times(int index) {
  return complex_event_times_.Mutable(index);
}
inline ::Common::ComplexEventTimes* ComplexEventDates::add_complex_event_times() {
  return complex_event_times_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventTimes >&
ComplexEventDates::complex_event_times() const {
  return complex_event_times_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventTimes >*
ComplexEventDates::mutable_complex_event_times() {
  return &complex_event_times_;
}

// -------------------------------------------------------------------

// ComplexEvents

// optional .Common.ComplexEventConditionEnum complex_event_condition = 1;
inline bool ComplexEvents::has_complex_event_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComplexEvents::set_has_complex_event_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComplexEvents::clear_has_complex_event_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComplexEvents::clear_complex_event_condition() {
  complex_event_condition_ = 0;
  clear_has_complex_event_condition();
}
inline ::Common::ComplexEventConditionEnum ComplexEvents::complex_event_condition() const {
  return static_cast< ::Common::ComplexEventConditionEnum >(complex_event_condition_);
}
inline void ComplexEvents::set_complex_event_condition(::Common::ComplexEventConditionEnum value) {
  assert(::Common::ComplexEventConditionEnum_IsValid(value));
  set_has_complex_event_condition();
  complex_event_condition_ = value;
}

// repeated .Common.ComplexEventDates complex_event_dates = 2;
inline int ComplexEvents::complex_event_dates_size() const {
  return complex_event_dates_.size();
}
inline void ComplexEvents::clear_complex_event_dates() {
  complex_event_dates_.Clear();
}
inline const ::Common::ComplexEventDates& ComplexEvents::complex_event_dates(int index) const {
  return complex_event_dates_.Get(index);
}
inline ::Common::ComplexEventDates* ComplexEvents::mutable_complex_event_dates(int index) {
  return complex_event_dates_.Mutable(index);
}
inline ::Common::ComplexEventDates* ComplexEvents::add_complex_event_dates() {
  return complex_event_dates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventDates >&
ComplexEvents::complex_event_dates() const {
  return complex_event_dates_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::ComplexEventDates >*
ComplexEvents::mutable_complex_event_dates() {
  return &complex_event_dates_;
}

// optional sfixed64 complex_event_price = 3;
inline bool ComplexEvents::has_complex_event_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComplexEvents::set_has_complex_event_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComplexEvents::clear_has_complex_event_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComplexEvents::clear_complex_event_price() {
  complex_event_price_ = GOOGLE_LONGLONG(0);
  clear_has_complex_event_price();
}
inline ::google::protobuf::int64 ComplexEvents::complex_event_price() const {
  return complex_event_price_;
}
inline void ComplexEvents::set_complex_event_price(::google::protobuf::int64 value) {
  set_has_complex_event_price();
  complex_event_price_ = value;
}

// optional sfixed32 complex_event_price_exponent = 4;
inline bool ComplexEvents::has_complex_event_price_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComplexEvents::set_has_complex_event_price_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComplexEvents::clear_has_complex_event_price_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComplexEvents::clear_complex_event_price_exponent() {
  complex_event_price_exponent_ = 0;
  clear_has_complex_event_price_exponent();
}
inline ::google::protobuf::int32 ComplexEvents::complex_event_price_exponent() const {
  return complex_event_price_exponent_;
}
inline void ComplexEvents::set_complex_event_price_exponent(::google::protobuf::int32 value) {
  set_has_complex_event_price_exponent();
  complex_event_price_exponent_ = value;
}

// optional .Common.ComplexEventPriceBoundaryMethodEnum complex_event_price_boundary_method = 5;
inline bool ComplexEvents::has_complex_event_price_boundary_method() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ComplexEvents::set_has_complex_event_price_boundary_method() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ComplexEvents::clear_has_complex_event_price_boundary_method() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ComplexEvents::clear_complex_event_price_boundary_method() {
  complex_event_price_boundary_method_ = 0;
  clear_has_complex_event_price_boundary_method();
}
inline ::Common::ComplexEventPriceBoundaryMethodEnum ComplexEvents::complex_event_price_boundary_method() const {
  return static_cast< ::Common::ComplexEventPriceBoundaryMethodEnum >(complex_event_price_boundary_method_);
}
inline void ComplexEvents::set_complex_event_price_boundary_method(::Common::ComplexEventPriceBoundaryMethodEnum value) {
  assert(::Common::ComplexEventPriceBoundaryMethodEnum_IsValid(value));
  set_has_complex_event_price_boundary_method();
  complex_event_price_boundary_method_ = value;
}

// optional sfixed64 complex_event_price_boundary_precision = 6;
inline bool ComplexEvents::has_complex_event_price_boundary_precision() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ComplexEvents::set_has_complex_event_price_boundary_precision() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ComplexEvents::clear_has_complex_event_price_boundary_precision() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ComplexEvents::clear_complex_event_price_boundary_precision() {
  complex_event_price_boundary_precision_ = GOOGLE_LONGLONG(0);
  clear_has_complex_event_price_boundary_precision();
}
inline ::google::protobuf::int64 ComplexEvents::complex_event_price_boundary_precision() const {
  return complex_event_price_boundary_precision_;
}
inline void ComplexEvents::set_complex_event_price_boundary_precision(::google::protobuf::int64 value) {
  set_has_complex_event_price_boundary_precision();
  complex_event_price_boundary_precision_ = value;
}

// optional sfixed32 complex_event_price_boundary_precision_exponent = 7;
inline bool ComplexEvents::has_complex_event_price_boundary_precision_exponent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ComplexEvents::set_has_complex_event_price_boundary_precision_exponent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ComplexEvents::clear_has_complex_event_price_boundary_precision_exponent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ComplexEvents::clear_complex_event_price_boundary_precision_exponent() {
  complex_event_price_boundary_precision_exponent_ = 0;
  clear_has_complex_event_price_boundary_precision_exponent();
}
inline ::google::protobuf::int32 ComplexEvents::complex_event_price_boundary_precision_exponent() const {
  return complex_event_price_boundary_precision_exponent_;
}
inline void ComplexEvents::set_complex_event_price_boundary_precision_exponent(::google::protobuf::int32 value) {
  set_has_complex_event_price_boundary_precision_exponent();
  complex_event_price_boundary_precision_exponent_ = value;
}

// optional .Common.ComplexEventPriceTimeTypeEnum complex_event_price_time_type = 8;
inline bool ComplexEvents::has_complex_event_price_time_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ComplexEvents::set_has_complex_event_price_time_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ComplexEvents::clear_has_complex_event_price_time_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ComplexEvents::clear_complex_event_price_time_type() {
  complex_event_price_time_type_ = 0;
  clear_has_complex_event_price_time_type();
}
inline ::Common::ComplexEventPriceTimeTypeEnum ComplexEvents::complex_event_price_time_type() const {
  return static_cast< ::Common::ComplexEventPriceTimeTypeEnum >(complex_event_price_time_type_);
}
inline void ComplexEvents::set_complex_event_price_time_type(::Common::ComplexEventPriceTimeTypeEnum value) {
  assert(::Common::ComplexEventPriceTimeTypeEnum_IsValid(value));
  set_has_complex_event_price_time_type();
  complex_event_price_time_type_ = value;
}

// optional .Common.ComplexEventTypeEnum complex_event_type = 9;
inline bool ComplexEvents::has_complex_event_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ComplexEvents::set_has_complex_event_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ComplexEvents::clear_has_complex_event_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ComplexEvents::clear_complex_event_type() {
  complex_event_type_ = 0;
  clear_has_complex_event_type();
}
inline ::Common::ComplexEventTypeEnum ComplexEvents::complex_event_type() const {
  return static_cast< ::Common::ComplexEventTypeEnum >(complex_event_type_);
}
inline void ComplexEvents::set_complex_event_type(::Common::ComplexEventTypeEnum value) {
  assert(::Common::ComplexEventTypeEnum_IsValid(value));
  set_has_complex_event_type();
  complex_event_type_ = value;
}

// optional sfixed64 complex_opt_payout_amount = 10;
inline bool ComplexEvents::has_complex_opt_payout_amount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ComplexEvents::set_has_complex_opt_payout_amount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ComplexEvents::clear_has_complex_opt_payout_amount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ComplexEvents::clear_complex_opt_payout_amount() {
  complex_opt_payout_amount_ = GOOGLE_LONGLONG(0);
  clear_has_complex_opt_payout_amount();
}
inline ::google::protobuf::int64 ComplexEvents::complex_opt_payout_amount() const {
  return complex_opt_payout_amount_;
}
inline void ComplexEvents::set_complex_opt_payout_amount(::google::protobuf::int64 value) {
  set_has_complex_opt_payout_amount();
  complex_opt_payout_amount_ = value;
}

// optional sfixed32 complex_opt_payout_amount_exponent = 11;
inline bool ComplexEvents::has_complex_opt_payout_amount_exponent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ComplexEvents::set_has_complex_opt_payout_amount_exponent() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ComplexEvents::clear_has_complex_opt_payout_amount_exponent() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ComplexEvents::clear_complex_opt_payout_amount_exponent() {
  complex_opt_payout_amount_exponent_ = 0;
  clear_has_complex_opt_payout_amount_exponent();
}
inline ::google::protobuf::int32 ComplexEvents::complex_opt_payout_amount_exponent() const {
  return complex_opt_payout_amount_exponent_;
}
inline void ComplexEvents::set_complex_opt_payout_amount_exponent(::google::protobuf::int32 value) {
  set_has_complex_opt_payout_amount_exponent();
  complex_opt_payout_amount_exponent_ = value;
}

// -------------------------------------------------------------------

// StrikePriceDeterminationMethodUnion

// optional .Common.StrikePriceDeterminationMethodEnum strike_price_determination_method = 1;
inline bool StrikePriceDeterminationMethodUnion::has_strike_price_determination_method() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrikePriceDeterminationMethodUnion::set_has_strike_price_determination_method() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrikePriceDeterminationMethodUnion::clear_has_strike_price_determination_method() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrikePriceDeterminationMethodUnion::clear_strike_price_determination_method() {
  strike_price_determination_method_ = 0;
  clear_has_strike_price_determination_method();
}
inline ::Common::StrikePriceDeterminationMethodEnum StrikePriceDeterminationMethodUnion::strike_price_determination_method() const {
  return static_cast< ::Common::StrikePriceDeterminationMethodEnum >(strike_price_determination_method_);
}
inline void StrikePriceDeterminationMethodUnion::set_strike_price_determination_method(::Common::StrikePriceDeterminationMethodEnum value) {
  assert(::Common::StrikePriceDeterminationMethodEnum_IsValid(value));
  set_has_strike_price_determination_method();
  strike_price_determination_method_ = value;
}

// optional sfixed64 strike_price_determination_method_sfixed64 = 2;
inline bool StrikePriceDeterminationMethodUnion::has_strike_price_determination_method_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrikePriceDeterminationMethodUnion::set_has_strike_price_determination_method_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrikePriceDeterminationMethodUnion::clear_has_strike_price_determination_method_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrikePriceDeterminationMethodUnion::clear_strike_price_determination_method_sfixed64() {
  strike_price_determination_method_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_strike_price_determination_method_sfixed64();
}
inline ::google::protobuf::int64 StrikePriceDeterminationMethodUnion::strike_price_determination_method_sfixed64() const {
  return strike_price_determination_method_sfixed64_;
}
inline void StrikePriceDeterminationMethodUnion::set_strike_price_determination_method_sfixed64(::google::protobuf::int64 value) {
  set_has_strike_price_determination_method_sfixed64();
  strike_price_determination_method_sfixed64_ = value;
}

// -------------------------------------------------------------------

// FlowScheduleTypeUnion

// optional .Common.FlowScheduleTypeEnum flow_schedule_type = 1;
inline bool FlowScheduleTypeUnion::has_flow_schedule_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlowScheduleTypeUnion::set_has_flow_schedule_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FlowScheduleTypeUnion::clear_has_flow_schedule_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FlowScheduleTypeUnion::clear_flow_schedule_type() {
  flow_schedule_type_ = 0;
  clear_has_flow_schedule_type();
}
inline ::Common::FlowScheduleTypeEnum FlowScheduleTypeUnion::flow_schedule_type() const {
  return static_cast< ::Common::FlowScheduleTypeEnum >(flow_schedule_type_);
}
inline void FlowScheduleTypeUnion::set_flow_schedule_type(::Common::FlowScheduleTypeEnum value) {
  assert(::Common::FlowScheduleTypeEnum_IsValid(value));
  set_has_flow_schedule_type();
  flow_schedule_type_ = value;
}

// optional sfixed64 flow_schedule_type_sfixed64 = 2;
inline bool FlowScheduleTypeUnion::has_flow_schedule_type_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlowScheduleTypeUnion::set_has_flow_schedule_type_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FlowScheduleTypeUnion::clear_has_flow_schedule_type_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FlowScheduleTypeUnion::clear_flow_schedule_type_sfixed64() {
  flow_schedule_type_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_flow_schedule_type_sfixed64();
}
inline ::google::protobuf::int64 FlowScheduleTypeUnion::flow_schedule_type_sfixed64() const {
  return flow_schedule_type_sfixed64_;
}
inline void FlowScheduleTypeUnion::set_flow_schedule_type_sfixed64(::google::protobuf::int64 value) {
  set_has_flow_schedule_type_sfixed64();
  flow_schedule_type_sfixed64_ = value;
}

// -------------------------------------------------------------------

// CpProgramUnion

// optional .Common.CpProgramEnum cp_program = 1;
inline bool CpProgramUnion::has_cp_program() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CpProgramUnion::set_has_cp_program() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CpProgramUnion::clear_has_cp_program() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CpProgramUnion::clear_cp_program() {
  cp_program_ = 0;
  clear_has_cp_program();
}
inline ::Common::CpProgramEnum CpProgramUnion::cp_program() const {
  return static_cast< ::Common::CpProgramEnum >(cp_program_);
}
inline void CpProgramUnion::set_cp_program(::Common::CpProgramEnum value) {
  assert(::Common::CpProgramEnum_IsValid(value));
  set_has_cp_program();
  cp_program_ = value;
}

// optional sfixed64 cp_program_sfixed64 = 2;
inline bool CpProgramUnion::has_cp_program_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CpProgramUnion::set_has_cp_program_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CpProgramUnion::clear_has_cp_program_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CpProgramUnion::clear_cp_program_sfixed64() {
  cp_program_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_cp_program_sfixed64();
}
inline ::google::protobuf::int64 CpProgramUnion::cp_program_sfixed64() const {
  return cp_program_sfixed64_;
}
inline void CpProgramUnion::set_cp_program_sfixed64(::google::protobuf::int64 value) {
  set_has_cp_program_sfixed64();
  cp_program_sfixed64_ = value;
}

// -------------------------------------------------------------------

// Instrument

// optional string cfi_code = 1;
inline bool Instrument::has_cfi_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Instrument::set_has_cfi_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Instrument::clear_has_cfi_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Instrument::clear_cfi_code() {
  if (cfi_code_ != &::google::protobuf::internal::kEmptyString) {
    cfi_code_->clear();
  }
  clear_has_cfi_code();
}
inline const ::std::string& Instrument::cfi_code() const {
  return *cfi_code_;
}
inline void Instrument::set_cfi_code(const ::std::string& value) {
  set_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    cfi_code_ = new ::std::string;
  }
  cfi_code_->assign(value);
}
inline void Instrument::set_cfi_code(const char* value) {
  set_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    cfi_code_ = new ::std::string;
  }
  cfi_code_->assign(value);
}
inline void Instrument::set_cfi_code(const char* value, size_t size) {
  set_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    cfi_code_ = new ::std::string;
  }
  cfi_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_cfi_code() {
  set_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    cfi_code_ = new ::std::string;
  }
  return cfi_code_;
}
inline ::std::string* Instrument::release_cfi_code() {
  clear_has_cfi_code();
  if (cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cfi_code_;
    cfi_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_cfi_code(::std::string* cfi_code) {
  if (cfi_code_ != &::google::protobuf::internal::kEmptyString) {
    delete cfi_code_;
  }
  if (cfi_code) {
    set_has_cfi_code();
    cfi_code_ = cfi_code;
  } else {
    clear_has_cfi_code();
    cfi_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double contract_multiplier = 2;
inline bool Instrument::has_contract_multiplier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Instrument::set_has_contract_multiplier() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Instrument::clear_has_contract_multiplier() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Instrument::clear_contract_multiplier() {
  contract_multiplier_ = 0;
  clear_has_contract_multiplier();
}
inline double Instrument::contract_multiplier() const {
  return contract_multiplier_;
}
inline void Instrument::set_contract_multiplier(double value) {
  set_has_contract_multiplier();
  contract_multiplier_ = value;
}

// optional string country_of_issue = 3;
inline bool Instrument::has_country_of_issue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Instrument::set_has_country_of_issue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Instrument::clear_has_country_of_issue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Instrument::clear_country_of_issue() {
  if (country_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    country_of_issue_->clear();
  }
  clear_has_country_of_issue();
}
inline const ::std::string& Instrument::country_of_issue() const {
  return *country_of_issue_;
}
inline void Instrument::set_country_of_issue(const ::std::string& value) {
  set_has_country_of_issue();
  if (country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    country_of_issue_ = new ::std::string;
  }
  country_of_issue_->assign(value);
}
inline void Instrument::set_country_of_issue(const char* value) {
  set_has_country_of_issue();
  if (country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    country_of_issue_ = new ::std::string;
  }
  country_of_issue_->assign(value);
}
inline void Instrument::set_country_of_issue(const char* value, size_t size) {
  set_has_country_of_issue();
  if (country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    country_of_issue_ = new ::std::string;
  }
  country_of_issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_country_of_issue() {
  set_has_country_of_issue();
  if (country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    country_of_issue_ = new ::std::string;
  }
  return country_of_issue_;
}
inline ::std::string* Instrument::release_country_of_issue() {
  clear_has_country_of_issue();
  if (country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = country_of_issue_;
    country_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_country_of_issue(::std::string* country_of_issue) {
  if (country_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    delete country_of_issue_;
  }
  if (country_of_issue) {
    set_has_country_of_issue();
    country_of_issue_ = country_of_issue;
  } else {
    clear_has_country_of_issue();
    country_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 coupon_payment_date = 4;
inline bool Instrument::has_coupon_payment_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Instrument::set_has_coupon_payment_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Instrument::clear_has_coupon_payment_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Instrument::clear_coupon_payment_date() {
  coupon_payment_date_ = 0;
  clear_has_coupon_payment_date();
}
inline ::google::protobuf::int32 Instrument::coupon_payment_date() const {
  return coupon_payment_date_;
}
inline void Instrument::set_coupon_payment_date(::google::protobuf::int32 value) {
  set_has_coupon_payment_date();
  coupon_payment_date_ = value;
}

// optional sfixed64 coupon_rate = 5;
inline bool Instrument::has_coupon_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Instrument::set_has_coupon_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Instrument::clear_has_coupon_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Instrument::clear_coupon_rate() {
  coupon_rate_ = GOOGLE_LONGLONG(0);
  clear_has_coupon_rate();
}
inline ::google::protobuf::int64 Instrument::coupon_rate() const {
  return coupon_rate_;
}
inline void Instrument::set_coupon_rate(::google::protobuf::int64 value) {
  set_has_coupon_rate();
  coupon_rate_ = value;
}

// optional sfixed32 coupon_rate_exponent = 6;
inline bool Instrument::has_coupon_rate_exponent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Instrument::set_has_coupon_rate_exponent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Instrument::clear_has_coupon_rate_exponent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Instrument::clear_coupon_rate_exponent() {
  coupon_rate_exponent_ = 0;
  clear_has_coupon_rate_exponent();
}
inline ::google::protobuf::int32 Instrument::coupon_rate_exponent() const {
  return coupon_rate_exponent_;
}
inline void Instrument::set_coupon_rate_exponent(::google::protobuf::int32 value) {
  set_has_coupon_rate_exponent();
  coupon_rate_exponent_ = value;
}

// optional string credit_rating = 7;
inline bool Instrument::has_credit_rating() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Instrument::set_has_credit_rating() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Instrument::clear_has_credit_rating() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Instrument::clear_credit_rating() {
  if (credit_rating_ != &::google::protobuf::internal::kEmptyString) {
    credit_rating_->clear();
  }
  clear_has_credit_rating();
}
inline const ::std::string& Instrument::credit_rating() const {
  return *credit_rating_;
}
inline void Instrument::set_credit_rating(const ::std::string& value) {
  set_has_credit_rating();
  if (credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    credit_rating_ = new ::std::string;
  }
  credit_rating_->assign(value);
}
inline void Instrument::set_credit_rating(const char* value) {
  set_has_credit_rating();
  if (credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    credit_rating_ = new ::std::string;
  }
  credit_rating_->assign(value);
}
inline void Instrument::set_credit_rating(const char* value, size_t size) {
  set_has_credit_rating();
  if (credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    credit_rating_ = new ::std::string;
  }
  credit_rating_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_credit_rating() {
  set_has_credit_rating();
  if (credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    credit_rating_ = new ::std::string;
  }
  return credit_rating_;
}
inline ::std::string* Instrument::release_credit_rating() {
  clear_has_credit_rating();
  if (credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = credit_rating_;
    credit_rating_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_credit_rating(::std::string* credit_rating) {
  if (credit_rating_ != &::google::protobuf::internal::kEmptyString) {
    delete credit_rating_;
  }
  if (credit_rating) {
    set_has_credit_rating();
    credit_rating_ = credit_rating;
  } else {
    clear_has_credit_rating();
    credit_rating_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_issuer = 8;
inline bool Instrument::has_encoded_issuer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Instrument::set_has_encoded_issuer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Instrument::clear_has_encoded_issuer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Instrument::clear_encoded_issuer() {
  if (encoded_issuer_ != &::google::protobuf::internal::kEmptyString) {
    encoded_issuer_->clear();
  }
  clear_has_encoded_issuer();
}
inline const ::std::string& Instrument::encoded_issuer() const {
  return *encoded_issuer_;
}
inline void Instrument::set_encoded_issuer(const ::std::string& value) {
  set_has_encoded_issuer();
  if (encoded_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_issuer_ = new ::std::string;
  }
  encoded_issuer_->assign(value);
}
inline void Instrument::set_encoded_issuer(const char* value) {
  set_has_encoded_issuer();
  if (encoded_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_issuer_ = new ::std::string;
  }
  encoded_issuer_->assign(value);
}
inline void Instrument::set_encoded_issuer(const void* value, size_t size) {
  set_has_encoded_issuer();
  if (encoded_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_issuer_ = new ::std::string;
  }
  encoded_issuer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_encoded_issuer() {
  set_has_encoded_issuer();
  if (encoded_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_issuer_ = new ::std::string;
  }
  return encoded_issuer_;
}
inline ::std::string* Instrument::release_encoded_issuer() {
  clear_has_encoded_issuer();
  if (encoded_issuer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_issuer_;
    encoded_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_encoded_issuer(::std::string* encoded_issuer) {
  if (encoded_issuer_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_issuer_;
  }
  if (encoded_issuer) {
    set_has_encoded_issuer();
    encoded_issuer_ = encoded_issuer;
  } else {
    clear_has_encoded_issuer();
    encoded_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_issuer_len = 9;
inline bool Instrument::has_encoded_issuer_len() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Instrument::set_has_encoded_issuer_len() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Instrument::clear_has_encoded_issuer_len() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Instrument::clear_encoded_issuer_len() {
  encoded_issuer_len_ = 0u;
  clear_has_encoded_issuer_len();
}
inline ::google::protobuf::uint32 Instrument::encoded_issuer_len() const {
  return encoded_issuer_len_;
}
inline void Instrument::set_encoded_issuer_len(::google::protobuf::uint32 value) {
  set_has_encoded_issuer_len();
  encoded_issuer_len_ = value;
}

// optional bytes encoded_security_desc = 10;
inline bool Instrument::has_encoded_security_desc() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Instrument::set_has_encoded_security_desc() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Instrument::clear_has_encoded_security_desc() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Instrument::clear_encoded_security_desc() {
  if (encoded_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    encoded_security_desc_->clear();
  }
  clear_has_encoded_security_desc();
}
inline const ::std::string& Instrument::encoded_security_desc() const {
  return *encoded_security_desc_;
}
inline void Instrument::set_encoded_security_desc(const ::std::string& value) {
  set_has_encoded_security_desc();
  if (encoded_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_desc_ = new ::std::string;
  }
  encoded_security_desc_->assign(value);
}
inline void Instrument::set_encoded_security_desc(const char* value) {
  set_has_encoded_security_desc();
  if (encoded_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_desc_ = new ::std::string;
  }
  encoded_security_desc_->assign(value);
}
inline void Instrument::set_encoded_security_desc(const void* value, size_t size) {
  set_has_encoded_security_desc();
  if (encoded_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_desc_ = new ::std::string;
  }
  encoded_security_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_encoded_security_desc() {
  set_has_encoded_security_desc();
  if (encoded_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_desc_ = new ::std::string;
  }
  return encoded_security_desc_;
}
inline ::std::string* Instrument::release_encoded_security_desc() {
  clear_has_encoded_security_desc();
  if (encoded_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_security_desc_;
    encoded_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_encoded_security_desc(::std::string* encoded_security_desc) {
  if (encoded_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_security_desc_;
  }
  if (encoded_security_desc) {
    set_has_encoded_security_desc();
    encoded_security_desc_ = encoded_security_desc;
  } else {
    clear_has_encoded_security_desc();
    encoded_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_security_desc_len = 11;
inline bool Instrument::has_encoded_security_desc_len() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Instrument::set_has_encoded_security_desc_len() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Instrument::clear_has_encoded_security_desc_len() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Instrument::clear_encoded_security_desc_len() {
  encoded_security_desc_len_ = 0u;
  clear_has_encoded_security_desc_len();
}
inline ::google::protobuf::uint32 Instrument::encoded_security_desc_len() const {
  return encoded_security_desc_len_;
}
inline void Instrument::set_encoded_security_desc_len(::google::protobuf::uint32 value) {
  set_has_encoded_security_desc_len();
  encoded_security_desc_len_ = value;
}

// optional double factor = 12;
inline bool Instrument::has_factor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Instrument::set_has_factor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Instrument::clear_has_factor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Instrument::clear_factor() {
  factor_ = 0;
  clear_has_factor();
}
inline double Instrument::factor() const {
  return factor_;
}
inline void Instrument::set_factor(double value) {
  set_has_factor();
  factor_ = value;
}

// optional string instr_registry = 13;
inline bool Instrument::has_instr_registry() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Instrument::set_has_instr_registry() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Instrument::clear_has_instr_registry() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Instrument::clear_instr_registry() {
  if (instr_registry_ != &::google::protobuf::internal::kEmptyString) {
    instr_registry_->clear();
  }
  clear_has_instr_registry();
}
inline const ::std::string& Instrument::instr_registry() const {
  return *instr_registry_;
}
inline void Instrument::set_instr_registry(const ::std::string& value) {
  set_has_instr_registry();
  if (instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    instr_registry_ = new ::std::string;
  }
  instr_registry_->assign(value);
}
inline void Instrument::set_instr_registry(const char* value) {
  set_has_instr_registry();
  if (instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    instr_registry_ = new ::std::string;
  }
  instr_registry_->assign(value);
}
inline void Instrument::set_instr_registry(const char* value, size_t size) {
  set_has_instr_registry();
  if (instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    instr_registry_ = new ::std::string;
  }
  instr_registry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_instr_registry() {
  set_has_instr_registry();
  if (instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    instr_registry_ = new ::std::string;
  }
  return instr_registry_;
}
inline ::std::string* Instrument::release_instr_registry() {
  clear_has_instr_registry();
  if (instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instr_registry_;
    instr_registry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_instr_registry(::std::string* instr_registry) {
  if (instr_registry_ != &::google::protobuf::internal::kEmptyString) {
    delete instr_registry_;
  }
  if (instr_registry) {
    set_has_instr_registry();
    instr_registry_ = instr_registry;
  } else {
    clear_has_instr_registry();
    instr_registry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 issue_date = 14;
inline bool Instrument::has_issue_date() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Instrument::set_has_issue_date() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Instrument::clear_has_issue_date() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Instrument::clear_issue_date() {
  issue_date_ = 0;
  clear_has_issue_date();
}
inline ::google::protobuf::int32 Instrument::issue_date() const {
  return issue_date_;
}
inline void Instrument::set_issue_date(::google::protobuf::int32 value) {
  set_has_issue_date();
  issue_date_ = value;
}

// optional string issuer = 15;
inline bool Instrument::has_issuer() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Instrument::set_has_issuer() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Instrument::clear_has_issuer() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Instrument::clear_issuer() {
  if (issuer_ != &::google::protobuf::internal::kEmptyString) {
    issuer_->clear();
  }
  clear_has_issuer();
}
inline const ::std::string& Instrument::issuer() const {
  return *issuer_;
}
inline void Instrument::set_issuer(const ::std::string& value) {
  set_has_issuer();
  if (issuer_ == &::google::protobuf::internal::kEmptyString) {
    issuer_ = new ::std::string;
  }
  issuer_->assign(value);
}
inline void Instrument::set_issuer(const char* value) {
  set_has_issuer();
  if (issuer_ == &::google::protobuf::internal::kEmptyString) {
    issuer_ = new ::std::string;
  }
  issuer_->assign(value);
}
inline void Instrument::set_issuer(const char* value, size_t size) {
  set_has_issuer();
  if (issuer_ == &::google::protobuf::internal::kEmptyString) {
    issuer_ = new ::std::string;
  }
  issuer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_issuer() {
  set_has_issuer();
  if (issuer_ == &::google::protobuf::internal::kEmptyString) {
    issuer_ = new ::std::string;
  }
  return issuer_;
}
inline ::std::string* Instrument::release_issuer() {
  clear_has_issuer();
  if (issuer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = issuer_;
    issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_issuer(::std::string* issuer) {
  if (issuer_ != &::google::protobuf::internal::kEmptyString) {
    delete issuer_;
  }
  if (issuer) {
    set_has_issuer();
    issuer_ = issuer;
  } else {
    clear_has_issuer();
    issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string locale_of_issue = 16;
inline bool Instrument::has_locale_of_issue() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Instrument::set_has_locale_of_issue() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Instrument::clear_has_locale_of_issue() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Instrument::clear_locale_of_issue() {
  if (locale_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    locale_of_issue_->clear();
  }
  clear_has_locale_of_issue();
}
inline const ::std::string& Instrument::locale_of_issue() const {
  return *locale_of_issue_;
}
inline void Instrument::set_locale_of_issue(const ::std::string& value) {
  set_has_locale_of_issue();
  if (locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    locale_of_issue_ = new ::std::string;
  }
  locale_of_issue_->assign(value);
}
inline void Instrument::set_locale_of_issue(const char* value) {
  set_has_locale_of_issue();
  if (locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    locale_of_issue_ = new ::std::string;
  }
  locale_of_issue_->assign(value);
}
inline void Instrument::set_locale_of_issue(const char* value, size_t size) {
  set_has_locale_of_issue();
  if (locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    locale_of_issue_ = new ::std::string;
  }
  locale_of_issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_locale_of_issue() {
  set_has_locale_of_issue();
  if (locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    locale_of_issue_ = new ::std::string;
  }
  return locale_of_issue_;
}
inline ::std::string* Instrument::release_locale_of_issue() {
  clear_has_locale_of_issue();
  if (locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = locale_of_issue_;
    locale_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_locale_of_issue(::std::string* locale_of_issue) {
  if (locale_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    delete locale_of_issue_;
  }
  if (locale_of_issue) {
    set_has_locale_of_issue();
    locale_of_issue_ = locale_of_issue;
  } else {
    clear_has_locale_of_issue();
    locale_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 maturity_date = 17;
inline bool Instrument::has_maturity_date() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Instrument::set_has_maturity_date() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Instrument::clear_has_maturity_date() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Instrument::clear_maturity_date() {
  maturity_date_ = 0;
  clear_has_maturity_date();
}
inline ::google::protobuf::int32 Instrument::maturity_date() const {
  return maturity_date_;
}
inline void Instrument::set_maturity_date(::google::protobuf::int32 value) {
  set_has_maturity_date();
  maturity_date_ = value;
}

// optional sfixed32 maturity_month_year = 18;
inline bool Instrument::has_maturity_month_year() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Instrument::set_has_maturity_month_year() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Instrument::clear_has_maturity_month_year() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Instrument::clear_maturity_month_year() {
  maturity_month_year_ = 0;
  clear_has_maturity_month_year();
}
inline ::google::protobuf::int32 Instrument::maturity_month_year() const {
  return maturity_month_year_;
}
inline void Instrument::set_maturity_month_year(::google::protobuf::int32 value) {
  set_has_maturity_month_year();
  maturity_month_year_ = value;
}

// optional string opt_attribute = 19;
inline bool Instrument::has_opt_attribute() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Instrument::set_has_opt_attribute() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Instrument::clear_has_opt_attribute() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Instrument::clear_opt_attribute() {
  if (opt_attribute_ != &::google::protobuf::internal::kEmptyString) {
    opt_attribute_->clear();
  }
  clear_has_opt_attribute();
}
inline const ::std::string& Instrument::opt_attribute() const {
  return *opt_attribute_;
}
inline void Instrument::set_opt_attribute(const ::std::string& value) {
  set_has_opt_attribute();
  if (opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    opt_attribute_ = new ::std::string;
  }
  opt_attribute_->assign(value);
}
inline void Instrument::set_opt_attribute(const char* value) {
  set_has_opt_attribute();
  if (opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    opt_attribute_ = new ::std::string;
  }
  opt_attribute_->assign(value);
}
inline void Instrument::set_opt_attribute(const char* value, size_t size) {
  set_has_opt_attribute();
  if (opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    opt_attribute_ = new ::std::string;
  }
  opt_attribute_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_opt_attribute() {
  set_has_opt_attribute();
  if (opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    opt_attribute_ = new ::std::string;
  }
  return opt_attribute_;
}
inline ::std::string* Instrument::release_opt_attribute() {
  clear_has_opt_attribute();
  if (opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = opt_attribute_;
    opt_attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_opt_attribute(::std::string* opt_attribute) {
  if (opt_attribute_ != &::google::protobuf::internal::kEmptyString) {
    delete opt_attribute_;
  }
  if (opt_attribute) {
    set_has_opt_attribute();
    opt_attribute_ = opt_attribute;
  } else {
    clear_has_opt_attribute();
    opt_attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.ProductEnum product = 20;
inline bool Instrument::has_product() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Instrument::set_has_product() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Instrument::clear_has_product() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Instrument::clear_product() {
  product_ = 0;
  clear_has_product();
}
inline ::Common::ProductEnum Instrument::product() const {
  return static_cast< ::Common::ProductEnum >(product_);
}
inline void Instrument::set_product(::Common::ProductEnum value) {
  assert(::Common::ProductEnum_IsValid(value));
  set_has_product();
  product_ = value;
}

// optional sfixed32 redemption_date = 21;
inline bool Instrument::has_redemption_date() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Instrument::set_has_redemption_date() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Instrument::clear_has_redemption_date() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Instrument::clear_redemption_date() {
  redemption_date_ = 0;
  clear_has_redemption_date();
}
inline ::google::protobuf::int32 Instrument::redemption_date() const {
  return redemption_date_;
}
inline void Instrument::set_redemption_date(::google::protobuf::int32 value) {
  set_has_redemption_date();
  redemption_date_ = value;
}

// optional string repo_collateral_security_type = 22;
inline bool Instrument::has_repo_collateral_security_type() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Instrument::set_has_repo_collateral_security_type() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Instrument::clear_has_repo_collateral_security_type() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Instrument::clear_repo_collateral_security_type() {
  if (repo_collateral_security_type_ != &::google::protobuf::internal::kEmptyString) {
    repo_collateral_security_type_->clear();
  }
  clear_has_repo_collateral_security_type();
}
inline const ::std::string& Instrument::repo_collateral_security_type() const {
  return *repo_collateral_security_type_;
}
inline void Instrument::set_repo_collateral_security_type(const ::std::string& value) {
  set_has_repo_collateral_security_type();
  if (repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    repo_collateral_security_type_ = new ::std::string;
  }
  repo_collateral_security_type_->assign(value);
}
inline void Instrument::set_repo_collateral_security_type(const char* value) {
  set_has_repo_collateral_security_type();
  if (repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    repo_collateral_security_type_ = new ::std::string;
  }
  repo_collateral_security_type_->assign(value);
}
inline void Instrument::set_repo_collateral_security_type(const char* value, size_t size) {
  set_has_repo_collateral_security_type();
  if (repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    repo_collateral_security_type_ = new ::std::string;
  }
  repo_collateral_security_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_repo_collateral_security_type() {
  set_has_repo_collateral_security_type();
  if (repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    repo_collateral_security_type_ = new ::std::string;
  }
  return repo_collateral_security_type_;
}
inline ::std::string* Instrument::release_repo_collateral_security_type() {
  clear_has_repo_collateral_security_type();
  if (repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = repo_collateral_security_type_;
    repo_collateral_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_repo_collateral_security_type(::std::string* repo_collateral_security_type) {
  if (repo_collateral_security_type_ != &::google::protobuf::internal::kEmptyString) {
    delete repo_collateral_security_type_;
  }
  if (repo_collateral_security_type) {
    set_has_repo_collateral_security_type();
    repo_collateral_security_type_ = repo_collateral_security_type;
  } else {
    clear_has_repo_collateral_security_type();
    repo_collateral_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 repurchase_rate = 23;
inline bool Instrument::has_repurchase_rate() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Instrument::set_has_repurchase_rate() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Instrument::clear_has_repurchase_rate() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Instrument::clear_repurchase_rate() {
  repurchase_rate_ = GOOGLE_LONGLONG(0);
  clear_has_repurchase_rate();
}
inline ::google::protobuf::int64 Instrument::repurchase_rate() const {
  return repurchase_rate_;
}
inline void Instrument::set_repurchase_rate(::google::protobuf::int64 value) {
  set_has_repurchase_rate();
  repurchase_rate_ = value;
}

// optional sfixed32 repurchase_rate_exponent = 24;
inline bool Instrument::has_repurchase_rate_exponent() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Instrument::set_has_repurchase_rate_exponent() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Instrument::clear_has_repurchase_rate_exponent() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Instrument::clear_repurchase_rate_exponent() {
  repurchase_rate_exponent_ = 0;
  clear_has_repurchase_rate_exponent();
}
inline ::google::protobuf::int32 Instrument::repurchase_rate_exponent() const {
  return repurchase_rate_exponent_;
}
inline void Instrument::set_repurchase_rate_exponent(::google::protobuf::int32 value) {
  set_has_repurchase_rate_exponent();
  repurchase_rate_exponent_ = value;
}

// optional sfixed64 repurchase_term = 25;
inline bool Instrument::has_repurchase_term() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Instrument::set_has_repurchase_term() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Instrument::clear_has_repurchase_term() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Instrument::clear_repurchase_term() {
  repurchase_term_ = GOOGLE_LONGLONG(0);
  clear_has_repurchase_term();
}
inline ::google::protobuf::int64 Instrument::repurchase_term() const {
  return repurchase_term_;
}
inline void Instrument::set_repurchase_term(::google::protobuf::int64 value) {
  set_has_repurchase_term();
  repurchase_term_ = value;
}

// optional string security_desc = 26;
inline bool Instrument::has_security_desc() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void Instrument::set_has_security_desc() {
  _has_bits_[0] |= 0x02000000u;
}
inline void Instrument::clear_has_security_desc() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void Instrument::clear_security_desc() {
  if (security_desc_ != &::google::protobuf::internal::kEmptyString) {
    security_desc_->clear();
  }
  clear_has_security_desc();
}
inline const ::std::string& Instrument::security_desc() const {
  return *security_desc_;
}
inline void Instrument::set_security_desc(const ::std::string& value) {
  set_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_desc_ = new ::std::string;
  }
  security_desc_->assign(value);
}
inline void Instrument::set_security_desc(const char* value) {
  set_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_desc_ = new ::std::string;
  }
  security_desc_->assign(value);
}
inline void Instrument::set_security_desc(const char* value, size_t size) {
  set_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_desc_ = new ::std::string;
  }
  security_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_security_desc() {
  set_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_desc_ = new ::std::string;
  }
  return security_desc_;
}
inline ::std::string* Instrument::release_security_desc() {
  clear_has_security_desc();
  if (security_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_desc_;
    security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_security_desc(::std::string* security_desc) {
  if (security_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete security_desc_;
  }
  if (security_desc) {
    set_has_security_desc();
    security_desc_ = security_desc;
  } else {
    clear_has_security_desc();
    security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_exchange = 27;
inline bool Instrument::has_security_exchange() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void Instrument::set_has_security_exchange() {
  _has_bits_[0] |= 0x04000000u;
}
inline void Instrument::clear_has_security_exchange() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void Instrument::clear_security_exchange() {
  if (security_exchange_ != &::google::protobuf::internal::kEmptyString) {
    security_exchange_->clear();
  }
  clear_has_security_exchange();
}
inline const ::std::string& Instrument::security_exchange() const {
  return *security_exchange_;
}
inline void Instrument::set_security_exchange(const ::std::string& value) {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  security_exchange_->assign(value);
}
inline void Instrument::set_security_exchange(const char* value) {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  security_exchange_->assign(value);
}
inline void Instrument::set_security_exchange(const char* value, size_t size) {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  security_exchange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_security_exchange() {
  set_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    security_exchange_ = new ::std::string;
  }
  return security_exchange_;
}
inline ::std::string* Instrument::release_security_exchange() {
  clear_has_security_exchange();
  if (security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_exchange_;
    security_exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_security_exchange(::std::string* security_exchange) {
  if (security_exchange_ != &::google::protobuf::internal::kEmptyString) {
    delete security_exchange_;
  }
  if (security_exchange) {
    set_has_security_exchange();
    security_exchange_ = security_exchange;
  } else {
    clear_has_security_exchange();
    security_exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_id = 28;
inline bool Instrument::has_security_id() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void Instrument::set_has_security_id() {
  _has_bits_[0] |= 0x08000000u;
}
inline void Instrument::clear_has_security_id() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void Instrument::clear_security_id() {
  if (security_id_ != &::google::protobuf::internal::kEmptyString) {
    security_id_->clear();
  }
  clear_has_security_id();
}
inline const ::std::string& Instrument::security_id() const {
  return *security_id_;
}
inline void Instrument::set_security_id(const ::std::string& value) {
  set_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    security_id_ = new ::std::string;
  }
  security_id_->assign(value);
}
inline void Instrument::set_security_id(const char* value) {
  set_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    security_id_ = new ::std::string;
  }
  security_id_->assign(value);
}
inline void Instrument::set_security_id(const char* value, size_t size) {
  set_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    security_id_ = new ::std::string;
  }
  security_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_security_id() {
  set_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    security_id_ = new ::std::string;
  }
  return security_id_;
}
inline ::std::string* Instrument::release_security_id() {
  clear_has_security_id();
  if (security_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_id_;
    security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_security_id(::std::string* security_id) {
  if (security_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_id_;
  }
  if (security_id) {
    set_has_security_id();
    security_id_ = security_id;
  } else {
    clear_has_security_id();
    security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.SecurityIdSourceEnum security_id_source = 29;
inline bool Instrument::has_security_id_source() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void Instrument::set_has_security_id_source() {
  _has_bits_[0] |= 0x10000000u;
}
inline void Instrument::clear_has_security_id_source() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void Instrument::clear_security_id_source() {
  security_id_source_ = 0;
  clear_has_security_id_source();
}
inline ::Common::SecurityIdSourceEnum Instrument::security_id_source() const {
  return static_cast< ::Common::SecurityIdSourceEnum >(security_id_source_);
}
inline void Instrument::set_security_id_source(::Common::SecurityIdSourceEnum value) {
  assert(::Common::SecurityIdSourceEnum_IsValid(value));
  set_has_security_id_source();
  security_id_source_ = value;
}

// optional .Common.SecurityTypeEnum security_type = 30;
inline bool Instrument::has_security_type() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void Instrument::set_has_security_type() {
  _has_bits_[0] |= 0x20000000u;
}
inline void Instrument::clear_has_security_type() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void Instrument::clear_security_type() {
  security_type_ = 0;
  clear_has_security_type();
}
inline ::Common::SecurityTypeEnum Instrument::security_type() const {
  return static_cast< ::Common::SecurityTypeEnum >(security_type_);
}
inline void Instrument::set_security_type(::Common::SecurityTypeEnum value) {
  assert(::Common::SecurityTypeEnum_IsValid(value));
  set_has_security_type();
  security_type_ = value;
}

// optional string state_or_province_of_issue = 31;
inline bool Instrument::has_state_or_province_of_issue() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void Instrument::set_has_state_or_province_of_issue() {
  _has_bits_[0] |= 0x40000000u;
}
inline void Instrument::clear_has_state_or_province_of_issue() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void Instrument::clear_state_or_province_of_issue() {
  if (state_or_province_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    state_or_province_of_issue_->clear();
  }
  clear_has_state_or_province_of_issue();
}
inline const ::std::string& Instrument::state_or_province_of_issue() const {
  return *state_or_province_of_issue_;
}
inline void Instrument::set_state_or_province_of_issue(const ::std::string& value) {
  set_has_state_or_province_of_issue();
  if (state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    state_or_province_of_issue_ = new ::std::string;
  }
  state_or_province_of_issue_->assign(value);
}
inline void Instrument::set_state_or_province_of_issue(const char* value) {
  set_has_state_or_province_of_issue();
  if (state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    state_or_province_of_issue_ = new ::std::string;
  }
  state_or_province_of_issue_->assign(value);
}
inline void Instrument::set_state_or_province_of_issue(const char* value, size_t size) {
  set_has_state_or_province_of_issue();
  if (state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    state_or_province_of_issue_ = new ::std::string;
  }
  state_or_province_of_issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_state_or_province_of_issue() {
  set_has_state_or_province_of_issue();
  if (state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    state_or_province_of_issue_ = new ::std::string;
  }
  return state_or_province_of_issue_;
}
inline ::std::string* Instrument::release_state_or_province_of_issue() {
  clear_has_state_or_province_of_issue();
  if (state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = state_or_province_of_issue_;
    state_or_province_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_state_or_province_of_issue(::std::string* state_or_province_of_issue) {
  if (state_or_province_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    delete state_or_province_of_issue_;
  }
  if (state_or_province_of_issue) {
    set_has_state_or_province_of_issue();
    state_or_province_of_issue_ = state_or_province_of_issue;
  } else {
    clear_has_state_or_province_of_issue();
    state_or_province_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 strike_price = 32;
inline bool Instrument::has_strike_price() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void Instrument::set_has_strike_price() {
  _has_bits_[0] |= 0x80000000u;
}
inline void Instrument::clear_has_strike_price() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void Instrument::clear_strike_price() {
  strike_price_ = GOOGLE_LONGLONG(0);
  clear_has_strike_price();
}
inline ::google::protobuf::int64 Instrument::strike_price() const {
  return strike_price_;
}
inline void Instrument::set_strike_price(::google::protobuf::int64 value) {
  set_has_strike_price();
  strike_price_ = value;
}

// optional sfixed32 strike_price_exponent = 33;
inline bool Instrument::has_strike_price_exponent() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void Instrument::set_has_strike_price_exponent() {
  _has_bits_[1] |= 0x00000001u;
}
inline void Instrument::clear_has_strike_price_exponent() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void Instrument::clear_strike_price_exponent() {
  strike_price_exponent_ = 0;
  clear_has_strike_price_exponent();
}
inline ::google::protobuf::int32 Instrument::strike_price_exponent() const {
  return strike_price_exponent_;
}
inline void Instrument::set_strike_price_exponent(::google::protobuf::int32 value) {
  set_has_strike_price_exponent();
  strike_price_exponent_ = value;
}

// optional string symbol = 34;
inline bool Instrument::has_symbol() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void Instrument::set_has_symbol() {
  _has_bits_[1] |= 0x00000002u;
}
inline void Instrument::clear_has_symbol() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void Instrument::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& Instrument::symbol() const {
  return *symbol_;
}
inline void Instrument::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void Instrument::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
}
inline void Instrument::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    symbol_ = new ::std::string;
  }
  return symbol_;
}
inline ::std::string* Instrument::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.SymbolSfxEnum symbol_sfx = 35;
inline bool Instrument::has_symbol_sfx() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void Instrument::set_has_symbol_sfx() {
  _has_bits_[1] |= 0x00000004u;
}
inline void Instrument::clear_has_symbol_sfx() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void Instrument::clear_symbol_sfx() {
  symbol_sfx_ = 0;
  clear_has_symbol_sfx();
}
inline ::Common::SymbolSfxEnum Instrument::symbol_sfx() const {
  return static_cast< ::Common::SymbolSfxEnum >(symbol_sfx_);
}
inline void Instrument::set_symbol_sfx(::Common::SymbolSfxEnum value) {
  assert(::Common::SymbolSfxEnum_IsValid(value));
  set_has_symbol_sfx();
  symbol_sfx_ = value;
}

// optional .Common.CpProgramEnum cp_program = 36;
inline bool Instrument::has_cp_program() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void Instrument::set_has_cp_program() {
  _has_bits_[1] |= 0x00000008u;
}
inline void Instrument::clear_has_cp_program() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void Instrument::clear_cp_program() {
  cp_program_ = 0;
  clear_has_cp_program();
}
inline ::Common::CpProgramEnum Instrument::cp_program() const {
  return static_cast< ::Common::CpProgramEnum >(cp_program_);
}
inline void Instrument::set_cp_program(::Common::CpProgramEnum value) {
  assert(::Common::CpProgramEnum_IsValid(value));
  set_has_cp_program();
  cp_program_ = value;
}

// optional string cp_reg_type = 37;
inline bool Instrument::has_cp_reg_type() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void Instrument::set_has_cp_reg_type() {
  _has_bits_[1] |= 0x00000010u;
}
inline void Instrument::clear_has_cp_reg_type() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void Instrument::clear_cp_reg_type() {
  if (cp_reg_type_ != &::google::protobuf::internal::kEmptyString) {
    cp_reg_type_->clear();
  }
  clear_has_cp_reg_type();
}
inline const ::std::string& Instrument::cp_reg_type() const {
  return *cp_reg_type_;
}
inline void Instrument::set_cp_reg_type(const ::std::string& value) {
  set_has_cp_reg_type();
  if (cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    cp_reg_type_ = new ::std::string;
  }
  cp_reg_type_->assign(value);
}
inline void Instrument::set_cp_reg_type(const char* value) {
  set_has_cp_reg_type();
  if (cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    cp_reg_type_ = new ::std::string;
  }
  cp_reg_type_->assign(value);
}
inline void Instrument::set_cp_reg_type(const char* value, size_t size) {
  set_has_cp_reg_type();
  if (cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    cp_reg_type_ = new ::std::string;
  }
  cp_reg_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_cp_reg_type() {
  set_has_cp_reg_type();
  if (cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    cp_reg_type_ = new ::std::string;
  }
  return cp_reg_type_;
}
inline ::std::string* Instrument::release_cp_reg_type() {
  clear_has_cp_reg_type();
  if (cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cp_reg_type_;
    cp_reg_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_cp_reg_type(::std::string* cp_reg_type) {
  if (cp_reg_type_ != &::google::protobuf::internal::kEmptyString) {
    delete cp_reg_type_;
  }
  if (cp_reg_type) {
    set_has_cp_reg_type();
    cp_reg_type_ = cp_reg_type;
  } else {
    clear_has_cp_reg_type();
    cp_reg_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 contract_settl_month = 38;
inline bool Instrument::has_contract_settl_month() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void Instrument::set_has_contract_settl_month() {
  _has_bits_[1] |= 0x00000020u;
}
inline void Instrument::clear_has_contract_settl_month() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void Instrument::clear_contract_settl_month() {
  contract_settl_month_ = 0;
  clear_has_contract_settl_month();
}
inline ::google::protobuf::int32 Instrument::contract_settl_month() const {
  return contract_settl_month_;
}
inline void Instrument::set_contract_settl_month(::google::protobuf::int32 value) {
  set_has_contract_settl_month();
  contract_settl_month_ = value;
}

// optional sfixed32 dated_date = 39;
inline bool Instrument::has_dated_date() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void Instrument::set_has_dated_date() {
  _has_bits_[1] |= 0x00000040u;
}
inline void Instrument::clear_has_dated_date() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void Instrument::clear_dated_date() {
  dated_date_ = 0;
  clear_has_dated_date();
}
inline ::google::protobuf::int32 Instrument::dated_date() const {
  return dated_date_;
}
inline void Instrument::set_dated_date(::google::protobuf::int32 value) {
  set_has_dated_date();
  dated_date_ = value;
}

// repeated .Common.EvntGrp evnt_grp = 40;
inline int Instrument::evnt_grp_size() const {
  return evnt_grp_.size();
}
inline void Instrument::clear_evnt_grp() {
  evnt_grp_.Clear();
}
inline const ::Common::EvntGrp& Instrument::evnt_grp(int index) const {
  return evnt_grp_.Get(index);
}
inline ::Common::EvntGrp* Instrument::mutable_evnt_grp(int index) {
  return evnt_grp_.Mutable(index);
}
inline ::Common::EvntGrp* Instrument::add_evnt_grp() {
  return evnt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::EvntGrp >&
Instrument::evnt_grp() const {
  return evnt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::EvntGrp >*
Instrument::mutable_evnt_grp() {
  return &evnt_grp_;
}

// optional string instrmt_assignment_method = 41;
inline bool Instrument::has_instrmt_assignment_method() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void Instrument::set_has_instrmt_assignment_method() {
  _has_bits_[1] |= 0x00000100u;
}
inline void Instrument::clear_has_instrmt_assignment_method() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void Instrument::clear_instrmt_assignment_method() {
  if (instrmt_assignment_method_ != &::google::protobuf::internal::kEmptyString) {
    instrmt_assignment_method_->clear();
  }
  clear_has_instrmt_assignment_method();
}
inline const ::std::string& Instrument::instrmt_assignment_method() const {
  return *instrmt_assignment_method_;
}
inline void Instrument::set_instrmt_assignment_method(const ::std::string& value) {
  set_has_instrmt_assignment_method();
  if (instrmt_assignment_method_ == &::google::protobuf::internal::kEmptyString) {
    instrmt_assignment_method_ = new ::std::string;
  }
  instrmt_assignment_method_->assign(value);
}
inline void Instrument::set_instrmt_assignment_method(const char* value) {
  set_has_instrmt_assignment_method();
  if (instrmt_assignment_method_ == &::google::protobuf::internal::kEmptyString) {
    instrmt_assignment_method_ = new ::std::string;
  }
  instrmt_assignment_method_->assign(value);
}
inline void Instrument::set_instrmt_assignment_method(const char* value, size_t size) {
  set_has_instrmt_assignment_method();
  if (instrmt_assignment_method_ == &::google::protobuf::internal::kEmptyString) {
    instrmt_assignment_method_ = new ::std::string;
  }
  instrmt_assignment_method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_instrmt_assignment_method() {
  set_has_instrmt_assignment_method();
  if (instrmt_assignment_method_ == &::google::protobuf::internal::kEmptyString) {
    instrmt_assignment_method_ = new ::std::string;
  }
  return instrmt_assignment_method_;
}
inline ::std::string* Instrument::release_instrmt_assignment_method() {
  clear_has_instrmt_assignment_method();
  if (instrmt_assignment_method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instrmt_assignment_method_;
    instrmt_assignment_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_instrmt_assignment_method(::std::string* instrmt_assignment_method) {
  if (instrmt_assignment_method_ != &::google::protobuf::internal::kEmptyString) {
    delete instrmt_assignment_method_;
  }
  if (instrmt_assignment_method) {
    set_has_instrmt_assignment_method();
    instrmt_assignment_method_ = instrmt_assignment_method;
  } else {
    clear_has_instrmt_assignment_method();
    instrmt_assignment_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.InstrumentParties instrument_parties = 42;
inline int Instrument::instrument_parties_size() const {
  return instrument_parties_.size();
}
inline void Instrument::clear_instrument_parties() {
  instrument_parties_.Clear();
}
inline const ::Common::InstrumentParties& Instrument::instrument_parties(int index) const {
  return instrument_parties_.Get(index);
}
inline ::Common::InstrumentParties* Instrument::mutable_instrument_parties(int index) {
  return instrument_parties_.Mutable(index);
}
inline ::Common::InstrumentParties* Instrument::add_instrument_parties() {
  return instrument_parties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrumentParties >&
Instrument::instrument_parties() const {
  return instrument_parties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrumentParties >*
Instrument::mutable_instrument_parties() {
  return &instrument_parties_;
}

// optional sfixed32 interest_accrual_date = 43;
inline bool Instrument::has_interest_accrual_date() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void Instrument::set_has_interest_accrual_date() {
  _has_bits_[1] |= 0x00000400u;
}
inline void Instrument::clear_has_interest_accrual_date() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void Instrument::clear_interest_accrual_date() {
  interest_accrual_date_ = 0;
  clear_has_interest_accrual_date();
}
inline ::google::protobuf::int32 Instrument::interest_accrual_date() const {
  return interest_accrual_date_;
}
inline void Instrument::set_interest_accrual_date(::google::protobuf::int32 value) {
  set_has_interest_accrual_date();
  interest_accrual_date_ = value;
}

// optional string maturity_time = 44;
inline bool Instrument::has_maturity_time() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void Instrument::set_has_maturity_time() {
  _has_bits_[1] |= 0x00000800u;
}
inline void Instrument::clear_has_maturity_time() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void Instrument::clear_maturity_time() {
  if (maturity_time_ != &::google::protobuf::internal::kEmptyString) {
    maturity_time_->clear();
  }
  clear_has_maturity_time();
}
inline const ::std::string& Instrument::maturity_time() const {
  return *maturity_time_;
}
inline void Instrument::set_maturity_time(const ::std::string& value) {
  set_has_maturity_time();
  if (maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    maturity_time_ = new ::std::string;
  }
  maturity_time_->assign(value);
}
inline void Instrument::set_maturity_time(const char* value) {
  set_has_maturity_time();
  if (maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    maturity_time_ = new ::std::string;
  }
  maturity_time_->assign(value);
}
inline void Instrument::set_maturity_time(const char* value, size_t size) {
  set_has_maturity_time();
  if (maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    maturity_time_ = new ::std::string;
  }
  maturity_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_maturity_time() {
  set_has_maturity_time();
  if (maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    maturity_time_ = new ::std::string;
  }
  return maturity_time_;
}
inline ::std::string* Instrument::release_maturity_time() {
  clear_has_maturity_time();
  if (maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = maturity_time_;
    maturity_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_maturity_time(::std::string* maturity_time) {
  if (maturity_time_ != &::google::protobuf::internal::kEmptyString) {
    delete maturity_time_;
  }
  if (maturity_time) {
    set_has_maturity_time();
    maturity_time_ = maturity_time;
  } else {
    clear_has_maturity_time();
    maturity_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double min_price_increment = 45;
inline bool Instrument::has_min_price_increment() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void Instrument::set_has_min_price_increment() {
  _has_bits_[1] |= 0x00001000u;
}
inline void Instrument::clear_has_min_price_increment() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void Instrument::clear_min_price_increment() {
  min_price_increment_ = 0;
  clear_has_min_price_increment();
}
inline double Instrument::min_price_increment() const {
  return min_price_increment_;
}
inline void Instrument::set_min_price_increment(double value) {
  set_has_min_price_increment();
  min_price_increment_ = value;
}

// optional sfixed64 nt_position_limit = 46;
inline bool Instrument::has_nt_position_limit() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void Instrument::set_has_nt_position_limit() {
  _has_bits_[1] |= 0x00002000u;
}
inline void Instrument::clear_has_nt_position_limit() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void Instrument::clear_nt_position_limit() {
  nt_position_limit_ = GOOGLE_LONGLONG(0);
  clear_has_nt_position_limit();
}
inline ::google::protobuf::int64 Instrument::nt_position_limit() const {
  return nt_position_limit_;
}
inline void Instrument::set_nt_position_limit(::google::protobuf::int64 value) {
  set_has_nt_position_limit();
  nt_position_limit_ = value;
}

// optional string pool = 47;
inline bool Instrument::has_pool() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void Instrument::set_has_pool() {
  _has_bits_[1] |= 0x00004000u;
}
inline void Instrument::clear_has_pool() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void Instrument::clear_pool() {
  if (pool_ != &::google::protobuf::internal::kEmptyString) {
    pool_->clear();
  }
  clear_has_pool();
}
inline const ::std::string& Instrument::pool() const {
  return *pool_;
}
inline void Instrument::set_pool(const ::std::string& value) {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void Instrument::set_pool(const char* value) {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void Instrument::set_pool(const char* value, size_t size) {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_pool() {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  return pool_;
}
inline ::std::string* Instrument::release_pool() {
  clear_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pool_;
    pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_pool(::std::string* pool) {
  if (pool_ != &::google::protobuf::internal::kEmptyString) {
    delete pool_;
  }
  if (pool) {
    set_has_pool();
    pool_ = pool;
  } else {
    clear_has_pool();
    pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 position_limit = 48;
inline bool Instrument::has_position_limit() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void Instrument::set_has_position_limit() {
  _has_bits_[1] |= 0x00008000u;
}
inline void Instrument::clear_has_position_limit() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void Instrument::clear_position_limit() {
  position_limit_ = GOOGLE_LONGLONG(0);
  clear_has_position_limit();
}
inline ::google::protobuf::int64 Instrument::position_limit() const {
  return position_limit_;
}
inline void Instrument::set_position_limit(::google::protobuf::int64 value) {
  set_has_position_limit();
  position_limit_ = value;
}

// optional .Common.PutOrCallEnum put_or_call = 49;
inline bool Instrument::has_put_or_call() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void Instrument::set_has_put_or_call() {
  _has_bits_[1] |= 0x00010000u;
}
inline void Instrument::clear_has_put_or_call() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void Instrument::clear_put_or_call() {
  put_or_call_ = 0;
  clear_has_put_or_call();
}
inline ::Common::PutOrCallEnum Instrument::put_or_call() const {
  return static_cast< ::Common::PutOrCallEnum >(put_or_call_);
}
inline void Instrument::set_put_or_call(::Common::PutOrCallEnum value) {
  assert(::Common::PutOrCallEnum_IsValid(value));
  set_has_put_or_call();
  put_or_call_ = value;
}

// repeated .Common.SecAltIdGrp sec_alt_id_grp = 50;
inline int Instrument::sec_alt_id_grp_size() const {
  return sec_alt_id_grp_.size();
}
inline void Instrument::clear_sec_alt_id_grp() {
  sec_alt_id_grp_.Clear();
}
inline const ::Common::SecAltIdGrp& Instrument::sec_alt_id_grp(int index) const {
  return sec_alt_id_grp_.Get(index);
}
inline ::Common::SecAltIdGrp* Instrument::mutable_sec_alt_id_grp(int index) {
  return sec_alt_id_grp_.Mutable(index);
}
inline ::Common::SecAltIdGrp* Instrument::add_sec_alt_id_grp() {
  return sec_alt_id_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::SecAltIdGrp >&
Instrument::sec_alt_id_grp() const {
  return sec_alt_id_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::SecAltIdGrp >*
Instrument::mutable_sec_alt_id_grp() {
  return &sec_alt_id_grp_;
}

// optional .Common.SecurityStatusEnum security_status = 51;
inline bool Instrument::has_security_status() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void Instrument::set_has_security_status() {
  _has_bits_[1] |= 0x00040000u;
}
inline void Instrument::clear_has_security_status() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void Instrument::clear_security_status() {
  security_status_ = 0;
  clear_has_security_status();
}
inline ::Common::SecurityStatusEnum Instrument::security_status() const {
  return static_cast< ::Common::SecurityStatusEnum >(security_status_);
}
inline void Instrument::set_security_status(::Common::SecurityStatusEnum value) {
  assert(::Common::SecurityStatusEnum_IsValid(value));
  set_has_security_status();
  security_status_ = value;
}

// optional string security_sub_type = 52;
inline bool Instrument::has_security_sub_type() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void Instrument::set_has_security_sub_type() {
  _has_bits_[1] |= 0x00080000u;
}
inline void Instrument::clear_has_security_sub_type() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void Instrument::clear_security_sub_type() {
  if (security_sub_type_ != &::google::protobuf::internal::kEmptyString) {
    security_sub_type_->clear();
  }
  clear_has_security_sub_type();
}
inline const ::std::string& Instrument::security_sub_type() const {
  return *security_sub_type_;
}
inline void Instrument::set_security_sub_type(const ::std::string& value) {
  set_has_security_sub_type();
  if (security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    security_sub_type_ = new ::std::string;
  }
  security_sub_type_->assign(value);
}
inline void Instrument::set_security_sub_type(const char* value) {
  set_has_security_sub_type();
  if (security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    security_sub_type_ = new ::std::string;
  }
  security_sub_type_->assign(value);
}
inline void Instrument::set_security_sub_type(const char* value, size_t size) {
  set_has_security_sub_type();
  if (security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    security_sub_type_ = new ::std::string;
  }
  security_sub_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_security_sub_type() {
  set_has_security_sub_type();
  if (security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    security_sub_type_ = new ::std::string;
  }
  return security_sub_type_;
}
inline ::std::string* Instrument::release_security_sub_type() {
  clear_has_security_sub_type();
  if (security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_sub_type_;
    security_sub_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_security_sub_type(::std::string* security_sub_type) {
  if (security_sub_type_ != &::google::protobuf::internal::kEmptyString) {
    delete security_sub_type_;
  }
  if (security_sub_type) {
    set_has_security_sub_type();
    security_sub_type_ = security_sub_type;
  } else {
    clear_has_security_sub_type();
    security_sub_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string settle_on_open_flag = 53;
inline bool Instrument::has_settle_on_open_flag() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void Instrument::set_has_settle_on_open_flag() {
  _has_bits_[1] |= 0x00100000u;
}
inline void Instrument::clear_has_settle_on_open_flag() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void Instrument::clear_settle_on_open_flag() {
  if (settle_on_open_flag_ != &::google::protobuf::internal::kEmptyString) {
    settle_on_open_flag_->clear();
  }
  clear_has_settle_on_open_flag();
}
inline const ::std::string& Instrument::settle_on_open_flag() const {
  return *settle_on_open_flag_;
}
inline void Instrument::set_settle_on_open_flag(const ::std::string& value) {
  set_has_settle_on_open_flag();
  if (settle_on_open_flag_ == &::google::protobuf::internal::kEmptyString) {
    settle_on_open_flag_ = new ::std::string;
  }
  settle_on_open_flag_->assign(value);
}
inline void Instrument::set_settle_on_open_flag(const char* value) {
  set_has_settle_on_open_flag();
  if (settle_on_open_flag_ == &::google::protobuf::internal::kEmptyString) {
    settle_on_open_flag_ = new ::std::string;
  }
  settle_on_open_flag_->assign(value);
}
inline void Instrument::set_settle_on_open_flag(const char* value, size_t size) {
  set_has_settle_on_open_flag();
  if (settle_on_open_flag_ == &::google::protobuf::internal::kEmptyString) {
    settle_on_open_flag_ = new ::std::string;
  }
  settle_on_open_flag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_settle_on_open_flag() {
  set_has_settle_on_open_flag();
  if (settle_on_open_flag_ == &::google::protobuf::internal::kEmptyString) {
    settle_on_open_flag_ = new ::std::string;
  }
  return settle_on_open_flag_;
}
inline ::std::string* Instrument::release_settle_on_open_flag() {
  clear_has_settle_on_open_flag();
  if (settle_on_open_flag_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = settle_on_open_flag_;
    settle_on_open_flag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_settle_on_open_flag(::std::string* settle_on_open_flag) {
  if (settle_on_open_flag_ != &::google::protobuf::internal::kEmptyString) {
    delete settle_on_open_flag_;
  }
  if (settle_on_open_flag) {
    set_has_settle_on_open_flag();
    settle_on_open_flag_ = settle_on_open_flag;
  } else {
    clear_has_settle_on_open_flag();
    settle_on_open_flag_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string strike_currency = 54;
inline bool Instrument::has_strike_currency() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void Instrument::set_has_strike_currency() {
  _has_bits_[1] |= 0x00200000u;
}
inline void Instrument::clear_has_strike_currency() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void Instrument::clear_strike_currency() {
  if (strike_currency_ != &::google::protobuf::internal::kEmptyString) {
    strike_currency_->clear();
  }
  clear_has_strike_currency();
}
inline const ::std::string& Instrument::strike_currency() const {
  return *strike_currency_;
}
inline void Instrument::set_strike_currency(const ::std::string& value) {
  set_has_strike_currency();
  if (strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    strike_currency_ = new ::std::string;
  }
  strike_currency_->assign(value);
}
inline void Instrument::set_strike_currency(const char* value) {
  set_has_strike_currency();
  if (strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    strike_currency_ = new ::std::string;
  }
  strike_currency_->assign(value);
}
inline void Instrument::set_strike_currency(const char* value, size_t size) {
  set_has_strike_currency();
  if (strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    strike_currency_ = new ::std::string;
  }
  strike_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_strike_currency() {
  set_has_strike_currency();
  if (strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    strike_currency_ = new ::std::string;
  }
  return strike_currency_;
}
inline ::std::string* Instrument::release_strike_currency() {
  clear_has_strike_currency();
  if (strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strike_currency_;
    strike_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_strike_currency(::std::string* strike_currency) {
  if (strike_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete strike_currency_;
  }
  if (strike_currency) {
    set_has_strike_currency();
    strike_currency_ = strike_currency;
  } else {
    clear_has_strike_currency();
    strike_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double strike_multiplier = 55;
inline bool Instrument::has_strike_multiplier() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void Instrument::set_has_strike_multiplier() {
  _has_bits_[1] |= 0x00400000u;
}
inline void Instrument::clear_has_strike_multiplier() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void Instrument::clear_strike_multiplier() {
  strike_multiplier_ = 0;
  clear_has_strike_multiplier();
}
inline double Instrument::strike_multiplier() const {
  return strike_multiplier_;
}
inline void Instrument::set_strike_multiplier(double value) {
  set_has_strike_multiplier();
  strike_multiplier_ = value;
}

// optional double strike_value = 56;
inline bool Instrument::has_strike_value() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void Instrument::set_has_strike_value() {
  _has_bits_[1] |= 0x00800000u;
}
inline void Instrument::clear_has_strike_value() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void Instrument::clear_strike_value() {
  strike_value_ = 0;
  clear_has_strike_value();
}
inline double Instrument::strike_value() const {
  return strike_value_;
}
inline void Instrument::set_strike_value(double value) {
  set_has_strike_value();
  strike_value_ = value;
}

// optional .Common.TimeUnitEnum time_unit = 57;
inline bool Instrument::has_time_unit() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void Instrument::set_has_time_unit() {
  _has_bits_[1] |= 0x01000000u;
}
inline void Instrument::clear_has_time_unit() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void Instrument::clear_time_unit() {
  time_unit_ = 0;
  clear_has_time_unit();
}
inline ::Common::TimeUnitEnum Instrument::time_unit() const {
  return static_cast< ::Common::TimeUnitEnum >(time_unit_);
}
inline void Instrument::set_time_unit(::Common::TimeUnitEnum value) {
  assert(::Common::TimeUnitEnum_IsValid(value));
  set_has_time_unit();
  time_unit_ = value;
}

// optional .Common.UnitOfMeasureEnum unit_of_measure = 58;
inline bool Instrument::has_unit_of_measure() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void Instrument::set_has_unit_of_measure() {
  _has_bits_[1] |= 0x02000000u;
}
inline void Instrument::clear_has_unit_of_measure() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void Instrument::clear_unit_of_measure() {
  unit_of_measure_ = 0;
  clear_has_unit_of_measure();
}
inline ::Common::UnitOfMeasureEnum Instrument::unit_of_measure() const {
  return static_cast< ::Common::UnitOfMeasureEnum >(unit_of_measure_);
}
inline void Instrument::set_unit_of_measure(::Common::UnitOfMeasureEnum value) {
  assert(::Common::UnitOfMeasureEnum_IsValid(value));
  set_has_unit_of_measure();
  unit_of_measure_ = value;
}

// optional sfixed64 cap_price = 59;
inline bool Instrument::has_cap_price() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void Instrument::set_has_cap_price() {
  _has_bits_[1] |= 0x04000000u;
}
inline void Instrument::clear_has_cap_price() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void Instrument::clear_cap_price() {
  cap_price_ = GOOGLE_LONGLONG(0);
  clear_has_cap_price();
}
inline ::google::protobuf::int64 Instrument::cap_price() const {
  return cap_price_;
}
inline void Instrument::set_cap_price(::google::protobuf::int64 value) {
  set_has_cap_price();
  cap_price_ = value;
}

// optional sfixed32 cap_price_exponent = 60;
inline bool Instrument::has_cap_price_exponent() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void Instrument::set_has_cap_price_exponent() {
  _has_bits_[1] |= 0x08000000u;
}
inline void Instrument::clear_has_cap_price_exponent() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void Instrument::clear_cap_price_exponent() {
  cap_price_exponent_ = 0;
  clear_has_cap_price_exponent();
}
inline ::google::protobuf::int32 Instrument::cap_price_exponent() const {
  return cap_price_exponent_;
}
inline void Instrument::set_cap_price_exponent(::google::protobuf::int32 value) {
  set_has_cap_price_exponent();
  cap_price_exponent_ = value;
}

// optional .Common.ExerciseStyleEnum exercise_style = 61;
inline bool Instrument::has_exercise_style() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void Instrument::set_has_exercise_style() {
  _has_bits_[1] |= 0x10000000u;
}
inline void Instrument::clear_has_exercise_style() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void Instrument::clear_exercise_style() {
  exercise_style_ = 0;
  clear_has_exercise_style();
}
inline ::Common::ExerciseStyleEnum Instrument::exercise_style() const {
  return static_cast< ::Common::ExerciseStyleEnum >(exercise_style_);
}
inline void Instrument::set_exercise_style(::Common::ExerciseStyleEnum value) {
  assert(::Common::ExerciseStyleEnum_IsValid(value));
  set_has_exercise_style();
  exercise_style_ = value;
}

// optional bool flex_product_eligibility_indicator = 62;
inline bool Instrument::has_flex_product_eligibility_indicator() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void Instrument::set_has_flex_product_eligibility_indicator() {
  _has_bits_[1] |= 0x20000000u;
}
inline void Instrument::clear_has_flex_product_eligibility_indicator() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void Instrument::clear_flex_product_eligibility_indicator() {
  flex_product_eligibility_indicator_ = false;
  clear_has_flex_product_eligibility_indicator();
}
inline bool Instrument::flex_product_eligibility_indicator() const {
  return flex_product_eligibility_indicator_;
}
inline void Instrument::set_flex_product_eligibility_indicator(bool value) {
  set_has_flex_product_eligibility_indicator();
  flex_product_eligibility_indicator_ = value;
}

// optional bool flexible_indicator = 63;
inline bool Instrument::has_flexible_indicator() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void Instrument::set_has_flexible_indicator() {
  _has_bits_[1] |= 0x40000000u;
}
inline void Instrument::clear_has_flexible_indicator() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void Instrument::clear_flexible_indicator() {
  flexible_indicator_ = false;
  clear_has_flexible_indicator();
}
inline bool Instrument::flexible_indicator() const {
  return flexible_indicator_;
}
inline void Instrument::set_flexible_indicator(bool value) {
  set_has_flexible_indicator();
  flexible_indicator_ = value;
}

// optional sfixed64 floor_price = 64;
inline bool Instrument::has_floor_price() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void Instrument::set_has_floor_price() {
  _has_bits_[1] |= 0x80000000u;
}
inline void Instrument::clear_has_floor_price() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void Instrument::clear_floor_price() {
  floor_price_ = GOOGLE_LONGLONG(0);
  clear_has_floor_price();
}
inline ::google::protobuf::int64 Instrument::floor_price() const {
  return floor_price_;
}
inline void Instrument::set_floor_price(::google::protobuf::int64 value) {
  set_has_floor_price();
  floor_price_ = value;
}

// optional sfixed32 floor_price_exponent = 65;
inline bool Instrument::has_floor_price_exponent() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void Instrument::set_has_floor_price_exponent() {
  _has_bits_[2] |= 0x00000001u;
}
inline void Instrument::clear_has_floor_price_exponent() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void Instrument::clear_floor_price_exponent() {
  floor_price_exponent_ = 0;
  clear_has_floor_price_exponent();
}
inline ::google::protobuf::int32 Instrument::floor_price_exponent() const {
  return floor_price_exponent_;
}
inline void Instrument::set_floor_price_exponent(::google::protobuf::int32 value) {
  set_has_floor_price_exponent();
  floor_price_exponent_ = value;
}

// optional .Common.ListMethodEnum list_method = 66;
inline bool Instrument::has_list_method() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void Instrument::set_has_list_method() {
  _has_bits_[2] |= 0x00000002u;
}
inline void Instrument::clear_has_list_method() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void Instrument::clear_list_method() {
  list_method_ = 0;
  clear_has_list_method();
}
inline ::Common::ListMethodEnum Instrument::list_method() const {
  return static_cast< ::Common::ListMethodEnum >(list_method_);
}
inline void Instrument::set_list_method(::Common::ListMethodEnum value) {
  assert(::Common::ListMethodEnum_IsValid(value));
  set_has_list_method();
  list_method_ = value;
}

// optional sfixed64 min_price_increment_amount = 67;
inline bool Instrument::has_min_price_increment_amount() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void Instrument::set_has_min_price_increment_amount() {
  _has_bits_[2] |= 0x00000004u;
}
inline void Instrument::clear_has_min_price_increment_amount() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void Instrument::clear_min_price_increment_amount() {
  min_price_increment_amount_ = GOOGLE_LONGLONG(0);
  clear_has_min_price_increment_amount();
}
inline ::google::protobuf::int64 Instrument::min_price_increment_amount() const {
  return min_price_increment_amount_;
}
inline void Instrument::set_min_price_increment_amount(::google::protobuf::int64 value) {
  set_has_min_price_increment_amount();
  min_price_increment_amount_ = value;
}

// optional sfixed32 min_price_increment_amount_exponent = 68;
inline bool Instrument::has_min_price_increment_amount_exponent() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void Instrument::set_has_min_price_increment_amount_exponent() {
  _has_bits_[2] |= 0x00000008u;
}
inline void Instrument::clear_has_min_price_increment_amount_exponent() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void Instrument::clear_min_price_increment_amount_exponent() {
  min_price_increment_amount_exponent_ = 0;
  clear_has_min_price_increment_amount_exponent();
}
inline ::google::protobuf::int32 Instrument::min_price_increment_amount_exponent() const {
  return min_price_increment_amount_exponent_;
}
inline void Instrument::set_min_price_increment_amount_exponent(::google::protobuf::int32 value) {
  set_has_min_price_increment_amount_exponent();
  min_price_increment_amount_exponent_ = value;
}

// optional sfixed64 opt_payout_amount = 69;
inline bool Instrument::has_opt_payout_amount() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void Instrument::set_has_opt_payout_amount() {
  _has_bits_[2] |= 0x00000010u;
}
inline void Instrument::clear_has_opt_payout_amount() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void Instrument::clear_opt_payout_amount() {
  opt_payout_amount_ = GOOGLE_LONGLONG(0);
  clear_has_opt_payout_amount();
}
inline ::google::protobuf::int64 Instrument::opt_payout_amount() const {
  return opt_payout_amount_;
}
inline void Instrument::set_opt_payout_amount(::google::protobuf::int64 value) {
  set_has_opt_payout_amount();
  opt_payout_amount_ = value;
}

// optional sfixed32 opt_payout_amount_exponent = 70;
inline bool Instrument::has_opt_payout_amount_exponent() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void Instrument::set_has_opt_payout_amount_exponent() {
  _has_bits_[2] |= 0x00000020u;
}
inline void Instrument::clear_has_opt_payout_amount_exponent() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void Instrument::clear_opt_payout_amount_exponent() {
  opt_payout_amount_exponent_ = 0;
  clear_has_opt_payout_amount_exponent();
}
inline ::google::protobuf::int32 Instrument::opt_payout_amount_exponent() const {
  return opt_payout_amount_exponent_;
}
inline void Instrument::set_opt_payout_amount_exponent(::google::protobuf::int32 value) {
  set_has_opt_payout_amount_exponent();
  opt_payout_amount_exponent_ = value;
}

// optional .Common.PriceQuoteMethodEnum price_quote_method = 71;
inline bool Instrument::has_price_quote_method() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void Instrument::set_has_price_quote_method() {
  _has_bits_[2] |= 0x00000040u;
}
inline void Instrument::clear_has_price_quote_method() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void Instrument::clear_price_quote_method() {
  price_quote_method_ = 0;
  clear_has_price_quote_method();
}
inline ::Common::PriceQuoteMethodEnum Instrument::price_quote_method() const {
  return static_cast< ::Common::PriceQuoteMethodEnum >(price_quote_method_);
}
inline void Instrument::set_price_quote_method(::Common::PriceQuoteMethodEnum value) {
  assert(::Common::PriceQuoteMethodEnum_IsValid(value));
  set_has_price_quote_method();
  price_quote_method_ = value;
}

// optional string price_unit_of_measure = 72;
inline bool Instrument::has_price_unit_of_measure() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void Instrument::set_has_price_unit_of_measure() {
  _has_bits_[2] |= 0x00000080u;
}
inline void Instrument::clear_has_price_unit_of_measure() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void Instrument::clear_price_unit_of_measure() {
  if (price_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    price_unit_of_measure_->clear();
  }
  clear_has_price_unit_of_measure();
}
inline const ::std::string& Instrument::price_unit_of_measure() const {
  return *price_unit_of_measure_;
}
inline void Instrument::set_price_unit_of_measure(const ::std::string& value) {
  set_has_price_unit_of_measure();
  if (price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    price_unit_of_measure_ = new ::std::string;
  }
  price_unit_of_measure_->assign(value);
}
inline void Instrument::set_price_unit_of_measure(const char* value) {
  set_has_price_unit_of_measure();
  if (price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    price_unit_of_measure_ = new ::std::string;
  }
  price_unit_of_measure_->assign(value);
}
inline void Instrument::set_price_unit_of_measure(const char* value, size_t size) {
  set_has_price_unit_of_measure();
  if (price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    price_unit_of_measure_ = new ::std::string;
  }
  price_unit_of_measure_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_price_unit_of_measure() {
  set_has_price_unit_of_measure();
  if (price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    price_unit_of_measure_ = new ::std::string;
  }
  return price_unit_of_measure_;
}
inline ::std::string* Instrument::release_price_unit_of_measure() {
  clear_has_price_unit_of_measure();
  if (price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = price_unit_of_measure_;
    price_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_price_unit_of_measure(::std::string* price_unit_of_measure) {
  if (price_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    delete price_unit_of_measure_;
  }
  if (price_unit_of_measure) {
    set_has_price_unit_of_measure();
    price_unit_of_measure_ = price_unit_of_measure;
  } else {
    clear_has_price_unit_of_measure();
    price_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 price_unit_of_measure_qty = 73;
inline bool Instrument::has_price_unit_of_measure_qty() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void Instrument::set_has_price_unit_of_measure_qty() {
  _has_bits_[2] |= 0x00000100u;
}
inline void Instrument::clear_has_price_unit_of_measure_qty() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void Instrument::clear_price_unit_of_measure_qty() {
  price_unit_of_measure_qty_ = GOOGLE_LONGLONG(0);
  clear_has_price_unit_of_measure_qty();
}
inline ::google::protobuf::int64 Instrument::price_unit_of_measure_qty() const {
  return price_unit_of_measure_qty_;
}
inline void Instrument::set_price_unit_of_measure_qty(::google::protobuf::int64 value) {
  set_has_price_unit_of_measure_qty();
  price_unit_of_measure_qty_ = value;
}

// optional sfixed32 price_unit_of_measure_qty_exponent = 74;
inline bool Instrument::has_price_unit_of_measure_qty_exponent() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void Instrument::set_has_price_unit_of_measure_qty_exponent() {
  _has_bits_[2] |= 0x00000200u;
}
inline void Instrument::clear_has_price_unit_of_measure_qty_exponent() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void Instrument::clear_price_unit_of_measure_qty_exponent() {
  price_unit_of_measure_qty_exponent_ = 0;
  clear_has_price_unit_of_measure_qty_exponent();
}
inline ::google::protobuf::int32 Instrument::price_unit_of_measure_qty_exponent() const {
  return price_unit_of_measure_qty_exponent_;
}
inline void Instrument::set_price_unit_of_measure_qty_exponent(::google::protobuf::int32 value) {
  set_has_price_unit_of_measure_qty_exponent();
  price_unit_of_measure_qty_exponent_ = value;
}

// optional string product_complex = 75;
inline bool Instrument::has_product_complex() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void Instrument::set_has_product_complex() {
  _has_bits_[2] |= 0x00000400u;
}
inline void Instrument::clear_has_product_complex() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void Instrument::clear_product_complex() {
  if (product_complex_ != &::google::protobuf::internal::kEmptyString) {
    product_complex_->clear();
  }
  clear_has_product_complex();
}
inline const ::std::string& Instrument::product_complex() const {
  return *product_complex_;
}
inline void Instrument::set_product_complex(const ::std::string& value) {
  set_has_product_complex();
  if (product_complex_ == &::google::protobuf::internal::kEmptyString) {
    product_complex_ = new ::std::string;
  }
  product_complex_->assign(value);
}
inline void Instrument::set_product_complex(const char* value) {
  set_has_product_complex();
  if (product_complex_ == &::google::protobuf::internal::kEmptyString) {
    product_complex_ = new ::std::string;
  }
  product_complex_->assign(value);
}
inline void Instrument::set_product_complex(const char* value, size_t size) {
  set_has_product_complex();
  if (product_complex_ == &::google::protobuf::internal::kEmptyString) {
    product_complex_ = new ::std::string;
  }
  product_complex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_product_complex() {
  set_has_product_complex();
  if (product_complex_ == &::google::protobuf::internal::kEmptyString) {
    product_complex_ = new ::std::string;
  }
  return product_complex_;
}
inline ::std::string* Instrument::release_product_complex() {
  clear_has_product_complex();
  if (product_complex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = product_complex_;
    product_complex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_product_complex(::std::string* product_complex) {
  if (product_complex_ != &::google::protobuf::internal::kEmptyString) {
    delete product_complex_;
  }
  if (product_complex) {
    set_has_product_complex();
    product_complex_ = product_complex;
  } else {
    clear_has_product_complex();
    product_complex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_group = 76;
inline bool Instrument::has_security_group() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void Instrument::set_has_security_group() {
  _has_bits_[2] |= 0x00000800u;
}
inline void Instrument::clear_has_security_group() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void Instrument::clear_security_group() {
  if (security_group_ != &::google::protobuf::internal::kEmptyString) {
    security_group_->clear();
  }
  clear_has_security_group();
}
inline const ::std::string& Instrument::security_group() const {
  return *security_group_;
}
inline void Instrument::set_security_group(const ::std::string& value) {
  set_has_security_group();
  if (security_group_ == &::google::protobuf::internal::kEmptyString) {
    security_group_ = new ::std::string;
  }
  security_group_->assign(value);
}
inline void Instrument::set_security_group(const char* value) {
  set_has_security_group();
  if (security_group_ == &::google::protobuf::internal::kEmptyString) {
    security_group_ = new ::std::string;
  }
  security_group_->assign(value);
}
inline void Instrument::set_security_group(const char* value, size_t size) {
  set_has_security_group();
  if (security_group_ == &::google::protobuf::internal::kEmptyString) {
    security_group_ = new ::std::string;
  }
  security_group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Instrument::mutable_security_group() {
  set_has_security_group();
  if (security_group_ == &::google::protobuf::internal::kEmptyString) {
    security_group_ = new ::std::string;
  }
  return security_group_;
}
inline ::std::string* Instrument::release_security_group() {
  clear_has_security_group();
  if (security_group_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_group_;
    security_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Instrument::set_allocated_security_group(::std::string* security_group) {
  if (security_group_ != &::google::protobuf::internal::kEmptyString) {
    delete security_group_;
  }
  if (security_group) {
    set_has_security_group();
    security_group_ = security_group;
  } else {
    clear_has_security_group();
    security_group_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.SecurityXml security_xml = 77;
inline bool Instrument::has_security_xml() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void Instrument::set_has_security_xml() {
  _has_bits_[2] |= 0x00001000u;
}
inline void Instrument::clear_has_security_xml() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void Instrument::clear_security_xml() {
  if (security_xml_ != NULL) security_xml_->::Common::SecurityXml::Clear();
  clear_has_security_xml();
}
inline const ::Common::SecurityXml& Instrument::security_xml() const {
  return security_xml_ != NULL ? *security_xml_ : *default_instance_->security_xml_;
}
inline ::Common::SecurityXml* Instrument::mutable_security_xml() {
  set_has_security_xml();
  if (security_xml_ == NULL) security_xml_ = new ::Common::SecurityXml;
  return security_xml_;
}
inline ::Common::SecurityXml* Instrument::release_security_xml() {
  clear_has_security_xml();
  ::Common::SecurityXml* temp = security_xml_;
  security_xml_ = NULL;
  return temp;
}
inline void Instrument::set_allocated_security_xml(::Common::SecurityXml* security_xml) {
  delete security_xml_;
  security_xml_ = security_xml;
  if (security_xml) {
    set_has_security_xml();
  } else {
    clear_has_security_xml();
  }
}

// optional .Common.SettlMethodEnum settl_method = 78;
inline bool Instrument::has_settl_method() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void Instrument::set_has_settl_method() {
  _has_bits_[2] |= 0x00002000u;
}
inline void Instrument::clear_has_settl_method() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void Instrument::clear_settl_method() {
  settl_method_ = 0;
  clear_has_settl_method();
}
inline ::Common::SettlMethodEnum Instrument::settl_method() const {
  return static_cast< ::Common::SettlMethodEnum >(settl_method_);
}
inline void Instrument::set_settl_method(::Common::SettlMethodEnum value) {
  assert(::Common::SettlMethodEnum_IsValid(value));
  set_has_settl_method();
  settl_method_ = value;
}

// optional sfixed64 unit_of_measure_qty = 79;
inline bool Instrument::has_unit_of_measure_qty() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void Instrument::set_has_unit_of_measure_qty() {
  _has_bits_[2] |= 0x00004000u;
}
inline void Instrument::clear_has_unit_of_measure_qty() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void Instrument::clear_unit_of_measure_qty() {
  unit_of_measure_qty_ = GOOGLE_LONGLONG(0);
  clear_has_unit_of_measure_qty();
}
inline ::google::protobuf::int64 Instrument::unit_of_measure_qty() const {
  return unit_of_measure_qty_;
}
inline void Instrument::set_unit_of_measure_qty(::google::protobuf::int64 value) {
  set_has_unit_of_measure_qty();
  unit_of_measure_qty_ = value;
}

// optional sfixed32 unit_of_measure_qty_exponent = 80;
inline bool Instrument::has_unit_of_measure_qty_exponent() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void Instrument::set_has_unit_of_measure_qty_exponent() {
  _has_bits_[2] |= 0x00008000u;
}
inline void Instrument::clear_has_unit_of_measure_qty_exponent() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void Instrument::clear_unit_of_measure_qty_exponent() {
  unit_of_measure_qty_exponent_ = 0;
  clear_has_unit_of_measure_qty_exponent();
}
inline ::google::protobuf::int32 Instrument::unit_of_measure_qty_exponent() const {
  return unit_of_measure_qty_exponent_;
}
inline void Instrument::set_unit_of_measure_qty_exponent(::google::protobuf::int32 value) {
  set_has_unit_of_measure_qty_exponent();
  unit_of_measure_qty_exponent_ = value;
}

// optional .Common.ValuationMethodEnum valuation_method = 81;
inline bool Instrument::has_valuation_method() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void Instrument::set_has_valuation_method() {
  _has_bits_[2] |= 0x00010000u;
}
inline void Instrument::clear_has_valuation_method() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void Instrument::clear_valuation_method() {
  valuation_method_ = 0;
  clear_has_valuation_method();
}
inline ::Common::ValuationMethodEnum Instrument::valuation_method() const {
  return static_cast< ::Common::ValuationMethodEnum >(valuation_method_);
}
inline void Instrument::set_valuation_method(::Common::ValuationMethodEnum value) {
  assert(::Common::ValuationMethodEnum_IsValid(value));
  set_has_valuation_method();
  valuation_method_ = value;
}

// optional .Common.ContractMultiplierUnitEnum contract_multiplier_unit = 82;
inline bool Instrument::has_contract_multiplier_unit() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void Instrument::set_has_contract_multiplier_unit() {
  _has_bits_[2] |= 0x00020000u;
}
inline void Instrument::clear_has_contract_multiplier_unit() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void Instrument::clear_contract_multiplier_unit() {
  contract_multiplier_unit_ = 0;
  clear_has_contract_multiplier_unit();
}
inline ::Common::ContractMultiplierUnitEnum Instrument::contract_multiplier_unit() const {
  return static_cast< ::Common::ContractMultiplierUnitEnum >(contract_multiplier_unit_);
}
inline void Instrument::set_contract_multiplier_unit(::Common::ContractMultiplierUnitEnum value) {
  assert(::Common::ContractMultiplierUnitEnum_IsValid(value));
  set_has_contract_multiplier_unit();
  contract_multiplier_unit_ = value;
}

// optional .Common.FlowScheduleTypeEnum flow_schedule_type = 83;
inline bool Instrument::has_flow_schedule_type() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void Instrument::set_has_flow_schedule_type() {
  _has_bits_[2] |= 0x00040000u;
}
inline void Instrument::clear_has_flow_schedule_type() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void Instrument::clear_flow_schedule_type() {
  flow_schedule_type_ = 0;
  clear_has_flow_schedule_type();
}
inline ::Common::FlowScheduleTypeEnum Instrument::flow_schedule_type() const {
  return static_cast< ::Common::FlowScheduleTypeEnum >(flow_schedule_type_);
}
inline void Instrument::set_flow_schedule_type(::Common::FlowScheduleTypeEnum value) {
  assert(::Common::FlowScheduleTypeEnum_IsValid(value));
  set_has_flow_schedule_type();
  flow_schedule_type_ = value;
}

// optional sfixed64 attachment_point = 84;
inline bool Instrument::has_attachment_point() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void Instrument::set_has_attachment_point() {
  _has_bits_[2] |= 0x00080000u;
}
inline void Instrument::clear_has_attachment_point() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void Instrument::clear_attachment_point() {
  attachment_point_ = GOOGLE_LONGLONG(0);
  clear_has_attachment_point();
}
inline ::google::protobuf::int64 Instrument::attachment_point() const {
  return attachment_point_;
}
inline void Instrument::set_attachment_point(::google::protobuf::int64 value) {
  set_has_attachment_point();
  attachment_point_ = value;
}

// optional sfixed32 attachment_point_exponent = 85;
inline bool Instrument::has_attachment_point_exponent() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void Instrument::set_has_attachment_point_exponent() {
  _has_bits_[2] |= 0x00100000u;
}
inline void Instrument::clear_has_attachment_point_exponent() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void Instrument::clear_attachment_point_exponent() {
  attachment_point_exponent_ = 0;
  clear_has_attachment_point_exponent();
}
inline ::google::protobuf::int32 Instrument::attachment_point_exponent() const {
  return attachment_point_exponent_;
}
inline void Instrument::set_attachment_point_exponent(::google::protobuf::int32 value) {
  set_has_attachment_point_exponent();
  attachment_point_exponent_ = value;
}

// optional sfixed64 detachment_point = 86;
inline bool Instrument::has_detachment_point() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void Instrument::set_has_detachment_point() {
  _has_bits_[2] |= 0x00200000u;
}
inline void Instrument::clear_has_detachment_point() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void Instrument::clear_detachment_point() {
  detachment_point_ = GOOGLE_LONGLONG(0);
  clear_has_detachment_point();
}
inline ::google::protobuf::int64 Instrument::detachment_point() const {
  return detachment_point_;
}
inline void Instrument::set_detachment_point(::google::protobuf::int64 value) {
  set_has_detachment_point();
  detachment_point_ = value;
}

// optional sfixed32 detachment_point_exponent = 87;
inline bool Instrument::has_detachment_point_exponent() const {
  return (_has_bits_[2] & 0x00400000u) != 0;
}
inline void Instrument::set_has_detachment_point_exponent() {
  _has_bits_[2] |= 0x00400000u;
}
inline void Instrument::clear_has_detachment_point_exponent() {
  _has_bits_[2] &= ~0x00400000u;
}
inline void Instrument::clear_detachment_point_exponent() {
  detachment_point_exponent_ = 0;
  clear_has_detachment_point_exponent();
}
inline ::google::protobuf::int32 Instrument::detachment_point_exponent() const {
  return detachment_point_exponent_;
}
inline void Instrument::set_detachment_point_exponent(::google::protobuf::int32 value) {
  set_has_detachment_point_exponent();
  detachment_point_exponent_ = value;
}

// optional sfixed64 notional_percentage_outstanding = 88;
inline bool Instrument::has_notional_percentage_outstanding() const {
  return (_has_bits_[2] & 0x00800000u) != 0;
}
inline void Instrument::set_has_notional_percentage_outstanding() {
  _has_bits_[2] |= 0x00800000u;
}
inline void Instrument::clear_has_notional_percentage_outstanding() {
  _has_bits_[2] &= ~0x00800000u;
}
inline void Instrument::clear_notional_percentage_outstanding() {
  notional_percentage_outstanding_ = GOOGLE_LONGLONG(0);
  clear_has_notional_percentage_outstanding();
}
inline ::google::protobuf::int64 Instrument::notional_percentage_outstanding() const {
  return notional_percentage_outstanding_;
}
inline void Instrument::set_notional_percentage_outstanding(::google::protobuf::int64 value) {
  set_has_notional_percentage_outstanding();
  notional_percentage_outstanding_ = value;
}

// optional sfixed32 notional_percentage_outstanding_exponent = 89;
inline bool Instrument::has_notional_percentage_outstanding_exponent() const {
  return (_has_bits_[2] & 0x01000000u) != 0;
}
inline void Instrument::set_has_notional_percentage_outstanding_exponent() {
  _has_bits_[2] |= 0x01000000u;
}
inline void Instrument::clear_has_notional_percentage_outstanding_exponent() {
  _has_bits_[2] &= ~0x01000000u;
}
inline void Instrument::clear_notional_percentage_outstanding_exponent() {
  notional_percentage_outstanding_exponent_ = 0;
  clear_has_notional_percentage_outstanding_exponent();
}
inline ::google::protobuf::int32 Instrument::notional_percentage_outstanding_exponent() const {
  return notional_percentage_outstanding_exponent_;
}
inline void Instrument::set_notional_percentage_outstanding_exponent(::google::protobuf::int32 value) {
  set_has_notional_percentage_outstanding_exponent();
  notional_percentage_outstanding_exponent_ = value;
}

// optional sfixed64 original_notional_percentage_outstanding = 90;
inline bool Instrument::has_original_notional_percentage_outstanding() const {
  return (_has_bits_[2] & 0x02000000u) != 0;
}
inline void Instrument::set_has_original_notional_percentage_outstanding() {
  _has_bits_[2] |= 0x02000000u;
}
inline void Instrument::clear_has_original_notional_percentage_outstanding() {
  _has_bits_[2] &= ~0x02000000u;
}
inline void Instrument::clear_original_notional_percentage_outstanding() {
  original_notional_percentage_outstanding_ = GOOGLE_LONGLONG(0);
  clear_has_original_notional_percentage_outstanding();
}
inline ::google::protobuf::int64 Instrument::original_notional_percentage_outstanding() const {
  return original_notional_percentage_outstanding_;
}
inline void Instrument::set_original_notional_percentage_outstanding(::google::protobuf::int64 value) {
  set_has_original_notional_percentage_outstanding();
  original_notional_percentage_outstanding_ = value;
}

// optional sfixed32 original_notional_percentage_outstanding_exponent = 91;
inline bool Instrument::has_original_notional_percentage_outstanding_exponent() const {
  return (_has_bits_[2] & 0x04000000u) != 0;
}
inline void Instrument::set_has_original_notional_percentage_outstanding_exponent() {
  _has_bits_[2] |= 0x04000000u;
}
inline void Instrument::clear_has_original_notional_percentage_outstanding_exponent() {
  _has_bits_[2] &= ~0x04000000u;
}
inline void Instrument::clear_original_notional_percentage_outstanding_exponent() {
  original_notional_percentage_outstanding_exponent_ = 0;
  clear_has_original_notional_percentage_outstanding_exponent();
}
inline ::google::protobuf::int32 Instrument::original_notional_percentage_outstanding_exponent() const {
  return original_notional_percentage_outstanding_exponent_;
}
inline void Instrument::set_original_notional_percentage_outstanding_exponent(::google::protobuf::int32 value) {
  set_has_original_notional_percentage_outstanding_exponent();
  original_notional_percentage_outstanding_exponent_ = value;
}

// optional .Common.RestructuringTypeEnum restructuring_type = 92;
inline bool Instrument::has_restructuring_type() const {
  return (_has_bits_[2] & 0x08000000u) != 0;
}
inline void Instrument::set_has_restructuring_type() {
  _has_bits_[2] |= 0x08000000u;
}
inline void Instrument::clear_has_restructuring_type() {
  _has_bits_[2] &= ~0x08000000u;
}
inline void Instrument::clear_restructuring_type() {
  restructuring_type_ = 0;
  clear_has_restructuring_type();
}
inline ::Common::RestructuringTypeEnum Instrument::restructuring_type() const {
  return static_cast< ::Common::RestructuringTypeEnum >(restructuring_type_);
}
inline void Instrument::set_restructuring_type(::Common::RestructuringTypeEnum value) {
  assert(::Common::RestructuringTypeEnum_IsValid(value));
  set_has_restructuring_type();
  restructuring_type_ = value;
}

// optional .Common.SeniorityEnum seniority = 93;
inline bool Instrument::has_seniority() const {
  return (_has_bits_[2] & 0x10000000u) != 0;
}
inline void Instrument::set_has_seniority() {
  _has_bits_[2] |= 0x10000000u;
}
inline void Instrument::clear_has_seniority() {
  _has_bits_[2] &= ~0x10000000u;
}
inline void Instrument::clear_seniority() {
  seniority_ = 0;
  clear_has_seniority();
}
inline ::Common::SeniorityEnum Instrument::seniority() const {
  return static_cast< ::Common::SeniorityEnum >(seniority_);
}
inline void Instrument::set_seniority(::Common::SeniorityEnum value) {
  assert(::Common::SeniorityEnum_IsValid(value));
  set_has_seniority();
  seniority_ = value;
}

// repeated .Common.ComplexEvents complex_events = 94;
inline int Instrument::complex_events_size() const {
  return complex_events_.size();
}
inline void Instrument::clear_complex_events() {
  complex_events_.Clear();
}
inline const ::Common::ComplexEvents& Instrument::complex_events(int index) const {
  return complex_events_.Get(index);
}
inline ::Common::ComplexEvents* Instrument::mutable_complex_events(int index) {
  return complex_events_.Mutable(index);
}
inline ::Common::ComplexEvents* Instrument::add_complex_events() {
  return complex_events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::ComplexEvents >&
Instrument::complex_events() const {
  return complex_events_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::ComplexEvents >*
Instrument::mutable_complex_events() {
  return &complex_events_;
}

// optional .Common.OptPayoutTypeEnum opt_payout_type = 95;
inline bool Instrument::has_opt_payout_type() const {
  return (_has_bits_[2] & 0x40000000u) != 0;
}
inline void Instrument::set_has_opt_payout_type() {
  _has_bits_[2] |= 0x40000000u;
}
inline void Instrument::clear_has_opt_payout_type() {
  _has_bits_[2] &= ~0x40000000u;
}
inline void Instrument::clear_opt_payout_type() {
  opt_payout_type_ = 0;
  clear_has_opt_payout_type();
}
inline ::Common::OptPayoutTypeEnum Instrument::opt_payout_type() const {
  return static_cast< ::Common::OptPayoutTypeEnum >(opt_payout_type_);
}
inline void Instrument::set_opt_payout_type(::Common::OptPayoutTypeEnum value) {
  assert(::Common::OptPayoutTypeEnum_IsValid(value));
  set_has_opt_payout_type();
  opt_payout_type_ = value;
}

// optional .Common.StrikePriceBoundaryMethodEnum strike_price_boundary_method = 96;
inline bool Instrument::has_strike_price_boundary_method() const {
  return (_has_bits_[2] & 0x80000000u) != 0;
}
inline void Instrument::set_has_strike_price_boundary_method() {
  _has_bits_[2] |= 0x80000000u;
}
inline void Instrument::clear_has_strike_price_boundary_method() {
  _has_bits_[2] &= ~0x80000000u;
}
inline void Instrument::clear_strike_price_boundary_method() {
  strike_price_boundary_method_ = 0;
  clear_has_strike_price_boundary_method();
}
inline ::Common::StrikePriceBoundaryMethodEnum Instrument::strike_price_boundary_method() const {
  return static_cast< ::Common::StrikePriceBoundaryMethodEnum >(strike_price_boundary_method_);
}
inline void Instrument::set_strike_price_boundary_method(::Common::StrikePriceBoundaryMethodEnum value) {
  assert(::Common::StrikePriceBoundaryMethodEnum_IsValid(value));
  set_has_strike_price_boundary_method();
  strike_price_boundary_method_ = value;
}

// optional sfixed64 strike_price_boundary_precision = 97;
inline bool Instrument::has_strike_price_boundary_precision() const {
  return (_has_bits_[3] & 0x00000001u) != 0;
}
inline void Instrument::set_has_strike_price_boundary_precision() {
  _has_bits_[3] |= 0x00000001u;
}
inline void Instrument::clear_has_strike_price_boundary_precision() {
  _has_bits_[3] &= ~0x00000001u;
}
inline void Instrument::clear_strike_price_boundary_precision() {
  strike_price_boundary_precision_ = GOOGLE_LONGLONG(0);
  clear_has_strike_price_boundary_precision();
}
inline ::google::protobuf::int64 Instrument::strike_price_boundary_precision() const {
  return strike_price_boundary_precision_;
}
inline void Instrument::set_strike_price_boundary_precision(::google::protobuf::int64 value) {
  set_has_strike_price_boundary_precision();
  strike_price_boundary_precision_ = value;
}

// optional sfixed32 strike_price_boundary_precision_exponent = 98;
inline bool Instrument::has_strike_price_boundary_precision_exponent() const {
  return (_has_bits_[3] & 0x00000002u) != 0;
}
inline void Instrument::set_has_strike_price_boundary_precision_exponent() {
  _has_bits_[3] |= 0x00000002u;
}
inline void Instrument::clear_has_strike_price_boundary_precision_exponent() {
  _has_bits_[3] &= ~0x00000002u;
}
inline void Instrument::clear_strike_price_boundary_precision_exponent() {
  strike_price_boundary_precision_exponent_ = 0;
  clear_has_strike_price_boundary_precision_exponent();
}
inline ::google::protobuf::int32 Instrument::strike_price_boundary_precision_exponent() const {
  return strike_price_boundary_precision_exponent_;
}
inline void Instrument::set_strike_price_boundary_precision_exponent(::google::protobuf::int32 value) {
  set_has_strike_price_boundary_precision_exponent();
  strike_price_boundary_precision_exponent_ = value;
}

// optional .Common.StrikePriceDeterminationMethodEnum strike_price_determination_method = 99;
inline bool Instrument::has_strike_price_determination_method() const {
  return (_has_bits_[3] & 0x00000004u) != 0;
}
inline void Instrument::set_has_strike_price_determination_method() {
  _has_bits_[3] |= 0x00000004u;
}
inline void Instrument::clear_has_strike_price_determination_method() {
  _has_bits_[3] &= ~0x00000004u;
}
inline void Instrument::clear_strike_price_determination_method() {
  strike_price_determination_method_ = 0;
  clear_has_strike_price_determination_method();
}
inline ::Common::StrikePriceDeterminationMethodEnum Instrument::strike_price_determination_method() const {
  return static_cast< ::Common::StrikePriceDeterminationMethodEnum >(strike_price_determination_method_);
}
inline void Instrument::set_strike_price_determination_method(::Common::StrikePriceDeterminationMethodEnum value) {
  assert(::Common::StrikePriceDeterminationMethodEnum_IsValid(value));
  set_has_strike_price_determination_method();
  strike_price_determination_method_ = value;
}

// optional .Common.UnderlyingPriceDeterminationMethodEnum underlying_price_determination_method = 100;
inline bool Instrument::has_underlying_price_determination_method() const {
  return (_has_bits_[3] & 0x00000008u) != 0;
}
inline void Instrument::set_has_underlying_price_determination_method() {
  _has_bits_[3] |= 0x00000008u;
}
inline void Instrument::clear_has_underlying_price_determination_method() {
  _has_bits_[3] &= ~0x00000008u;
}
inline void Instrument::clear_underlying_price_determination_method() {
  underlying_price_determination_method_ = 0;
  clear_has_underlying_price_determination_method();
}
inline ::Common::UnderlyingPriceDeterminationMethodEnum Instrument::underlying_price_determination_method() const {
  return static_cast< ::Common::UnderlyingPriceDeterminationMethodEnum >(underlying_price_determination_method_);
}
inline void Instrument::set_underlying_price_determination_method(::Common::UnderlyingPriceDeterminationMethodEnum value) {
  assert(::Common::UnderlyingPriceDeterminationMethodEnum_IsValid(value));
  set_has_underlying_price_determination_method();
  underlying_price_determination_method_ = value;
}

// -------------------------------------------------------------------

// FinancingDetails

// optional string agreement_currency = 1;
inline bool FinancingDetails::has_agreement_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FinancingDetails::set_has_agreement_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FinancingDetails::clear_has_agreement_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FinancingDetails::clear_agreement_currency() {
  if (agreement_currency_ != &::google::protobuf::internal::kEmptyString) {
    agreement_currency_->clear();
  }
  clear_has_agreement_currency();
}
inline const ::std::string& FinancingDetails::agreement_currency() const {
  return *agreement_currency_;
}
inline void FinancingDetails::set_agreement_currency(const ::std::string& value) {
  set_has_agreement_currency();
  if (agreement_currency_ == &::google::protobuf::internal::kEmptyString) {
    agreement_currency_ = new ::std::string;
  }
  agreement_currency_->assign(value);
}
inline void FinancingDetails::set_agreement_currency(const char* value) {
  set_has_agreement_currency();
  if (agreement_currency_ == &::google::protobuf::internal::kEmptyString) {
    agreement_currency_ = new ::std::string;
  }
  agreement_currency_->assign(value);
}
inline void FinancingDetails::set_agreement_currency(const char* value, size_t size) {
  set_has_agreement_currency();
  if (agreement_currency_ == &::google::protobuf::internal::kEmptyString) {
    agreement_currency_ = new ::std::string;
  }
  agreement_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FinancingDetails::mutable_agreement_currency() {
  set_has_agreement_currency();
  if (agreement_currency_ == &::google::protobuf::internal::kEmptyString) {
    agreement_currency_ = new ::std::string;
  }
  return agreement_currency_;
}
inline ::std::string* FinancingDetails::release_agreement_currency() {
  clear_has_agreement_currency();
  if (agreement_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agreement_currency_;
    agreement_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FinancingDetails::set_allocated_agreement_currency(::std::string* agreement_currency) {
  if (agreement_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete agreement_currency_;
  }
  if (agreement_currency) {
    set_has_agreement_currency();
    agreement_currency_ = agreement_currency;
  } else {
    clear_has_agreement_currency();
    agreement_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 agreement_date = 2;
inline bool FinancingDetails::has_agreement_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FinancingDetails::set_has_agreement_date() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FinancingDetails::clear_has_agreement_date() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FinancingDetails::clear_agreement_date() {
  agreement_date_ = 0;
  clear_has_agreement_date();
}
inline ::google::protobuf::int32 FinancingDetails::agreement_date() const {
  return agreement_date_;
}
inline void FinancingDetails::set_agreement_date(::google::protobuf::int32 value) {
  set_has_agreement_date();
  agreement_date_ = value;
}

// optional string agreement_desc = 3;
inline bool FinancingDetails::has_agreement_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FinancingDetails::set_has_agreement_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FinancingDetails::clear_has_agreement_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FinancingDetails::clear_agreement_desc() {
  if (agreement_desc_ != &::google::protobuf::internal::kEmptyString) {
    agreement_desc_->clear();
  }
  clear_has_agreement_desc();
}
inline const ::std::string& FinancingDetails::agreement_desc() const {
  return *agreement_desc_;
}
inline void FinancingDetails::set_agreement_desc(const ::std::string& value) {
  set_has_agreement_desc();
  if (agreement_desc_ == &::google::protobuf::internal::kEmptyString) {
    agreement_desc_ = new ::std::string;
  }
  agreement_desc_->assign(value);
}
inline void FinancingDetails::set_agreement_desc(const char* value) {
  set_has_agreement_desc();
  if (agreement_desc_ == &::google::protobuf::internal::kEmptyString) {
    agreement_desc_ = new ::std::string;
  }
  agreement_desc_->assign(value);
}
inline void FinancingDetails::set_agreement_desc(const char* value, size_t size) {
  set_has_agreement_desc();
  if (agreement_desc_ == &::google::protobuf::internal::kEmptyString) {
    agreement_desc_ = new ::std::string;
  }
  agreement_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FinancingDetails::mutable_agreement_desc() {
  set_has_agreement_desc();
  if (agreement_desc_ == &::google::protobuf::internal::kEmptyString) {
    agreement_desc_ = new ::std::string;
  }
  return agreement_desc_;
}
inline ::std::string* FinancingDetails::release_agreement_desc() {
  clear_has_agreement_desc();
  if (agreement_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agreement_desc_;
    agreement_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FinancingDetails::set_allocated_agreement_desc(::std::string* agreement_desc) {
  if (agreement_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete agreement_desc_;
  }
  if (agreement_desc) {
    set_has_agreement_desc();
    agreement_desc_ = agreement_desc;
  } else {
    clear_has_agreement_desc();
    agreement_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string agreement_id = 4;
inline bool FinancingDetails::has_agreement_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FinancingDetails::set_has_agreement_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FinancingDetails::clear_has_agreement_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FinancingDetails::clear_agreement_id() {
  if (agreement_id_ != &::google::protobuf::internal::kEmptyString) {
    agreement_id_->clear();
  }
  clear_has_agreement_id();
}
inline const ::std::string& FinancingDetails::agreement_id() const {
  return *agreement_id_;
}
inline void FinancingDetails::set_agreement_id(const ::std::string& value) {
  set_has_agreement_id();
  if (agreement_id_ == &::google::protobuf::internal::kEmptyString) {
    agreement_id_ = new ::std::string;
  }
  agreement_id_->assign(value);
}
inline void FinancingDetails::set_agreement_id(const char* value) {
  set_has_agreement_id();
  if (agreement_id_ == &::google::protobuf::internal::kEmptyString) {
    agreement_id_ = new ::std::string;
  }
  agreement_id_->assign(value);
}
inline void FinancingDetails::set_agreement_id(const char* value, size_t size) {
  set_has_agreement_id();
  if (agreement_id_ == &::google::protobuf::internal::kEmptyString) {
    agreement_id_ = new ::std::string;
  }
  agreement_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FinancingDetails::mutable_agreement_id() {
  set_has_agreement_id();
  if (agreement_id_ == &::google::protobuf::internal::kEmptyString) {
    agreement_id_ = new ::std::string;
  }
  return agreement_id_;
}
inline ::std::string* FinancingDetails::release_agreement_id() {
  clear_has_agreement_id();
  if (agreement_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agreement_id_;
    agreement_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FinancingDetails::set_allocated_agreement_id(::std::string* agreement_id) {
  if (agreement_id_ != &::google::protobuf::internal::kEmptyString) {
    delete agreement_id_;
  }
  if (agreement_id) {
    set_has_agreement_id();
    agreement_id_ = agreement_id;
  } else {
    clear_has_agreement_id();
    agreement_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.DeliveryTypeEnum delivery_type = 5;
inline bool FinancingDetails::has_delivery_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FinancingDetails::set_has_delivery_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FinancingDetails::clear_has_delivery_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FinancingDetails::clear_delivery_type() {
  delivery_type_ = 0;
  clear_has_delivery_type();
}
inline ::Common::DeliveryTypeEnum FinancingDetails::delivery_type() const {
  return static_cast< ::Common::DeliveryTypeEnum >(delivery_type_);
}
inline void FinancingDetails::set_delivery_type(::Common::DeliveryTypeEnum value) {
  assert(::Common::DeliveryTypeEnum_IsValid(value));
  set_has_delivery_type();
  delivery_type_ = value;
}

// optional sfixed32 end_date = 6;
inline bool FinancingDetails::has_end_date() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FinancingDetails::set_has_end_date() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FinancingDetails::clear_has_end_date() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FinancingDetails::clear_end_date() {
  end_date_ = 0;
  clear_has_end_date();
}
inline ::google::protobuf::int32 FinancingDetails::end_date() const {
  return end_date_;
}
inline void FinancingDetails::set_end_date(::google::protobuf::int32 value) {
  set_has_end_date();
  end_date_ = value;
}

// optional sfixed64 margin_ratio = 7;
inline bool FinancingDetails::has_margin_ratio() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FinancingDetails::set_has_margin_ratio() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FinancingDetails::clear_has_margin_ratio() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FinancingDetails::clear_margin_ratio() {
  margin_ratio_ = GOOGLE_LONGLONG(0);
  clear_has_margin_ratio();
}
inline ::google::protobuf::int64 FinancingDetails::margin_ratio() const {
  return margin_ratio_;
}
inline void FinancingDetails::set_margin_ratio(::google::protobuf::int64 value) {
  set_has_margin_ratio();
  margin_ratio_ = value;
}

// optional sfixed32 margin_ratio_exponent = 8;
inline bool FinancingDetails::has_margin_ratio_exponent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FinancingDetails::set_has_margin_ratio_exponent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FinancingDetails::clear_has_margin_ratio_exponent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FinancingDetails::clear_margin_ratio_exponent() {
  margin_ratio_exponent_ = 0;
  clear_has_margin_ratio_exponent();
}
inline ::google::protobuf::int32 FinancingDetails::margin_ratio_exponent() const {
  return margin_ratio_exponent_;
}
inline void FinancingDetails::set_margin_ratio_exponent(::google::protobuf::int32 value) {
  set_has_margin_ratio_exponent();
  margin_ratio_exponent_ = value;
}

// optional sfixed32 start_date = 9;
inline bool FinancingDetails::has_start_date() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FinancingDetails::set_has_start_date() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FinancingDetails::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FinancingDetails::clear_start_date() {
  start_date_ = 0;
  clear_has_start_date();
}
inline ::google::protobuf::int32 FinancingDetails::start_date() const {
  return start_date_;
}
inline void FinancingDetails::set_start_date(::google::protobuf::int32 value) {
  set_has_start_date();
  start_date_ = value;
}

// optional .Common.TerminationTypeEnum termination_type = 10;
inline bool FinancingDetails::has_termination_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FinancingDetails::set_has_termination_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FinancingDetails::clear_has_termination_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FinancingDetails::clear_termination_type() {
  termination_type_ = 0;
  clear_has_termination_type();
}
inline ::Common::TerminationTypeEnum FinancingDetails::termination_type() const {
  return static_cast< ::Common::TerminationTypeEnum >(termination_type_);
}
inline void FinancingDetails::set_termination_type(::Common::TerminationTypeEnum value) {
  assert(::Common::TerminationTypeEnum_IsValid(value));
  set_has_termination_type();
  termination_type_ = value;
}

// -------------------------------------------------------------------

// UndSecAltIdGrp

// optional string underlying_security_alt_id = 1;
inline bool UndSecAltIdGrp::has_underlying_security_alt_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndSecAltIdGrp::set_has_underlying_security_alt_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndSecAltIdGrp::clear_has_underlying_security_alt_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndSecAltIdGrp::clear_underlying_security_alt_id() {
  if (underlying_security_alt_id_ != &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_->clear();
  }
  clear_has_underlying_security_alt_id();
}
inline const ::std::string& UndSecAltIdGrp::underlying_security_alt_id() const {
  return *underlying_security_alt_id_;
}
inline void UndSecAltIdGrp::set_underlying_security_alt_id(const ::std::string& value) {
  set_has_underlying_security_alt_id();
  if (underlying_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_ = new ::std::string;
  }
  underlying_security_alt_id_->assign(value);
}
inline void UndSecAltIdGrp::set_underlying_security_alt_id(const char* value) {
  set_has_underlying_security_alt_id();
  if (underlying_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_ = new ::std::string;
  }
  underlying_security_alt_id_->assign(value);
}
inline void UndSecAltIdGrp::set_underlying_security_alt_id(const char* value, size_t size) {
  set_has_underlying_security_alt_id();
  if (underlying_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_ = new ::std::string;
  }
  underlying_security_alt_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UndSecAltIdGrp::mutable_underlying_security_alt_id() {
  set_has_underlying_security_alt_id();
  if (underlying_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_ = new ::std::string;
  }
  return underlying_security_alt_id_;
}
inline ::std::string* UndSecAltIdGrp::release_underlying_security_alt_id() {
  clear_has_underlying_security_alt_id();
  if (underlying_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_security_alt_id_;
    underlying_security_alt_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UndSecAltIdGrp::set_allocated_underlying_security_alt_id(::std::string* underlying_security_alt_id) {
  if (underlying_security_alt_id_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_security_alt_id_;
  }
  if (underlying_security_alt_id) {
    set_has_underlying_security_alt_id();
    underlying_security_alt_id_ = underlying_security_alt_id;
  } else {
    clear_has_underlying_security_alt_id();
    underlying_security_alt_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_security_alt_id_source = 2;
inline bool UndSecAltIdGrp::has_underlying_security_alt_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndSecAltIdGrp::set_has_underlying_security_alt_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndSecAltIdGrp::clear_has_underlying_security_alt_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndSecAltIdGrp::clear_underlying_security_alt_id_source() {
  if (underlying_security_alt_id_source_ != &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_source_->clear();
  }
  clear_has_underlying_security_alt_id_source();
}
inline const ::std::string& UndSecAltIdGrp::underlying_security_alt_id_source() const {
  return *underlying_security_alt_id_source_;
}
inline void UndSecAltIdGrp::set_underlying_security_alt_id_source(const ::std::string& value) {
  set_has_underlying_security_alt_id_source();
  if (underlying_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_source_ = new ::std::string;
  }
  underlying_security_alt_id_source_->assign(value);
}
inline void UndSecAltIdGrp::set_underlying_security_alt_id_source(const char* value) {
  set_has_underlying_security_alt_id_source();
  if (underlying_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_source_ = new ::std::string;
  }
  underlying_security_alt_id_source_->assign(value);
}
inline void UndSecAltIdGrp::set_underlying_security_alt_id_source(const char* value, size_t size) {
  set_has_underlying_security_alt_id_source();
  if (underlying_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_source_ = new ::std::string;
  }
  underlying_security_alt_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UndSecAltIdGrp::mutable_underlying_security_alt_id_source() {
  set_has_underlying_security_alt_id_source();
  if (underlying_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_alt_id_source_ = new ::std::string;
  }
  return underlying_security_alt_id_source_;
}
inline ::std::string* UndSecAltIdGrp::release_underlying_security_alt_id_source() {
  clear_has_underlying_security_alt_id_source();
  if (underlying_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_security_alt_id_source_;
    underlying_security_alt_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UndSecAltIdGrp::set_allocated_underlying_security_alt_id_source(::std::string* underlying_security_alt_id_source) {
  if (underlying_security_alt_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_security_alt_id_source_;
  }
  if (underlying_security_alt_id_source) {
    set_has_underlying_security_alt_id_source();
    underlying_security_alt_id_source_ = underlying_security_alt_id_source;
  } else {
    clear_has_underlying_security_alt_id_source();
    underlying_security_alt_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UnderlyingStipulations

// optional string underlying_stip_type = 1;
inline bool UnderlyingStipulations::has_underlying_stip_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnderlyingStipulations::set_has_underlying_stip_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnderlyingStipulations::clear_has_underlying_stip_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnderlyingStipulations::clear_underlying_stip_type() {
  if (underlying_stip_type_ != &::google::protobuf::internal::kEmptyString) {
    underlying_stip_type_->clear();
  }
  clear_has_underlying_stip_type();
}
inline const ::std::string& UnderlyingStipulations::underlying_stip_type() const {
  return *underlying_stip_type_;
}
inline void UnderlyingStipulations::set_underlying_stip_type(const ::std::string& value) {
  set_has_underlying_stip_type();
  if (underlying_stip_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_stip_type_ = new ::std::string;
  }
  underlying_stip_type_->assign(value);
}
inline void UnderlyingStipulations::set_underlying_stip_type(const char* value) {
  set_has_underlying_stip_type();
  if (underlying_stip_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_stip_type_ = new ::std::string;
  }
  underlying_stip_type_->assign(value);
}
inline void UnderlyingStipulations::set_underlying_stip_type(const char* value, size_t size) {
  set_has_underlying_stip_type();
  if (underlying_stip_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_stip_type_ = new ::std::string;
  }
  underlying_stip_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingStipulations::mutable_underlying_stip_type() {
  set_has_underlying_stip_type();
  if (underlying_stip_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_stip_type_ = new ::std::string;
  }
  return underlying_stip_type_;
}
inline ::std::string* UnderlyingStipulations::release_underlying_stip_type() {
  clear_has_underlying_stip_type();
  if (underlying_stip_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_stip_type_;
    underlying_stip_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingStipulations::set_allocated_underlying_stip_type(::std::string* underlying_stip_type) {
  if (underlying_stip_type_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_stip_type_;
  }
  if (underlying_stip_type) {
    set_has_underlying_stip_type();
    underlying_stip_type_ = underlying_stip_type;
  } else {
    clear_has_underlying_stip_type();
    underlying_stip_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_stip_value = 2;
inline bool UnderlyingStipulations::has_underlying_stip_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnderlyingStipulations::set_has_underlying_stip_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnderlyingStipulations::clear_has_underlying_stip_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnderlyingStipulations::clear_underlying_stip_value() {
  if (underlying_stip_value_ != &::google::protobuf::internal::kEmptyString) {
    underlying_stip_value_->clear();
  }
  clear_has_underlying_stip_value();
}
inline const ::std::string& UnderlyingStipulations::underlying_stip_value() const {
  return *underlying_stip_value_;
}
inline void UnderlyingStipulations::set_underlying_stip_value(const ::std::string& value) {
  set_has_underlying_stip_value();
  if (underlying_stip_value_ == &::google::protobuf::internal::kEmptyString) {
    underlying_stip_value_ = new ::std::string;
  }
  underlying_stip_value_->assign(value);
}
inline void UnderlyingStipulations::set_underlying_stip_value(const char* value) {
  set_has_underlying_stip_value();
  if (underlying_stip_value_ == &::google::protobuf::internal::kEmptyString) {
    underlying_stip_value_ = new ::std::string;
  }
  underlying_stip_value_->assign(value);
}
inline void UnderlyingStipulations::set_underlying_stip_value(const char* value, size_t size) {
  set_has_underlying_stip_value();
  if (underlying_stip_value_ == &::google::protobuf::internal::kEmptyString) {
    underlying_stip_value_ = new ::std::string;
  }
  underlying_stip_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingStipulations::mutable_underlying_stip_value() {
  set_has_underlying_stip_value();
  if (underlying_stip_value_ == &::google::protobuf::internal::kEmptyString) {
    underlying_stip_value_ = new ::std::string;
  }
  return underlying_stip_value_;
}
inline ::std::string* UnderlyingStipulations::release_underlying_stip_value() {
  clear_has_underlying_stip_value();
  if (underlying_stip_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_stip_value_;
    underlying_stip_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingStipulations::set_allocated_underlying_stip_value(::std::string* underlying_stip_value) {
  if (underlying_stip_value_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_stip_value_;
  }
  if (underlying_stip_value) {
    set_has_underlying_stip_value();
    underlying_stip_value_ = underlying_stip_value;
  } else {
    clear_has_underlying_stip_value();
    underlying_stip_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UndlyInstrumentPtysSubGrp

// optional string underlying_instrument_party_sub_id = 1;
inline bool UndlyInstrumentPtysSubGrp::has_underlying_instrument_party_sub_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndlyInstrumentPtysSubGrp::set_has_underlying_instrument_party_sub_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndlyInstrumentPtysSubGrp::clear_has_underlying_instrument_party_sub_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndlyInstrumentPtysSubGrp::clear_underlying_instrument_party_sub_id() {
  if (underlying_instrument_party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_sub_id_->clear();
  }
  clear_has_underlying_instrument_party_sub_id();
}
inline const ::std::string& UndlyInstrumentPtysSubGrp::underlying_instrument_party_sub_id() const {
  return *underlying_instrument_party_sub_id_;
}
inline void UndlyInstrumentPtysSubGrp::set_underlying_instrument_party_sub_id(const ::std::string& value) {
  set_has_underlying_instrument_party_sub_id();
  if (underlying_instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_sub_id_ = new ::std::string;
  }
  underlying_instrument_party_sub_id_->assign(value);
}
inline void UndlyInstrumentPtysSubGrp::set_underlying_instrument_party_sub_id(const char* value) {
  set_has_underlying_instrument_party_sub_id();
  if (underlying_instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_sub_id_ = new ::std::string;
  }
  underlying_instrument_party_sub_id_->assign(value);
}
inline void UndlyInstrumentPtysSubGrp::set_underlying_instrument_party_sub_id(const char* value, size_t size) {
  set_has_underlying_instrument_party_sub_id();
  if (underlying_instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_sub_id_ = new ::std::string;
  }
  underlying_instrument_party_sub_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UndlyInstrumentPtysSubGrp::mutable_underlying_instrument_party_sub_id() {
  set_has_underlying_instrument_party_sub_id();
  if (underlying_instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_sub_id_ = new ::std::string;
  }
  return underlying_instrument_party_sub_id_;
}
inline ::std::string* UndlyInstrumentPtysSubGrp::release_underlying_instrument_party_sub_id() {
  clear_has_underlying_instrument_party_sub_id();
  if (underlying_instrument_party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_instrument_party_sub_id_;
    underlying_instrument_party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UndlyInstrumentPtysSubGrp::set_allocated_underlying_instrument_party_sub_id(::std::string* underlying_instrument_party_sub_id) {
  if (underlying_instrument_party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_instrument_party_sub_id_;
  }
  if (underlying_instrument_party_sub_id) {
    set_has_underlying_instrument_party_sub_id();
    underlying_instrument_party_sub_id_ = underlying_instrument_party_sub_id;
  } else {
    clear_has_underlying_instrument_party_sub_id();
    underlying_instrument_party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 underlying_instrument_party_sub_id_type = 2;
inline bool UndlyInstrumentPtysSubGrp::has_underlying_instrument_party_sub_id_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndlyInstrumentPtysSubGrp::set_has_underlying_instrument_party_sub_id_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndlyInstrumentPtysSubGrp::clear_has_underlying_instrument_party_sub_id_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndlyInstrumentPtysSubGrp::clear_underlying_instrument_party_sub_id_type() {
  underlying_instrument_party_sub_id_type_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_instrument_party_sub_id_type();
}
inline ::google::protobuf::int64 UndlyInstrumentPtysSubGrp::underlying_instrument_party_sub_id_type() const {
  return underlying_instrument_party_sub_id_type_;
}
inline void UndlyInstrumentPtysSubGrp::set_underlying_instrument_party_sub_id_type(::google::protobuf::int64 value) {
  set_has_underlying_instrument_party_sub_id_type();
  underlying_instrument_party_sub_id_type_ = value;
}

// -------------------------------------------------------------------

// UndlyInstrumentParties

// optional string underlying_instrument_party_id = 1;
inline bool UndlyInstrumentParties::has_underlying_instrument_party_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndlyInstrumentParties::set_has_underlying_instrument_party_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndlyInstrumentParties::clear_has_underlying_instrument_party_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndlyInstrumentParties::clear_underlying_instrument_party_id() {
  if (underlying_instrument_party_id_ != &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_->clear();
  }
  clear_has_underlying_instrument_party_id();
}
inline const ::std::string& UndlyInstrumentParties::underlying_instrument_party_id() const {
  return *underlying_instrument_party_id_;
}
inline void UndlyInstrumentParties::set_underlying_instrument_party_id(const ::std::string& value) {
  set_has_underlying_instrument_party_id();
  if (underlying_instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_ = new ::std::string;
  }
  underlying_instrument_party_id_->assign(value);
}
inline void UndlyInstrumentParties::set_underlying_instrument_party_id(const char* value) {
  set_has_underlying_instrument_party_id();
  if (underlying_instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_ = new ::std::string;
  }
  underlying_instrument_party_id_->assign(value);
}
inline void UndlyInstrumentParties::set_underlying_instrument_party_id(const char* value, size_t size) {
  set_has_underlying_instrument_party_id();
  if (underlying_instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_ = new ::std::string;
  }
  underlying_instrument_party_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UndlyInstrumentParties::mutable_underlying_instrument_party_id() {
  set_has_underlying_instrument_party_id();
  if (underlying_instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_ = new ::std::string;
  }
  return underlying_instrument_party_id_;
}
inline ::std::string* UndlyInstrumentParties::release_underlying_instrument_party_id() {
  clear_has_underlying_instrument_party_id();
  if (underlying_instrument_party_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_instrument_party_id_;
    underlying_instrument_party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UndlyInstrumentParties::set_allocated_underlying_instrument_party_id(::std::string* underlying_instrument_party_id) {
  if (underlying_instrument_party_id_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_instrument_party_id_;
  }
  if (underlying_instrument_party_id) {
    set_has_underlying_instrument_party_id();
    underlying_instrument_party_id_ = underlying_instrument_party_id;
  } else {
    clear_has_underlying_instrument_party_id();
    underlying_instrument_party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_instrument_party_id_source = 2;
inline bool UndlyInstrumentParties::has_underlying_instrument_party_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UndlyInstrumentParties::set_has_underlying_instrument_party_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UndlyInstrumentParties::clear_has_underlying_instrument_party_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UndlyInstrumentParties::clear_underlying_instrument_party_id_source() {
  if (underlying_instrument_party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_source_->clear();
  }
  clear_has_underlying_instrument_party_id_source();
}
inline const ::std::string& UndlyInstrumentParties::underlying_instrument_party_id_source() const {
  return *underlying_instrument_party_id_source_;
}
inline void UndlyInstrumentParties::set_underlying_instrument_party_id_source(const ::std::string& value) {
  set_has_underlying_instrument_party_id_source();
  if (underlying_instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_source_ = new ::std::string;
  }
  underlying_instrument_party_id_source_->assign(value);
}
inline void UndlyInstrumentParties::set_underlying_instrument_party_id_source(const char* value) {
  set_has_underlying_instrument_party_id_source();
  if (underlying_instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_source_ = new ::std::string;
  }
  underlying_instrument_party_id_source_->assign(value);
}
inline void UndlyInstrumentParties::set_underlying_instrument_party_id_source(const char* value, size_t size) {
  set_has_underlying_instrument_party_id_source();
  if (underlying_instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_source_ = new ::std::string;
  }
  underlying_instrument_party_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UndlyInstrumentParties::mutable_underlying_instrument_party_id_source() {
  set_has_underlying_instrument_party_id_source();
  if (underlying_instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instrument_party_id_source_ = new ::std::string;
  }
  return underlying_instrument_party_id_source_;
}
inline ::std::string* UndlyInstrumentParties::release_underlying_instrument_party_id_source() {
  clear_has_underlying_instrument_party_id_source();
  if (underlying_instrument_party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_instrument_party_id_source_;
    underlying_instrument_party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UndlyInstrumentParties::set_allocated_underlying_instrument_party_id_source(::std::string* underlying_instrument_party_id_source) {
  if (underlying_instrument_party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_instrument_party_id_source_;
  }
  if (underlying_instrument_party_id_source) {
    set_has_underlying_instrument_party_id_source();
    underlying_instrument_party_id_source_ = underlying_instrument_party_id_source;
  } else {
    clear_has_underlying_instrument_party_id_source();
    underlying_instrument_party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 underlying_instrument_party_role = 3;
inline bool UndlyInstrumentParties::has_underlying_instrument_party_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UndlyInstrumentParties::set_has_underlying_instrument_party_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UndlyInstrumentParties::clear_has_underlying_instrument_party_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UndlyInstrumentParties::clear_underlying_instrument_party_role() {
  underlying_instrument_party_role_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_instrument_party_role();
}
inline ::google::protobuf::int64 UndlyInstrumentParties::underlying_instrument_party_role() const {
  return underlying_instrument_party_role_;
}
inline void UndlyInstrumentParties::set_underlying_instrument_party_role(::google::protobuf::int64 value) {
  set_has_underlying_instrument_party_role();
  underlying_instrument_party_role_ = value;
}

// repeated .Common.UndlyInstrumentPtysSubGrp undly_instrument_ptys_sub_grp = 4;
inline int UndlyInstrumentParties::undly_instrument_ptys_sub_grp_size() const {
  return undly_instrument_ptys_sub_grp_.size();
}
inline void UndlyInstrumentParties::clear_undly_instrument_ptys_sub_grp() {
  undly_instrument_ptys_sub_grp_.Clear();
}
inline const ::Common::UndlyInstrumentPtysSubGrp& UndlyInstrumentParties::undly_instrument_ptys_sub_grp(int index) const {
  return undly_instrument_ptys_sub_grp_.Get(index);
}
inline ::Common::UndlyInstrumentPtysSubGrp* UndlyInstrumentParties::mutable_undly_instrument_ptys_sub_grp(int index) {
  return undly_instrument_ptys_sub_grp_.Mutable(index);
}
inline ::Common::UndlyInstrumentPtysSubGrp* UndlyInstrumentParties::add_undly_instrument_ptys_sub_grp() {
  return undly_instrument_ptys_sub_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentPtysSubGrp >&
UndlyInstrumentParties::undly_instrument_ptys_sub_grp() const {
  return undly_instrument_ptys_sub_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentPtysSubGrp >*
UndlyInstrumentParties::mutable_undly_instrument_ptys_sub_grp() {
  return &undly_instrument_ptys_sub_grp_;
}

// -------------------------------------------------------------------

// UnderlyingFlowScheduleTypeUnion

// optional sfixed64 underlying_flow_schedule_type = 1;
inline bool UnderlyingFlowScheduleTypeUnion::has_underlying_flow_schedule_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnderlyingFlowScheduleTypeUnion::set_has_underlying_flow_schedule_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnderlyingFlowScheduleTypeUnion::clear_has_underlying_flow_schedule_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnderlyingFlowScheduleTypeUnion::clear_underlying_flow_schedule_type() {
  underlying_flow_schedule_type_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_flow_schedule_type();
}
inline ::google::protobuf::int64 UnderlyingFlowScheduleTypeUnion::underlying_flow_schedule_type() const {
  return underlying_flow_schedule_type_;
}
inline void UnderlyingFlowScheduleTypeUnion::set_underlying_flow_schedule_type(::google::protobuf::int64 value) {
  set_has_underlying_flow_schedule_type();
  underlying_flow_schedule_type_ = value;
}

// optional sfixed64 underlying_flow_schedule_type_sfixed64 = 2;
inline bool UnderlyingFlowScheduleTypeUnion::has_underlying_flow_schedule_type_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnderlyingFlowScheduleTypeUnion::set_has_underlying_flow_schedule_type_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnderlyingFlowScheduleTypeUnion::clear_has_underlying_flow_schedule_type_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnderlyingFlowScheduleTypeUnion::clear_underlying_flow_schedule_type_sfixed64() {
  underlying_flow_schedule_type_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_flow_schedule_type_sfixed64();
}
inline ::google::protobuf::int64 UnderlyingFlowScheduleTypeUnion::underlying_flow_schedule_type_sfixed64() const {
  return underlying_flow_schedule_type_sfixed64_;
}
inline void UnderlyingFlowScheduleTypeUnion::set_underlying_flow_schedule_type_sfixed64(::google::protobuf::int64 value) {
  set_has_underlying_flow_schedule_type_sfixed64();
  underlying_flow_schedule_type_sfixed64_ = value;
}

// -------------------------------------------------------------------

// UnderlyingInstrument

// optional bytes encoded_underlying_issuer = 1;
inline bool UnderlyingInstrument::has_encoded_underlying_issuer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnderlyingInstrument::set_has_encoded_underlying_issuer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnderlyingInstrument::clear_has_encoded_underlying_issuer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnderlyingInstrument::clear_encoded_underlying_issuer() {
  if (encoded_underlying_issuer_ != &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_issuer_->clear();
  }
  clear_has_encoded_underlying_issuer();
}
inline const ::std::string& UnderlyingInstrument::encoded_underlying_issuer() const {
  return *encoded_underlying_issuer_;
}
inline void UnderlyingInstrument::set_encoded_underlying_issuer(const ::std::string& value) {
  set_has_encoded_underlying_issuer();
  if (encoded_underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_issuer_ = new ::std::string;
  }
  encoded_underlying_issuer_->assign(value);
}
inline void UnderlyingInstrument::set_encoded_underlying_issuer(const char* value) {
  set_has_encoded_underlying_issuer();
  if (encoded_underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_issuer_ = new ::std::string;
  }
  encoded_underlying_issuer_->assign(value);
}
inline void UnderlyingInstrument::set_encoded_underlying_issuer(const void* value, size_t size) {
  set_has_encoded_underlying_issuer();
  if (encoded_underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_issuer_ = new ::std::string;
  }
  encoded_underlying_issuer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_encoded_underlying_issuer() {
  set_has_encoded_underlying_issuer();
  if (encoded_underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_issuer_ = new ::std::string;
  }
  return encoded_underlying_issuer_;
}
inline ::std::string* UnderlyingInstrument::release_encoded_underlying_issuer() {
  clear_has_encoded_underlying_issuer();
  if (encoded_underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_underlying_issuer_;
    encoded_underlying_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_encoded_underlying_issuer(::std::string* encoded_underlying_issuer) {
  if (encoded_underlying_issuer_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_underlying_issuer_;
  }
  if (encoded_underlying_issuer) {
    set_has_encoded_underlying_issuer();
    encoded_underlying_issuer_ = encoded_underlying_issuer;
  } else {
    clear_has_encoded_underlying_issuer();
    encoded_underlying_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_underlying_issuer_len = 2;
inline bool UnderlyingInstrument::has_encoded_underlying_issuer_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnderlyingInstrument::set_has_encoded_underlying_issuer_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnderlyingInstrument::clear_has_encoded_underlying_issuer_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnderlyingInstrument::clear_encoded_underlying_issuer_len() {
  encoded_underlying_issuer_len_ = 0u;
  clear_has_encoded_underlying_issuer_len();
}
inline ::google::protobuf::uint32 UnderlyingInstrument::encoded_underlying_issuer_len() const {
  return encoded_underlying_issuer_len_;
}
inline void UnderlyingInstrument::set_encoded_underlying_issuer_len(::google::protobuf::uint32 value) {
  set_has_encoded_underlying_issuer_len();
  encoded_underlying_issuer_len_ = value;
}

// optional bytes encoded_underlying_security_desc = 3;
inline bool UnderlyingInstrument::has_encoded_underlying_security_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnderlyingInstrument::set_has_encoded_underlying_security_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnderlyingInstrument::clear_has_encoded_underlying_security_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnderlyingInstrument::clear_encoded_underlying_security_desc() {
  if (encoded_underlying_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_security_desc_->clear();
  }
  clear_has_encoded_underlying_security_desc();
}
inline const ::std::string& UnderlyingInstrument::encoded_underlying_security_desc() const {
  return *encoded_underlying_security_desc_;
}
inline void UnderlyingInstrument::set_encoded_underlying_security_desc(const ::std::string& value) {
  set_has_encoded_underlying_security_desc();
  if (encoded_underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_security_desc_ = new ::std::string;
  }
  encoded_underlying_security_desc_->assign(value);
}
inline void UnderlyingInstrument::set_encoded_underlying_security_desc(const char* value) {
  set_has_encoded_underlying_security_desc();
  if (encoded_underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_security_desc_ = new ::std::string;
  }
  encoded_underlying_security_desc_->assign(value);
}
inline void UnderlyingInstrument::set_encoded_underlying_security_desc(const void* value, size_t size) {
  set_has_encoded_underlying_security_desc();
  if (encoded_underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_security_desc_ = new ::std::string;
  }
  encoded_underlying_security_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_encoded_underlying_security_desc() {
  set_has_encoded_underlying_security_desc();
  if (encoded_underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_underlying_security_desc_ = new ::std::string;
  }
  return encoded_underlying_security_desc_;
}
inline ::std::string* UnderlyingInstrument::release_encoded_underlying_security_desc() {
  clear_has_encoded_underlying_security_desc();
  if (encoded_underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_underlying_security_desc_;
    encoded_underlying_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_encoded_underlying_security_desc(::std::string* encoded_underlying_security_desc) {
  if (encoded_underlying_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_underlying_security_desc_;
  }
  if (encoded_underlying_security_desc) {
    set_has_encoded_underlying_security_desc();
    encoded_underlying_security_desc_ = encoded_underlying_security_desc;
  } else {
    clear_has_encoded_underlying_security_desc();
    encoded_underlying_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_underlying_security_desc_len = 4;
inline bool UnderlyingInstrument::has_encoded_underlying_security_desc_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnderlyingInstrument::set_has_encoded_underlying_security_desc_len() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnderlyingInstrument::clear_has_encoded_underlying_security_desc_len() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnderlyingInstrument::clear_encoded_underlying_security_desc_len() {
  encoded_underlying_security_desc_len_ = 0u;
  clear_has_encoded_underlying_security_desc_len();
}
inline ::google::protobuf::uint32 UnderlyingInstrument::encoded_underlying_security_desc_len() const {
  return encoded_underlying_security_desc_len_;
}
inline void UnderlyingInstrument::set_encoded_underlying_security_desc_len(::google::protobuf::uint32 value) {
  set_has_encoded_underlying_security_desc_len();
  encoded_underlying_security_desc_len_ = value;
}

// optional string underlying_cfi_code = 5;
inline bool UnderlyingInstrument::has_underlying_cfi_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_cfi_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UnderlyingInstrument::clear_has_underlying_cfi_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UnderlyingInstrument::clear_underlying_cfi_code() {
  if (underlying_cfi_code_ != &::google::protobuf::internal::kEmptyString) {
    underlying_cfi_code_->clear();
  }
  clear_has_underlying_cfi_code();
}
inline const ::std::string& UnderlyingInstrument::underlying_cfi_code() const {
  return *underlying_cfi_code_;
}
inline void UnderlyingInstrument::set_underlying_cfi_code(const ::std::string& value) {
  set_has_underlying_cfi_code();
  if (underlying_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cfi_code_ = new ::std::string;
  }
  underlying_cfi_code_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_cfi_code(const char* value) {
  set_has_underlying_cfi_code();
  if (underlying_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cfi_code_ = new ::std::string;
  }
  underlying_cfi_code_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_cfi_code(const char* value, size_t size) {
  set_has_underlying_cfi_code();
  if (underlying_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cfi_code_ = new ::std::string;
  }
  underlying_cfi_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_cfi_code() {
  set_has_underlying_cfi_code();
  if (underlying_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cfi_code_ = new ::std::string;
  }
  return underlying_cfi_code_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_cfi_code() {
  clear_has_underlying_cfi_code();
  if (underlying_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_cfi_code_;
    underlying_cfi_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_cfi_code(::std::string* underlying_cfi_code) {
  if (underlying_cfi_code_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_cfi_code_;
  }
  if (underlying_cfi_code) {
    set_has_underlying_cfi_code();
    underlying_cfi_code_ = underlying_cfi_code;
  } else {
    clear_has_underlying_cfi_code();
    underlying_cfi_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double underlying_contract_multiplier = 6;
inline bool UnderlyingInstrument::has_underlying_contract_multiplier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_contract_multiplier() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UnderlyingInstrument::clear_has_underlying_contract_multiplier() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UnderlyingInstrument::clear_underlying_contract_multiplier() {
  underlying_contract_multiplier_ = 0;
  clear_has_underlying_contract_multiplier();
}
inline double UnderlyingInstrument::underlying_contract_multiplier() const {
  return underlying_contract_multiplier_;
}
inline void UnderlyingInstrument::set_underlying_contract_multiplier(double value) {
  set_has_underlying_contract_multiplier();
  underlying_contract_multiplier_ = value;
}

// optional string underlying_country_of_issue = 7;
inline bool UnderlyingInstrument::has_underlying_country_of_issue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_country_of_issue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UnderlyingInstrument::clear_has_underlying_country_of_issue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UnderlyingInstrument::clear_underlying_country_of_issue() {
  if (underlying_country_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    underlying_country_of_issue_->clear();
  }
  clear_has_underlying_country_of_issue();
}
inline const ::std::string& UnderlyingInstrument::underlying_country_of_issue() const {
  return *underlying_country_of_issue_;
}
inline void UnderlyingInstrument::set_underlying_country_of_issue(const ::std::string& value) {
  set_has_underlying_country_of_issue();
  if (underlying_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_country_of_issue_ = new ::std::string;
  }
  underlying_country_of_issue_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_country_of_issue(const char* value) {
  set_has_underlying_country_of_issue();
  if (underlying_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_country_of_issue_ = new ::std::string;
  }
  underlying_country_of_issue_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_country_of_issue(const char* value, size_t size) {
  set_has_underlying_country_of_issue();
  if (underlying_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_country_of_issue_ = new ::std::string;
  }
  underlying_country_of_issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_country_of_issue() {
  set_has_underlying_country_of_issue();
  if (underlying_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_country_of_issue_ = new ::std::string;
  }
  return underlying_country_of_issue_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_country_of_issue() {
  clear_has_underlying_country_of_issue();
  if (underlying_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_country_of_issue_;
    underlying_country_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_country_of_issue(::std::string* underlying_country_of_issue) {
  if (underlying_country_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_country_of_issue_;
  }
  if (underlying_country_of_issue) {
    set_has_underlying_country_of_issue();
    underlying_country_of_issue_ = underlying_country_of_issue;
  } else {
    clear_has_underlying_country_of_issue();
    underlying_country_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 underlying_coupon_payment_date = 8;
inline bool UnderlyingInstrument::has_underlying_coupon_payment_date() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_coupon_payment_date() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UnderlyingInstrument::clear_has_underlying_coupon_payment_date() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UnderlyingInstrument::clear_underlying_coupon_payment_date() {
  underlying_coupon_payment_date_ = 0;
  clear_has_underlying_coupon_payment_date();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_coupon_payment_date() const {
  return underlying_coupon_payment_date_;
}
inline void UnderlyingInstrument::set_underlying_coupon_payment_date(::google::protobuf::int32 value) {
  set_has_underlying_coupon_payment_date();
  underlying_coupon_payment_date_ = value;
}

// optional sfixed64 underlying_coupon_rate = 9;
inline bool UnderlyingInstrument::has_underlying_coupon_rate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_coupon_rate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UnderlyingInstrument::clear_has_underlying_coupon_rate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UnderlyingInstrument::clear_underlying_coupon_rate() {
  underlying_coupon_rate_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_coupon_rate();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_coupon_rate() const {
  return underlying_coupon_rate_;
}
inline void UnderlyingInstrument::set_underlying_coupon_rate(::google::protobuf::int64 value) {
  set_has_underlying_coupon_rate();
  underlying_coupon_rate_ = value;
}

// optional sfixed32 underlying_coupon_rate_exponent = 10;
inline bool UnderlyingInstrument::has_underlying_coupon_rate_exponent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_coupon_rate_exponent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UnderlyingInstrument::clear_has_underlying_coupon_rate_exponent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UnderlyingInstrument::clear_underlying_coupon_rate_exponent() {
  underlying_coupon_rate_exponent_ = 0;
  clear_has_underlying_coupon_rate_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_coupon_rate_exponent() const {
  return underlying_coupon_rate_exponent_;
}
inline void UnderlyingInstrument::set_underlying_coupon_rate_exponent(::google::protobuf::int32 value) {
  set_has_underlying_coupon_rate_exponent();
  underlying_coupon_rate_exponent_ = value;
}

// optional string underlying_credit_rating = 11;
inline bool UnderlyingInstrument::has_underlying_credit_rating() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_credit_rating() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UnderlyingInstrument::clear_has_underlying_credit_rating() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UnderlyingInstrument::clear_underlying_credit_rating() {
  if (underlying_credit_rating_ != &::google::protobuf::internal::kEmptyString) {
    underlying_credit_rating_->clear();
  }
  clear_has_underlying_credit_rating();
}
inline const ::std::string& UnderlyingInstrument::underlying_credit_rating() const {
  return *underlying_credit_rating_;
}
inline void UnderlyingInstrument::set_underlying_credit_rating(const ::std::string& value) {
  set_has_underlying_credit_rating();
  if (underlying_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    underlying_credit_rating_ = new ::std::string;
  }
  underlying_credit_rating_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_credit_rating(const char* value) {
  set_has_underlying_credit_rating();
  if (underlying_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    underlying_credit_rating_ = new ::std::string;
  }
  underlying_credit_rating_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_credit_rating(const char* value, size_t size) {
  set_has_underlying_credit_rating();
  if (underlying_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    underlying_credit_rating_ = new ::std::string;
  }
  underlying_credit_rating_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_credit_rating() {
  set_has_underlying_credit_rating();
  if (underlying_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    underlying_credit_rating_ = new ::std::string;
  }
  return underlying_credit_rating_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_credit_rating() {
  clear_has_underlying_credit_rating();
  if (underlying_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_credit_rating_;
    underlying_credit_rating_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_credit_rating(::std::string* underlying_credit_rating) {
  if (underlying_credit_rating_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_credit_rating_;
  }
  if (underlying_credit_rating) {
    set_has_underlying_credit_rating();
    underlying_credit_rating_ = underlying_credit_rating;
  } else {
    clear_has_underlying_credit_rating();
    underlying_credit_rating_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double underlying_factor = 12;
inline bool UnderlyingInstrument::has_underlying_factor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_factor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UnderlyingInstrument::clear_has_underlying_factor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UnderlyingInstrument::clear_underlying_factor() {
  underlying_factor_ = 0;
  clear_has_underlying_factor();
}
inline double UnderlyingInstrument::underlying_factor() const {
  return underlying_factor_;
}
inline void UnderlyingInstrument::set_underlying_factor(double value) {
  set_has_underlying_factor();
  underlying_factor_ = value;
}

// optional string underlying_instr_registry = 13;
inline bool UnderlyingInstrument::has_underlying_instr_registry() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_instr_registry() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UnderlyingInstrument::clear_has_underlying_instr_registry() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UnderlyingInstrument::clear_underlying_instr_registry() {
  if (underlying_instr_registry_ != &::google::protobuf::internal::kEmptyString) {
    underlying_instr_registry_->clear();
  }
  clear_has_underlying_instr_registry();
}
inline const ::std::string& UnderlyingInstrument::underlying_instr_registry() const {
  return *underlying_instr_registry_;
}
inline void UnderlyingInstrument::set_underlying_instr_registry(const ::std::string& value) {
  set_has_underlying_instr_registry();
  if (underlying_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instr_registry_ = new ::std::string;
  }
  underlying_instr_registry_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_instr_registry(const char* value) {
  set_has_underlying_instr_registry();
  if (underlying_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instr_registry_ = new ::std::string;
  }
  underlying_instr_registry_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_instr_registry(const char* value, size_t size) {
  set_has_underlying_instr_registry();
  if (underlying_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instr_registry_ = new ::std::string;
  }
  underlying_instr_registry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_instr_registry() {
  set_has_underlying_instr_registry();
  if (underlying_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    underlying_instr_registry_ = new ::std::string;
  }
  return underlying_instr_registry_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_instr_registry() {
  clear_has_underlying_instr_registry();
  if (underlying_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_instr_registry_;
    underlying_instr_registry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_instr_registry(::std::string* underlying_instr_registry) {
  if (underlying_instr_registry_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_instr_registry_;
  }
  if (underlying_instr_registry) {
    set_has_underlying_instr_registry();
    underlying_instr_registry_ = underlying_instr_registry;
  } else {
    clear_has_underlying_instr_registry();
    underlying_instr_registry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 underlying_issue_date = 14;
inline bool UnderlyingInstrument::has_underlying_issue_date() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_issue_date() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UnderlyingInstrument::clear_has_underlying_issue_date() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UnderlyingInstrument::clear_underlying_issue_date() {
  underlying_issue_date_ = 0;
  clear_has_underlying_issue_date();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_issue_date() const {
  return underlying_issue_date_;
}
inline void UnderlyingInstrument::set_underlying_issue_date(::google::protobuf::int32 value) {
  set_has_underlying_issue_date();
  underlying_issue_date_ = value;
}

// optional string underlying_issuer = 15;
inline bool UnderlyingInstrument::has_underlying_issuer() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_issuer() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UnderlyingInstrument::clear_has_underlying_issuer() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UnderlyingInstrument::clear_underlying_issuer() {
  if (underlying_issuer_ != &::google::protobuf::internal::kEmptyString) {
    underlying_issuer_->clear();
  }
  clear_has_underlying_issuer();
}
inline const ::std::string& UnderlyingInstrument::underlying_issuer() const {
  return *underlying_issuer_;
}
inline void UnderlyingInstrument::set_underlying_issuer(const ::std::string& value) {
  set_has_underlying_issuer();
  if (underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    underlying_issuer_ = new ::std::string;
  }
  underlying_issuer_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_issuer(const char* value) {
  set_has_underlying_issuer();
  if (underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    underlying_issuer_ = new ::std::string;
  }
  underlying_issuer_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_issuer(const char* value, size_t size) {
  set_has_underlying_issuer();
  if (underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    underlying_issuer_ = new ::std::string;
  }
  underlying_issuer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_issuer() {
  set_has_underlying_issuer();
  if (underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    underlying_issuer_ = new ::std::string;
  }
  return underlying_issuer_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_issuer() {
  clear_has_underlying_issuer();
  if (underlying_issuer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_issuer_;
    underlying_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_issuer(::std::string* underlying_issuer) {
  if (underlying_issuer_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_issuer_;
  }
  if (underlying_issuer) {
    set_has_underlying_issuer();
    underlying_issuer_ = underlying_issuer;
  } else {
    clear_has_underlying_issuer();
    underlying_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_locale_of_issue = 16;
inline bool UnderlyingInstrument::has_underlying_locale_of_issue() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_locale_of_issue() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UnderlyingInstrument::clear_has_underlying_locale_of_issue() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UnderlyingInstrument::clear_underlying_locale_of_issue() {
  if (underlying_locale_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    underlying_locale_of_issue_->clear();
  }
  clear_has_underlying_locale_of_issue();
}
inline const ::std::string& UnderlyingInstrument::underlying_locale_of_issue() const {
  return *underlying_locale_of_issue_;
}
inline void UnderlyingInstrument::set_underlying_locale_of_issue(const ::std::string& value) {
  set_has_underlying_locale_of_issue();
  if (underlying_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_locale_of_issue_ = new ::std::string;
  }
  underlying_locale_of_issue_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_locale_of_issue(const char* value) {
  set_has_underlying_locale_of_issue();
  if (underlying_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_locale_of_issue_ = new ::std::string;
  }
  underlying_locale_of_issue_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_locale_of_issue(const char* value, size_t size) {
  set_has_underlying_locale_of_issue();
  if (underlying_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_locale_of_issue_ = new ::std::string;
  }
  underlying_locale_of_issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_locale_of_issue() {
  set_has_underlying_locale_of_issue();
  if (underlying_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_locale_of_issue_ = new ::std::string;
  }
  return underlying_locale_of_issue_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_locale_of_issue() {
  clear_has_underlying_locale_of_issue();
  if (underlying_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_locale_of_issue_;
    underlying_locale_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_locale_of_issue(::std::string* underlying_locale_of_issue) {
  if (underlying_locale_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_locale_of_issue_;
  }
  if (underlying_locale_of_issue) {
    set_has_underlying_locale_of_issue();
    underlying_locale_of_issue_ = underlying_locale_of_issue;
  } else {
    clear_has_underlying_locale_of_issue();
    underlying_locale_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 underlying_maturity_date = 17;
inline bool UnderlyingInstrument::has_underlying_maturity_date() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_maturity_date() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UnderlyingInstrument::clear_has_underlying_maturity_date() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UnderlyingInstrument::clear_underlying_maturity_date() {
  underlying_maturity_date_ = 0;
  clear_has_underlying_maturity_date();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_maturity_date() const {
  return underlying_maturity_date_;
}
inline void UnderlyingInstrument::set_underlying_maturity_date(::google::protobuf::int32 value) {
  set_has_underlying_maturity_date();
  underlying_maturity_date_ = value;
}

// optional sfixed32 underlying_maturity_month_year = 18;
inline bool UnderlyingInstrument::has_underlying_maturity_month_year() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_maturity_month_year() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UnderlyingInstrument::clear_has_underlying_maturity_month_year() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UnderlyingInstrument::clear_underlying_maturity_month_year() {
  underlying_maturity_month_year_ = 0;
  clear_has_underlying_maturity_month_year();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_maturity_month_year() const {
  return underlying_maturity_month_year_;
}
inline void UnderlyingInstrument::set_underlying_maturity_month_year(::google::protobuf::int32 value) {
  set_has_underlying_maturity_month_year();
  underlying_maturity_month_year_ = value;
}

// optional string underlying_opt_attribute = 19;
inline bool UnderlyingInstrument::has_underlying_opt_attribute() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_opt_attribute() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UnderlyingInstrument::clear_has_underlying_opt_attribute() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UnderlyingInstrument::clear_underlying_opt_attribute() {
  if (underlying_opt_attribute_ != &::google::protobuf::internal::kEmptyString) {
    underlying_opt_attribute_->clear();
  }
  clear_has_underlying_opt_attribute();
}
inline const ::std::string& UnderlyingInstrument::underlying_opt_attribute() const {
  return *underlying_opt_attribute_;
}
inline void UnderlyingInstrument::set_underlying_opt_attribute(const ::std::string& value) {
  set_has_underlying_opt_attribute();
  if (underlying_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    underlying_opt_attribute_ = new ::std::string;
  }
  underlying_opt_attribute_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_opt_attribute(const char* value) {
  set_has_underlying_opt_attribute();
  if (underlying_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    underlying_opt_attribute_ = new ::std::string;
  }
  underlying_opt_attribute_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_opt_attribute(const char* value, size_t size) {
  set_has_underlying_opt_attribute();
  if (underlying_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    underlying_opt_attribute_ = new ::std::string;
  }
  underlying_opt_attribute_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_opt_attribute() {
  set_has_underlying_opt_attribute();
  if (underlying_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    underlying_opt_attribute_ = new ::std::string;
  }
  return underlying_opt_attribute_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_opt_attribute() {
  clear_has_underlying_opt_attribute();
  if (underlying_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_opt_attribute_;
    underlying_opt_attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_opt_attribute(::std::string* underlying_opt_attribute) {
  if (underlying_opt_attribute_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_opt_attribute_;
  }
  if (underlying_opt_attribute) {
    set_has_underlying_opt_attribute();
    underlying_opt_attribute_ = underlying_opt_attribute;
  } else {
    clear_has_underlying_opt_attribute();
    underlying_opt_attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 underlying_product = 20;
inline bool UnderlyingInstrument::has_underlying_product() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_product() {
  _has_bits_[0] |= 0x00080000u;
}
inline void UnderlyingInstrument::clear_has_underlying_product() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void UnderlyingInstrument::clear_underlying_product() {
  underlying_product_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_product();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_product() const {
  return underlying_product_;
}
inline void UnderlyingInstrument::set_underlying_product(::google::protobuf::int64 value) {
  set_has_underlying_product();
  underlying_product_ = value;
}

// optional sfixed64 underlying_put_or_call = 21;
inline bool UnderlyingInstrument::has_underlying_put_or_call() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_put_or_call() {
  _has_bits_[0] |= 0x00100000u;
}
inline void UnderlyingInstrument::clear_has_underlying_put_or_call() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void UnderlyingInstrument::clear_underlying_put_or_call() {
  underlying_put_or_call_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_put_or_call();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_put_or_call() const {
  return underlying_put_or_call_;
}
inline void UnderlyingInstrument::set_underlying_put_or_call(::google::protobuf::int64 value) {
  set_has_underlying_put_or_call();
  underlying_put_or_call_ = value;
}

// optional sfixed32 underlying_redemption_date = 22;
inline bool UnderlyingInstrument::has_underlying_redemption_date() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_redemption_date() {
  _has_bits_[0] |= 0x00200000u;
}
inline void UnderlyingInstrument::clear_has_underlying_redemption_date() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void UnderlyingInstrument::clear_underlying_redemption_date() {
  underlying_redemption_date_ = 0;
  clear_has_underlying_redemption_date();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_redemption_date() const {
  return underlying_redemption_date_;
}
inline void UnderlyingInstrument::set_underlying_redemption_date(::google::protobuf::int32 value) {
  set_has_underlying_redemption_date();
  underlying_redemption_date_ = value;
}

// optional string underlying_repo_collateral_security_type = 23;
inline bool UnderlyingInstrument::has_underlying_repo_collateral_security_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_repo_collateral_security_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void UnderlyingInstrument::clear_has_underlying_repo_collateral_security_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void UnderlyingInstrument::clear_underlying_repo_collateral_security_type() {
  if (underlying_repo_collateral_security_type_ != &::google::protobuf::internal::kEmptyString) {
    underlying_repo_collateral_security_type_->clear();
  }
  clear_has_underlying_repo_collateral_security_type();
}
inline const ::std::string& UnderlyingInstrument::underlying_repo_collateral_security_type() const {
  return *underlying_repo_collateral_security_type_;
}
inline void UnderlyingInstrument::set_underlying_repo_collateral_security_type(const ::std::string& value) {
  set_has_underlying_repo_collateral_security_type();
  if (underlying_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_repo_collateral_security_type_ = new ::std::string;
  }
  underlying_repo_collateral_security_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_repo_collateral_security_type(const char* value) {
  set_has_underlying_repo_collateral_security_type();
  if (underlying_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_repo_collateral_security_type_ = new ::std::string;
  }
  underlying_repo_collateral_security_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_repo_collateral_security_type(const char* value, size_t size) {
  set_has_underlying_repo_collateral_security_type();
  if (underlying_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_repo_collateral_security_type_ = new ::std::string;
  }
  underlying_repo_collateral_security_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_repo_collateral_security_type() {
  set_has_underlying_repo_collateral_security_type();
  if (underlying_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_repo_collateral_security_type_ = new ::std::string;
  }
  return underlying_repo_collateral_security_type_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_repo_collateral_security_type() {
  clear_has_underlying_repo_collateral_security_type();
  if (underlying_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_repo_collateral_security_type_;
    underlying_repo_collateral_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_repo_collateral_security_type(::std::string* underlying_repo_collateral_security_type) {
  if (underlying_repo_collateral_security_type_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_repo_collateral_security_type_;
  }
  if (underlying_repo_collateral_security_type) {
    set_has_underlying_repo_collateral_security_type();
    underlying_repo_collateral_security_type_ = underlying_repo_collateral_security_type;
  } else {
    clear_has_underlying_repo_collateral_security_type();
    underlying_repo_collateral_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 underlying_repurchase_rate = 24;
inline bool UnderlyingInstrument::has_underlying_repurchase_rate() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_repurchase_rate() {
  _has_bits_[0] |= 0x00800000u;
}
inline void UnderlyingInstrument::clear_has_underlying_repurchase_rate() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void UnderlyingInstrument::clear_underlying_repurchase_rate() {
  underlying_repurchase_rate_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_repurchase_rate();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_repurchase_rate() const {
  return underlying_repurchase_rate_;
}
inline void UnderlyingInstrument::set_underlying_repurchase_rate(::google::protobuf::int64 value) {
  set_has_underlying_repurchase_rate();
  underlying_repurchase_rate_ = value;
}

// optional sfixed32 underlying_repurchase_rate_exponent = 25;
inline bool UnderlyingInstrument::has_underlying_repurchase_rate_exponent() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_repurchase_rate_exponent() {
  _has_bits_[0] |= 0x01000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_repurchase_rate_exponent() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void UnderlyingInstrument::clear_underlying_repurchase_rate_exponent() {
  underlying_repurchase_rate_exponent_ = 0;
  clear_has_underlying_repurchase_rate_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_repurchase_rate_exponent() const {
  return underlying_repurchase_rate_exponent_;
}
inline void UnderlyingInstrument::set_underlying_repurchase_rate_exponent(::google::protobuf::int32 value) {
  set_has_underlying_repurchase_rate_exponent();
  underlying_repurchase_rate_exponent_ = value;
}

// optional sfixed64 underlying_repurchase_term = 26;
inline bool UnderlyingInstrument::has_underlying_repurchase_term() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_repurchase_term() {
  _has_bits_[0] |= 0x02000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_repurchase_term() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void UnderlyingInstrument::clear_underlying_repurchase_term() {
  underlying_repurchase_term_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_repurchase_term();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_repurchase_term() const {
  return underlying_repurchase_term_;
}
inline void UnderlyingInstrument::set_underlying_repurchase_term(::google::protobuf::int64 value) {
  set_has_underlying_repurchase_term();
  underlying_repurchase_term_ = value;
}

// optional string underlying_security_desc = 27;
inline bool UnderlyingInstrument::has_underlying_security_desc() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_security_desc() {
  _has_bits_[0] |= 0x04000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_security_desc() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void UnderlyingInstrument::clear_underlying_security_desc() {
  if (underlying_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    underlying_security_desc_->clear();
  }
  clear_has_underlying_security_desc();
}
inline const ::std::string& UnderlyingInstrument::underlying_security_desc() const {
  return *underlying_security_desc_;
}
inline void UnderlyingInstrument::set_underlying_security_desc(const ::std::string& value) {
  set_has_underlying_security_desc();
  if (underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_desc_ = new ::std::string;
  }
  underlying_security_desc_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_desc(const char* value) {
  set_has_underlying_security_desc();
  if (underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_desc_ = new ::std::string;
  }
  underlying_security_desc_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_desc(const char* value, size_t size) {
  set_has_underlying_security_desc();
  if (underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_desc_ = new ::std::string;
  }
  underlying_security_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_security_desc() {
  set_has_underlying_security_desc();
  if (underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_desc_ = new ::std::string;
  }
  return underlying_security_desc_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_security_desc() {
  clear_has_underlying_security_desc();
  if (underlying_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_security_desc_;
    underlying_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_security_desc(::std::string* underlying_security_desc) {
  if (underlying_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_security_desc_;
  }
  if (underlying_security_desc) {
    set_has_underlying_security_desc();
    underlying_security_desc_ = underlying_security_desc;
  } else {
    clear_has_underlying_security_desc();
    underlying_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_security_exchange = 28;
inline bool UnderlyingInstrument::has_underlying_security_exchange() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_security_exchange() {
  _has_bits_[0] |= 0x08000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_security_exchange() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void UnderlyingInstrument::clear_underlying_security_exchange() {
  if (underlying_security_exchange_ != &::google::protobuf::internal::kEmptyString) {
    underlying_security_exchange_->clear();
  }
  clear_has_underlying_security_exchange();
}
inline const ::std::string& UnderlyingInstrument::underlying_security_exchange() const {
  return *underlying_security_exchange_;
}
inline void UnderlyingInstrument::set_underlying_security_exchange(const ::std::string& value) {
  set_has_underlying_security_exchange();
  if (underlying_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_exchange_ = new ::std::string;
  }
  underlying_security_exchange_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_exchange(const char* value) {
  set_has_underlying_security_exchange();
  if (underlying_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_exchange_ = new ::std::string;
  }
  underlying_security_exchange_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_exchange(const char* value, size_t size) {
  set_has_underlying_security_exchange();
  if (underlying_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_exchange_ = new ::std::string;
  }
  underlying_security_exchange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_security_exchange() {
  set_has_underlying_security_exchange();
  if (underlying_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_exchange_ = new ::std::string;
  }
  return underlying_security_exchange_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_security_exchange() {
  clear_has_underlying_security_exchange();
  if (underlying_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_security_exchange_;
    underlying_security_exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_security_exchange(::std::string* underlying_security_exchange) {
  if (underlying_security_exchange_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_security_exchange_;
  }
  if (underlying_security_exchange) {
    set_has_underlying_security_exchange();
    underlying_security_exchange_ = underlying_security_exchange;
  } else {
    clear_has_underlying_security_exchange();
    underlying_security_exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_security_id = 29;
inline bool UnderlyingInstrument::has_underlying_security_id() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_security_id() {
  _has_bits_[0] |= 0x10000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_security_id() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void UnderlyingInstrument::clear_underlying_security_id() {
  if (underlying_security_id_ != &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_->clear();
  }
  clear_has_underlying_security_id();
}
inline const ::std::string& UnderlyingInstrument::underlying_security_id() const {
  return *underlying_security_id_;
}
inline void UnderlyingInstrument::set_underlying_security_id(const ::std::string& value) {
  set_has_underlying_security_id();
  if (underlying_security_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_ = new ::std::string;
  }
  underlying_security_id_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_id(const char* value) {
  set_has_underlying_security_id();
  if (underlying_security_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_ = new ::std::string;
  }
  underlying_security_id_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_id(const char* value, size_t size) {
  set_has_underlying_security_id();
  if (underlying_security_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_ = new ::std::string;
  }
  underlying_security_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_security_id() {
  set_has_underlying_security_id();
  if (underlying_security_id_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_ = new ::std::string;
  }
  return underlying_security_id_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_security_id() {
  clear_has_underlying_security_id();
  if (underlying_security_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_security_id_;
    underlying_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_security_id(::std::string* underlying_security_id) {
  if (underlying_security_id_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_security_id_;
  }
  if (underlying_security_id) {
    set_has_underlying_security_id();
    underlying_security_id_ = underlying_security_id;
  } else {
    clear_has_underlying_security_id();
    underlying_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_security_id_source = 30;
inline bool UnderlyingInstrument::has_underlying_security_id_source() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_security_id_source() {
  _has_bits_[0] |= 0x20000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_security_id_source() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void UnderlyingInstrument::clear_underlying_security_id_source() {
  if (underlying_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_source_->clear();
  }
  clear_has_underlying_security_id_source();
}
inline const ::std::string& UnderlyingInstrument::underlying_security_id_source() const {
  return *underlying_security_id_source_;
}
inline void UnderlyingInstrument::set_underlying_security_id_source(const ::std::string& value) {
  set_has_underlying_security_id_source();
  if (underlying_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_source_ = new ::std::string;
  }
  underlying_security_id_source_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_id_source(const char* value) {
  set_has_underlying_security_id_source();
  if (underlying_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_source_ = new ::std::string;
  }
  underlying_security_id_source_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_id_source(const char* value, size_t size) {
  set_has_underlying_security_id_source();
  if (underlying_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_source_ = new ::std::string;
  }
  underlying_security_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_security_id_source() {
  set_has_underlying_security_id_source();
  if (underlying_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_id_source_ = new ::std::string;
  }
  return underlying_security_id_source_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_security_id_source() {
  clear_has_underlying_security_id_source();
  if (underlying_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_security_id_source_;
    underlying_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_security_id_source(::std::string* underlying_security_id_source) {
  if (underlying_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_security_id_source_;
  }
  if (underlying_security_id_source) {
    set_has_underlying_security_id_source();
    underlying_security_id_source_ = underlying_security_id_source;
  } else {
    clear_has_underlying_security_id_source();
    underlying_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_security_type = 31;
inline bool UnderlyingInstrument::has_underlying_security_type() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_security_type() {
  _has_bits_[0] |= 0x40000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_security_type() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void UnderlyingInstrument::clear_underlying_security_type() {
  if (underlying_security_type_ != &::google::protobuf::internal::kEmptyString) {
    underlying_security_type_->clear();
  }
  clear_has_underlying_security_type();
}
inline const ::std::string& UnderlyingInstrument::underlying_security_type() const {
  return *underlying_security_type_;
}
inline void UnderlyingInstrument::set_underlying_security_type(const ::std::string& value) {
  set_has_underlying_security_type();
  if (underlying_security_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_type_ = new ::std::string;
  }
  underlying_security_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_type(const char* value) {
  set_has_underlying_security_type();
  if (underlying_security_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_type_ = new ::std::string;
  }
  underlying_security_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_type(const char* value, size_t size) {
  set_has_underlying_security_type();
  if (underlying_security_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_type_ = new ::std::string;
  }
  underlying_security_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_security_type() {
  set_has_underlying_security_type();
  if (underlying_security_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_type_ = new ::std::string;
  }
  return underlying_security_type_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_security_type() {
  clear_has_underlying_security_type();
  if (underlying_security_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_security_type_;
    underlying_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_security_type(::std::string* underlying_security_type) {
  if (underlying_security_type_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_security_type_;
  }
  if (underlying_security_type) {
    set_has_underlying_security_type();
    underlying_security_type_ = underlying_security_type;
  } else {
    clear_has_underlying_security_type();
    underlying_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_state_or_province_of_issue = 32;
inline bool UnderlyingInstrument::has_underlying_state_or_province_of_issue() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_state_or_province_of_issue() {
  _has_bits_[0] |= 0x80000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_state_or_province_of_issue() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void UnderlyingInstrument::clear_underlying_state_or_province_of_issue() {
  if (underlying_state_or_province_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    underlying_state_or_province_of_issue_->clear();
  }
  clear_has_underlying_state_or_province_of_issue();
}
inline const ::std::string& UnderlyingInstrument::underlying_state_or_province_of_issue() const {
  return *underlying_state_or_province_of_issue_;
}
inline void UnderlyingInstrument::set_underlying_state_or_province_of_issue(const ::std::string& value) {
  set_has_underlying_state_or_province_of_issue();
  if (underlying_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_state_or_province_of_issue_ = new ::std::string;
  }
  underlying_state_or_province_of_issue_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_state_or_province_of_issue(const char* value) {
  set_has_underlying_state_or_province_of_issue();
  if (underlying_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_state_or_province_of_issue_ = new ::std::string;
  }
  underlying_state_or_province_of_issue_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_state_or_province_of_issue(const char* value, size_t size) {
  set_has_underlying_state_or_province_of_issue();
  if (underlying_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_state_or_province_of_issue_ = new ::std::string;
  }
  underlying_state_or_province_of_issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_state_or_province_of_issue() {
  set_has_underlying_state_or_province_of_issue();
  if (underlying_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    underlying_state_or_province_of_issue_ = new ::std::string;
  }
  return underlying_state_or_province_of_issue_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_state_or_province_of_issue() {
  clear_has_underlying_state_or_province_of_issue();
  if (underlying_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_state_or_province_of_issue_;
    underlying_state_or_province_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_state_or_province_of_issue(::std::string* underlying_state_or_province_of_issue) {
  if (underlying_state_or_province_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_state_or_province_of_issue_;
  }
  if (underlying_state_or_province_of_issue) {
    set_has_underlying_state_or_province_of_issue();
    underlying_state_or_province_of_issue_ = underlying_state_or_province_of_issue;
  } else {
    clear_has_underlying_state_or_province_of_issue();
    underlying_state_or_province_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 underlying_strike_price = 33;
inline bool UnderlyingInstrument::has_underlying_strike_price() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_strike_price() {
  _has_bits_[1] |= 0x00000001u;
}
inline void UnderlyingInstrument::clear_has_underlying_strike_price() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void UnderlyingInstrument::clear_underlying_strike_price() {
  underlying_strike_price_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_strike_price();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_strike_price() const {
  return underlying_strike_price_;
}
inline void UnderlyingInstrument::set_underlying_strike_price(::google::protobuf::int64 value) {
  set_has_underlying_strike_price();
  underlying_strike_price_ = value;
}

// optional sfixed32 underlying_strike_price_exponent = 34;
inline bool UnderlyingInstrument::has_underlying_strike_price_exponent() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_strike_price_exponent() {
  _has_bits_[1] |= 0x00000002u;
}
inline void UnderlyingInstrument::clear_has_underlying_strike_price_exponent() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void UnderlyingInstrument::clear_underlying_strike_price_exponent() {
  underlying_strike_price_exponent_ = 0;
  clear_has_underlying_strike_price_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_strike_price_exponent() const {
  return underlying_strike_price_exponent_;
}
inline void UnderlyingInstrument::set_underlying_strike_price_exponent(::google::protobuf::int32 value) {
  set_has_underlying_strike_price_exponent();
  underlying_strike_price_exponent_ = value;
}

// optional string underlying_symbol = 35;
inline bool UnderlyingInstrument::has_underlying_symbol() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_symbol() {
  _has_bits_[1] |= 0x00000004u;
}
inline void UnderlyingInstrument::clear_has_underlying_symbol() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void UnderlyingInstrument::clear_underlying_symbol() {
  if (underlying_symbol_ != &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_->clear();
  }
  clear_has_underlying_symbol();
}
inline const ::std::string& UnderlyingInstrument::underlying_symbol() const {
  return *underlying_symbol_;
}
inline void UnderlyingInstrument::set_underlying_symbol(const ::std::string& value) {
  set_has_underlying_symbol();
  if (underlying_symbol_ == &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_ = new ::std::string;
  }
  underlying_symbol_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_symbol(const char* value) {
  set_has_underlying_symbol();
  if (underlying_symbol_ == &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_ = new ::std::string;
  }
  underlying_symbol_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_symbol(const char* value, size_t size) {
  set_has_underlying_symbol();
  if (underlying_symbol_ == &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_ = new ::std::string;
  }
  underlying_symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_symbol() {
  set_has_underlying_symbol();
  if (underlying_symbol_ == &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_ = new ::std::string;
  }
  return underlying_symbol_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_symbol() {
  clear_has_underlying_symbol();
  if (underlying_symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_symbol_;
    underlying_symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_symbol(::std::string* underlying_symbol) {
  if (underlying_symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_symbol_;
  }
  if (underlying_symbol) {
    set_has_underlying_symbol();
    underlying_symbol_ = underlying_symbol;
  } else {
    clear_has_underlying_symbol();
    underlying_symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_symbol_sfx = 36;
inline bool UnderlyingInstrument::has_underlying_symbol_sfx() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_symbol_sfx() {
  _has_bits_[1] |= 0x00000008u;
}
inline void UnderlyingInstrument::clear_has_underlying_symbol_sfx() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void UnderlyingInstrument::clear_underlying_symbol_sfx() {
  if (underlying_symbol_sfx_ != &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_sfx_->clear();
  }
  clear_has_underlying_symbol_sfx();
}
inline const ::std::string& UnderlyingInstrument::underlying_symbol_sfx() const {
  return *underlying_symbol_sfx_;
}
inline void UnderlyingInstrument::set_underlying_symbol_sfx(const ::std::string& value) {
  set_has_underlying_symbol_sfx();
  if (underlying_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_sfx_ = new ::std::string;
  }
  underlying_symbol_sfx_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_symbol_sfx(const char* value) {
  set_has_underlying_symbol_sfx();
  if (underlying_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_sfx_ = new ::std::string;
  }
  underlying_symbol_sfx_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_symbol_sfx(const char* value, size_t size) {
  set_has_underlying_symbol_sfx();
  if (underlying_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_sfx_ = new ::std::string;
  }
  underlying_symbol_sfx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_symbol_sfx() {
  set_has_underlying_symbol_sfx();
  if (underlying_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    underlying_symbol_sfx_ = new ::std::string;
  }
  return underlying_symbol_sfx_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_symbol_sfx() {
  clear_has_underlying_symbol_sfx();
  if (underlying_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_symbol_sfx_;
    underlying_symbol_sfx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_symbol_sfx(::std::string* underlying_symbol_sfx) {
  if (underlying_symbol_sfx_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_symbol_sfx_;
  }
  if (underlying_symbol_sfx) {
    set_has_underlying_symbol_sfx();
    underlying_symbol_sfx_ = underlying_symbol_sfx;
  } else {
    clear_has_underlying_symbol_sfx();
    underlying_symbol_sfx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.UndSecAltIdGrp und_sec_alt_id_grp = 37;
inline int UnderlyingInstrument::und_sec_alt_id_grp_size() const {
  return und_sec_alt_id_grp_.size();
}
inline void UnderlyingInstrument::clear_und_sec_alt_id_grp() {
  und_sec_alt_id_grp_.Clear();
}
inline const ::Common::UndSecAltIdGrp& UnderlyingInstrument::und_sec_alt_id_grp(int index) const {
  return und_sec_alt_id_grp_.Get(index);
}
inline ::Common::UndSecAltIdGrp* UnderlyingInstrument::mutable_und_sec_alt_id_grp(int index) {
  return und_sec_alt_id_grp_.Mutable(index);
}
inline ::Common::UndSecAltIdGrp* UnderlyingInstrument::add_und_sec_alt_id_grp() {
  return und_sec_alt_id_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndSecAltIdGrp >&
UnderlyingInstrument::und_sec_alt_id_grp() const {
  return und_sec_alt_id_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndSecAltIdGrp >*
UnderlyingInstrument::mutable_und_sec_alt_id_grp() {
  return &und_sec_alt_id_grp_;
}

// optional sfixed64 underlying_adjusted_quantity = 38;
inline bool UnderlyingInstrument::has_underlying_adjusted_quantity() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_adjusted_quantity() {
  _has_bits_[1] |= 0x00000020u;
}
inline void UnderlyingInstrument::clear_has_underlying_adjusted_quantity() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void UnderlyingInstrument::clear_underlying_adjusted_quantity() {
  underlying_adjusted_quantity_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_adjusted_quantity();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_adjusted_quantity() const {
  return underlying_adjusted_quantity_;
}
inline void UnderlyingInstrument::set_underlying_adjusted_quantity(::google::protobuf::int64 value) {
  set_has_underlying_adjusted_quantity();
  underlying_adjusted_quantity_ = value;
}

// optional sfixed32 underlying_adjusted_quantity_exponent = 39;
inline bool UnderlyingInstrument::has_underlying_adjusted_quantity_exponent() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_adjusted_quantity_exponent() {
  _has_bits_[1] |= 0x00000040u;
}
inline void UnderlyingInstrument::clear_has_underlying_adjusted_quantity_exponent() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void UnderlyingInstrument::clear_underlying_adjusted_quantity_exponent() {
  underlying_adjusted_quantity_exponent_ = 0;
  clear_has_underlying_adjusted_quantity_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_adjusted_quantity_exponent() const {
  return underlying_adjusted_quantity_exponent_;
}
inline void UnderlyingInstrument::set_underlying_adjusted_quantity_exponent(::google::protobuf::int32 value) {
  set_has_underlying_adjusted_quantity_exponent();
  underlying_adjusted_quantity_exponent_ = value;
}

// optional sfixed64 underlying_allocation_percent = 40;
inline bool UnderlyingInstrument::has_underlying_allocation_percent() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_allocation_percent() {
  _has_bits_[1] |= 0x00000080u;
}
inline void UnderlyingInstrument::clear_has_underlying_allocation_percent() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void UnderlyingInstrument::clear_underlying_allocation_percent() {
  underlying_allocation_percent_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_allocation_percent();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_allocation_percent() const {
  return underlying_allocation_percent_;
}
inline void UnderlyingInstrument::set_underlying_allocation_percent(::google::protobuf::int64 value) {
  set_has_underlying_allocation_percent();
  underlying_allocation_percent_ = value;
}

// optional sfixed32 underlying_allocation_percent_exponent = 41;
inline bool UnderlyingInstrument::has_underlying_allocation_percent_exponent() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_allocation_percent_exponent() {
  _has_bits_[1] |= 0x00000100u;
}
inline void UnderlyingInstrument::clear_has_underlying_allocation_percent_exponent() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void UnderlyingInstrument::clear_underlying_allocation_percent_exponent() {
  underlying_allocation_percent_exponent_ = 0;
  clear_has_underlying_allocation_percent_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_allocation_percent_exponent() const {
  return underlying_allocation_percent_exponent_;
}
inline void UnderlyingInstrument::set_underlying_allocation_percent_exponent(::google::protobuf::int32 value) {
  set_has_underlying_allocation_percent_exponent();
  underlying_allocation_percent_exponent_ = value;
}

// optional string underlying_cp_program = 42;
inline bool UnderlyingInstrument::has_underlying_cp_program() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_cp_program() {
  _has_bits_[1] |= 0x00000200u;
}
inline void UnderlyingInstrument::clear_has_underlying_cp_program() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void UnderlyingInstrument::clear_underlying_cp_program() {
  if (underlying_cp_program_ != &::google::protobuf::internal::kEmptyString) {
    underlying_cp_program_->clear();
  }
  clear_has_underlying_cp_program();
}
inline const ::std::string& UnderlyingInstrument::underlying_cp_program() const {
  return *underlying_cp_program_;
}
inline void UnderlyingInstrument::set_underlying_cp_program(const ::std::string& value) {
  set_has_underlying_cp_program();
  if (underlying_cp_program_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cp_program_ = new ::std::string;
  }
  underlying_cp_program_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_cp_program(const char* value) {
  set_has_underlying_cp_program();
  if (underlying_cp_program_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cp_program_ = new ::std::string;
  }
  underlying_cp_program_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_cp_program(const char* value, size_t size) {
  set_has_underlying_cp_program();
  if (underlying_cp_program_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cp_program_ = new ::std::string;
  }
  underlying_cp_program_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_cp_program() {
  set_has_underlying_cp_program();
  if (underlying_cp_program_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cp_program_ = new ::std::string;
  }
  return underlying_cp_program_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_cp_program() {
  clear_has_underlying_cp_program();
  if (underlying_cp_program_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_cp_program_;
    underlying_cp_program_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_cp_program(::std::string* underlying_cp_program) {
  if (underlying_cp_program_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_cp_program_;
  }
  if (underlying_cp_program) {
    set_has_underlying_cp_program();
    underlying_cp_program_ = underlying_cp_program;
  } else {
    clear_has_underlying_cp_program();
    underlying_cp_program_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_cp_reg_type = 43;
inline bool UnderlyingInstrument::has_underlying_cp_reg_type() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_cp_reg_type() {
  _has_bits_[1] |= 0x00000400u;
}
inline void UnderlyingInstrument::clear_has_underlying_cp_reg_type() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void UnderlyingInstrument::clear_underlying_cp_reg_type() {
  if (underlying_cp_reg_type_ != &::google::protobuf::internal::kEmptyString) {
    underlying_cp_reg_type_->clear();
  }
  clear_has_underlying_cp_reg_type();
}
inline const ::std::string& UnderlyingInstrument::underlying_cp_reg_type() const {
  return *underlying_cp_reg_type_;
}
inline void UnderlyingInstrument::set_underlying_cp_reg_type(const ::std::string& value) {
  set_has_underlying_cp_reg_type();
  if (underlying_cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cp_reg_type_ = new ::std::string;
  }
  underlying_cp_reg_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_cp_reg_type(const char* value) {
  set_has_underlying_cp_reg_type();
  if (underlying_cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cp_reg_type_ = new ::std::string;
  }
  underlying_cp_reg_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_cp_reg_type(const char* value, size_t size) {
  set_has_underlying_cp_reg_type();
  if (underlying_cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cp_reg_type_ = new ::std::string;
  }
  underlying_cp_reg_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_cp_reg_type() {
  set_has_underlying_cp_reg_type();
  if (underlying_cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_cp_reg_type_ = new ::std::string;
  }
  return underlying_cp_reg_type_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_cp_reg_type() {
  clear_has_underlying_cp_reg_type();
  if (underlying_cp_reg_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_cp_reg_type_;
    underlying_cp_reg_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_cp_reg_type(::std::string* underlying_cp_reg_type) {
  if (underlying_cp_reg_type_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_cp_reg_type_;
  }
  if (underlying_cp_reg_type) {
    set_has_underlying_cp_reg_type();
    underlying_cp_reg_type_ = underlying_cp_reg_type;
  } else {
    clear_has_underlying_cp_reg_type();
    underlying_cp_reg_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 underlying_cap_value = 44;
inline bool UnderlyingInstrument::has_underlying_cap_value() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_cap_value() {
  _has_bits_[1] |= 0x00000800u;
}
inline void UnderlyingInstrument::clear_has_underlying_cap_value() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void UnderlyingInstrument::clear_underlying_cap_value() {
  underlying_cap_value_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_cap_value();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_cap_value() const {
  return underlying_cap_value_;
}
inline void UnderlyingInstrument::set_underlying_cap_value(::google::protobuf::int64 value) {
  set_has_underlying_cap_value();
  underlying_cap_value_ = value;
}

// optional sfixed32 underlying_cap_value_exponent = 45;
inline bool UnderlyingInstrument::has_underlying_cap_value_exponent() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_cap_value_exponent() {
  _has_bits_[1] |= 0x00001000u;
}
inline void UnderlyingInstrument::clear_has_underlying_cap_value_exponent() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void UnderlyingInstrument::clear_underlying_cap_value_exponent() {
  underlying_cap_value_exponent_ = 0;
  clear_has_underlying_cap_value_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_cap_value_exponent() const {
  return underlying_cap_value_exponent_;
}
inline void UnderlyingInstrument::set_underlying_cap_value_exponent(::google::protobuf::int32 value) {
  set_has_underlying_cap_value_exponent();
  underlying_cap_value_exponent_ = value;
}

// optional sfixed64 underlying_cash_amount = 46;
inline bool UnderlyingInstrument::has_underlying_cash_amount() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_cash_amount() {
  _has_bits_[1] |= 0x00002000u;
}
inline void UnderlyingInstrument::clear_has_underlying_cash_amount() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void UnderlyingInstrument::clear_underlying_cash_amount() {
  underlying_cash_amount_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_cash_amount();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_cash_amount() const {
  return underlying_cash_amount_;
}
inline void UnderlyingInstrument::set_underlying_cash_amount(::google::protobuf::int64 value) {
  set_has_underlying_cash_amount();
  underlying_cash_amount_ = value;
}

// optional sfixed32 underlying_cash_amount_exponent = 47;
inline bool UnderlyingInstrument::has_underlying_cash_amount_exponent() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_cash_amount_exponent() {
  _has_bits_[1] |= 0x00004000u;
}
inline void UnderlyingInstrument::clear_has_underlying_cash_amount_exponent() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void UnderlyingInstrument::clear_underlying_cash_amount_exponent() {
  underlying_cash_amount_exponent_ = 0;
  clear_has_underlying_cash_amount_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_cash_amount_exponent() const {
  return underlying_cash_amount_exponent_;
}
inline void UnderlyingInstrument::set_underlying_cash_amount_exponent(::google::protobuf::int32 value) {
  set_has_underlying_cash_amount_exponent();
  underlying_cash_amount_exponent_ = value;
}

// optional .Common.UnderlyingCashTypeEnum underlying_cash_type = 48;
inline bool UnderlyingInstrument::has_underlying_cash_type() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_cash_type() {
  _has_bits_[1] |= 0x00008000u;
}
inline void UnderlyingInstrument::clear_has_underlying_cash_type() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void UnderlyingInstrument::clear_underlying_cash_type() {
  underlying_cash_type_ = 0;
  clear_has_underlying_cash_type();
}
inline ::Common::UnderlyingCashTypeEnum UnderlyingInstrument::underlying_cash_type() const {
  return static_cast< ::Common::UnderlyingCashTypeEnum >(underlying_cash_type_);
}
inline void UnderlyingInstrument::set_underlying_cash_type(::Common::UnderlyingCashTypeEnum value) {
  assert(::Common::UnderlyingCashTypeEnum_IsValid(value));
  set_has_underlying_cash_type();
  underlying_cash_type_ = value;
}

// optional string underlying_currency = 49;
inline bool UnderlyingInstrument::has_underlying_currency() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_currency() {
  _has_bits_[1] |= 0x00010000u;
}
inline void UnderlyingInstrument::clear_has_underlying_currency() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void UnderlyingInstrument::clear_underlying_currency() {
  if (underlying_currency_ != &::google::protobuf::internal::kEmptyString) {
    underlying_currency_->clear();
  }
  clear_has_underlying_currency();
}
inline const ::std::string& UnderlyingInstrument::underlying_currency() const {
  return *underlying_currency_;
}
inline void UnderlyingInstrument::set_underlying_currency(const ::std::string& value) {
  set_has_underlying_currency();
  if (underlying_currency_ == &::google::protobuf::internal::kEmptyString) {
    underlying_currency_ = new ::std::string;
  }
  underlying_currency_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_currency(const char* value) {
  set_has_underlying_currency();
  if (underlying_currency_ == &::google::protobuf::internal::kEmptyString) {
    underlying_currency_ = new ::std::string;
  }
  underlying_currency_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_currency(const char* value, size_t size) {
  set_has_underlying_currency();
  if (underlying_currency_ == &::google::protobuf::internal::kEmptyString) {
    underlying_currency_ = new ::std::string;
  }
  underlying_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_currency() {
  set_has_underlying_currency();
  if (underlying_currency_ == &::google::protobuf::internal::kEmptyString) {
    underlying_currency_ = new ::std::string;
  }
  return underlying_currency_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_currency() {
  clear_has_underlying_currency();
  if (underlying_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_currency_;
    underlying_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_currency(::std::string* underlying_currency) {
  if (underlying_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_currency_;
  }
  if (underlying_currency) {
    set_has_underlying_currency();
    underlying_currency_ = underlying_currency;
  } else {
    clear_has_underlying_currency();
    underlying_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 underlying_current_value = 50;
inline bool UnderlyingInstrument::has_underlying_current_value() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_current_value() {
  _has_bits_[1] |= 0x00020000u;
}
inline void UnderlyingInstrument::clear_has_underlying_current_value() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void UnderlyingInstrument::clear_underlying_current_value() {
  underlying_current_value_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_current_value();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_current_value() const {
  return underlying_current_value_;
}
inline void UnderlyingInstrument::set_underlying_current_value(::google::protobuf::int64 value) {
  set_has_underlying_current_value();
  underlying_current_value_ = value;
}

// optional sfixed32 underlying_current_value_exponent = 51;
inline bool UnderlyingInstrument::has_underlying_current_value_exponent() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_current_value_exponent() {
  _has_bits_[1] |= 0x00040000u;
}
inline void UnderlyingInstrument::clear_has_underlying_current_value_exponent() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void UnderlyingInstrument::clear_underlying_current_value_exponent() {
  underlying_current_value_exponent_ = 0;
  clear_has_underlying_current_value_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_current_value_exponent() const {
  return underlying_current_value_exponent_;
}
inline void UnderlyingInstrument::set_underlying_current_value_exponent(::google::protobuf::int32 value) {
  set_has_underlying_current_value_exponent();
  underlying_current_value_exponent_ = value;
}

// optional sfixed64 underlying_dirty_price = 52;
inline bool UnderlyingInstrument::has_underlying_dirty_price() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_dirty_price() {
  _has_bits_[1] |= 0x00080000u;
}
inline void UnderlyingInstrument::clear_has_underlying_dirty_price() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void UnderlyingInstrument::clear_underlying_dirty_price() {
  underlying_dirty_price_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_dirty_price();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_dirty_price() const {
  return underlying_dirty_price_;
}
inline void UnderlyingInstrument::set_underlying_dirty_price(::google::protobuf::int64 value) {
  set_has_underlying_dirty_price();
  underlying_dirty_price_ = value;
}

// optional sfixed32 underlying_dirty_price_exponent = 53;
inline bool UnderlyingInstrument::has_underlying_dirty_price_exponent() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_dirty_price_exponent() {
  _has_bits_[1] |= 0x00100000u;
}
inline void UnderlyingInstrument::clear_has_underlying_dirty_price_exponent() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void UnderlyingInstrument::clear_underlying_dirty_price_exponent() {
  underlying_dirty_price_exponent_ = 0;
  clear_has_underlying_dirty_price_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_dirty_price_exponent() const {
  return underlying_dirty_price_exponent_;
}
inline void UnderlyingInstrument::set_underlying_dirty_price_exponent(::google::protobuf::int32 value) {
  set_has_underlying_dirty_price_exponent();
  underlying_dirty_price_exponent_ = value;
}

// optional sfixed64 underlying_end_price = 54;
inline bool UnderlyingInstrument::has_underlying_end_price() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_end_price() {
  _has_bits_[1] |= 0x00200000u;
}
inline void UnderlyingInstrument::clear_has_underlying_end_price() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void UnderlyingInstrument::clear_underlying_end_price() {
  underlying_end_price_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_end_price();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_end_price() const {
  return underlying_end_price_;
}
inline void UnderlyingInstrument::set_underlying_end_price(::google::protobuf::int64 value) {
  set_has_underlying_end_price();
  underlying_end_price_ = value;
}

// optional sfixed32 underlying_end_price_exponent = 55;
inline bool UnderlyingInstrument::has_underlying_end_price_exponent() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_end_price_exponent() {
  _has_bits_[1] |= 0x00400000u;
}
inline void UnderlyingInstrument::clear_has_underlying_end_price_exponent() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void UnderlyingInstrument::clear_underlying_end_price_exponent() {
  underlying_end_price_exponent_ = 0;
  clear_has_underlying_end_price_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_end_price_exponent() const {
  return underlying_end_price_exponent_;
}
inline void UnderlyingInstrument::set_underlying_end_price_exponent(::google::protobuf::int32 value) {
  set_has_underlying_end_price_exponent();
  underlying_end_price_exponent_ = value;
}

// optional sfixed64 underlying_end_value = 56;
inline bool UnderlyingInstrument::has_underlying_end_value() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_end_value() {
  _has_bits_[1] |= 0x00800000u;
}
inline void UnderlyingInstrument::clear_has_underlying_end_value() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void UnderlyingInstrument::clear_underlying_end_value() {
  underlying_end_value_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_end_value();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_end_value() const {
  return underlying_end_value_;
}
inline void UnderlyingInstrument::set_underlying_end_value(::google::protobuf::int64 value) {
  set_has_underlying_end_value();
  underlying_end_value_ = value;
}

// optional sfixed32 underlying_end_value_exponent = 57;
inline bool UnderlyingInstrument::has_underlying_end_value_exponent() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_end_value_exponent() {
  _has_bits_[1] |= 0x01000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_end_value_exponent() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void UnderlyingInstrument::clear_underlying_end_value_exponent() {
  underlying_end_value_exponent_ = 0;
  clear_has_underlying_end_value_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_end_value_exponent() const {
  return underlying_end_value_exponent_;
}
inline void UnderlyingInstrument::set_underlying_end_value_exponent(::google::protobuf::int32 value) {
  set_has_underlying_end_value_exponent();
  underlying_end_value_exponent_ = value;
}

// optional double underlying_fx_rate = 58;
inline bool UnderlyingInstrument::has_underlying_fx_rate() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_fx_rate() {
  _has_bits_[1] |= 0x02000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_fx_rate() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void UnderlyingInstrument::clear_underlying_fx_rate() {
  underlying_fx_rate_ = 0;
  clear_has_underlying_fx_rate();
}
inline double UnderlyingInstrument::underlying_fx_rate() const {
  return underlying_fx_rate_;
}
inline void UnderlyingInstrument::set_underlying_fx_rate(double value) {
  set_has_underlying_fx_rate();
  underlying_fx_rate_ = value;
}

// optional .Common.UnderlyingFxRateCalcEnum underlying_fx_rate_calc = 59;
inline bool UnderlyingInstrument::has_underlying_fx_rate_calc() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_fx_rate_calc() {
  _has_bits_[1] |= 0x04000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_fx_rate_calc() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void UnderlyingInstrument::clear_underlying_fx_rate_calc() {
  underlying_fx_rate_calc_ = 0;
  clear_has_underlying_fx_rate_calc();
}
inline ::Common::UnderlyingFxRateCalcEnum UnderlyingInstrument::underlying_fx_rate_calc() const {
  return static_cast< ::Common::UnderlyingFxRateCalcEnum >(underlying_fx_rate_calc_);
}
inline void UnderlyingInstrument::set_underlying_fx_rate_calc(::Common::UnderlyingFxRateCalcEnum value) {
  assert(::Common::UnderlyingFxRateCalcEnum_IsValid(value));
  set_has_underlying_fx_rate_calc();
  underlying_fx_rate_calc_ = value;
}

// optional sfixed64 underlying_px = 60;
inline bool UnderlyingInstrument::has_underlying_px() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_px() {
  _has_bits_[1] |= 0x08000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_px() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void UnderlyingInstrument::clear_underlying_px() {
  underlying_px_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_px();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_px() const {
  return underlying_px_;
}
inline void UnderlyingInstrument::set_underlying_px(::google::protobuf::int64 value) {
  set_has_underlying_px();
  underlying_px_ = value;
}

// optional sfixed32 underlying_px_exponent = 61;
inline bool UnderlyingInstrument::has_underlying_px_exponent() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_px_exponent() {
  _has_bits_[1] |= 0x10000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_px_exponent() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void UnderlyingInstrument::clear_underlying_px_exponent() {
  underlying_px_exponent_ = 0;
  clear_has_underlying_px_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_px_exponent() const {
  return underlying_px_exponent_;
}
inline void UnderlyingInstrument::set_underlying_px_exponent(::google::protobuf::int32 value) {
  set_has_underlying_px_exponent();
  underlying_px_exponent_ = value;
}

// optional sfixed64 underlying_qty = 62;
inline bool UnderlyingInstrument::has_underlying_qty() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_qty() {
  _has_bits_[1] |= 0x20000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_qty() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void UnderlyingInstrument::clear_underlying_qty() {
  underlying_qty_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_qty();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_qty() const {
  return underlying_qty_;
}
inline void UnderlyingInstrument::set_underlying_qty(::google::protobuf::int64 value) {
  set_has_underlying_qty();
  underlying_qty_ = value;
}

// optional sfixed32 underlying_qty_exponent = 63;
inline bool UnderlyingInstrument::has_underlying_qty_exponent() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_qty_exponent() {
  _has_bits_[1] |= 0x40000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_qty_exponent() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void UnderlyingInstrument::clear_underlying_qty_exponent() {
  underlying_qty_exponent_ = 0;
  clear_has_underlying_qty_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_qty_exponent() const {
  return underlying_qty_exponent_;
}
inline void UnderlyingInstrument::set_underlying_qty_exponent(::google::protobuf::int32 value) {
  set_has_underlying_qty_exponent();
  underlying_qty_exponent_ = value;
}

// optional string underlying_security_sub_type = 64;
inline bool UnderlyingInstrument::has_underlying_security_sub_type() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_security_sub_type() {
  _has_bits_[1] |= 0x80000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_security_sub_type() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void UnderlyingInstrument::clear_underlying_security_sub_type() {
  if (underlying_security_sub_type_ != &::google::protobuf::internal::kEmptyString) {
    underlying_security_sub_type_->clear();
  }
  clear_has_underlying_security_sub_type();
}
inline const ::std::string& UnderlyingInstrument::underlying_security_sub_type() const {
  return *underlying_security_sub_type_;
}
inline void UnderlyingInstrument::set_underlying_security_sub_type(const ::std::string& value) {
  set_has_underlying_security_sub_type();
  if (underlying_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_sub_type_ = new ::std::string;
  }
  underlying_security_sub_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_sub_type(const char* value) {
  set_has_underlying_security_sub_type();
  if (underlying_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_sub_type_ = new ::std::string;
  }
  underlying_security_sub_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_security_sub_type(const char* value, size_t size) {
  set_has_underlying_security_sub_type();
  if (underlying_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_sub_type_ = new ::std::string;
  }
  underlying_security_sub_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_security_sub_type() {
  set_has_underlying_security_sub_type();
  if (underlying_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_security_sub_type_ = new ::std::string;
  }
  return underlying_security_sub_type_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_security_sub_type() {
  clear_has_underlying_security_sub_type();
  if (underlying_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_security_sub_type_;
    underlying_security_sub_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_security_sub_type(::std::string* underlying_security_sub_type) {
  if (underlying_security_sub_type_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_security_sub_type_;
  }
  if (underlying_security_sub_type) {
    set_has_underlying_security_sub_type();
    underlying_security_sub_type_ = underlying_security_sub_type;
  } else {
    clear_has_underlying_security_sub_type();
    underlying_security_sub_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_settl_method = 65;
inline bool UnderlyingInstrument::has_underlying_settl_method() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_settl_method() {
  _has_bits_[2] |= 0x00000001u;
}
inline void UnderlyingInstrument::clear_has_underlying_settl_method() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void UnderlyingInstrument::clear_underlying_settl_method() {
  if (underlying_settl_method_ != &::google::protobuf::internal::kEmptyString) {
    underlying_settl_method_->clear();
  }
  clear_has_underlying_settl_method();
}
inline const ::std::string& UnderlyingInstrument::underlying_settl_method() const {
  return *underlying_settl_method_;
}
inline void UnderlyingInstrument::set_underlying_settl_method(const ::std::string& value) {
  set_has_underlying_settl_method();
  if (underlying_settl_method_ == &::google::protobuf::internal::kEmptyString) {
    underlying_settl_method_ = new ::std::string;
  }
  underlying_settl_method_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_settl_method(const char* value) {
  set_has_underlying_settl_method();
  if (underlying_settl_method_ == &::google::protobuf::internal::kEmptyString) {
    underlying_settl_method_ = new ::std::string;
  }
  underlying_settl_method_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_settl_method(const char* value, size_t size) {
  set_has_underlying_settl_method();
  if (underlying_settl_method_ == &::google::protobuf::internal::kEmptyString) {
    underlying_settl_method_ = new ::std::string;
  }
  underlying_settl_method_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_settl_method() {
  set_has_underlying_settl_method();
  if (underlying_settl_method_ == &::google::protobuf::internal::kEmptyString) {
    underlying_settl_method_ = new ::std::string;
  }
  return underlying_settl_method_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_settl_method() {
  clear_has_underlying_settl_method();
  if (underlying_settl_method_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_settl_method_;
    underlying_settl_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_settl_method(::std::string* underlying_settl_method) {
  if (underlying_settl_method_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_settl_method_;
  }
  if (underlying_settl_method) {
    set_has_underlying_settl_method();
    underlying_settl_method_ = underlying_settl_method;
  } else {
    clear_has_underlying_settl_method();
    underlying_settl_method_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.UnderlyingSettlementTypeEnum underlying_settlement_type = 66;
inline bool UnderlyingInstrument::has_underlying_settlement_type() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_settlement_type() {
  _has_bits_[2] |= 0x00000002u;
}
inline void UnderlyingInstrument::clear_has_underlying_settlement_type() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void UnderlyingInstrument::clear_underlying_settlement_type() {
  underlying_settlement_type_ = 0;
  clear_has_underlying_settlement_type();
}
inline ::Common::UnderlyingSettlementTypeEnum UnderlyingInstrument::underlying_settlement_type() const {
  return static_cast< ::Common::UnderlyingSettlementTypeEnum >(underlying_settlement_type_);
}
inline void UnderlyingInstrument::set_underlying_settlement_type(::Common::UnderlyingSettlementTypeEnum value) {
  assert(::Common::UnderlyingSettlementTypeEnum_IsValid(value));
  set_has_underlying_settlement_type();
  underlying_settlement_type_ = value;
}

// optional sfixed64 underlying_start_value = 67;
inline bool UnderlyingInstrument::has_underlying_start_value() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_start_value() {
  _has_bits_[2] |= 0x00000004u;
}
inline void UnderlyingInstrument::clear_has_underlying_start_value() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void UnderlyingInstrument::clear_underlying_start_value() {
  underlying_start_value_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_start_value();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_start_value() const {
  return underlying_start_value_;
}
inline void UnderlyingInstrument::set_underlying_start_value(::google::protobuf::int64 value) {
  set_has_underlying_start_value();
  underlying_start_value_ = value;
}

// optional sfixed32 underlying_start_value_exponent = 68;
inline bool UnderlyingInstrument::has_underlying_start_value_exponent() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_start_value_exponent() {
  _has_bits_[2] |= 0x00000008u;
}
inline void UnderlyingInstrument::clear_has_underlying_start_value_exponent() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void UnderlyingInstrument::clear_underlying_start_value_exponent() {
  underlying_start_value_exponent_ = 0;
  clear_has_underlying_start_value_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_start_value_exponent() const {
  return underlying_start_value_exponent_;
}
inline void UnderlyingInstrument::set_underlying_start_value_exponent(::google::protobuf::int32 value) {
  set_has_underlying_start_value_exponent();
  underlying_start_value_exponent_ = value;
}

// repeated .Common.UnderlyingStipulations underlying_stipulations = 69;
inline int UnderlyingInstrument::underlying_stipulations_size() const {
  return underlying_stipulations_.size();
}
inline void UnderlyingInstrument::clear_underlying_stipulations() {
  underlying_stipulations_.Clear();
}
inline const ::Common::UnderlyingStipulations& UnderlyingInstrument::underlying_stipulations(int index) const {
  return underlying_stipulations_.Get(index);
}
inline ::Common::UnderlyingStipulations* UnderlyingInstrument::mutable_underlying_stipulations(int index) {
  return underlying_stipulations_.Mutable(index);
}
inline ::Common::UnderlyingStipulations* UnderlyingInstrument::add_underlying_stipulations() {
  return underlying_stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UnderlyingStipulations >&
UnderlyingInstrument::underlying_stipulations() const {
  return underlying_stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UnderlyingStipulations >*
UnderlyingInstrument::mutable_underlying_stipulations() {
  return &underlying_stipulations_;
}

// optional string underlying_strike_currency = 70;
inline bool UnderlyingInstrument::has_underlying_strike_currency() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_strike_currency() {
  _has_bits_[2] |= 0x00000020u;
}
inline void UnderlyingInstrument::clear_has_underlying_strike_currency() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void UnderlyingInstrument::clear_underlying_strike_currency() {
  if (underlying_strike_currency_ != &::google::protobuf::internal::kEmptyString) {
    underlying_strike_currency_->clear();
  }
  clear_has_underlying_strike_currency();
}
inline const ::std::string& UnderlyingInstrument::underlying_strike_currency() const {
  return *underlying_strike_currency_;
}
inline void UnderlyingInstrument::set_underlying_strike_currency(const ::std::string& value) {
  set_has_underlying_strike_currency();
  if (underlying_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    underlying_strike_currency_ = new ::std::string;
  }
  underlying_strike_currency_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_strike_currency(const char* value) {
  set_has_underlying_strike_currency();
  if (underlying_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    underlying_strike_currency_ = new ::std::string;
  }
  underlying_strike_currency_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_strike_currency(const char* value, size_t size) {
  set_has_underlying_strike_currency();
  if (underlying_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    underlying_strike_currency_ = new ::std::string;
  }
  underlying_strike_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_strike_currency() {
  set_has_underlying_strike_currency();
  if (underlying_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    underlying_strike_currency_ = new ::std::string;
  }
  return underlying_strike_currency_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_strike_currency() {
  clear_has_underlying_strike_currency();
  if (underlying_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_strike_currency_;
    underlying_strike_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_strike_currency(::std::string* underlying_strike_currency) {
  if (underlying_strike_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_strike_currency_;
  }
  if (underlying_strike_currency) {
    set_has_underlying_strike_currency();
    underlying_strike_currency_ = underlying_strike_currency;
  } else {
    clear_has_underlying_strike_currency();
    underlying_strike_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_time_unit = 71;
inline bool UnderlyingInstrument::has_underlying_time_unit() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_time_unit() {
  _has_bits_[2] |= 0x00000040u;
}
inline void UnderlyingInstrument::clear_has_underlying_time_unit() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void UnderlyingInstrument::clear_underlying_time_unit() {
  if (underlying_time_unit_ != &::google::protobuf::internal::kEmptyString) {
    underlying_time_unit_->clear();
  }
  clear_has_underlying_time_unit();
}
inline const ::std::string& UnderlyingInstrument::underlying_time_unit() const {
  return *underlying_time_unit_;
}
inline void UnderlyingInstrument::set_underlying_time_unit(const ::std::string& value) {
  set_has_underlying_time_unit();
  if (underlying_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    underlying_time_unit_ = new ::std::string;
  }
  underlying_time_unit_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_time_unit(const char* value) {
  set_has_underlying_time_unit();
  if (underlying_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    underlying_time_unit_ = new ::std::string;
  }
  underlying_time_unit_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_time_unit(const char* value, size_t size) {
  set_has_underlying_time_unit();
  if (underlying_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    underlying_time_unit_ = new ::std::string;
  }
  underlying_time_unit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_time_unit() {
  set_has_underlying_time_unit();
  if (underlying_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    underlying_time_unit_ = new ::std::string;
  }
  return underlying_time_unit_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_time_unit() {
  clear_has_underlying_time_unit();
  if (underlying_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_time_unit_;
    underlying_time_unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_time_unit(::std::string* underlying_time_unit) {
  if (underlying_time_unit_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_time_unit_;
  }
  if (underlying_time_unit) {
    set_has_underlying_time_unit();
    underlying_time_unit_ = underlying_time_unit;
  } else {
    clear_has_underlying_time_unit();
    underlying_time_unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_unit_of_measure = 72;
inline bool UnderlyingInstrument::has_underlying_unit_of_measure() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_unit_of_measure() {
  _has_bits_[2] |= 0x00000080u;
}
inline void UnderlyingInstrument::clear_has_underlying_unit_of_measure() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void UnderlyingInstrument::clear_underlying_unit_of_measure() {
  if (underlying_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    underlying_unit_of_measure_->clear();
  }
  clear_has_underlying_unit_of_measure();
}
inline const ::std::string& UnderlyingInstrument::underlying_unit_of_measure() const {
  return *underlying_unit_of_measure_;
}
inline void UnderlyingInstrument::set_underlying_unit_of_measure(const ::std::string& value) {
  set_has_underlying_unit_of_measure();
  if (underlying_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    underlying_unit_of_measure_ = new ::std::string;
  }
  underlying_unit_of_measure_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_unit_of_measure(const char* value) {
  set_has_underlying_unit_of_measure();
  if (underlying_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    underlying_unit_of_measure_ = new ::std::string;
  }
  underlying_unit_of_measure_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_unit_of_measure(const char* value, size_t size) {
  set_has_underlying_unit_of_measure();
  if (underlying_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    underlying_unit_of_measure_ = new ::std::string;
  }
  underlying_unit_of_measure_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_unit_of_measure() {
  set_has_underlying_unit_of_measure();
  if (underlying_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    underlying_unit_of_measure_ = new ::std::string;
  }
  return underlying_unit_of_measure_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_unit_of_measure() {
  clear_has_underlying_unit_of_measure();
  if (underlying_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_unit_of_measure_;
    underlying_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_unit_of_measure(::std::string* underlying_unit_of_measure) {
  if (underlying_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_unit_of_measure_;
  }
  if (underlying_unit_of_measure) {
    set_has_underlying_unit_of_measure();
    underlying_unit_of_measure_ = underlying_unit_of_measure;
  } else {
    clear_has_underlying_unit_of_measure();
    underlying_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.UndlyInstrumentParties undly_instrument_parties = 73;
inline int UnderlyingInstrument::undly_instrument_parties_size() const {
  return undly_instrument_parties_.size();
}
inline void UnderlyingInstrument::clear_undly_instrument_parties() {
  undly_instrument_parties_.Clear();
}
inline const ::Common::UndlyInstrumentParties& UnderlyingInstrument::undly_instrument_parties(int index) const {
  return undly_instrument_parties_.Get(index);
}
inline ::Common::UndlyInstrumentParties* UnderlyingInstrument::mutable_undly_instrument_parties(int index) {
  return undly_instrument_parties_.Mutable(index);
}
inline ::Common::UndlyInstrumentParties* UnderlyingInstrument::add_undly_instrument_parties() {
  return undly_instrument_parties_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentParties >&
UnderlyingInstrument::undly_instrument_parties() const {
  return undly_instrument_parties_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndlyInstrumentParties >*
UnderlyingInstrument::mutable_undly_instrument_parties() {
  return &undly_instrument_parties_;
}

// optional sfixed64 underlying_exercise_style = 74;
inline bool UnderlyingInstrument::has_underlying_exercise_style() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_exercise_style() {
  _has_bits_[2] |= 0x00000200u;
}
inline void UnderlyingInstrument::clear_has_underlying_exercise_style() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void UnderlyingInstrument::clear_underlying_exercise_style() {
  underlying_exercise_style_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_exercise_style();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_exercise_style() const {
  return underlying_exercise_style_;
}
inline void UnderlyingInstrument::set_underlying_exercise_style(::google::protobuf::int64 value) {
  set_has_underlying_exercise_style();
  underlying_exercise_style_ = value;
}

// optional string underlying_maturity_time = 75;
inline bool UnderlyingInstrument::has_underlying_maturity_time() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_maturity_time() {
  _has_bits_[2] |= 0x00000400u;
}
inline void UnderlyingInstrument::clear_has_underlying_maturity_time() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void UnderlyingInstrument::clear_underlying_maturity_time() {
  if (underlying_maturity_time_ != &::google::protobuf::internal::kEmptyString) {
    underlying_maturity_time_->clear();
  }
  clear_has_underlying_maturity_time();
}
inline const ::std::string& UnderlyingInstrument::underlying_maturity_time() const {
  return *underlying_maturity_time_;
}
inline void UnderlyingInstrument::set_underlying_maturity_time(const ::std::string& value) {
  set_has_underlying_maturity_time();
  if (underlying_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    underlying_maturity_time_ = new ::std::string;
  }
  underlying_maturity_time_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_maturity_time(const char* value) {
  set_has_underlying_maturity_time();
  if (underlying_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    underlying_maturity_time_ = new ::std::string;
  }
  underlying_maturity_time_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_maturity_time(const char* value, size_t size) {
  set_has_underlying_maturity_time();
  if (underlying_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    underlying_maturity_time_ = new ::std::string;
  }
  underlying_maturity_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_maturity_time() {
  set_has_underlying_maturity_time();
  if (underlying_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    underlying_maturity_time_ = new ::std::string;
  }
  return underlying_maturity_time_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_maturity_time() {
  clear_has_underlying_maturity_time();
  if (underlying_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_maturity_time_;
    underlying_maturity_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_maturity_time(::std::string* underlying_maturity_time) {
  if (underlying_maturity_time_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_maturity_time_;
  }
  if (underlying_maturity_time) {
    set_has_underlying_maturity_time();
    underlying_maturity_time_ = underlying_maturity_time;
  } else {
    clear_has_underlying_maturity_time();
    underlying_maturity_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_price_unit_of_measure = 76;
inline bool UnderlyingInstrument::has_underlying_price_unit_of_measure() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_price_unit_of_measure() {
  _has_bits_[2] |= 0x00000800u;
}
inline void UnderlyingInstrument::clear_has_underlying_price_unit_of_measure() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void UnderlyingInstrument::clear_underlying_price_unit_of_measure() {
  if (underlying_price_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    underlying_price_unit_of_measure_->clear();
  }
  clear_has_underlying_price_unit_of_measure();
}
inline const ::std::string& UnderlyingInstrument::underlying_price_unit_of_measure() const {
  return *underlying_price_unit_of_measure_;
}
inline void UnderlyingInstrument::set_underlying_price_unit_of_measure(const ::std::string& value) {
  set_has_underlying_price_unit_of_measure();
  if (underlying_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    underlying_price_unit_of_measure_ = new ::std::string;
  }
  underlying_price_unit_of_measure_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_price_unit_of_measure(const char* value) {
  set_has_underlying_price_unit_of_measure();
  if (underlying_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    underlying_price_unit_of_measure_ = new ::std::string;
  }
  underlying_price_unit_of_measure_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_price_unit_of_measure(const char* value, size_t size) {
  set_has_underlying_price_unit_of_measure();
  if (underlying_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    underlying_price_unit_of_measure_ = new ::std::string;
  }
  underlying_price_unit_of_measure_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_price_unit_of_measure() {
  set_has_underlying_price_unit_of_measure();
  if (underlying_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    underlying_price_unit_of_measure_ = new ::std::string;
  }
  return underlying_price_unit_of_measure_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_price_unit_of_measure() {
  clear_has_underlying_price_unit_of_measure();
  if (underlying_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_price_unit_of_measure_;
    underlying_price_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_price_unit_of_measure(::std::string* underlying_price_unit_of_measure) {
  if (underlying_price_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_price_unit_of_measure_;
  }
  if (underlying_price_unit_of_measure) {
    set_has_underlying_price_unit_of_measure();
    underlying_price_unit_of_measure_ = underlying_price_unit_of_measure;
  } else {
    clear_has_underlying_price_unit_of_measure();
    underlying_price_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 underlying_price_unit_of_measure_qty = 77;
inline bool UnderlyingInstrument::has_underlying_price_unit_of_measure_qty() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_price_unit_of_measure_qty() {
  _has_bits_[2] |= 0x00001000u;
}
inline void UnderlyingInstrument::clear_has_underlying_price_unit_of_measure_qty() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void UnderlyingInstrument::clear_underlying_price_unit_of_measure_qty() {
  underlying_price_unit_of_measure_qty_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_price_unit_of_measure_qty();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_price_unit_of_measure_qty() const {
  return underlying_price_unit_of_measure_qty_;
}
inline void UnderlyingInstrument::set_underlying_price_unit_of_measure_qty(::google::protobuf::int64 value) {
  set_has_underlying_price_unit_of_measure_qty();
  underlying_price_unit_of_measure_qty_ = value;
}

// optional sfixed32 underlying_price_unit_of_measure_qty_exponent = 78;
inline bool UnderlyingInstrument::has_underlying_price_unit_of_measure_qty_exponent() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_price_unit_of_measure_qty_exponent() {
  _has_bits_[2] |= 0x00002000u;
}
inline void UnderlyingInstrument::clear_has_underlying_price_unit_of_measure_qty_exponent() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void UnderlyingInstrument::clear_underlying_price_unit_of_measure_qty_exponent() {
  underlying_price_unit_of_measure_qty_exponent_ = 0;
  clear_has_underlying_price_unit_of_measure_qty_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_price_unit_of_measure_qty_exponent() const {
  return underlying_price_unit_of_measure_qty_exponent_;
}
inline void UnderlyingInstrument::set_underlying_price_unit_of_measure_qty_exponent(::google::protobuf::int32 value) {
  set_has_underlying_price_unit_of_measure_qty_exponent();
  underlying_price_unit_of_measure_qty_exponent_ = value;
}

// optional sfixed64 underlying_unit_of_measure_qty = 79;
inline bool UnderlyingInstrument::has_underlying_unit_of_measure_qty() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_unit_of_measure_qty() {
  _has_bits_[2] |= 0x00004000u;
}
inline void UnderlyingInstrument::clear_has_underlying_unit_of_measure_qty() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void UnderlyingInstrument::clear_underlying_unit_of_measure_qty() {
  underlying_unit_of_measure_qty_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_unit_of_measure_qty();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_unit_of_measure_qty() const {
  return underlying_unit_of_measure_qty_;
}
inline void UnderlyingInstrument::set_underlying_unit_of_measure_qty(::google::protobuf::int64 value) {
  set_has_underlying_unit_of_measure_qty();
  underlying_unit_of_measure_qty_ = value;
}

// optional sfixed32 underlying_unit_of_measure_qty_exponent = 80;
inline bool UnderlyingInstrument::has_underlying_unit_of_measure_qty_exponent() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_unit_of_measure_qty_exponent() {
  _has_bits_[2] |= 0x00008000u;
}
inline void UnderlyingInstrument::clear_has_underlying_unit_of_measure_qty_exponent() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void UnderlyingInstrument::clear_underlying_unit_of_measure_qty_exponent() {
  underlying_unit_of_measure_qty_exponent_ = 0;
  clear_has_underlying_unit_of_measure_qty_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_unit_of_measure_qty_exponent() const {
  return underlying_unit_of_measure_qty_exponent_;
}
inline void UnderlyingInstrument::set_underlying_unit_of_measure_qty_exponent(::google::protobuf::int32 value) {
  set_has_underlying_unit_of_measure_qty_exponent();
  underlying_unit_of_measure_qty_exponent_ = value;
}

// optional sfixed64 underlying_contract_multiplier_unit = 81;
inline bool UnderlyingInstrument::has_underlying_contract_multiplier_unit() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_contract_multiplier_unit() {
  _has_bits_[2] |= 0x00010000u;
}
inline void UnderlyingInstrument::clear_has_underlying_contract_multiplier_unit() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void UnderlyingInstrument::clear_underlying_contract_multiplier_unit() {
  underlying_contract_multiplier_unit_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_contract_multiplier_unit();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_contract_multiplier_unit() const {
  return underlying_contract_multiplier_unit_;
}
inline void UnderlyingInstrument::set_underlying_contract_multiplier_unit(::google::protobuf::int64 value) {
  set_has_underlying_contract_multiplier_unit();
  underlying_contract_multiplier_unit_ = value;
}

// optional sfixed64 underlying_flow_schedule_type = 82;
inline bool UnderlyingInstrument::has_underlying_flow_schedule_type() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_flow_schedule_type() {
  _has_bits_[2] |= 0x00020000u;
}
inline void UnderlyingInstrument::clear_has_underlying_flow_schedule_type() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void UnderlyingInstrument::clear_underlying_flow_schedule_type() {
  underlying_flow_schedule_type_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_flow_schedule_type();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_flow_schedule_type() const {
  return underlying_flow_schedule_type_;
}
inline void UnderlyingInstrument::set_underlying_flow_schedule_type(::google::protobuf::int64 value) {
  set_has_underlying_flow_schedule_type();
  underlying_flow_schedule_type_ = value;
}

// optional sfixed64 underlying_attachment_point = 83;
inline bool UnderlyingInstrument::has_underlying_attachment_point() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_attachment_point() {
  _has_bits_[2] |= 0x00040000u;
}
inline void UnderlyingInstrument::clear_has_underlying_attachment_point() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void UnderlyingInstrument::clear_underlying_attachment_point() {
  underlying_attachment_point_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_attachment_point();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_attachment_point() const {
  return underlying_attachment_point_;
}
inline void UnderlyingInstrument::set_underlying_attachment_point(::google::protobuf::int64 value) {
  set_has_underlying_attachment_point();
  underlying_attachment_point_ = value;
}

// optional sfixed32 underlying_attachment_point_exponent = 84;
inline bool UnderlyingInstrument::has_underlying_attachment_point_exponent() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_attachment_point_exponent() {
  _has_bits_[2] |= 0x00080000u;
}
inline void UnderlyingInstrument::clear_has_underlying_attachment_point_exponent() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void UnderlyingInstrument::clear_underlying_attachment_point_exponent() {
  underlying_attachment_point_exponent_ = 0;
  clear_has_underlying_attachment_point_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_attachment_point_exponent() const {
  return underlying_attachment_point_exponent_;
}
inline void UnderlyingInstrument::set_underlying_attachment_point_exponent(::google::protobuf::int32 value) {
  set_has_underlying_attachment_point_exponent();
  underlying_attachment_point_exponent_ = value;
}

// optional sfixed64 underlying_detachment_point = 85;
inline bool UnderlyingInstrument::has_underlying_detachment_point() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_detachment_point() {
  _has_bits_[2] |= 0x00100000u;
}
inline void UnderlyingInstrument::clear_has_underlying_detachment_point() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void UnderlyingInstrument::clear_underlying_detachment_point() {
  underlying_detachment_point_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_detachment_point();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_detachment_point() const {
  return underlying_detachment_point_;
}
inline void UnderlyingInstrument::set_underlying_detachment_point(::google::protobuf::int64 value) {
  set_has_underlying_detachment_point();
  underlying_detachment_point_ = value;
}

// optional sfixed32 underlying_detachment_point_exponent = 86;
inline bool UnderlyingInstrument::has_underlying_detachment_point_exponent() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_detachment_point_exponent() {
  _has_bits_[2] |= 0x00200000u;
}
inline void UnderlyingInstrument::clear_has_underlying_detachment_point_exponent() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void UnderlyingInstrument::clear_underlying_detachment_point_exponent() {
  underlying_detachment_point_exponent_ = 0;
  clear_has_underlying_detachment_point_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_detachment_point_exponent() const {
  return underlying_detachment_point_exponent_;
}
inline void UnderlyingInstrument::set_underlying_detachment_point_exponent(::google::protobuf::int32 value) {
  set_has_underlying_detachment_point_exponent();
  underlying_detachment_point_exponent_ = value;
}

// optional sfixed64 underlying_notional_percentage_outstanding = 87;
inline bool UnderlyingInstrument::has_underlying_notional_percentage_outstanding() const {
  return (_has_bits_[2] & 0x00400000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_notional_percentage_outstanding() {
  _has_bits_[2] |= 0x00400000u;
}
inline void UnderlyingInstrument::clear_has_underlying_notional_percentage_outstanding() {
  _has_bits_[2] &= ~0x00400000u;
}
inline void UnderlyingInstrument::clear_underlying_notional_percentage_outstanding() {
  underlying_notional_percentage_outstanding_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_notional_percentage_outstanding();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_notional_percentage_outstanding() const {
  return underlying_notional_percentage_outstanding_;
}
inline void UnderlyingInstrument::set_underlying_notional_percentage_outstanding(::google::protobuf::int64 value) {
  set_has_underlying_notional_percentage_outstanding();
  underlying_notional_percentage_outstanding_ = value;
}

// optional sfixed32 underlying_notional_percentage_outstanding_exponent = 88;
inline bool UnderlyingInstrument::has_underlying_notional_percentage_outstanding_exponent() const {
  return (_has_bits_[2] & 0x00800000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_notional_percentage_outstanding_exponent() {
  _has_bits_[2] |= 0x00800000u;
}
inline void UnderlyingInstrument::clear_has_underlying_notional_percentage_outstanding_exponent() {
  _has_bits_[2] &= ~0x00800000u;
}
inline void UnderlyingInstrument::clear_underlying_notional_percentage_outstanding_exponent() {
  underlying_notional_percentage_outstanding_exponent_ = 0;
  clear_has_underlying_notional_percentage_outstanding_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_notional_percentage_outstanding_exponent() const {
  return underlying_notional_percentage_outstanding_exponent_;
}
inline void UnderlyingInstrument::set_underlying_notional_percentage_outstanding_exponent(::google::protobuf::int32 value) {
  set_has_underlying_notional_percentage_outstanding_exponent();
  underlying_notional_percentage_outstanding_exponent_ = value;
}

// optional sfixed64 underlying_original_notional_percentage_outstanding = 89;
inline bool UnderlyingInstrument::has_underlying_original_notional_percentage_outstanding() const {
  return (_has_bits_[2] & 0x01000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_original_notional_percentage_outstanding() {
  _has_bits_[2] |= 0x01000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_original_notional_percentage_outstanding() {
  _has_bits_[2] &= ~0x01000000u;
}
inline void UnderlyingInstrument::clear_underlying_original_notional_percentage_outstanding() {
  underlying_original_notional_percentage_outstanding_ = GOOGLE_LONGLONG(0);
  clear_has_underlying_original_notional_percentage_outstanding();
}
inline ::google::protobuf::int64 UnderlyingInstrument::underlying_original_notional_percentage_outstanding() const {
  return underlying_original_notional_percentage_outstanding_;
}
inline void UnderlyingInstrument::set_underlying_original_notional_percentage_outstanding(::google::protobuf::int64 value) {
  set_has_underlying_original_notional_percentage_outstanding();
  underlying_original_notional_percentage_outstanding_ = value;
}

// optional sfixed32 underlying_original_notional_percentage_outstanding_exponent = 90;
inline bool UnderlyingInstrument::has_underlying_original_notional_percentage_outstanding_exponent() const {
  return (_has_bits_[2] & 0x02000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_original_notional_percentage_outstanding_exponent() {
  _has_bits_[2] |= 0x02000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_original_notional_percentage_outstanding_exponent() {
  _has_bits_[2] &= ~0x02000000u;
}
inline void UnderlyingInstrument::clear_underlying_original_notional_percentage_outstanding_exponent() {
  underlying_original_notional_percentage_outstanding_exponent_ = 0;
  clear_has_underlying_original_notional_percentage_outstanding_exponent();
}
inline ::google::protobuf::int32 UnderlyingInstrument::underlying_original_notional_percentage_outstanding_exponent() const {
  return underlying_original_notional_percentage_outstanding_exponent_;
}
inline void UnderlyingInstrument::set_underlying_original_notional_percentage_outstanding_exponent(::google::protobuf::int32 value) {
  set_has_underlying_original_notional_percentage_outstanding_exponent();
  underlying_original_notional_percentage_outstanding_exponent_ = value;
}

// optional string underlying_restructuring_type = 91;
inline bool UnderlyingInstrument::has_underlying_restructuring_type() const {
  return (_has_bits_[2] & 0x04000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_restructuring_type() {
  _has_bits_[2] |= 0x04000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_restructuring_type() {
  _has_bits_[2] &= ~0x04000000u;
}
inline void UnderlyingInstrument::clear_underlying_restructuring_type() {
  if (underlying_restructuring_type_ != &::google::protobuf::internal::kEmptyString) {
    underlying_restructuring_type_->clear();
  }
  clear_has_underlying_restructuring_type();
}
inline const ::std::string& UnderlyingInstrument::underlying_restructuring_type() const {
  return *underlying_restructuring_type_;
}
inline void UnderlyingInstrument::set_underlying_restructuring_type(const ::std::string& value) {
  set_has_underlying_restructuring_type();
  if (underlying_restructuring_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_restructuring_type_ = new ::std::string;
  }
  underlying_restructuring_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_restructuring_type(const char* value) {
  set_has_underlying_restructuring_type();
  if (underlying_restructuring_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_restructuring_type_ = new ::std::string;
  }
  underlying_restructuring_type_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_restructuring_type(const char* value, size_t size) {
  set_has_underlying_restructuring_type();
  if (underlying_restructuring_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_restructuring_type_ = new ::std::string;
  }
  underlying_restructuring_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_restructuring_type() {
  set_has_underlying_restructuring_type();
  if (underlying_restructuring_type_ == &::google::protobuf::internal::kEmptyString) {
    underlying_restructuring_type_ = new ::std::string;
  }
  return underlying_restructuring_type_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_restructuring_type() {
  clear_has_underlying_restructuring_type();
  if (underlying_restructuring_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_restructuring_type_;
    underlying_restructuring_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_restructuring_type(::std::string* underlying_restructuring_type) {
  if (underlying_restructuring_type_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_restructuring_type_;
  }
  if (underlying_restructuring_type) {
    set_has_underlying_restructuring_type();
    underlying_restructuring_type_ = underlying_restructuring_type;
  } else {
    clear_has_underlying_restructuring_type();
    underlying_restructuring_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string underlying_seniority = 92;
inline bool UnderlyingInstrument::has_underlying_seniority() const {
  return (_has_bits_[2] & 0x08000000u) != 0;
}
inline void UnderlyingInstrument::set_has_underlying_seniority() {
  _has_bits_[2] |= 0x08000000u;
}
inline void UnderlyingInstrument::clear_has_underlying_seniority() {
  _has_bits_[2] &= ~0x08000000u;
}
inline void UnderlyingInstrument::clear_underlying_seniority() {
  if (underlying_seniority_ != &::google::protobuf::internal::kEmptyString) {
    underlying_seniority_->clear();
  }
  clear_has_underlying_seniority();
}
inline const ::std::string& UnderlyingInstrument::underlying_seniority() const {
  return *underlying_seniority_;
}
inline void UnderlyingInstrument::set_underlying_seniority(const ::std::string& value) {
  set_has_underlying_seniority();
  if (underlying_seniority_ == &::google::protobuf::internal::kEmptyString) {
    underlying_seniority_ = new ::std::string;
  }
  underlying_seniority_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_seniority(const char* value) {
  set_has_underlying_seniority();
  if (underlying_seniority_ == &::google::protobuf::internal::kEmptyString) {
    underlying_seniority_ = new ::std::string;
  }
  underlying_seniority_->assign(value);
}
inline void UnderlyingInstrument::set_underlying_seniority(const char* value, size_t size) {
  set_has_underlying_seniority();
  if (underlying_seniority_ == &::google::protobuf::internal::kEmptyString) {
    underlying_seniority_ = new ::std::string;
  }
  underlying_seniority_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnderlyingInstrument::mutable_underlying_seniority() {
  set_has_underlying_seniority();
  if (underlying_seniority_ == &::google::protobuf::internal::kEmptyString) {
    underlying_seniority_ = new ::std::string;
  }
  return underlying_seniority_;
}
inline ::std::string* UnderlyingInstrument::release_underlying_seniority() {
  clear_has_underlying_seniority();
  if (underlying_seniority_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = underlying_seniority_;
    underlying_seniority_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnderlyingInstrument::set_allocated_underlying_seniority(::std::string* underlying_seniority) {
  if (underlying_seniority_ != &::google::protobuf::internal::kEmptyString) {
    delete underlying_seniority_;
  }
  if (underlying_seniority) {
    set_has_underlying_seniority();
    underlying_seniority_ = underlying_seniority;
  } else {
    clear_has_underlying_seniority();
    underlying_seniority_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UndInstrmtGrp

// optional .Common.UnderlyingInstrument underlying_instrument = 1;
inline bool UndInstrmtGrp::has_underlying_instrument() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UndInstrmtGrp::set_has_underlying_instrument() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UndInstrmtGrp::clear_has_underlying_instrument() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UndInstrmtGrp::clear_underlying_instrument() {
  if (underlying_instrument_ != NULL) underlying_instrument_->::Common::UnderlyingInstrument::Clear();
  clear_has_underlying_instrument();
}
inline const ::Common::UnderlyingInstrument& UndInstrmtGrp::underlying_instrument() const {
  return underlying_instrument_ != NULL ? *underlying_instrument_ : *default_instance_->underlying_instrument_;
}
inline ::Common::UnderlyingInstrument* UndInstrmtGrp::mutable_underlying_instrument() {
  set_has_underlying_instrument();
  if (underlying_instrument_ == NULL) underlying_instrument_ = new ::Common::UnderlyingInstrument;
  return underlying_instrument_;
}
inline ::Common::UnderlyingInstrument* UndInstrmtGrp::release_underlying_instrument() {
  clear_has_underlying_instrument();
  ::Common::UnderlyingInstrument* temp = underlying_instrument_;
  underlying_instrument_ = NULL;
  return temp;
}
inline void UndInstrmtGrp::set_allocated_underlying_instrument(::Common::UnderlyingInstrument* underlying_instrument) {
  delete underlying_instrument_;
  underlying_instrument_ = underlying_instrument;
  if (underlying_instrument) {
    set_has_underlying_instrument();
  } else {
    clear_has_underlying_instrument();
  }
}

// -------------------------------------------------------------------

// Stipulations

// optional .Common.StipulationTypeEnum stipulation_type = 1;
inline bool Stipulations::has_stipulation_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stipulations::set_has_stipulation_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stipulations::clear_has_stipulation_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stipulations::clear_stipulation_type() {
  stipulation_type_ = 0;
  clear_has_stipulation_type();
}
inline ::Common::StipulationTypeEnum Stipulations::stipulation_type() const {
  return static_cast< ::Common::StipulationTypeEnum >(stipulation_type_);
}
inline void Stipulations::set_stipulation_type(::Common::StipulationTypeEnum value) {
  assert(::Common::StipulationTypeEnum_IsValid(value));
  set_has_stipulation_type();
  stipulation_type_ = value;
}

// optional string stipulation_value = 2;
inline bool Stipulations::has_stipulation_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stipulations::set_has_stipulation_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stipulations::clear_has_stipulation_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stipulations::clear_stipulation_value() {
  if (stipulation_value_ != &::google::protobuf::internal::kEmptyString) {
    stipulation_value_->clear();
  }
  clear_has_stipulation_value();
}
inline const ::std::string& Stipulations::stipulation_value() const {
  return *stipulation_value_;
}
inline void Stipulations::set_stipulation_value(const ::std::string& value) {
  set_has_stipulation_value();
  if (stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    stipulation_value_ = new ::std::string;
  }
  stipulation_value_->assign(value);
}
inline void Stipulations::set_stipulation_value(const char* value) {
  set_has_stipulation_value();
  if (stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    stipulation_value_ = new ::std::string;
  }
  stipulation_value_->assign(value);
}
inline void Stipulations::set_stipulation_value(const char* value, size_t size) {
  set_has_stipulation_value();
  if (stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    stipulation_value_ = new ::std::string;
  }
  stipulation_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stipulations::mutable_stipulation_value() {
  set_has_stipulation_value();
  if (stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    stipulation_value_ = new ::std::string;
  }
  return stipulation_value_;
}
inline ::std::string* Stipulations::release_stipulation_value() {
  clear_has_stipulation_value();
  if (stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stipulation_value_;
    stipulation_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Stipulations::set_allocated_stipulation_value(::std::string* stipulation_value) {
  if (stipulation_value_ != &::google::protobuf::internal::kEmptyString) {
    delete stipulation_value_;
  }
  if (stipulation_value) {
    set_has_stipulation_value();
    stipulation_value_ = stipulation_value;
  } else {
    clear_has_stipulation_value();
    stipulation_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OrderQtyData

// optional sfixed64 cash_order_qty = 1;
inline bool OrderQtyData::has_cash_order_qty() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrderQtyData::set_has_cash_order_qty() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrderQtyData::clear_has_cash_order_qty() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrderQtyData::clear_cash_order_qty() {
  cash_order_qty_ = GOOGLE_LONGLONG(0);
  clear_has_cash_order_qty();
}
inline ::google::protobuf::int64 OrderQtyData::cash_order_qty() const {
  return cash_order_qty_;
}
inline void OrderQtyData::set_cash_order_qty(::google::protobuf::int64 value) {
  set_has_cash_order_qty();
  cash_order_qty_ = value;
}

// optional sfixed32 cash_order_qty_exponent = 2;
inline bool OrderQtyData::has_cash_order_qty_exponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OrderQtyData::set_has_cash_order_qty_exponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OrderQtyData::clear_has_cash_order_qty_exponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OrderQtyData::clear_cash_order_qty_exponent() {
  cash_order_qty_exponent_ = 0;
  clear_has_cash_order_qty_exponent();
}
inline ::google::protobuf::int32 OrderQtyData::cash_order_qty_exponent() const {
  return cash_order_qty_exponent_;
}
inline void OrderQtyData::set_cash_order_qty_exponent(::google::protobuf::int32 value) {
  set_has_cash_order_qty_exponent();
  cash_order_qty_exponent_ = value;
}

// optional sfixed64 order_percent = 3;
inline bool OrderQtyData::has_order_percent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OrderQtyData::set_has_order_percent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OrderQtyData::clear_has_order_percent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OrderQtyData::clear_order_percent() {
  order_percent_ = GOOGLE_LONGLONG(0);
  clear_has_order_percent();
}
inline ::google::protobuf::int64 OrderQtyData::order_percent() const {
  return order_percent_;
}
inline void OrderQtyData::set_order_percent(::google::protobuf::int64 value) {
  set_has_order_percent();
  order_percent_ = value;
}

// optional sfixed32 order_percent_exponent = 4;
inline bool OrderQtyData::has_order_percent_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OrderQtyData::set_has_order_percent_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OrderQtyData::clear_has_order_percent_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OrderQtyData::clear_order_percent_exponent() {
  order_percent_exponent_ = 0;
  clear_has_order_percent_exponent();
}
inline ::google::protobuf::int32 OrderQtyData::order_percent_exponent() const {
  return order_percent_exponent_;
}
inline void OrderQtyData::set_order_percent_exponent(::google::protobuf::int32 value) {
  set_has_order_percent_exponent();
  order_percent_exponent_ = value;
}

// optional sfixed64 order_qty = 5;
inline bool OrderQtyData::has_order_qty() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OrderQtyData::set_has_order_qty() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OrderQtyData::clear_has_order_qty() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OrderQtyData::clear_order_qty() {
  order_qty_ = GOOGLE_LONGLONG(0);
  clear_has_order_qty();
}
inline ::google::protobuf::int64 OrderQtyData::order_qty() const {
  return order_qty_;
}
inline void OrderQtyData::set_order_qty(::google::protobuf::int64 value) {
  set_has_order_qty();
  order_qty_ = value;
}

// optional sfixed32 order_qty_exponent = 6;
inline bool OrderQtyData::has_order_qty_exponent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OrderQtyData::set_has_order_qty_exponent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OrderQtyData::clear_has_order_qty_exponent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OrderQtyData::clear_order_qty_exponent() {
  order_qty_exponent_ = 0;
  clear_has_order_qty_exponent();
}
inline ::google::protobuf::int32 OrderQtyData::order_qty_exponent() const {
  return order_qty_exponent_;
}
inline void OrderQtyData::set_order_qty_exponent(::google::protobuf::int32 value) {
  set_has_order_qty_exponent();
  order_qty_exponent_ = value;
}

// optional .Common.RoundingDirectionEnum rounding_direction = 7;
inline bool OrderQtyData::has_rounding_direction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OrderQtyData::set_has_rounding_direction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OrderQtyData::clear_has_rounding_direction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OrderQtyData::clear_rounding_direction() {
  rounding_direction_ = 0;
  clear_has_rounding_direction();
}
inline ::Common::RoundingDirectionEnum OrderQtyData::rounding_direction() const {
  return static_cast< ::Common::RoundingDirectionEnum >(rounding_direction_);
}
inline void OrderQtyData::set_rounding_direction(::Common::RoundingDirectionEnum value) {
  assert(::Common::RoundingDirectionEnum_IsValid(value));
  set_has_rounding_direction();
  rounding_direction_ = value;
}

// optional double rounding_modulus = 8;
inline bool OrderQtyData::has_rounding_modulus() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OrderQtyData::set_has_rounding_modulus() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OrderQtyData::clear_has_rounding_modulus() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OrderQtyData::clear_rounding_modulus() {
  rounding_modulus_ = 0;
  clear_has_rounding_modulus();
}
inline double OrderQtyData::rounding_modulus() const {
  return rounding_modulus_;
}
inline void OrderQtyData::set_rounding_modulus(double value) {
  set_has_rounding_modulus();
  rounding_modulus_ = value;
}

// -------------------------------------------------------------------

// TriggeringInstruction

// optional .Common.TriggerActionEnum trigger_action = 1;
inline bool TriggeringInstruction::has_trigger_action() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_action() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TriggeringInstruction::clear_has_trigger_action() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TriggeringInstruction::clear_trigger_action() {
  trigger_action_ = 0;
  clear_has_trigger_action();
}
inline ::Common::TriggerActionEnum TriggeringInstruction::trigger_action() const {
  return static_cast< ::Common::TriggerActionEnum >(trigger_action_);
}
inline void TriggeringInstruction::set_trigger_action(::Common::TriggerActionEnum value) {
  assert(::Common::TriggerActionEnum_IsValid(value));
  set_has_trigger_action();
  trigger_action_ = value;
}

// optional sfixed64 trigger_new_price = 2;
inline bool TriggeringInstruction::has_trigger_new_price() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_new_price() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TriggeringInstruction::clear_has_trigger_new_price() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TriggeringInstruction::clear_trigger_new_price() {
  trigger_new_price_ = GOOGLE_LONGLONG(0);
  clear_has_trigger_new_price();
}
inline ::google::protobuf::int64 TriggeringInstruction::trigger_new_price() const {
  return trigger_new_price_;
}
inline void TriggeringInstruction::set_trigger_new_price(::google::protobuf::int64 value) {
  set_has_trigger_new_price();
  trigger_new_price_ = value;
}

// optional sfixed32 trigger_new_price_exponent = 3;
inline bool TriggeringInstruction::has_trigger_new_price_exponent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_new_price_exponent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TriggeringInstruction::clear_has_trigger_new_price_exponent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TriggeringInstruction::clear_trigger_new_price_exponent() {
  trigger_new_price_exponent_ = 0;
  clear_has_trigger_new_price_exponent();
}
inline ::google::protobuf::int32 TriggeringInstruction::trigger_new_price_exponent() const {
  return trigger_new_price_exponent_;
}
inline void TriggeringInstruction::set_trigger_new_price_exponent(::google::protobuf::int32 value) {
  set_has_trigger_new_price_exponent();
  trigger_new_price_exponent_ = value;
}

// optional sfixed64 trigger_new_qty = 4;
inline bool TriggeringInstruction::has_trigger_new_qty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_new_qty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TriggeringInstruction::clear_has_trigger_new_qty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TriggeringInstruction::clear_trigger_new_qty() {
  trigger_new_qty_ = GOOGLE_LONGLONG(0);
  clear_has_trigger_new_qty();
}
inline ::google::protobuf::int64 TriggeringInstruction::trigger_new_qty() const {
  return trigger_new_qty_;
}
inline void TriggeringInstruction::set_trigger_new_qty(::google::protobuf::int64 value) {
  set_has_trigger_new_qty();
  trigger_new_qty_ = value;
}

// optional sfixed32 trigger_new_qty_exponent = 5;
inline bool TriggeringInstruction::has_trigger_new_qty_exponent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_new_qty_exponent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TriggeringInstruction::clear_has_trigger_new_qty_exponent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TriggeringInstruction::clear_trigger_new_qty_exponent() {
  trigger_new_qty_exponent_ = 0;
  clear_has_trigger_new_qty_exponent();
}
inline ::google::protobuf::int32 TriggeringInstruction::trigger_new_qty_exponent() const {
  return trigger_new_qty_exponent_;
}
inline void TriggeringInstruction::set_trigger_new_qty_exponent(::google::protobuf::int32 value) {
  set_has_trigger_new_qty_exponent();
  trigger_new_qty_exponent_ = value;
}

// optional .Common.TriggerOrderTypeEnum trigger_order_type = 6;
inline bool TriggeringInstruction::has_trigger_order_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_order_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TriggeringInstruction::clear_has_trigger_order_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TriggeringInstruction::clear_trigger_order_type() {
  trigger_order_type_ = 0;
  clear_has_trigger_order_type();
}
inline ::Common::TriggerOrderTypeEnum TriggeringInstruction::trigger_order_type() const {
  return static_cast< ::Common::TriggerOrderTypeEnum >(trigger_order_type_);
}
inline void TriggeringInstruction::set_trigger_order_type(::Common::TriggerOrderTypeEnum value) {
  assert(::Common::TriggerOrderTypeEnum_IsValid(value));
  set_has_trigger_order_type();
  trigger_order_type_ = value;
}

// optional sfixed64 trigger_price = 7;
inline bool TriggeringInstruction::has_trigger_price() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_price() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TriggeringInstruction::clear_has_trigger_price() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TriggeringInstruction::clear_trigger_price() {
  trigger_price_ = GOOGLE_LONGLONG(0);
  clear_has_trigger_price();
}
inline ::google::protobuf::int64 TriggeringInstruction::trigger_price() const {
  return trigger_price_;
}
inline void TriggeringInstruction::set_trigger_price(::google::protobuf::int64 value) {
  set_has_trigger_price();
  trigger_price_ = value;
}

// optional sfixed32 trigger_price_exponent = 8;
inline bool TriggeringInstruction::has_trigger_price_exponent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_price_exponent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TriggeringInstruction::clear_has_trigger_price_exponent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TriggeringInstruction::clear_trigger_price_exponent() {
  trigger_price_exponent_ = 0;
  clear_has_trigger_price_exponent();
}
inline ::google::protobuf::int32 TriggeringInstruction::trigger_price_exponent() const {
  return trigger_price_exponent_;
}
inline void TriggeringInstruction::set_trigger_price_exponent(::google::protobuf::int32 value) {
  set_has_trigger_price_exponent();
  trigger_price_exponent_ = value;
}

// optional .Common.TriggerPriceDirectionEnum trigger_price_direction = 9;
inline bool TriggeringInstruction::has_trigger_price_direction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_price_direction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TriggeringInstruction::clear_has_trigger_price_direction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TriggeringInstruction::clear_trigger_price_direction() {
  trigger_price_direction_ = 0;
  clear_has_trigger_price_direction();
}
inline ::Common::TriggerPriceDirectionEnum TriggeringInstruction::trigger_price_direction() const {
  return static_cast< ::Common::TriggerPriceDirectionEnum >(trigger_price_direction_);
}
inline void TriggeringInstruction::set_trigger_price_direction(::Common::TriggerPriceDirectionEnum value) {
  assert(::Common::TriggerPriceDirectionEnum_IsValid(value));
  set_has_trigger_price_direction();
  trigger_price_direction_ = value;
}

// optional .Common.TriggerPriceTypeEnum trigger_price_type = 10;
inline bool TriggeringInstruction::has_trigger_price_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_price_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TriggeringInstruction::clear_has_trigger_price_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TriggeringInstruction::clear_trigger_price_type() {
  trigger_price_type_ = 0;
  clear_has_trigger_price_type();
}
inline ::Common::TriggerPriceTypeEnum TriggeringInstruction::trigger_price_type() const {
  return static_cast< ::Common::TriggerPriceTypeEnum >(trigger_price_type_);
}
inline void TriggeringInstruction::set_trigger_price_type(::Common::TriggerPriceTypeEnum value) {
  assert(::Common::TriggerPriceTypeEnum_IsValid(value));
  set_has_trigger_price_type();
  trigger_price_type_ = value;
}

// optional .Common.TriggerPriceTypeScopeEnum trigger_price_type_scope = 11;
inline bool TriggeringInstruction::has_trigger_price_type_scope() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_price_type_scope() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TriggeringInstruction::clear_has_trigger_price_type_scope() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TriggeringInstruction::clear_trigger_price_type_scope() {
  trigger_price_type_scope_ = 0;
  clear_has_trigger_price_type_scope();
}
inline ::Common::TriggerPriceTypeScopeEnum TriggeringInstruction::trigger_price_type_scope() const {
  return static_cast< ::Common::TriggerPriceTypeScopeEnum >(trigger_price_type_scope_);
}
inline void TriggeringInstruction::set_trigger_price_type_scope(::Common::TriggerPriceTypeScopeEnum value) {
  assert(::Common::TriggerPriceTypeScopeEnum_IsValid(value));
  set_has_trigger_price_type_scope();
  trigger_price_type_scope_ = value;
}

// optional string trigger_security_desc = 12;
inline bool TriggeringInstruction::has_trigger_security_desc() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_security_desc() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TriggeringInstruction::clear_has_trigger_security_desc() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TriggeringInstruction::clear_trigger_security_desc() {
  if (trigger_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    trigger_security_desc_->clear();
  }
  clear_has_trigger_security_desc();
}
inline const ::std::string& TriggeringInstruction::trigger_security_desc() const {
  return *trigger_security_desc_;
}
inline void TriggeringInstruction::set_trigger_security_desc(const ::std::string& value) {
  set_has_trigger_security_desc();
  if (trigger_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_desc_ = new ::std::string;
  }
  trigger_security_desc_->assign(value);
}
inline void TriggeringInstruction::set_trigger_security_desc(const char* value) {
  set_has_trigger_security_desc();
  if (trigger_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_desc_ = new ::std::string;
  }
  trigger_security_desc_->assign(value);
}
inline void TriggeringInstruction::set_trigger_security_desc(const char* value, size_t size) {
  set_has_trigger_security_desc();
  if (trigger_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_desc_ = new ::std::string;
  }
  trigger_security_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggeringInstruction::mutable_trigger_security_desc() {
  set_has_trigger_security_desc();
  if (trigger_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_desc_ = new ::std::string;
  }
  return trigger_security_desc_;
}
inline ::std::string* TriggeringInstruction::release_trigger_security_desc() {
  clear_has_trigger_security_desc();
  if (trigger_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trigger_security_desc_;
    trigger_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggeringInstruction::set_allocated_trigger_security_desc(::std::string* trigger_security_desc) {
  if (trigger_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete trigger_security_desc_;
  }
  if (trigger_security_desc) {
    set_has_trigger_security_desc();
    trigger_security_desc_ = trigger_security_desc;
  } else {
    clear_has_trigger_security_desc();
    trigger_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string trigger_security_id = 13;
inline bool TriggeringInstruction::has_trigger_security_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_security_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TriggeringInstruction::clear_has_trigger_security_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TriggeringInstruction::clear_trigger_security_id() {
  if (trigger_security_id_ != &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_->clear();
  }
  clear_has_trigger_security_id();
}
inline const ::std::string& TriggeringInstruction::trigger_security_id() const {
  return *trigger_security_id_;
}
inline void TriggeringInstruction::set_trigger_security_id(const ::std::string& value) {
  set_has_trigger_security_id();
  if (trigger_security_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_ = new ::std::string;
  }
  trigger_security_id_->assign(value);
}
inline void TriggeringInstruction::set_trigger_security_id(const char* value) {
  set_has_trigger_security_id();
  if (trigger_security_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_ = new ::std::string;
  }
  trigger_security_id_->assign(value);
}
inline void TriggeringInstruction::set_trigger_security_id(const char* value, size_t size) {
  set_has_trigger_security_id();
  if (trigger_security_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_ = new ::std::string;
  }
  trigger_security_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggeringInstruction::mutable_trigger_security_id() {
  set_has_trigger_security_id();
  if (trigger_security_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_ = new ::std::string;
  }
  return trigger_security_id_;
}
inline ::std::string* TriggeringInstruction::release_trigger_security_id() {
  clear_has_trigger_security_id();
  if (trigger_security_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trigger_security_id_;
    trigger_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggeringInstruction::set_allocated_trigger_security_id(::std::string* trigger_security_id) {
  if (trigger_security_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trigger_security_id_;
  }
  if (trigger_security_id) {
    set_has_trigger_security_id();
    trigger_security_id_ = trigger_security_id;
  } else {
    clear_has_trigger_security_id();
    trigger_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string trigger_security_id_source = 14;
inline bool TriggeringInstruction::has_trigger_security_id_source() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_security_id_source() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TriggeringInstruction::clear_has_trigger_security_id_source() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TriggeringInstruction::clear_trigger_security_id_source() {
  if (trigger_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_source_->clear();
  }
  clear_has_trigger_security_id_source();
}
inline const ::std::string& TriggeringInstruction::trigger_security_id_source() const {
  return *trigger_security_id_source_;
}
inline void TriggeringInstruction::set_trigger_security_id_source(const ::std::string& value) {
  set_has_trigger_security_id_source();
  if (trigger_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_source_ = new ::std::string;
  }
  trigger_security_id_source_->assign(value);
}
inline void TriggeringInstruction::set_trigger_security_id_source(const char* value) {
  set_has_trigger_security_id_source();
  if (trigger_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_source_ = new ::std::string;
  }
  trigger_security_id_source_->assign(value);
}
inline void TriggeringInstruction::set_trigger_security_id_source(const char* value, size_t size) {
  set_has_trigger_security_id_source();
  if (trigger_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_source_ = new ::std::string;
  }
  trigger_security_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggeringInstruction::mutable_trigger_security_id_source() {
  set_has_trigger_security_id_source();
  if (trigger_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    trigger_security_id_source_ = new ::std::string;
  }
  return trigger_security_id_source_;
}
inline ::std::string* TriggeringInstruction::release_trigger_security_id_source() {
  clear_has_trigger_security_id_source();
  if (trigger_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trigger_security_id_source_;
    trigger_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggeringInstruction::set_allocated_trigger_security_id_source(::std::string* trigger_security_id_source) {
  if (trigger_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete trigger_security_id_source_;
  }
  if (trigger_security_id_source) {
    set_has_trigger_security_id_source();
    trigger_security_id_source_ = trigger_security_id_source;
  } else {
    clear_has_trigger_security_id_source();
    trigger_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string trigger_symbol = 15;
inline bool TriggeringInstruction::has_trigger_symbol() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_symbol() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TriggeringInstruction::clear_has_trigger_symbol() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TriggeringInstruction::clear_trigger_symbol() {
  if (trigger_symbol_ != &::google::protobuf::internal::kEmptyString) {
    trigger_symbol_->clear();
  }
  clear_has_trigger_symbol();
}
inline const ::std::string& TriggeringInstruction::trigger_symbol() const {
  return *trigger_symbol_;
}
inline void TriggeringInstruction::set_trigger_symbol(const ::std::string& value) {
  set_has_trigger_symbol();
  if (trigger_symbol_ == &::google::protobuf::internal::kEmptyString) {
    trigger_symbol_ = new ::std::string;
  }
  trigger_symbol_->assign(value);
}
inline void TriggeringInstruction::set_trigger_symbol(const char* value) {
  set_has_trigger_symbol();
  if (trigger_symbol_ == &::google::protobuf::internal::kEmptyString) {
    trigger_symbol_ = new ::std::string;
  }
  trigger_symbol_->assign(value);
}
inline void TriggeringInstruction::set_trigger_symbol(const char* value, size_t size) {
  set_has_trigger_symbol();
  if (trigger_symbol_ == &::google::protobuf::internal::kEmptyString) {
    trigger_symbol_ = new ::std::string;
  }
  trigger_symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggeringInstruction::mutable_trigger_symbol() {
  set_has_trigger_symbol();
  if (trigger_symbol_ == &::google::protobuf::internal::kEmptyString) {
    trigger_symbol_ = new ::std::string;
  }
  return trigger_symbol_;
}
inline ::std::string* TriggeringInstruction::release_trigger_symbol() {
  clear_has_trigger_symbol();
  if (trigger_symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trigger_symbol_;
    trigger_symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggeringInstruction::set_allocated_trigger_symbol(::std::string* trigger_symbol) {
  if (trigger_symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete trigger_symbol_;
  }
  if (trigger_symbol) {
    set_has_trigger_symbol();
    trigger_symbol_ = trigger_symbol;
  } else {
    clear_has_trigger_symbol();
    trigger_symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string trigger_trading_session_id = 16;
inline bool TriggeringInstruction::has_trigger_trading_session_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_trading_session_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TriggeringInstruction::clear_has_trigger_trading_session_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TriggeringInstruction::clear_trigger_trading_session_id() {
  if (trigger_trading_session_id_ != &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_id_->clear();
  }
  clear_has_trigger_trading_session_id();
}
inline const ::std::string& TriggeringInstruction::trigger_trading_session_id() const {
  return *trigger_trading_session_id_;
}
inline void TriggeringInstruction::set_trigger_trading_session_id(const ::std::string& value) {
  set_has_trigger_trading_session_id();
  if (trigger_trading_session_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_id_ = new ::std::string;
  }
  trigger_trading_session_id_->assign(value);
}
inline void TriggeringInstruction::set_trigger_trading_session_id(const char* value) {
  set_has_trigger_trading_session_id();
  if (trigger_trading_session_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_id_ = new ::std::string;
  }
  trigger_trading_session_id_->assign(value);
}
inline void TriggeringInstruction::set_trigger_trading_session_id(const char* value, size_t size) {
  set_has_trigger_trading_session_id();
  if (trigger_trading_session_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_id_ = new ::std::string;
  }
  trigger_trading_session_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggeringInstruction::mutable_trigger_trading_session_id() {
  set_has_trigger_trading_session_id();
  if (trigger_trading_session_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_id_ = new ::std::string;
  }
  return trigger_trading_session_id_;
}
inline ::std::string* TriggeringInstruction::release_trigger_trading_session_id() {
  clear_has_trigger_trading_session_id();
  if (trigger_trading_session_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trigger_trading_session_id_;
    trigger_trading_session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggeringInstruction::set_allocated_trigger_trading_session_id(::std::string* trigger_trading_session_id) {
  if (trigger_trading_session_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trigger_trading_session_id_;
  }
  if (trigger_trading_session_id) {
    set_has_trigger_trading_session_id();
    trigger_trading_session_id_ = trigger_trading_session_id;
  } else {
    clear_has_trigger_trading_session_id();
    trigger_trading_session_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string trigger_trading_session_sub_id = 17;
inline bool TriggeringInstruction::has_trigger_trading_session_sub_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_trading_session_sub_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TriggeringInstruction::clear_has_trigger_trading_session_sub_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TriggeringInstruction::clear_trigger_trading_session_sub_id() {
  if (trigger_trading_session_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_sub_id_->clear();
  }
  clear_has_trigger_trading_session_sub_id();
}
inline const ::std::string& TriggeringInstruction::trigger_trading_session_sub_id() const {
  return *trigger_trading_session_sub_id_;
}
inline void TriggeringInstruction::set_trigger_trading_session_sub_id(const ::std::string& value) {
  set_has_trigger_trading_session_sub_id();
  if (trigger_trading_session_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_sub_id_ = new ::std::string;
  }
  trigger_trading_session_sub_id_->assign(value);
}
inline void TriggeringInstruction::set_trigger_trading_session_sub_id(const char* value) {
  set_has_trigger_trading_session_sub_id();
  if (trigger_trading_session_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_sub_id_ = new ::std::string;
  }
  trigger_trading_session_sub_id_->assign(value);
}
inline void TriggeringInstruction::set_trigger_trading_session_sub_id(const char* value, size_t size) {
  set_has_trigger_trading_session_sub_id();
  if (trigger_trading_session_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_sub_id_ = new ::std::string;
  }
  trigger_trading_session_sub_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TriggeringInstruction::mutable_trigger_trading_session_sub_id() {
  set_has_trigger_trading_session_sub_id();
  if (trigger_trading_session_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    trigger_trading_session_sub_id_ = new ::std::string;
  }
  return trigger_trading_session_sub_id_;
}
inline ::std::string* TriggeringInstruction::release_trigger_trading_session_sub_id() {
  clear_has_trigger_trading_session_sub_id();
  if (trigger_trading_session_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trigger_trading_session_sub_id_;
    trigger_trading_session_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TriggeringInstruction::set_allocated_trigger_trading_session_sub_id(::std::string* trigger_trading_session_sub_id) {
  if (trigger_trading_session_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trigger_trading_session_sub_id_;
  }
  if (trigger_trading_session_sub_id) {
    set_has_trigger_trading_session_sub_id();
    trigger_trading_session_sub_id_ = trigger_trading_session_sub_id;
  } else {
    clear_has_trigger_trading_session_sub_id();
    trigger_trading_session_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.TriggerTypeEnum trigger_type = 18;
inline bool TriggeringInstruction::has_trigger_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void TriggeringInstruction::set_has_trigger_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void TriggeringInstruction::clear_has_trigger_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void TriggeringInstruction::clear_trigger_type() {
  trigger_type_ = 0;
  clear_has_trigger_type();
}
inline ::Common::TriggerTypeEnum TriggeringInstruction::trigger_type() const {
  return static_cast< ::Common::TriggerTypeEnum >(trigger_type_);
}
inline void TriggeringInstruction::set_trigger_type(::Common::TriggerTypeEnum value) {
  assert(::Common::TriggerTypeEnum_IsValid(value));
  set_has_trigger_type();
  trigger_type_ = value;
}

// -------------------------------------------------------------------

// SpreadOrBenchmarkCurveData

// optional string benchmark_curve_currency = 1;
inline bool SpreadOrBenchmarkCurveData::has_benchmark_curve_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_benchmark_curve_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_benchmark_curve_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpreadOrBenchmarkCurveData::clear_benchmark_curve_currency() {
  if (benchmark_curve_currency_ != &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_currency_->clear();
  }
  clear_has_benchmark_curve_currency();
}
inline const ::std::string& SpreadOrBenchmarkCurveData::benchmark_curve_currency() const {
  return *benchmark_curve_currency_;
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_curve_currency(const ::std::string& value) {
  set_has_benchmark_curve_currency();
  if (benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_currency_ = new ::std::string;
  }
  benchmark_curve_currency_->assign(value);
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_curve_currency(const char* value) {
  set_has_benchmark_curve_currency();
  if (benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_currency_ = new ::std::string;
  }
  benchmark_curve_currency_->assign(value);
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_curve_currency(const char* value, size_t size) {
  set_has_benchmark_curve_currency();
  if (benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_currency_ = new ::std::string;
  }
  benchmark_curve_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpreadOrBenchmarkCurveData::mutable_benchmark_curve_currency() {
  set_has_benchmark_curve_currency();
  if (benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_currency_ = new ::std::string;
  }
  return benchmark_curve_currency_;
}
inline ::std::string* SpreadOrBenchmarkCurveData::release_benchmark_curve_currency() {
  clear_has_benchmark_curve_currency();
  if (benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = benchmark_curve_currency_;
    benchmark_curve_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpreadOrBenchmarkCurveData::set_allocated_benchmark_curve_currency(::std::string* benchmark_curve_currency) {
  if (benchmark_curve_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete benchmark_curve_currency_;
  }
  if (benchmark_curve_currency) {
    set_has_benchmark_curve_currency();
    benchmark_curve_currency_ = benchmark_curve_currency;
  } else {
    clear_has_benchmark_curve_currency();
    benchmark_curve_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.BenchmarkCurveNameEnum benchmark_curve_name = 2;
inline bool SpreadOrBenchmarkCurveData::has_benchmark_curve_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_benchmark_curve_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_benchmark_curve_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpreadOrBenchmarkCurveData::clear_benchmark_curve_name() {
  benchmark_curve_name_ = 0;
  clear_has_benchmark_curve_name();
}
inline ::Common::BenchmarkCurveNameEnum SpreadOrBenchmarkCurveData::benchmark_curve_name() const {
  return static_cast< ::Common::BenchmarkCurveNameEnum >(benchmark_curve_name_);
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_curve_name(::Common::BenchmarkCurveNameEnum value) {
  assert(::Common::BenchmarkCurveNameEnum_IsValid(value));
  set_has_benchmark_curve_name();
  benchmark_curve_name_ = value;
}

// optional string benchmark_curve_point = 3;
inline bool SpreadOrBenchmarkCurveData::has_benchmark_curve_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_benchmark_curve_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_benchmark_curve_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpreadOrBenchmarkCurveData::clear_benchmark_curve_point() {
  if (benchmark_curve_point_ != &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_point_->clear();
  }
  clear_has_benchmark_curve_point();
}
inline const ::std::string& SpreadOrBenchmarkCurveData::benchmark_curve_point() const {
  return *benchmark_curve_point_;
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_curve_point(const ::std::string& value) {
  set_has_benchmark_curve_point();
  if (benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_point_ = new ::std::string;
  }
  benchmark_curve_point_->assign(value);
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_curve_point(const char* value) {
  set_has_benchmark_curve_point();
  if (benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_point_ = new ::std::string;
  }
  benchmark_curve_point_->assign(value);
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_curve_point(const char* value, size_t size) {
  set_has_benchmark_curve_point();
  if (benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_point_ = new ::std::string;
  }
  benchmark_curve_point_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpreadOrBenchmarkCurveData::mutable_benchmark_curve_point() {
  set_has_benchmark_curve_point();
  if (benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_curve_point_ = new ::std::string;
  }
  return benchmark_curve_point_;
}
inline ::std::string* SpreadOrBenchmarkCurveData::release_benchmark_curve_point() {
  clear_has_benchmark_curve_point();
  if (benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = benchmark_curve_point_;
    benchmark_curve_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpreadOrBenchmarkCurveData::set_allocated_benchmark_curve_point(::std::string* benchmark_curve_point) {
  if (benchmark_curve_point_ != &::google::protobuf::internal::kEmptyString) {
    delete benchmark_curve_point_;
  }
  if (benchmark_curve_point) {
    set_has_benchmark_curve_point();
    benchmark_curve_point_ = benchmark_curve_point;
  } else {
    clear_has_benchmark_curve_point();
    benchmark_curve_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 spread = 4;
inline bool SpreadOrBenchmarkCurveData::has_spread() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_spread() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_spread() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpreadOrBenchmarkCurveData::clear_spread() {
  spread_ = GOOGLE_LONGLONG(0);
  clear_has_spread();
}
inline ::google::protobuf::int64 SpreadOrBenchmarkCurveData::spread() const {
  return spread_;
}
inline void SpreadOrBenchmarkCurveData::set_spread(::google::protobuf::int64 value) {
  set_has_spread();
  spread_ = value;
}

// optional sfixed32 spread_exponent = 5;
inline bool SpreadOrBenchmarkCurveData::has_spread_exponent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_spread_exponent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_spread_exponent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpreadOrBenchmarkCurveData::clear_spread_exponent() {
  spread_exponent_ = 0;
  clear_has_spread_exponent();
}
inline ::google::protobuf::int32 SpreadOrBenchmarkCurveData::spread_exponent() const {
  return spread_exponent_;
}
inline void SpreadOrBenchmarkCurveData::set_spread_exponent(::google::protobuf::int32 value) {
  set_has_spread_exponent();
  spread_exponent_ = value;
}

// optional sfixed64 benchmark_price = 6;
inline bool SpreadOrBenchmarkCurveData::has_benchmark_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_benchmark_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_benchmark_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SpreadOrBenchmarkCurveData::clear_benchmark_price() {
  benchmark_price_ = GOOGLE_LONGLONG(0);
  clear_has_benchmark_price();
}
inline ::google::protobuf::int64 SpreadOrBenchmarkCurveData::benchmark_price() const {
  return benchmark_price_;
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_price(::google::protobuf::int64 value) {
  set_has_benchmark_price();
  benchmark_price_ = value;
}

// optional sfixed32 benchmark_price_exponent = 7;
inline bool SpreadOrBenchmarkCurveData::has_benchmark_price_exponent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_benchmark_price_exponent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_benchmark_price_exponent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SpreadOrBenchmarkCurveData::clear_benchmark_price_exponent() {
  benchmark_price_exponent_ = 0;
  clear_has_benchmark_price_exponent();
}
inline ::google::protobuf::int32 SpreadOrBenchmarkCurveData::benchmark_price_exponent() const {
  return benchmark_price_exponent_;
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_price_exponent(::google::protobuf::int32 value) {
  set_has_benchmark_price_exponent();
  benchmark_price_exponent_ = value;
}

// optional sfixed64 benchmark_price_type = 8;
inline bool SpreadOrBenchmarkCurveData::has_benchmark_price_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_benchmark_price_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_benchmark_price_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SpreadOrBenchmarkCurveData::clear_benchmark_price_type() {
  benchmark_price_type_ = GOOGLE_LONGLONG(0);
  clear_has_benchmark_price_type();
}
inline ::google::protobuf::int64 SpreadOrBenchmarkCurveData::benchmark_price_type() const {
  return benchmark_price_type_;
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_price_type(::google::protobuf::int64 value) {
  set_has_benchmark_price_type();
  benchmark_price_type_ = value;
}

// optional string benchmark_security_id = 9;
inline bool SpreadOrBenchmarkCurveData::has_benchmark_security_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_benchmark_security_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_benchmark_security_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SpreadOrBenchmarkCurveData::clear_benchmark_security_id() {
  if (benchmark_security_id_ != &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_->clear();
  }
  clear_has_benchmark_security_id();
}
inline const ::std::string& SpreadOrBenchmarkCurveData::benchmark_security_id() const {
  return *benchmark_security_id_;
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_security_id(const ::std::string& value) {
  set_has_benchmark_security_id();
  if (benchmark_security_id_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_ = new ::std::string;
  }
  benchmark_security_id_->assign(value);
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_security_id(const char* value) {
  set_has_benchmark_security_id();
  if (benchmark_security_id_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_ = new ::std::string;
  }
  benchmark_security_id_->assign(value);
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_security_id(const char* value, size_t size) {
  set_has_benchmark_security_id();
  if (benchmark_security_id_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_ = new ::std::string;
  }
  benchmark_security_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpreadOrBenchmarkCurveData::mutable_benchmark_security_id() {
  set_has_benchmark_security_id();
  if (benchmark_security_id_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_ = new ::std::string;
  }
  return benchmark_security_id_;
}
inline ::std::string* SpreadOrBenchmarkCurveData::release_benchmark_security_id() {
  clear_has_benchmark_security_id();
  if (benchmark_security_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = benchmark_security_id_;
    benchmark_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpreadOrBenchmarkCurveData::set_allocated_benchmark_security_id(::std::string* benchmark_security_id) {
  if (benchmark_security_id_ != &::google::protobuf::internal::kEmptyString) {
    delete benchmark_security_id_;
  }
  if (benchmark_security_id) {
    set_has_benchmark_security_id();
    benchmark_security_id_ = benchmark_security_id;
  } else {
    clear_has_benchmark_security_id();
    benchmark_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string benchmark_security_id_source = 10;
inline bool SpreadOrBenchmarkCurveData::has_benchmark_security_id_source() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SpreadOrBenchmarkCurveData::set_has_benchmark_security_id_source() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SpreadOrBenchmarkCurveData::clear_has_benchmark_security_id_source() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SpreadOrBenchmarkCurveData::clear_benchmark_security_id_source() {
  if (benchmark_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_source_->clear();
  }
  clear_has_benchmark_security_id_source();
}
inline const ::std::string& SpreadOrBenchmarkCurveData::benchmark_security_id_source() const {
  return *benchmark_security_id_source_;
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_security_id_source(const ::std::string& value) {
  set_has_benchmark_security_id_source();
  if (benchmark_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_source_ = new ::std::string;
  }
  benchmark_security_id_source_->assign(value);
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_security_id_source(const char* value) {
  set_has_benchmark_security_id_source();
  if (benchmark_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_source_ = new ::std::string;
  }
  benchmark_security_id_source_->assign(value);
}
inline void SpreadOrBenchmarkCurveData::set_benchmark_security_id_source(const char* value, size_t size) {
  set_has_benchmark_security_id_source();
  if (benchmark_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_source_ = new ::std::string;
  }
  benchmark_security_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpreadOrBenchmarkCurveData::mutable_benchmark_security_id_source() {
  set_has_benchmark_security_id_source();
  if (benchmark_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    benchmark_security_id_source_ = new ::std::string;
  }
  return benchmark_security_id_source_;
}
inline ::std::string* SpreadOrBenchmarkCurveData::release_benchmark_security_id_source() {
  clear_has_benchmark_security_id_source();
  if (benchmark_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = benchmark_security_id_source_;
    benchmark_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpreadOrBenchmarkCurveData::set_allocated_benchmark_security_id_source(::std::string* benchmark_security_id_source) {
  if (benchmark_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete benchmark_security_id_source_;
  }
  if (benchmark_security_id_source) {
    set_has_benchmark_security_id_source();
    benchmark_security_id_source_ = benchmark_security_id_source;
  } else {
    clear_has_benchmark_security_id_source();
    benchmark_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// YieldData

// optional sfixed64 yield = 1;
inline bool YieldData::has_yield() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YieldData::set_has_yield() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YieldData::clear_has_yield() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YieldData::clear_yield() {
  yield_ = GOOGLE_LONGLONG(0);
  clear_has_yield();
}
inline ::google::protobuf::int64 YieldData::yield() const {
  return yield_;
}
inline void YieldData::set_yield(::google::protobuf::int64 value) {
  set_has_yield();
  yield_ = value;
}

// optional sfixed32 yield_exponent = 2;
inline bool YieldData::has_yield_exponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YieldData::set_has_yield_exponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YieldData::clear_has_yield_exponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YieldData::clear_yield_exponent() {
  yield_exponent_ = 0;
  clear_has_yield_exponent();
}
inline ::google::protobuf::int32 YieldData::yield_exponent() const {
  return yield_exponent_;
}
inline void YieldData::set_yield_exponent(::google::protobuf::int32 value) {
  set_has_yield_exponent();
  yield_exponent_ = value;
}

// optional .Common.YieldTypeEnum yield_type = 3;
inline bool YieldData::has_yield_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YieldData::set_has_yield_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YieldData::clear_has_yield_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YieldData::clear_yield_type() {
  yield_type_ = 0;
  clear_has_yield_type();
}
inline ::Common::YieldTypeEnum YieldData::yield_type() const {
  return static_cast< ::Common::YieldTypeEnum >(yield_type_);
}
inline void YieldData::set_yield_type(::Common::YieldTypeEnum value) {
  assert(::Common::YieldTypeEnum_IsValid(value));
  set_has_yield_type();
  yield_type_ = value;
}

// optional sfixed32 yield_calc_date = 4;
inline bool YieldData::has_yield_calc_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YieldData::set_has_yield_calc_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YieldData::clear_has_yield_calc_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YieldData::clear_yield_calc_date() {
  yield_calc_date_ = 0;
  clear_has_yield_calc_date();
}
inline ::google::protobuf::int32 YieldData::yield_calc_date() const {
  return yield_calc_date_;
}
inline void YieldData::set_yield_calc_date(::google::protobuf::int32 value) {
  set_has_yield_calc_date();
  yield_calc_date_ = value;
}

// optional sfixed32 yield_redemption_date = 5;
inline bool YieldData::has_yield_redemption_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YieldData::set_has_yield_redemption_date() {
  _has_bits_[0] |= 0x00000010u;
}
inline void YieldData::clear_has_yield_redemption_date() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void YieldData::clear_yield_redemption_date() {
  yield_redemption_date_ = 0;
  clear_has_yield_redemption_date();
}
inline ::google::protobuf::int32 YieldData::yield_redemption_date() const {
  return yield_redemption_date_;
}
inline void YieldData::set_yield_redemption_date(::google::protobuf::int32 value) {
  set_has_yield_redemption_date();
  yield_redemption_date_ = value;
}

// optional sfixed64 yield_redemption_price = 6;
inline bool YieldData::has_yield_redemption_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void YieldData::set_has_yield_redemption_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void YieldData::clear_has_yield_redemption_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void YieldData::clear_yield_redemption_price() {
  yield_redemption_price_ = GOOGLE_LONGLONG(0);
  clear_has_yield_redemption_price();
}
inline ::google::protobuf::int64 YieldData::yield_redemption_price() const {
  return yield_redemption_price_;
}
inline void YieldData::set_yield_redemption_price(::google::protobuf::int64 value) {
  set_has_yield_redemption_price();
  yield_redemption_price_ = value;
}

// optional sfixed32 yield_redemption_price_exponent = 7;
inline bool YieldData::has_yield_redemption_price_exponent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void YieldData::set_has_yield_redemption_price_exponent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void YieldData::clear_has_yield_redemption_price_exponent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void YieldData::clear_yield_redemption_price_exponent() {
  yield_redemption_price_exponent_ = 0;
  clear_has_yield_redemption_price_exponent();
}
inline ::google::protobuf::int32 YieldData::yield_redemption_price_exponent() const {
  return yield_redemption_price_exponent_;
}
inline void YieldData::set_yield_redemption_price_exponent(::google::protobuf::int32 value) {
  set_has_yield_redemption_price_exponent();
  yield_redemption_price_exponent_ = value;
}

// optional sfixed64 yield_redemption_price_type = 8;
inline bool YieldData::has_yield_redemption_price_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void YieldData::set_has_yield_redemption_price_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void YieldData::clear_has_yield_redemption_price_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void YieldData::clear_yield_redemption_price_type() {
  yield_redemption_price_type_ = GOOGLE_LONGLONG(0);
  clear_has_yield_redemption_price_type();
}
inline ::google::protobuf::int64 YieldData::yield_redemption_price_type() const {
  return yield_redemption_price_type_;
}
inline void YieldData::set_yield_redemption_price_type(::google::protobuf::int64 value) {
  set_has_yield_redemption_price_type();
  yield_redemption_price_type_ = value;
}

// -------------------------------------------------------------------

// CommissionData

// optional string comm_currency = 1;
inline bool CommissionData::has_comm_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommissionData::set_has_comm_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommissionData::clear_has_comm_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommissionData::clear_comm_currency() {
  if (comm_currency_ != &::google::protobuf::internal::kEmptyString) {
    comm_currency_->clear();
  }
  clear_has_comm_currency();
}
inline const ::std::string& CommissionData::comm_currency() const {
  return *comm_currency_;
}
inline void CommissionData::set_comm_currency(const ::std::string& value) {
  set_has_comm_currency();
  if (comm_currency_ == &::google::protobuf::internal::kEmptyString) {
    comm_currency_ = new ::std::string;
  }
  comm_currency_->assign(value);
}
inline void CommissionData::set_comm_currency(const char* value) {
  set_has_comm_currency();
  if (comm_currency_ == &::google::protobuf::internal::kEmptyString) {
    comm_currency_ = new ::std::string;
  }
  comm_currency_->assign(value);
}
inline void CommissionData::set_comm_currency(const char* value, size_t size) {
  set_has_comm_currency();
  if (comm_currency_ == &::google::protobuf::internal::kEmptyString) {
    comm_currency_ = new ::std::string;
  }
  comm_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommissionData::mutable_comm_currency() {
  set_has_comm_currency();
  if (comm_currency_ == &::google::protobuf::internal::kEmptyString) {
    comm_currency_ = new ::std::string;
  }
  return comm_currency_;
}
inline ::std::string* CommissionData::release_comm_currency() {
  clear_has_comm_currency();
  if (comm_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comm_currency_;
    comm_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CommissionData::set_allocated_comm_currency(::std::string* comm_currency) {
  if (comm_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete comm_currency_;
  }
  if (comm_currency) {
    set_has_comm_currency();
    comm_currency_ = comm_currency;
  } else {
    clear_has_comm_currency();
    comm_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.CommTypeEnum comm_type = 2;
inline bool CommissionData::has_comm_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommissionData::set_has_comm_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommissionData::clear_has_comm_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommissionData::clear_comm_type() {
  comm_type_ = 0;
  clear_has_comm_type();
}
inline ::Common::CommTypeEnum CommissionData::comm_type() const {
  return static_cast< ::Common::CommTypeEnum >(comm_type_);
}
inline void CommissionData::set_comm_type(::Common::CommTypeEnum value) {
  assert(::Common::CommTypeEnum_IsValid(value));
  set_has_comm_type();
  comm_type_ = value;
}

// optional sfixed64 commission = 3;
inline bool CommissionData::has_commission() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommissionData::set_has_commission() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommissionData::clear_has_commission() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommissionData::clear_commission() {
  commission_ = GOOGLE_LONGLONG(0);
  clear_has_commission();
}
inline ::google::protobuf::int64 CommissionData::commission() const {
  return commission_;
}
inline void CommissionData::set_commission(::google::protobuf::int64 value) {
  set_has_commission();
  commission_ = value;
}

// optional sfixed32 commission_exponent = 4;
inline bool CommissionData::has_commission_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommissionData::set_has_commission_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommissionData::clear_has_commission_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommissionData::clear_commission_exponent() {
  commission_exponent_ = 0;
  clear_has_commission_exponent();
}
inline ::google::protobuf::int32 CommissionData::commission_exponent() const {
  return commission_exponent_;
}
inline void CommissionData::set_commission_exponent(::google::protobuf::int32 value) {
  set_has_commission_exponent();
  commission_exponent_ = value;
}

// optional .Common.FundRenewWaivEnum fund_renew_waiv = 5;
inline bool CommissionData::has_fund_renew_waiv() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommissionData::set_has_fund_renew_waiv() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommissionData::clear_has_fund_renew_waiv() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommissionData::clear_fund_renew_waiv() {
  fund_renew_waiv_ = 0;
  clear_has_fund_renew_waiv();
}
inline ::Common::FundRenewWaivEnum CommissionData::fund_renew_waiv() const {
  return static_cast< ::Common::FundRenewWaivEnum >(fund_renew_waiv_);
}
inline void CommissionData::set_fund_renew_waiv(::Common::FundRenewWaivEnum value) {
  assert(::Common::FundRenewWaivEnum_IsValid(value));
  set_has_fund_renew_waiv();
  fund_renew_waiv_ = value;
}

// -------------------------------------------------------------------

// PegInstructions

// optional .Common.PegLimitTypeEnum peg_limit_type = 1;
inline bool PegInstructions::has_peg_limit_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PegInstructions::set_has_peg_limit_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PegInstructions::clear_has_peg_limit_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PegInstructions::clear_peg_limit_type() {
  peg_limit_type_ = 0;
  clear_has_peg_limit_type();
}
inline ::Common::PegLimitTypeEnum PegInstructions::peg_limit_type() const {
  return static_cast< ::Common::PegLimitTypeEnum >(peg_limit_type_);
}
inline void PegInstructions::set_peg_limit_type(::Common::PegLimitTypeEnum value) {
  assert(::Common::PegLimitTypeEnum_IsValid(value));
  set_has_peg_limit_type();
  peg_limit_type_ = value;
}

// optional .Common.PegMoveTypeEnum peg_move_type = 2;
inline bool PegInstructions::has_peg_move_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PegInstructions::set_has_peg_move_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PegInstructions::clear_has_peg_move_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PegInstructions::clear_peg_move_type() {
  peg_move_type_ = 0;
  clear_has_peg_move_type();
}
inline ::Common::PegMoveTypeEnum PegInstructions::peg_move_type() const {
  return static_cast< ::Common::PegMoveTypeEnum >(peg_move_type_);
}
inline void PegInstructions::set_peg_move_type(::Common::PegMoveTypeEnum value) {
  assert(::Common::PegMoveTypeEnum_IsValid(value));
  set_has_peg_move_type();
  peg_move_type_ = value;
}

// optional .Common.PegOffsetTypeEnum peg_offset_type = 3;
inline bool PegInstructions::has_peg_offset_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PegInstructions::set_has_peg_offset_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PegInstructions::clear_has_peg_offset_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PegInstructions::clear_peg_offset_type() {
  peg_offset_type_ = 0;
  clear_has_peg_offset_type();
}
inline ::Common::PegOffsetTypeEnum PegInstructions::peg_offset_type() const {
  return static_cast< ::Common::PegOffsetTypeEnum >(peg_offset_type_);
}
inline void PegInstructions::set_peg_offset_type(::Common::PegOffsetTypeEnum value) {
  assert(::Common::PegOffsetTypeEnum_IsValid(value));
  set_has_peg_offset_type();
  peg_offset_type_ = value;
}

// optional double peg_offset_value = 4;
inline bool PegInstructions::has_peg_offset_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PegInstructions::set_has_peg_offset_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PegInstructions::clear_has_peg_offset_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PegInstructions::clear_peg_offset_value() {
  peg_offset_value_ = 0;
  clear_has_peg_offset_value();
}
inline double PegInstructions::peg_offset_value() const {
  return peg_offset_value_;
}
inline void PegInstructions::set_peg_offset_value(double value) {
  set_has_peg_offset_value();
  peg_offset_value_ = value;
}

// optional .Common.PegPriceTypeEnum peg_price_type = 5;
inline bool PegInstructions::has_peg_price_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PegInstructions::set_has_peg_price_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PegInstructions::clear_has_peg_price_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PegInstructions::clear_peg_price_type() {
  peg_price_type_ = 0;
  clear_has_peg_price_type();
}
inline ::Common::PegPriceTypeEnum PegInstructions::peg_price_type() const {
  return static_cast< ::Common::PegPriceTypeEnum >(peg_price_type_);
}
inline void PegInstructions::set_peg_price_type(::Common::PegPriceTypeEnum value) {
  assert(::Common::PegPriceTypeEnum_IsValid(value));
  set_has_peg_price_type();
  peg_price_type_ = value;
}

// optional .Common.PegRoundDirectionEnum peg_round_direction = 6;
inline bool PegInstructions::has_peg_round_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PegInstructions::set_has_peg_round_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PegInstructions::clear_has_peg_round_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PegInstructions::clear_peg_round_direction() {
  peg_round_direction_ = 0;
  clear_has_peg_round_direction();
}
inline ::Common::PegRoundDirectionEnum PegInstructions::peg_round_direction() const {
  return static_cast< ::Common::PegRoundDirectionEnum >(peg_round_direction_);
}
inline void PegInstructions::set_peg_round_direction(::Common::PegRoundDirectionEnum value) {
  assert(::Common::PegRoundDirectionEnum_IsValid(value));
  set_has_peg_round_direction();
  peg_round_direction_ = value;
}

// optional .Common.PegScopeEnum peg_scope = 7;
inline bool PegInstructions::has_peg_scope() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PegInstructions::set_has_peg_scope() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PegInstructions::clear_has_peg_scope() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PegInstructions::clear_peg_scope() {
  peg_scope_ = 0;
  clear_has_peg_scope();
}
inline ::Common::PegScopeEnum PegInstructions::peg_scope() const {
  return static_cast< ::Common::PegScopeEnum >(peg_scope_);
}
inline void PegInstructions::set_peg_scope(::Common::PegScopeEnum value) {
  assert(::Common::PegScopeEnum_IsValid(value));
  set_has_peg_scope();
  peg_scope_ = value;
}

// optional string peg_security_desc = 8;
inline bool PegInstructions::has_peg_security_desc() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PegInstructions::set_has_peg_security_desc() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PegInstructions::clear_has_peg_security_desc() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PegInstructions::clear_peg_security_desc() {
  if (peg_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    peg_security_desc_->clear();
  }
  clear_has_peg_security_desc();
}
inline const ::std::string& PegInstructions::peg_security_desc() const {
  return *peg_security_desc_;
}
inline void PegInstructions::set_peg_security_desc(const ::std::string& value) {
  set_has_peg_security_desc();
  if (peg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_desc_ = new ::std::string;
  }
  peg_security_desc_->assign(value);
}
inline void PegInstructions::set_peg_security_desc(const char* value) {
  set_has_peg_security_desc();
  if (peg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_desc_ = new ::std::string;
  }
  peg_security_desc_->assign(value);
}
inline void PegInstructions::set_peg_security_desc(const char* value, size_t size) {
  set_has_peg_security_desc();
  if (peg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_desc_ = new ::std::string;
  }
  peg_security_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PegInstructions::mutable_peg_security_desc() {
  set_has_peg_security_desc();
  if (peg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_desc_ = new ::std::string;
  }
  return peg_security_desc_;
}
inline ::std::string* PegInstructions::release_peg_security_desc() {
  clear_has_peg_security_desc();
  if (peg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peg_security_desc_;
    peg_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PegInstructions::set_allocated_peg_security_desc(::std::string* peg_security_desc) {
  if (peg_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete peg_security_desc_;
  }
  if (peg_security_desc) {
    set_has_peg_security_desc();
    peg_security_desc_ = peg_security_desc;
  } else {
    clear_has_peg_security_desc();
    peg_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string peg_security_id = 9;
inline bool PegInstructions::has_peg_security_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PegInstructions::set_has_peg_security_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PegInstructions::clear_has_peg_security_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PegInstructions::clear_peg_security_id() {
  if (peg_security_id_ != &::google::protobuf::internal::kEmptyString) {
    peg_security_id_->clear();
  }
  clear_has_peg_security_id();
}
inline const ::std::string& PegInstructions::peg_security_id() const {
  return *peg_security_id_;
}
inline void PegInstructions::set_peg_security_id(const ::std::string& value) {
  set_has_peg_security_id();
  if (peg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_id_ = new ::std::string;
  }
  peg_security_id_->assign(value);
}
inline void PegInstructions::set_peg_security_id(const char* value) {
  set_has_peg_security_id();
  if (peg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_id_ = new ::std::string;
  }
  peg_security_id_->assign(value);
}
inline void PegInstructions::set_peg_security_id(const char* value, size_t size) {
  set_has_peg_security_id();
  if (peg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_id_ = new ::std::string;
  }
  peg_security_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PegInstructions::mutable_peg_security_id() {
  set_has_peg_security_id();
  if (peg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_id_ = new ::std::string;
  }
  return peg_security_id_;
}
inline ::std::string* PegInstructions::release_peg_security_id() {
  clear_has_peg_security_id();
  if (peg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peg_security_id_;
    peg_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PegInstructions::set_allocated_peg_security_id(::std::string* peg_security_id) {
  if (peg_security_id_ != &::google::protobuf::internal::kEmptyString) {
    delete peg_security_id_;
  }
  if (peg_security_id) {
    set_has_peg_security_id();
    peg_security_id_ = peg_security_id;
  } else {
    clear_has_peg_security_id();
    peg_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string peg_security_id_source = 10;
inline bool PegInstructions::has_peg_security_id_source() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PegInstructions::set_has_peg_security_id_source() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PegInstructions::clear_has_peg_security_id_source() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PegInstructions::clear_peg_security_id_source() {
  if (peg_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    peg_security_id_source_->clear();
  }
  clear_has_peg_security_id_source();
}
inline const ::std::string& PegInstructions::peg_security_id_source() const {
  return *peg_security_id_source_;
}
inline void PegInstructions::set_peg_security_id_source(const ::std::string& value) {
  set_has_peg_security_id_source();
  if (peg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_id_source_ = new ::std::string;
  }
  peg_security_id_source_->assign(value);
}
inline void PegInstructions::set_peg_security_id_source(const char* value) {
  set_has_peg_security_id_source();
  if (peg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_id_source_ = new ::std::string;
  }
  peg_security_id_source_->assign(value);
}
inline void PegInstructions::set_peg_security_id_source(const char* value, size_t size) {
  set_has_peg_security_id_source();
  if (peg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_id_source_ = new ::std::string;
  }
  peg_security_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PegInstructions::mutable_peg_security_id_source() {
  set_has_peg_security_id_source();
  if (peg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    peg_security_id_source_ = new ::std::string;
  }
  return peg_security_id_source_;
}
inline ::std::string* PegInstructions::release_peg_security_id_source() {
  clear_has_peg_security_id_source();
  if (peg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peg_security_id_source_;
    peg_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PegInstructions::set_allocated_peg_security_id_source(::std::string* peg_security_id_source) {
  if (peg_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete peg_security_id_source_;
  }
  if (peg_security_id_source) {
    set_has_peg_security_id_source();
    peg_security_id_source_ = peg_security_id_source;
  } else {
    clear_has_peg_security_id_source();
    peg_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string peg_symbol = 11;
inline bool PegInstructions::has_peg_symbol() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PegInstructions::set_has_peg_symbol() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PegInstructions::clear_has_peg_symbol() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PegInstructions::clear_peg_symbol() {
  if (peg_symbol_ != &::google::protobuf::internal::kEmptyString) {
    peg_symbol_->clear();
  }
  clear_has_peg_symbol();
}
inline const ::std::string& PegInstructions::peg_symbol() const {
  return *peg_symbol_;
}
inline void PegInstructions::set_peg_symbol(const ::std::string& value) {
  set_has_peg_symbol();
  if (peg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    peg_symbol_ = new ::std::string;
  }
  peg_symbol_->assign(value);
}
inline void PegInstructions::set_peg_symbol(const char* value) {
  set_has_peg_symbol();
  if (peg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    peg_symbol_ = new ::std::string;
  }
  peg_symbol_->assign(value);
}
inline void PegInstructions::set_peg_symbol(const char* value, size_t size) {
  set_has_peg_symbol();
  if (peg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    peg_symbol_ = new ::std::string;
  }
  peg_symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PegInstructions::mutable_peg_symbol() {
  set_has_peg_symbol();
  if (peg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    peg_symbol_ = new ::std::string;
  }
  return peg_symbol_;
}
inline ::std::string* PegInstructions::release_peg_symbol() {
  clear_has_peg_symbol();
  if (peg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = peg_symbol_;
    peg_symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PegInstructions::set_allocated_peg_symbol(::std::string* peg_symbol) {
  if (peg_symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete peg_symbol_;
  }
  if (peg_symbol) {
    set_has_peg_symbol();
    peg_symbol_ = peg_symbol;
  } else {
    clear_has_peg_symbol();
    peg_symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DiscretionInstructions

// optional .Common.DiscretionInstEnum discretion_inst = 1;
inline bool DiscretionInstructions::has_discretion_inst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscretionInstructions::set_has_discretion_inst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscretionInstructions::clear_has_discretion_inst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscretionInstructions::clear_discretion_inst() {
  discretion_inst_ = 0;
  clear_has_discretion_inst();
}
inline ::Common::DiscretionInstEnum DiscretionInstructions::discretion_inst() const {
  return static_cast< ::Common::DiscretionInstEnum >(discretion_inst_);
}
inline void DiscretionInstructions::set_discretion_inst(::Common::DiscretionInstEnum value) {
  assert(::Common::DiscretionInstEnum_IsValid(value));
  set_has_discretion_inst();
  discretion_inst_ = value;
}

// optional .Common.DiscretionLimitTypeEnum discretion_limit_type = 2;
inline bool DiscretionInstructions::has_discretion_limit_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscretionInstructions::set_has_discretion_limit_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscretionInstructions::clear_has_discretion_limit_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscretionInstructions::clear_discretion_limit_type() {
  discretion_limit_type_ = 0;
  clear_has_discretion_limit_type();
}
inline ::Common::DiscretionLimitTypeEnum DiscretionInstructions::discretion_limit_type() const {
  return static_cast< ::Common::DiscretionLimitTypeEnum >(discretion_limit_type_);
}
inline void DiscretionInstructions::set_discretion_limit_type(::Common::DiscretionLimitTypeEnum value) {
  assert(::Common::DiscretionLimitTypeEnum_IsValid(value));
  set_has_discretion_limit_type();
  discretion_limit_type_ = value;
}

// optional .Common.DiscretionMoveTypeEnum discretion_move_type = 3;
inline bool DiscretionInstructions::has_discretion_move_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscretionInstructions::set_has_discretion_move_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscretionInstructions::clear_has_discretion_move_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscretionInstructions::clear_discretion_move_type() {
  discretion_move_type_ = 0;
  clear_has_discretion_move_type();
}
inline ::Common::DiscretionMoveTypeEnum DiscretionInstructions::discretion_move_type() const {
  return static_cast< ::Common::DiscretionMoveTypeEnum >(discretion_move_type_);
}
inline void DiscretionInstructions::set_discretion_move_type(::Common::DiscretionMoveTypeEnum value) {
  assert(::Common::DiscretionMoveTypeEnum_IsValid(value));
  set_has_discretion_move_type();
  discretion_move_type_ = value;
}

// optional .Common.DiscretionOffsetTypeEnum discretion_offset_type = 4;
inline bool DiscretionInstructions::has_discretion_offset_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiscretionInstructions::set_has_discretion_offset_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiscretionInstructions::clear_has_discretion_offset_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiscretionInstructions::clear_discretion_offset_type() {
  discretion_offset_type_ = 0;
  clear_has_discretion_offset_type();
}
inline ::Common::DiscretionOffsetTypeEnum DiscretionInstructions::discretion_offset_type() const {
  return static_cast< ::Common::DiscretionOffsetTypeEnum >(discretion_offset_type_);
}
inline void DiscretionInstructions::set_discretion_offset_type(::Common::DiscretionOffsetTypeEnum value) {
  assert(::Common::DiscretionOffsetTypeEnum_IsValid(value));
  set_has_discretion_offset_type();
  discretion_offset_type_ = value;
}

// optional double discretion_offset_value = 5;
inline bool DiscretionInstructions::has_discretion_offset_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiscretionInstructions::set_has_discretion_offset_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiscretionInstructions::clear_has_discretion_offset_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiscretionInstructions::clear_discretion_offset_value() {
  discretion_offset_value_ = 0;
  clear_has_discretion_offset_value();
}
inline double DiscretionInstructions::discretion_offset_value() const {
  return discretion_offset_value_;
}
inline void DiscretionInstructions::set_discretion_offset_value(double value) {
  set_has_discretion_offset_value();
  discretion_offset_value_ = value;
}

// optional .Common.DiscretionRoundDirectionEnum discretion_round_direction = 6;
inline bool DiscretionInstructions::has_discretion_round_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiscretionInstructions::set_has_discretion_round_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DiscretionInstructions::clear_has_discretion_round_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DiscretionInstructions::clear_discretion_round_direction() {
  discretion_round_direction_ = 0;
  clear_has_discretion_round_direction();
}
inline ::Common::DiscretionRoundDirectionEnum DiscretionInstructions::discretion_round_direction() const {
  return static_cast< ::Common::DiscretionRoundDirectionEnum >(discretion_round_direction_);
}
inline void DiscretionInstructions::set_discretion_round_direction(::Common::DiscretionRoundDirectionEnum value) {
  assert(::Common::DiscretionRoundDirectionEnum_IsValid(value));
  set_has_discretion_round_direction();
  discretion_round_direction_ = value;
}

// optional .Common.DiscretionScopeEnum discretion_scope = 7;
inline bool DiscretionInstructions::has_discretion_scope() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiscretionInstructions::set_has_discretion_scope() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DiscretionInstructions::clear_has_discretion_scope() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DiscretionInstructions::clear_discretion_scope() {
  discretion_scope_ = 0;
  clear_has_discretion_scope();
}
inline ::Common::DiscretionScopeEnum DiscretionInstructions::discretion_scope() const {
  return static_cast< ::Common::DiscretionScopeEnum >(discretion_scope_);
}
inline void DiscretionInstructions::set_discretion_scope(::Common::DiscretionScopeEnum value) {
  assert(::Common::DiscretionScopeEnum_IsValid(value));
  set_has_discretion_scope();
  discretion_scope_ = value;
}

// -------------------------------------------------------------------

// StrategyParametersGrp

// optional string strategy_parameter_name = 1;
inline bool StrategyParametersGrp::has_strategy_parameter_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrategyParametersGrp::set_has_strategy_parameter_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrategyParametersGrp::clear_has_strategy_parameter_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrategyParametersGrp::clear_strategy_parameter_name() {
  if (strategy_parameter_name_ != &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_name_->clear();
  }
  clear_has_strategy_parameter_name();
}
inline const ::std::string& StrategyParametersGrp::strategy_parameter_name() const {
  return *strategy_parameter_name_;
}
inline void StrategyParametersGrp::set_strategy_parameter_name(const ::std::string& value) {
  set_has_strategy_parameter_name();
  if (strategy_parameter_name_ == &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_name_ = new ::std::string;
  }
  strategy_parameter_name_->assign(value);
}
inline void StrategyParametersGrp::set_strategy_parameter_name(const char* value) {
  set_has_strategy_parameter_name();
  if (strategy_parameter_name_ == &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_name_ = new ::std::string;
  }
  strategy_parameter_name_->assign(value);
}
inline void StrategyParametersGrp::set_strategy_parameter_name(const char* value, size_t size) {
  set_has_strategy_parameter_name();
  if (strategy_parameter_name_ == &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_name_ = new ::std::string;
  }
  strategy_parameter_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrategyParametersGrp::mutable_strategy_parameter_name() {
  set_has_strategy_parameter_name();
  if (strategy_parameter_name_ == &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_name_ = new ::std::string;
  }
  return strategy_parameter_name_;
}
inline ::std::string* StrategyParametersGrp::release_strategy_parameter_name() {
  clear_has_strategy_parameter_name();
  if (strategy_parameter_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategy_parameter_name_;
    strategy_parameter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StrategyParametersGrp::set_allocated_strategy_parameter_name(::std::string* strategy_parameter_name) {
  if (strategy_parameter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete strategy_parameter_name_;
  }
  if (strategy_parameter_name) {
    set_has_strategy_parameter_name();
    strategy_parameter_name_ = strategy_parameter_name;
  } else {
    clear_has_strategy_parameter_name();
    strategy_parameter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.StrategyParameterTypeEnum strategy_parameter_type = 2;
inline bool StrategyParametersGrp::has_strategy_parameter_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrategyParametersGrp::set_has_strategy_parameter_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrategyParametersGrp::clear_has_strategy_parameter_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrategyParametersGrp::clear_strategy_parameter_type() {
  strategy_parameter_type_ = 0;
  clear_has_strategy_parameter_type();
}
inline ::Common::StrategyParameterTypeEnum StrategyParametersGrp::strategy_parameter_type() const {
  return static_cast< ::Common::StrategyParameterTypeEnum >(strategy_parameter_type_);
}
inline void StrategyParametersGrp::set_strategy_parameter_type(::Common::StrategyParameterTypeEnum value) {
  assert(::Common::StrategyParameterTypeEnum_IsValid(value));
  set_has_strategy_parameter_type();
  strategy_parameter_type_ = value;
}

// optional string strategy_parameter_value = 3;
inline bool StrategyParametersGrp::has_strategy_parameter_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StrategyParametersGrp::set_has_strategy_parameter_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StrategyParametersGrp::clear_has_strategy_parameter_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StrategyParametersGrp::clear_strategy_parameter_value() {
  if (strategy_parameter_value_ != &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_value_->clear();
  }
  clear_has_strategy_parameter_value();
}
inline const ::std::string& StrategyParametersGrp::strategy_parameter_value() const {
  return *strategy_parameter_value_;
}
inline void StrategyParametersGrp::set_strategy_parameter_value(const ::std::string& value) {
  set_has_strategy_parameter_value();
  if (strategy_parameter_value_ == &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_value_ = new ::std::string;
  }
  strategy_parameter_value_->assign(value);
}
inline void StrategyParametersGrp::set_strategy_parameter_value(const char* value) {
  set_has_strategy_parameter_value();
  if (strategy_parameter_value_ == &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_value_ = new ::std::string;
  }
  strategy_parameter_value_->assign(value);
}
inline void StrategyParametersGrp::set_strategy_parameter_value(const char* value, size_t size) {
  set_has_strategy_parameter_value();
  if (strategy_parameter_value_ == &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_value_ = new ::std::string;
  }
  strategy_parameter_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrategyParametersGrp::mutable_strategy_parameter_value() {
  set_has_strategy_parameter_value();
  if (strategy_parameter_value_ == &::google::protobuf::internal::kEmptyString) {
    strategy_parameter_value_ = new ::std::string;
  }
  return strategy_parameter_value_;
}
inline ::std::string* StrategyParametersGrp::release_strategy_parameter_value() {
  clear_has_strategy_parameter_value();
  if (strategy_parameter_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strategy_parameter_value_;
    strategy_parameter_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StrategyParametersGrp::set_allocated_strategy_parameter_value(::std::string* strategy_parameter_value) {
  if (strategy_parameter_value_ != &::google::protobuf::internal::kEmptyString) {
    delete strategy_parameter_value_;
  }
  if (strategy_parameter_value) {
    set_has_strategy_parameter_value();
    strategy_parameter_value_ = strategy_parameter_value;
  } else {
    clear_has_strategy_parameter_value();
    strategy_parameter_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TrdRegTimestamps

// optional .Common.DeskOrderHandlingInstEnum desk_order_handling_inst = 1;
inline bool TrdRegTimestamps::has_desk_order_handling_inst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrdRegTimestamps::set_has_desk_order_handling_inst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrdRegTimestamps::clear_has_desk_order_handling_inst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrdRegTimestamps::clear_desk_order_handling_inst() {
  desk_order_handling_inst_ = 0;
  clear_has_desk_order_handling_inst();
}
inline ::Common::DeskOrderHandlingInstEnum TrdRegTimestamps::desk_order_handling_inst() const {
  return static_cast< ::Common::DeskOrderHandlingInstEnum >(desk_order_handling_inst_);
}
inline void TrdRegTimestamps::set_desk_order_handling_inst(::Common::DeskOrderHandlingInstEnum value) {
  assert(::Common::DeskOrderHandlingInstEnum_IsValid(value));
  set_has_desk_order_handling_inst();
  desk_order_handling_inst_ = value;
}

// optional .Common.DeskTypeEnum desk_type = 2;
inline bool TrdRegTimestamps::has_desk_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrdRegTimestamps::set_has_desk_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrdRegTimestamps::clear_has_desk_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrdRegTimestamps::clear_desk_type() {
  desk_type_ = 0;
  clear_has_desk_type();
}
inline ::Common::DeskTypeEnum TrdRegTimestamps::desk_type() const {
  return static_cast< ::Common::DeskTypeEnum >(desk_type_);
}
inline void TrdRegTimestamps::set_desk_type(::Common::DeskTypeEnum value) {
  assert(::Common::DeskTypeEnum_IsValid(value));
  set_has_desk_type();
  desk_type_ = value;
}

// optional .Common.DeskTypeSourceEnum desk_type_source = 3;
inline bool TrdRegTimestamps::has_desk_type_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrdRegTimestamps::set_has_desk_type_source() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrdRegTimestamps::clear_has_desk_type_source() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrdRegTimestamps::clear_desk_type_source() {
  desk_type_source_ = 0;
  clear_has_desk_type_source();
}
inline ::Common::DeskTypeSourceEnum TrdRegTimestamps::desk_type_source() const {
  return static_cast< ::Common::DeskTypeSourceEnum >(desk_type_source_);
}
inline void TrdRegTimestamps::set_desk_type_source(::Common::DeskTypeSourceEnum value) {
  assert(::Common::DeskTypeSourceEnum_IsValid(value));
  set_has_desk_type_source();
  desk_type_source_ = value;
}

// optional sfixed64 trd_reg_timestamp = 4;
inline bool TrdRegTimestamps::has_trd_reg_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrdRegTimestamps::set_has_trd_reg_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrdRegTimestamps::clear_has_trd_reg_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrdRegTimestamps::clear_trd_reg_timestamp() {
  trd_reg_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_trd_reg_timestamp();
}
inline ::google::protobuf::int64 TrdRegTimestamps::trd_reg_timestamp() const {
  return trd_reg_timestamp_;
}
inline void TrdRegTimestamps::set_trd_reg_timestamp(::google::protobuf::int64 value) {
  set_has_trd_reg_timestamp();
  trd_reg_timestamp_ = value;
}

// optional string trd_reg_timestamp_origin = 5;
inline bool TrdRegTimestamps::has_trd_reg_timestamp_origin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrdRegTimestamps::set_has_trd_reg_timestamp_origin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrdRegTimestamps::clear_has_trd_reg_timestamp_origin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrdRegTimestamps::clear_trd_reg_timestamp_origin() {
  if (trd_reg_timestamp_origin_ != &::google::protobuf::internal::kEmptyString) {
    trd_reg_timestamp_origin_->clear();
  }
  clear_has_trd_reg_timestamp_origin();
}
inline const ::std::string& TrdRegTimestamps::trd_reg_timestamp_origin() const {
  return *trd_reg_timestamp_origin_;
}
inline void TrdRegTimestamps::set_trd_reg_timestamp_origin(const ::std::string& value) {
  set_has_trd_reg_timestamp_origin();
  if (trd_reg_timestamp_origin_ == &::google::protobuf::internal::kEmptyString) {
    trd_reg_timestamp_origin_ = new ::std::string;
  }
  trd_reg_timestamp_origin_->assign(value);
}
inline void TrdRegTimestamps::set_trd_reg_timestamp_origin(const char* value) {
  set_has_trd_reg_timestamp_origin();
  if (trd_reg_timestamp_origin_ == &::google::protobuf::internal::kEmptyString) {
    trd_reg_timestamp_origin_ = new ::std::string;
  }
  trd_reg_timestamp_origin_->assign(value);
}
inline void TrdRegTimestamps::set_trd_reg_timestamp_origin(const char* value, size_t size) {
  set_has_trd_reg_timestamp_origin();
  if (trd_reg_timestamp_origin_ == &::google::protobuf::internal::kEmptyString) {
    trd_reg_timestamp_origin_ = new ::std::string;
  }
  trd_reg_timestamp_origin_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TrdRegTimestamps::mutable_trd_reg_timestamp_origin() {
  set_has_trd_reg_timestamp_origin();
  if (trd_reg_timestamp_origin_ == &::google::protobuf::internal::kEmptyString) {
    trd_reg_timestamp_origin_ = new ::std::string;
  }
  return trd_reg_timestamp_origin_;
}
inline ::std::string* TrdRegTimestamps::release_trd_reg_timestamp_origin() {
  clear_has_trd_reg_timestamp_origin();
  if (trd_reg_timestamp_origin_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trd_reg_timestamp_origin_;
    trd_reg_timestamp_origin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TrdRegTimestamps::set_allocated_trd_reg_timestamp_origin(::std::string* trd_reg_timestamp_origin) {
  if (trd_reg_timestamp_origin_ != &::google::protobuf::internal::kEmptyString) {
    delete trd_reg_timestamp_origin_;
  }
  if (trd_reg_timestamp_origin) {
    set_has_trd_reg_timestamp_origin();
    trd_reg_timestamp_origin_ = trd_reg_timestamp_origin;
  } else {
    clear_has_trd_reg_timestamp_origin();
    trd_reg_timestamp_origin_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.TrdRegTimestampTypeEnum trd_reg_timestamp_type = 6;
inline bool TrdRegTimestamps::has_trd_reg_timestamp_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrdRegTimestamps::set_has_trd_reg_timestamp_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrdRegTimestamps::clear_has_trd_reg_timestamp_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrdRegTimestamps::clear_trd_reg_timestamp_type() {
  trd_reg_timestamp_type_ = 0;
  clear_has_trd_reg_timestamp_type();
}
inline ::Common::TrdRegTimestampTypeEnum TrdRegTimestamps::trd_reg_timestamp_type() const {
  return static_cast< ::Common::TrdRegTimestampTypeEnum >(trd_reg_timestamp_type_);
}
inline void TrdRegTimestamps::set_trd_reg_timestamp_type(::Common::TrdRegTimestampTypeEnum value) {
  assert(::Common::TrdRegTimestampTypeEnum_IsValid(value));
  set_has_trd_reg_timestamp_type();
  trd_reg_timestamp_type_ = value;
}

// -------------------------------------------------------------------

// ApplicationSequenceControl

// optional string appl_id = 1;
inline bool ApplicationSequenceControl::has_appl_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ApplicationSequenceControl::set_has_appl_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ApplicationSequenceControl::clear_has_appl_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ApplicationSequenceControl::clear_appl_id() {
  if (appl_id_ != &::google::protobuf::internal::kEmptyString) {
    appl_id_->clear();
  }
  clear_has_appl_id();
}
inline const ::std::string& ApplicationSequenceControl::appl_id() const {
  return *appl_id_;
}
inline void ApplicationSequenceControl::set_appl_id(const ::std::string& value) {
  set_has_appl_id();
  if (appl_id_ == &::google::protobuf::internal::kEmptyString) {
    appl_id_ = new ::std::string;
  }
  appl_id_->assign(value);
}
inline void ApplicationSequenceControl::set_appl_id(const char* value) {
  set_has_appl_id();
  if (appl_id_ == &::google::protobuf::internal::kEmptyString) {
    appl_id_ = new ::std::string;
  }
  appl_id_->assign(value);
}
inline void ApplicationSequenceControl::set_appl_id(const char* value, size_t size) {
  set_has_appl_id();
  if (appl_id_ == &::google::protobuf::internal::kEmptyString) {
    appl_id_ = new ::std::string;
  }
  appl_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ApplicationSequenceControl::mutable_appl_id() {
  set_has_appl_id();
  if (appl_id_ == &::google::protobuf::internal::kEmptyString) {
    appl_id_ = new ::std::string;
  }
  return appl_id_;
}
inline ::std::string* ApplicationSequenceControl::release_appl_id() {
  clear_has_appl_id();
  if (appl_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appl_id_;
    appl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ApplicationSequenceControl::set_allocated_appl_id(::std::string* appl_id) {
  if (appl_id_ != &::google::protobuf::internal::kEmptyString) {
    delete appl_id_;
  }
  if (appl_id) {
    set_has_appl_id();
    appl_id_ = appl_id;
  } else {
    clear_has_appl_id();
    appl_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 appl_last_seq_num = 2;
inline bool ApplicationSequenceControl::has_appl_last_seq_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ApplicationSequenceControl::set_has_appl_last_seq_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ApplicationSequenceControl::clear_has_appl_last_seq_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ApplicationSequenceControl::clear_appl_last_seq_num() {
  appl_last_seq_num_ = 0u;
  clear_has_appl_last_seq_num();
}
inline ::google::protobuf::uint32 ApplicationSequenceControl::appl_last_seq_num() const {
  return appl_last_seq_num_;
}
inline void ApplicationSequenceControl::set_appl_last_seq_num(::google::protobuf::uint32 value) {
  set_has_appl_last_seq_num();
  appl_last_seq_num_ = value;
}

// optional bool appl_resend_flag = 3;
inline bool ApplicationSequenceControl::has_appl_resend_flag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ApplicationSequenceControl::set_has_appl_resend_flag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ApplicationSequenceControl::clear_has_appl_resend_flag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ApplicationSequenceControl::clear_appl_resend_flag() {
  appl_resend_flag_ = false;
  clear_has_appl_resend_flag();
}
inline bool ApplicationSequenceControl::appl_resend_flag() const {
  return appl_resend_flag_;
}
inline void ApplicationSequenceControl::set_appl_resend_flag(bool value) {
  set_has_appl_resend_flag();
  appl_resend_flag_ = value;
}

// optional fixed32 appl_seq_num = 4;
inline bool ApplicationSequenceControl::has_appl_seq_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ApplicationSequenceControl::set_has_appl_seq_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ApplicationSequenceControl::clear_has_appl_seq_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ApplicationSequenceControl::clear_appl_seq_num() {
  appl_seq_num_ = 0u;
  clear_has_appl_seq_num();
}
inline ::google::protobuf::uint32 ApplicationSequenceControl::appl_seq_num() const {
  return appl_seq_num_;
}
inline void ApplicationSequenceControl::set_appl_seq_num(::google::protobuf::uint32 value) {
  set_has_appl_seq_num();
  appl_seq_num_ = value;
}

// -------------------------------------------------------------------

// ContraGrp

// optional string contra_broker = 1;
inline bool ContraGrp::has_contra_broker() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContraGrp::set_has_contra_broker() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContraGrp::clear_has_contra_broker() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContraGrp::clear_contra_broker() {
  if (contra_broker_ != &::google::protobuf::internal::kEmptyString) {
    contra_broker_->clear();
  }
  clear_has_contra_broker();
}
inline const ::std::string& ContraGrp::contra_broker() const {
  return *contra_broker_;
}
inline void ContraGrp::set_contra_broker(const ::std::string& value) {
  set_has_contra_broker();
  if (contra_broker_ == &::google::protobuf::internal::kEmptyString) {
    contra_broker_ = new ::std::string;
  }
  contra_broker_->assign(value);
}
inline void ContraGrp::set_contra_broker(const char* value) {
  set_has_contra_broker();
  if (contra_broker_ == &::google::protobuf::internal::kEmptyString) {
    contra_broker_ = new ::std::string;
  }
  contra_broker_->assign(value);
}
inline void ContraGrp::set_contra_broker(const char* value, size_t size) {
  set_has_contra_broker();
  if (contra_broker_ == &::google::protobuf::internal::kEmptyString) {
    contra_broker_ = new ::std::string;
  }
  contra_broker_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContraGrp::mutable_contra_broker() {
  set_has_contra_broker();
  if (contra_broker_ == &::google::protobuf::internal::kEmptyString) {
    contra_broker_ = new ::std::string;
  }
  return contra_broker_;
}
inline ::std::string* ContraGrp::release_contra_broker() {
  clear_has_contra_broker();
  if (contra_broker_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contra_broker_;
    contra_broker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContraGrp::set_allocated_contra_broker(::std::string* contra_broker) {
  if (contra_broker_ != &::google::protobuf::internal::kEmptyString) {
    delete contra_broker_;
  }
  if (contra_broker) {
    set_has_contra_broker();
    contra_broker_ = contra_broker;
  } else {
    clear_has_contra_broker();
    contra_broker_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string contra_leg_ref_id = 2;
inline bool ContraGrp::has_contra_leg_ref_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContraGrp::set_has_contra_leg_ref_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContraGrp::clear_has_contra_leg_ref_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContraGrp::clear_contra_leg_ref_id() {
  if (contra_leg_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    contra_leg_ref_id_->clear();
  }
  clear_has_contra_leg_ref_id();
}
inline const ::std::string& ContraGrp::contra_leg_ref_id() const {
  return *contra_leg_ref_id_;
}
inline void ContraGrp::set_contra_leg_ref_id(const ::std::string& value) {
  set_has_contra_leg_ref_id();
  if (contra_leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    contra_leg_ref_id_ = new ::std::string;
  }
  contra_leg_ref_id_->assign(value);
}
inline void ContraGrp::set_contra_leg_ref_id(const char* value) {
  set_has_contra_leg_ref_id();
  if (contra_leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    contra_leg_ref_id_ = new ::std::string;
  }
  contra_leg_ref_id_->assign(value);
}
inline void ContraGrp::set_contra_leg_ref_id(const char* value, size_t size) {
  set_has_contra_leg_ref_id();
  if (contra_leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    contra_leg_ref_id_ = new ::std::string;
  }
  contra_leg_ref_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContraGrp::mutable_contra_leg_ref_id() {
  set_has_contra_leg_ref_id();
  if (contra_leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    contra_leg_ref_id_ = new ::std::string;
  }
  return contra_leg_ref_id_;
}
inline ::std::string* ContraGrp::release_contra_leg_ref_id() {
  clear_has_contra_leg_ref_id();
  if (contra_leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contra_leg_ref_id_;
    contra_leg_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContraGrp::set_allocated_contra_leg_ref_id(::std::string* contra_leg_ref_id) {
  if (contra_leg_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    delete contra_leg_ref_id_;
  }
  if (contra_leg_ref_id) {
    set_has_contra_leg_ref_id();
    contra_leg_ref_id_ = contra_leg_ref_id;
  } else {
    clear_has_contra_leg_ref_id();
    contra_leg_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 contra_trade_qty = 3;
inline bool ContraGrp::has_contra_trade_qty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContraGrp::set_has_contra_trade_qty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContraGrp::clear_has_contra_trade_qty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContraGrp::clear_contra_trade_qty() {
  contra_trade_qty_ = GOOGLE_LONGLONG(0);
  clear_has_contra_trade_qty();
}
inline ::google::protobuf::int64 ContraGrp::contra_trade_qty() const {
  return contra_trade_qty_;
}
inline void ContraGrp::set_contra_trade_qty(::google::protobuf::int64 value) {
  set_has_contra_trade_qty();
  contra_trade_qty_ = value;
}

// optional sfixed32 contra_trade_qty_exponent = 4;
inline bool ContraGrp::has_contra_trade_qty_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContraGrp::set_has_contra_trade_qty_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContraGrp::clear_has_contra_trade_qty_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContraGrp::clear_contra_trade_qty_exponent() {
  contra_trade_qty_exponent_ = 0;
  clear_has_contra_trade_qty_exponent();
}
inline ::google::protobuf::int32 ContraGrp::contra_trade_qty_exponent() const {
  return contra_trade_qty_exponent_;
}
inline void ContraGrp::set_contra_trade_qty_exponent(::google::protobuf::int32 value) {
  set_has_contra_trade_qty_exponent();
  contra_trade_qty_exponent_ = value;
}

// optional sfixed64 contra_trade_time = 5;
inline bool ContraGrp::has_contra_trade_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContraGrp::set_has_contra_trade_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContraGrp::clear_has_contra_trade_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContraGrp::clear_contra_trade_time() {
  contra_trade_time_ = GOOGLE_LONGLONG(0);
  clear_has_contra_trade_time();
}
inline ::google::protobuf::int64 ContraGrp::contra_trade_time() const {
  return contra_trade_time_;
}
inline void ContraGrp::set_contra_trade_time(::google::protobuf::int64 value) {
  set_has_contra_trade_time();
  contra_trade_time_ = value;
}

// optional string contra_trader = 6;
inline bool ContraGrp::has_contra_trader() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContraGrp::set_has_contra_trader() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContraGrp::clear_has_contra_trader() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContraGrp::clear_contra_trader() {
  if (contra_trader_ != &::google::protobuf::internal::kEmptyString) {
    contra_trader_->clear();
  }
  clear_has_contra_trader();
}
inline const ::std::string& ContraGrp::contra_trader() const {
  return *contra_trader_;
}
inline void ContraGrp::set_contra_trader(const ::std::string& value) {
  set_has_contra_trader();
  if (contra_trader_ == &::google::protobuf::internal::kEmptyString) {
    contra_trader_ = new ::std::string;
  }
  contra_trader_->assign(value);
}
inline void ContraGrp::set_contra_trader(const char* value) {
  set_has_contra_trader();
  if (contra_trader_ == &::google::protobuf::internal::kEmptyString) {
    contra_trader_ = new ::std::string;
  }
  contra_trader_->assign(value);
}
inline void ContraGrp::set_contra_trader(const char* value, size_t size) {
  set_has_contra_trader();
  if (contra_trader_ == &::google::protobuf::internal::kEmptyString) {
    contra_trader_ = new ::std::string;
  }
  contra_trader_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContraGrp::mutable_contra_trader() {
  set_has_contra_trader();
  if (contra_trader_ == &::google::protobuf::internal::kEmptyString) {
    contra_trader_ = new ::std::string;
  }
  return contra_trader_;
}
inline ::std::string* ContraGrp::release_contra_trader() {
  clear_has_contra_trader();
  if (contra_trader_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = contra_trader_;
    contra_trader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContraGrp::set_allocated_contra_trader(::std::string* contra_trader) {
  if (contra_trader_ != &::google::protobuf::internal::kEmptyString) {
    delete contra_trader_;
  }
  if (contra_trader) {
    set_has_contra_trader();
    contra_trader_ = contra_trader;
  } else {
    clear_has_contra_trader();
    contra_trader_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NstdPtys4SubGrp

// optional string nested4party_sub_id = 1;
inline bool NstdPtys4SubGrp::has_nested4party_sub_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NstdPtys4SubGrp::set_has_nested4party_sub_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NstdPtys4SubGrp::clear_has_nested4party_sub_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NstdPtys4SubGrp::clear_nested4party_sub_id() {
  if (nested4party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    nested4party_sub_id_->clear();
  }
  clear_has_nested4party_sub_id();
}
inline const ::std::string& NstdPtys4SubGrp::nested4party_sub_id() const {
  return *nested4party_sub_id_;
}
inline void NstdPtys4SubGrp::set_nested4party_sub_id(const ::std::string& value) {
  set_has_nested4party_sub_id();
  if (nested4party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_sub_id_ = new ::std::string;
  }
  nested4party_sub_id_->assign(value);
}
inline void NstdPtys4SubGrp::set_nested4party_sub_id(const char* value) {
  set_has_nested4party_sub_id();
  if (nested4party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_sub_id_ = new ::std::string;
  }
  nested4party_sub_id_->assign(value);
}
inline void NstdPtys4SubGrp::set_nested4party_sub_id(const char* value, size_t size) {
  set_has_nested4party_sub_id();
  if (nested4party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_sub_id_ = new ::std::string;
  }
  nested4party_sub_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NstdPtys4SubGrp::mutable_nested4party_sub_id() {
  set_has_nested4party_sub_id();
  if (nested4party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_sub_id_ = new ::std::string;
  }
  return nested4party_sub_id_;
}
inline ::std::string* NstdPtys4SubGrp::release_nested4party_sub_id() {
  clear_has_nested4party_sub_id();
  if (nested4party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested4party_sub_id_;
    nested4party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NstdPtys4SubGrp::set_allocated_nested4party_sub_id(::std::string* nested4party_sub_id) {
  if (nested4party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    delete nested4party_sub_id_;
  }
  if (nested4party_sub_id) {
    set_has_nested4party_sub_id();
    nested4party_sub_id_ = nested4party_sub_id;
  } else {
    clear_has_nested4party_sub_id();
    nested4party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 nested4party_sub_id_type = 2;
inline bool NstdPtys4SubGrp::has_nested4party_sub_id_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NstdPtys4SubGrp::set_has_nested4party_sub_id_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NstdPtys4SubGrp::clear_has_nested4party_sub_id_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NstdPtys4SubGrp::clear_nested4party_sub_id_type() {
  nested4party_sub_id_type_ = GOOGLE_LONGLONG(0);
  clear_has_nested4party_sub_id_type();
}
inline ::google::protobuf::int64 NstdPtys4SubGrp::nested4party_sub_id_type() const {
  return nested4party_sub_id_type_;
}
inline void NstdPtys4SubGrp::set_nested4party_sub_id_type(::google::protobuf::int64 value) {
  set_has_nested4party_sub_id_type();
  nested4party_sub_id_type_ = value;
}

// -------------------------------------------------------------------

// NestedParties4

// optional string nested4party_id = 1;
inline bool NestedParties4::has_nested4party_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NestedParties4::set_has_nested4party_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NestedParties4::clear_has_nested4party_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NestedParties4::clear_nested4party_id() {
  if (nested4party_id_ != &::google::protobuf::internal::kEmptyString) {
    nested4party_id_->clear();
  }
  clear_has_nested4party_id();
}
inline const ::std::string& NestedParties4::nested4party_id() const {
  return *nested4party_id_;
}
inline void NestedParties4::set_nested4party_id(const ::std::string& value) {
  set_has_nested4party_id();
  if (nested4party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_id_ = new ::std::string;
  }
  nested4party_id_->assign(value);
}
inline void NestedParties4::set_nested4party_id(const char* value) {
  set_has_nested4party_id();
  if (nested4party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_id_ = new ::std::string;
  }
  nested4party_id_->assign(value);
}
inline void NestedParties4::set_nested4party_id(const char* value, size_t size) {
  set_has_nested4party_id();
  if (nested4party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_id_ = new ::std::string;
  }
  nested4party_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NestedParties4::mutable_nested4party_id() {
  set_has_nested4party_id();
  if (nested4party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_id_ = new ::std::string;
  }
  return nested4party_id_;
}
inline ::std::string* NestedParties4::release_nested4party_id() {
  clear_has_nested4party_id();
  if (nested4party_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested4party_id_;
    nested4party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NestedParties4::set_allocated_nested4party_id(::std::string* nested4party_id) {
  if (nested4party_id_ != &::google::protobuf::internal::kEmptyString) {
    delete nested4party_id_;
  }
  if (nested4party_id) {
    set_has_nested4party_id();
    nested4party_id_ = nested4party_id;
  } else {
    clear_has_nested4party_id();
    nested4party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nested4party_id_source = 2;
inline bool NestedParties4::has_nested4party_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NestedParties4::set_has_nested4party_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NestedParties4::clear_has_nested4party_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NestedParties4::clear_nested4party_id_source() {
  if (nested4party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    nested4party_id_source_->clear();
  }
  clear_has_nested4party_id_source();
}
inline const ::std::string& NestedParties4::nested4party_id_source() const {
  return *nested4party_id_source_;
}
inline void NestedParties4::set_nested4party_id_source(const ::std::string& value) {
  set_has_nested4party_id_source();
  if (nested4party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_id_source_ = new ::std::string;
  }
  nested4party_id_source_->assign(value);
}
inline void NestedParties4::set_nested4party_id_source(const char* value) {
  set_has_nested4party_id_source();
  if (nested4party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_id_source_ = new ::std::string;
  }
  nested4party_id_source_->assign(value);
}
inline void NestedParties4::set_nested4party_id_source(const char* value, size_t size) {
  set_has_nested4party_id_source();
  if (nested4party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_id_source_ = new ::std::string;
  }
  nested4party_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NestedParties4::mutable_nested4party_id_source() {
  set_has_nested4party_id_source();
  if (nested4party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested4party_id_source_ = new ::std::string;
  }
  return nested4party_id_source_;
}
inline ::std::string* NestedParties4::release_nested4party_id_source() {
  clear_has_nested4party_id_source();
  if (nested4party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested4party_id_source_;
    nested4party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NestedParties4::set_allocated_nested4party_id_source(::std::string* nested4party_id_source) {
  if (nested4party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete nested4party_id_source_;
  }
  if (nested4party_id_source) {
    set_has_nested4party_id_source();
    nested4party_id_source_ = nested4party_id_source;
  } else {
    clear_has_nested4party_id_source();
    nested4party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 nested4party_role = 3;
inline bool NestedParties4::has_nested4party_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NestedParties4::set_has_nested4party_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NestedParties4::clear_has_nested4party_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NestedParties4::clear_nested4party_role() {
  nested4party_role_ = GOOGLE_LONGLONG(0);
  clear_has_nested4party_role();
}
inline ::google::protobuf::int64 NestedParties4::nested4party_role() const {
  return nested4party_role_;
}
inline void NestedParties4::set_nested4party_role(::google::protobuf::int64 value) {
  set_has_nested4party_role();
  nested4party_role_ = value;
}

// repeated .Common.NstdPtys4SubGrp nstd_ptys4sub_grp = 4;
inline int NestedParties4::nstd_ptys4sub_grp_size() const {
  return nstd_ptys4sub_grp_.size();
}
inline void NestedParties4::clear_nstd_ptys4sub_grp() {
  nstd_ptys4sub_grp_.Clear();
}
inline const ::Common::NstdPtys4SubGrp& NestedParties4::nstd_ptys4sub_grp(int index) const {
  return nstd_ptys4sub_grp_.Get(index);
}
inline ::Common::NstdPtys4SubGrp* NestedParties4::mutable_nstd_ptys4sub_grp(int index) {
  return nstd_ptys4sub_grp_.Mutable(index);
}
inline ::Common::NstdPtys4SubGrp* NestedParties4::add_nstd_ptys4sub_grp() {
  return nstd_ptys4sub_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys4SubGrp >&
NestedParties4::nstd_ptys4sub_grp() const {
  return nstd_ptys4sub_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys4SubGrp >*
NestedParties4::mutable_nstd_ptys4sub_grp() {
  return &nstd_ptys4sub_grp_;
}

// -------------------------------------------------------------------

// RateSource

// optional .Common.RateSourceEnum rate_source = 1;
inline bool RateSource::has_rate_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RateSource::set_has_rate_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RateSource::clear_has_rate_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RateSource::clear_rate_source() {
  rate_source_ = 0;
  clear_has_rate_source();
}
inline ::Common::RateSourceEnum RateSource::rate_source() const {
  return static_cast< ::Common::RateSourceEnum >(rate_source_);
}
inline void RateSource::set_rate_source(::Common::RateSourceEnum value) {
  assert(::Common::RateSourceEnum_IsValid(value));
  set_has_rate_source();
  rate_source_ = value;
}

// optional .Common.RateSourceTypeEnum rate_source_type = 2;
inline bool RateSource::has_rate_source_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RateSource::set_has_rate_source_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RateSource::clear_has_rate_source_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RateSource::clear_rate_source_type() {
  rate_source_type_ = 0;
  clear_has_rate_source_type();
}
inline ::Common::RateSourceTypeEnum RateSource::rate_source_type() const {
  return static_cast< ::Common::RateSourceTypeEnum >(rate_source_type_);
}
inline void RateSource::set_rate_source_type(::Common::RateSourceTypeEnum value) {
  assert(::Common::RateSourceTypeEnum_IsValid(value));
  set_has_rate_source_type();
  rate_source_type_ = value;
}

// optional string reference_page = 3;
inline bool RateSource::has_reference_page() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RateSource::set_has_reference_page() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RateSource::clear_has_reference_page() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RateSource::clear_reference_page() {
  if (reference_page_ != &::google::protobuf::internal::kEmptyString) {
    reference_page_->clear();
  }
  clear_has_reference_page();
}
inline const ::std::string& RateSource::reference_page() const {
  return *reference_page_;
}
inline void RateSource::set_reference_page(const ::std::string& value) {
  set_has_reference_page();
  if (reference_page_ == &::google::protobuf::internal::kEmptyString) {
    reference_page_ = new ::std::string;
  }
  reference_page_->assign(value);
}
inline void RateSource::set_reference_page(const char* value) {
  set_has_reference_page();
  if (reference_page_ == &::google::protobuf::internal::kEmptyString) {
    reference_page_ = new ::std::string;
  }
  reference_page_->assign(value);
}
inline void RateSource::set_reference_page(const char* value, size_t size) {
  set_has_reference_page();
  if (reference_page_ == &::google::protobuf::internal::kEmptyString) {
    reference_page_ = new ::std::string;
  }
  reference_page_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RateSource::mutable_reference_page() {
  set_has_reference_page();
  if (reference_page_ == &::google::protobuf::internal::kEmptyString) {
    reference_page_ = new ::std::string;
  }
  return reference_page_;
}
inline ::std::string* RateSource::release_reference_page() {
  clear_has_reference_page();
  if (reference_page_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reference_page_;
    reference_page_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RateSource::set_allocated_reference_page(::std::string* reference_page) {
  if (reference_page_ != &::google::protobuf::internal::kEmptyString) {
    delete reference_page_;
  }
  if (reference_page) {
    set_has_reference_page();
    reference_page_ = reference_page;
  } else {
    clear_has_reference_page();
    reference_page_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContAmtGrp

// optional string cont_amt_curr = 1;
inline bool ContAmtGrp::has_cont_amt_curr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContAmtGrp::set_has_cont_amt_curr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContAmtGrp::clear_has_cont_amt_curr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContAmtGrp::clear_cont_amt_curr() {
  if (cont_amt_curr_ != &::google::protobuf::internal::kEmptyString) {
    cont_amt_curr_->clear();
  }
  clear_has_cont_amt_curr();
}
inline const ::std::string& ContAmtGrp::cont_amt_curr() const {
  return *cont_amt_curr_;
}
inline void ContAmtGrp::set_cont_amt_curr(const ::std::string& value) {
  set_has_cont_amt_curr();
  if (cont_amt_curr_ == &::google::protobuf::internal::kEmptyString) {
    cont_amt_curr_ = new ::std::string;
  }
  cont_amt_curr_->assign(value);
}
inline void ContAmtGrp::set_cont_amt_curr(const char* value) {
  set_has_cont_amt_curr();
  if (cont_amt_curr_ == &::google::protobuf::internal::kEmptyString) {
    cont_amt_curr_ = new ::std::string;
  }
  cont_amt_curr_->assign(value);
}
inline void ContAmtGrp::set_cont_amt_curr(const char* value, size_t size) {
  set_has_cont_amt_curr();
  if (cont_amt_curr_ == &::google::protobuf::internal::kEmptyString) {
    cont_amt_curr_ = new ::std::string;
  }
  cont_amt_curr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContAmtGrp::mutable_cont_amt_curr() {
  set_has_cont_amt_curr();
  if (cont_amt_curr_ == &::google::protobuf::internal::kEmptyString) {
    cont_amt_curr_ = new ::std::string;
  }
  return cont_amt_curr_;
}
inline ::std::string* ContAmtGrp::release_cont_amt_curr() {
  clear_has_cont_amt_curr();
  if (cont_amt_curr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cont_amt_curr_;
    cont_amt_curr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContAmtGrp::set_allocated_cont_amt_curr(::std::string* cont_amt_curr) {
  if (cont_amt_curr_ != &::google::protobuf::internal::kEmptyString) {
    delete cont_amt_curr_;
  }
  if (cont_amt_curr) {
    set_has_cont_amt_curr();
    cont_amt_curr_ = cont_amt_curr;
  } else {
    clear_has_cont_amt_curr();
    cont_amt_curr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.ContAmtTypeEnum cont_amt_type = 2;
inline bool ContAmtGrp::has_cont_amt_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContAmtGrp::set_has_cont_amt_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContAmtGrp::clear_has_cont_amt_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContAmtGrp::clear_cont_amt_type() {
  cont_amt_type_ = 0;
  clear_has_cont_amt_type();
}
inline ::Common::ContAmtTypeEnum ContAmtGrp::cont_amt_type() const {
  return static_cast< ::Common::ContAmtTypeEnum >(cont_amt_type_);
}
inline void ContAmtGrp::set_cont_amt_type(::Common::ContAmtTypeEnum value) {
  assert(::Common::ContAmtTypeEnum_IsValid(value));
  set_has_cont_amt_type();
  cont_amt_type_ = value;
}

// optional double cont_amt_value = 3;
inline bool ContAmtGrp::has_cont_amt_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContAmtGrp::set_has_cont_amt_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContAmtGrp::clear_has_cont_amt_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContAmtGrp::clear_cont_amt_value() {
  cont_amt_value_ = 0;
  clear_has_cont_amt_value();
}
inline double ContAmtGrp::cont_amt_value() const {
  return cont_amt_value_;
}
inline void ContAmtGrp::set_cont_amt_value(double value) {
  set_has_cont_amt_value();
  cont_amt_value_ = value;
}

// -------------------------------------------------------------------

// LegSecAltIdGrp

// optional string leg_security_alt_id = 1;
inline bool LegSecAltIdGrp::has_leg_security_alt_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegSecAltIdGrp::set_has_leg_security_alt_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegSecAltIdGrp::clear_has_leg_security_alt_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegSecAltIdGrp::clear_leg_security_alt_id() {
  if (leg_security_alt_id_ != &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_->clear();
  }
  clear_has_leg_security_alt_id();
}
inline const ::std::string& LegSecAltIdGrp::leg_security_alt_id() const {
  return *leg_security_alt_id_;
}
inline void LegSecAltIdGrp::set_leg_security_alt_id(const ::std::string& value) {
  set_has_leg_security_alt_id();
  if (leg_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_ = new ::std::string;
  }
  leg_security_alt_id_->assign(value);
}
inline void LegSecAltIdGrp::set_leg_security_alt_id(const char* value) {
  set_has_leg_security_alt_id();
  if (leg_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_ = new ::std::string;
  }
  leg_security_alt_id_->assign(value);
}
inline void LegSecAltIdGrp::set_leg_security_alt_id(const char* value, size_t size) {
  set_has_leg_security_alt_id();
  if (leg_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_ = new ::std::string;
  }
  leg_security_alt_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegSecAltIdGrp::mutable_leg_security_alt_id() {
  set_has_leg_security_alt_id();
  if (leg_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_ = new ::std::string;
  }
  return leg_security_alt_id_;
}
inline ::std::string* LegSecAltIdGrp::release_leg_security_alt_id() {
  clear_has_leg_security_alt_id();
  if (leg_security_alt_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_security_alt_id_;
    leg_security_alt_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegSecAltIdGrp::set_allocated_leg_security_alt_id(::std::string* leg_security_alt_id) {
  if (leg_security_alt_id_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_security_alt_id_;
  }
  if (leg_security_alt_id) {
    set_has_leg_security_alt_id();
    leg_security_alt_id_ = leg_security_alt_id;
  } else {
    clear_has_leg_security_alt_id();
    leg_security_alt_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_security_alt_id_source = 2;
inline bool LegSecAltIdGrp::has_leg_security_alt_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegSecAltIdGrp::set_has_leg_security_alt_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegSecAltIdGrp::clear_has_leg_security_alt_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegSecAltIdGrp::clear_leg_security_alt_id_source() {
  if (leg_security_alt_id_source_ != &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_source_->clear();
  }
  clear_has_leg_security_alt_id_source();
}
inline const ::std::string& LegSecAltIdGrp::leg_security_alt_id_source() const {
  return *leg_security_alt_id_source_;
}
inline void LegSecAltIdGrp::set_leg_security_alt_id_source(const ::std::string& value) {
  set_has_leg_security_alt_id_source();
  if (leg_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_source_ = new ::std::string;
  }
  leg_security_alt_id_source_->assign(value);
}
inline void LegSecAltIdGrp::set_leg_security_alt_id_source(const char* value) {
  set_has_leg_security_alt_id_source();
  if (leg_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_source_ = new ::std::string;
  }
  leg_security_alt_id_source_->assign(value);
}
inline void LegSecAltIdGrp::set_leg_security_alt_id_source(const char* value, size_t size) {
  set_has_leg_security_alt_id_source();
  if (leg_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_source_ = new ::std::string;
  }
  leg_security_alt_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegSecAltIdGrp::mutable_leg_security_alt_id_source() {
  set_has_leg_security_alt_id_source();
  if (leg_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_alt_id_source_ = new ::std::string;
  }
  return leg_security_alt_id_source_;
}
inline ::std::string* LegSecAltIdGrp::release_leg_security_alt_id_source() {
  clear_has_leg_security_alt_id_source();
  if (leg_security_alt_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_security_alt_id_source_;
    leg_security_alt_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegSecAltIdGrp::set_allocated_leg_security_alt_id_source(::std::string* leg_security_alt_id_source) {
  if (leg_security_alt_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_security_alt_id_source_;
  }
  if (leg_security_alt_id_source) {
    set_has_leg_security_alt_id_source();
    leg_security_alt_id_source_ = leg_security_alt_id_source;
  } else {
    clear_has_leg_security_alt_id_source();
    leg_security_alt_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LegFlowScheduleTypeUnion

// optional sfixed64 leg_flow_schedule_type = 1;
inline bool LegFlowScheduleTypeUnion::has_leg_flow_schedule_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegFlowScheduleTypeUnion::set_has_leg_flow_schedule_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegFlowScheduleTypeUnion::clear_has_leg_flow_schedule_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegFlowScheduleTypeUnion::clear_leg_flow_schedule_type() {
  leg_flow_schedule_type_ = GOOGLE_LONGLONG(0);
  clear_has_leg_flow_schedule_type();
}
inline ::google::protobuf::int64 LegFlowScheduleTypeUnion::leg_flow_schedule_type() const {
  return leg_flow_schedule_type_;
}
inline void LegFlowScheduleTypeUnion::set_leg_flow_schedule_type(::google::protobuf::int64 value) {
  set_has_leg_flow_schedule_type();
  leg_flow_schedule_type_ = value;
}

// optional sfixed64 leg_flow_schedule_type_sfixed64 = 2;
inline bool LegFlowScheduleTypeUnion::has_leg_flow_schedule_type_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegFlowScheduleTypeUnion::set_has_leg_flow_schedule_type_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegFlowScheduleTypeUnion::clear_has_leg_flow_schedule_type_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegFlowScheduleTypeUnion::clear_leg_flow_schedule_type_sfixed64() {
  leg_flow_schedule_type_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_leg_flow_schedule_type_sfixed64();
}
inline ::google::protobuf::int64 LegFlowScheduleTypeUnion::leg_flow_schedule_type_sfixed64() const {
  return leg_flow_schedule_type_sfixed64_;
}
inline void LegFlowScheduleTypeUnion::set_leg_flow_schedule_type_sfixed64(::google::protobuf::int64 value) {
  set_has_leg_flow_schedule_type_sfixed64();
  leg_flow_schedule_type_sfixed64_ = value;
}

// -------------------------------------------------------------------

// InstrumentLeg

// optional bytes encoded_leg_issuer = 1;
inline bool InstrumentLeg::has_encoded_leg_issuer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrumentLeg::set_has_encoded_leg_issuer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrumentLeg::clear_has_encoded_leg_issuer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrumentLeg::clear_encoded_leg_issuer() {
  if (encoded_leg_issuer_ != &::google::protobuf::internal::kEmptyString) {
    encoded_leg_issuer_->clear();
  }
  clear_has_encoded_leg_issuer();
}
inline const ::std::string& InstrumentLeg::encoded_leg_issuer() const {
  return *encoded_leg_issuer_;
}
inline void InstrumentLeg::set_encoded_leg_issuer(const ::std::string& value) {
  set_has_encoded_leg_issuer();
  if (encoded_leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_leg_issuer_ = new ::std::string;
  }
  encoded_leg_issuer_->assign(value);
}
inline void InstrumentLeg::set_encoded_leg_issuer(const char* value) {
  set_has_encoded_leg_issuer();
  if (encoded_leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_leg_issuer_ = new ::std::string;
  }
  encoded_leg_issuer_->assign(value);
}
inline void InstrumentLeg::set_encoded_leg_issuer(const void* value, size_t size) {
  set_has_encoded_leg_issuer();
  if (encoded_leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_leg_issuer_ = new ::std::string;
  }
  encoded_leg_issuer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_encoded_leg_issuer() {
  set_has_encoded_leg_issuer();
  if (encoded_leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    encoded_leg_issuer_ = new ::std::string;
  }
  return encoded_leg_issuer_;
}
inline ::std::string* InstrumentLeg::release_encoded_leg_issuer() {
  clear_has_encoded_leg_issuer();
  if (encoded_leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_leg_issuer_;
    encoded_leg_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_encoded_leg_issuer(::std::string* encoded_leg_issuer) {
  if (encoded_leg_issuer_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_leg_issuer_;
  }
  if (encoded_leg_issuer) {
    set_has_encoded_leg_issuer();
    encoded_leg_issuer_ = encoded_leg_issuer;
  } else {
    clear_has_encoded_leg_issuer();
    encoded_leg_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_leg_issuer_len = 2;
inline bool InstrumentLeg::has_encoded_leg_issuer_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrumentLeg::set_has_encoded_leg_issuer_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrumentLeg::clear_has_encoded_leg_issuer_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrumentLeg::clear_encoded_leg_issuer_len() {
  encoded_leg_issuer_len_ = 0u;
  clear_has_encoded_leg_issuer_len();
}
inline ::google::protobuf::uint32 InstrumentLeg::encoded_leg_issuer_len() const {
  return encoded_leg_issuer_len_;
}
inline void InstrumentLeg::set_encoded_leg_issuer_len(::google::protobuf::uint32 value) {
  set_has_encoded_leg_issuer_len();
  encoded_leg_issuer_len_ = value;
}

// optional bytes encoded_leg_security_desc = 3;
inline bool InstrumentLeg::has_encoded_leg_security_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstrumentLeg::set_has_encoded_leg_security_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstrumentLeg::clear_has_encoded_leg_security_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstrumentLeg::clear_encoded_leg_security_desc() {
  if (encoded_leg_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    encoded_leg_security_desc_->clear();
  }
  clear_has_encoded_leg_security_desc();
}
inline const ::std::string& InstrumentLeg::encoded_leg_security_desc() const {
  return *encoded_leg_security_desc_;
}
inline void InstrumentLeg::set_encoded_leg_security_desc(const ::std::string& value) {
  set_has_encoded_leg_security_desc();
  if (encoded_leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_leg_security_desc_ = new ::std::string;
  }
  encoded_leg_security_desc_->assign(value);
}
inline void InstrumentLeg::set_encoded_leg_security_desc(const char* value) {
  set_has_encoded_leg_security_desc();
  if (encoded_leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_leg_security_desc_ = new ::std::string;
  }
  encoded_leg_security_desc_->assign(value);
}
inline void InstrumentLeg::set_encoded_leg_security_desc(const void* value, size_t size) {
  set_has_encoded_leg_security_desc();
  if (encoded_leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_leg_security_desc_ = new ::std::string;
  }
  encoded_leg_security_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_encoded_leg_security_desc() {
  set_has_encoded_leg_security_desc();
  if (encoded_leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_leg_security_desc_ = new ::std::string;
  }
  return encoded_leg_security_desc_;
}
inline ::std::string* InstrumentLeg::release_encoded_leg_security_desc() {
  clear_has_encoded_leg_security_desc();
  if (encoded_leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_leg_security_desc_;
    encoded_leg_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_encoded_leg_security_desc(::std::string* encoded_leg_security_desc) {
  if (encoded_leg_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_leg_security_desc_;
  }
  if (encoded_leg_security_desc) {
    set_has_encoded_leg_security_desc();
    encoded_leg_security_desc_ = encoded_leg_security_desc;
  } else {
    clear_has_encoded_leg_security_desc();
    encoded_leg_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_leg_security_desc_len = 4;
inline bool InstrumentLeg::has_encoded_leg_security_desc_len() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstrumentLeg::set_has_encoded_leg_security_desc_len() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstrumentLeg::clear_has_encoded_leg_security_desc_len() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstrumentLeg::clear_encoded_leg_security_desc_len() {
  encoded_leg_security_desc_len_ = 0u;
  clear_has_encoded_leg_security_desc_len();
}
inline ::google::protobuf::uint32 InstrumentLeg::encoded_leg_security_desc_len() const {
  return encoded_leg_security_desc_len_;
}
inline void InstrumentLeg::set_encoded_leg_security_desc_len(::google::protobuf::uint32 value) {
  set_has_encoded_leg_security_desc_len();
  encoded_leg_security_desc_len_ = value;
}

// optional string leg_cfi_code = 5;
inline bool InstrumentLeg::has_leg_cfi_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstrumentLeg::set_has_leg_cfi_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstrumentLeg::clear_has_leg_cfi_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstrumentLeg::clear_leg_cfi_code() {
  if (leg_cfi_code_ != &::google::protobuf::internal::kEmptyString) {
    leg_cfi_code_->clear();
  }
  clear_has_leg_cfi_code();
}
inline const ::std::string& InstrumentLeg::leg_cfi_code() const {
  return *leg_cfi_code_;
}
inline void InstrumentLeg::set_leg_cfi_code(const ::std::string& value) {
  set_has_leg_cfi_code();
  if (leg_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    leg_cfi_code_ = new ::std::string;
  }
  leg_cfi_code_->assign(value);
}
inline void InstrumentLeg::set_leg_cfi_code(const char* value) {
  set_has_leg_cfi_code();
  if (leg_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    leg_cfi_code_ = new ::std::string;
  }
  leg_cfi_code_->assign(value);
}
inline void InstrumentLeg::set_leg_cfi_code(const char* value, size_t size) {
  set_has_leg_cfi_code();
  if (leg_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    leg_cfi_code_ = new ::std::string;
  }
  leg_cfi_code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_cfi_code() {
  set_has_leg_cfi_code();
  if (leg_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    leg_cfi_code_ = new ::std::string;
  }
  return leg_cfi_code_;
}
inline ::std::string* InstrumentLeg::release_leg_cfi_code() {
  clear_has_leg_cfi_code();
  if (leg_cfi_code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_cfi_code_;
    leg_cfi_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_cfi_code(::std::string* leg_cfi_code) {
  if (leg_cfi_code_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_cfi_code_;
  }
  if (leg_cfi_code) {
    set_has_leg_cfi_code();
    leg_cfi_code_ = leg_cfi_code;
  } else {
    clear_has_leg_cfi_code();
    leg_cfi_code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double leg_contract_multiplier = 6;
inline bool InstrumentLeg::has_leg_contract_multiplier() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstrumentLeg::set_has_leg_contract_multiplier() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstrumentLeg::clear_has_leg_contract_multiplier() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstrumentLeg::clear_leg_contract_multiplier() {
  leg_contract_multiplier_ = 0;
  clear_has_leg_contract_multiplier();
}
inline double InstrumentLeg::leg_contract_multiplier() const {
  return leg_contract_multiplier_;
}
inline void InstrumentLeg::set_leg_contract_multiplier(double value) {
  set_has_leg_contract_multiplier();
  leg_contract_multiplier_ = value;
}

// optional string leg_country_of_issue = 7;
inline bool InstrumentLeg::has_leg_country_of_issue() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstrumentLeg::set_has_leg_country_of_issue() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstrumentLeg::clear_has_leg_country_of_issue() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstrumentLeg::clear_leg_country_of_issue() {
  if (leg_country_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    leg_country_of_issue_->clear();
  }
  clear_has_leg_country_of_issue();
}
inline const ::std::string& InstrumentLeg::leg_country_of_issue() const {
  return *leg_country_of_issue_;
}
inline void InstrumentLeg::set_leg_country_of_issue(const ::std::string& value) {
  set_has_leg_country_of_issue();
  if (leg_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_country_of_issue_ = new ::std::string;
  }
  leg_country_of_issue_->assign(value);
}
inline void InstrumentLeg::set_leg_country_of_issue(const char* value) {
  set_has_leg_country_of_issue();
  if (leg_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_country_of_issue_ = new ::std::string;
  }
  leg_country_of_issue_->assign(value);
}
inline void InstrumentLeg::set_leg_country_of_issue(const char* value, size_t size) {
  set_has_leg_country_of_issue();
  if (leg_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_country_of_issue_ = new ::std::string;
  }
  leg_country_of_issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_country_of_issue() {
  set_has_leg_country_of_issue();
  if (leg_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_country_of_issue_ = new ::std::string;
  }
  return leg_country_of_issue_;
}
inline ::std::string* InstrumentLeg::release_leg_country_of_issue() {
  clear_has_leg_country_of_issue();
  if (leg_country_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_country_of_issue_;
    leg_country_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_country_of_issue(::std::string* leg_country_of_issue) {
  if (leg_country_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_country_of_issue_;
  }
  if (leg_country_of_issue) {
    set_has_leg_country_of_issue();
    leg_country_of_issue_ = leg_country_of_issue;
  } else {
    clear_has_leg_country_of_issue();
    leg_country_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 leg_coupon_payment_date = 8;
inline bool InstrumentLeg::has_leg_coupon_payment_date() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstrumentLeg::set_has_leg_coupon_payment_date() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstrumentLeg::clear_has_leg_coupon_payment_date() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstrumentLeg::clear_leg_coupon_payment_date() {
  leg_coupon_payment_date_ = 0;
  clear_has_leg_coupon_payment_date();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_coupon_payment_date() const {
  return leg_coupon_payment_date_;
}
inline void InstrumentLeg::set_leg_coupon_payment_date(::google::protobuf::int32 value) {
  set_has_leg_coupon_payment_date();
  leg_coupon_payment_date_ = value;
}

// optional sfixed64 leg_coupon_rate = 9;
inline bool InstrumentLeg::has_leg_coupon_rate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstrumentLeg::set_has_leg_coupon_rate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstrumentLeg::clear_has_leg_coupon_rate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstrumentLeg::clear_leg_coupon_rate() {
  leg_coupon_rate_ = GOOGLE_LONGLONG(0);
  clear_has_leg_coupon_rate();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_coupon_rate() const {
  return leg_coupon_rate_;
}
inline void InstrumentLeg::set_leg_coupon_rate(::google::protobuf::int64 value) {
  set_has_leg_coupon_rate();
  leg_coupon_rate_ = value;
}

// optional sfixed32 leg_coupon_rate_exponent = 10;
inline bool InstrumentLeg::has_leg_coupon_rate_exponent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InstrumentLeg::set_has_leg_coupon_rate_exponent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InstrumentLeg::clear_has_leg_coupon_rate_exponent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InstrumentLeg::clear_leg_coupon_rate_exponent() {
  leg_coupon_rate_exponent_ = 0;
  clear_has_leg_coupon_rate_exponent();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_coupon_rate_exponent() const {
  return leg_coupon_rate_exponent_;
}
inline void InstrumentLeg::set_leg_coupon_rate_exponent(::google::protobuf::int32 value) {
  set_has_leg_coupon_rate_exponent();
  leg_coupon_rate_exponent_ = value;
}

// optional string leg_credit_rating = 11;
inline bool InstrumentLeg::has_leg_credit_rating() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InstrumentLeg::set_has_leg_credit_rating() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InstrumentLeg::clear_has_leg_credit_rating() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InstrumentLeg::clear_leg_credit_rating() {
  if (leg_credit_rating_ != &::google::protobuf::internal::kEmptyString) {
    leg_credit_rating_->clear();
  }
  clear_has_leg_credit_rating();
}
inline const ::std::string& InstrumentLeg::leg_credit_rating() const {
  return *leg_credit_rating_;
}
inline void InstrumentLeg::set_leg_credit_rating(const ::std::string& value) {
  set_has_leg_credit_rating();
  if (leg_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    leg_credit_rating_ = new ::std::string;
  }
  leg_credit_rating_->assign(value);
}
inline void InstrumentLeg::set_leg_credit_rating(const char* value) {
  set_has_leg_credit_rating();
  if (leg_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    leg_credit_rating_ = new ::std::string;
  }
  leg_credit_rating_->assign(value);
}
inline void InstrumentLeg::set_leg_credit_rating(const char* value, size_t size) {
  set_has_leg_credit_rating();
  if (leg_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    leg_credit_rating_ = new ::std::string;
  }
  leg_credit_rating_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_credit_rating() {
  set_has_leg_credit_rating();
  if (leg_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    leg_credit_rating_ = new ::std::string;
  }
  return leg_credit_rating_;
}
inline ::std::string* InstrumentLeg::release_leg_credit_rating() {
  clear_has_leg_credit_rating();
  if (leg_credit_rating_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_credit_rating_;
    leg_credit_rating_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_credit_rating(::std::string* leg_credit_rating) {
  if (leg_credit_rating_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_credit_rating_;
  }
  if (leg_credit_rating) {
    set_has_leg_credit_rating();
    leg_credit_rating_ = leg_credit_rating;
  } else {
    clear_has_leg_credit_rating();
    leg_credit_rating_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double leg_factor = 12;
inline bool InstrumentLeg::has_leg_factor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InstrumentLeg::set_has_leg_factor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InstrumentLeg::clear_has_leg_factor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InstrumentLeg::clear_leg_factor() {
  leg_factor_ = 0;
  clear_has_leg_factor();
}
inline double InstrumentLeg::leg_factor() const {
  return leg_factor_;
}
inline void InstrumentLeg::set_leg_factor(double value) {
  set_has_leg_factor();
  leg_factor_ = value;
}

// optional string leg_instr_registry = 13;
inline bool InstrumentLeg::has_leg_instr_registry() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InstrumentLeg::set_has_leg_instr_registry() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InstrumentLeg::clear_has_leg_instr_registry() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InstrumentLeg::clear_leg_instr_registry() {
  if (leg_instr_registry_ != &::google::protobuf::internal::kEmptyString) {
    leg_instr_registry_->clear();
  }
  clear_has_leg_instr_registry();
}
inline const ::std::string& InstrumentLeg::leg_instr_registry() const {
  return *leg_instr_registry_;
}
inline void InstrumentLeg::set_leg_instr_registry(const ::std::string& value) {
  set_has_leg_instr_registry();
  if (leg_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    leg_instr_registry_ = new ::std::string;
  }
  leg_instr_registry_->assign(value);
}
inline void InstrumentLeg::set_leg_instr_registry(const char* value) {
  set_has_leg_instr_registry();
  if (leg_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    leg_instr_registry_ = new ::std::string;
  }
  leg_instr_registry_->assign(value);
}
inline void InstrumentLeg::set_leg_instr_registry(const char* value, size_t size) {
  set_has_leg_instr_registry();
  if (leg_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    leg_instr_registry_ = new ::std::string;
  }
  leg_instr_registry_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_instr_registry() {
  set_has_leg_instr_registry();
  if (leg_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    leg_instr_registry_ = new ::std::string;
  }
  return leg_instr_registry_;
}
inline ::std::string* InstrumentLeg::release_leg_instr_registry() {
  clear_has_leg_instr_registry();
  if (leg_instr_registry_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_instr_registry_;
    leg_instr_registry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_instr_registry(::std::string* leg_instr_registry) {
  if (leg_instr_registry_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_instr_registry_;
  }
  if (leg_instr_registry) {
    set_has_leg_instr_registry();
    leg_instr_registry_ = leg_instr_registry;
  } else {
    clear_has_leg_instr_registry();
    leg_instr_registry_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 leg_issue_date = 14;
inline bool InstrumentLeg::has_leg_issue_date() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InstrumentLeg::set_has_leg_issue_date() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InstrumentLeg::clear_has_leg_issue_date() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InstrumentLeg::clear_leg_issue_date() {
  leg_issue_date_ = 0;
  clear_has_leg_issue_date();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_issue_date() const {
  return leg_issue_date_;
}
inline void InstrumentLeg::set_leg_issue_date(::google::protobuf::int32 value) {
  set_has_leg_issue_date();
  leg_issue_date_ = value;
}

// optional string leg_issuer = 15;
inline bool InstrumentLeg::has_leg_issuer() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InstrumentLeg::set_has_leg_issuer() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InstrumentLeg::clear_has_leg_issuer() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InstrumentLeg::clear_leg_issuer() {
  if (leg_issuer_ != &::google::protobuf::internal::kEmptyString) {
    leg_issuer_->clear();
  }
  clear_has_leg_issuer();
}
inline const ::std::string& InstrumentLeg::leg_issuer() const {
  return *leg_issuer_;
}
inline void InstrumentLeg::set_leg_issuer(const ::std::string& value) {
  set_has_leg_issuer();
  if (leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    leg_issuer_ = new ::std::string;
  }
  leg_issuer_->assign(value);
}
inline void InstrumentLeg::set_leg_issuer(const char* value) {
  set_has_leg_issuer();
  if (leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    leg_issuer_ = new ::std::string;
  }
  leg_issuer_->assign(value);
}
inline void InstrumentLeg::set_leg_issuer(const char* value, size_t size) {
  set_has_leg_issuer();
  if (leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    leg_issuer_ = new ::std::string;
  }
  leg_issuer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_issuer() {
  set_has_leg_issuer();
  if (leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    leg_issuer_ = new ::std::string;
  }
  return leg_issuer_;
}
inline ::std::string* InstrumentLeg::release_leg_issuer() {
  clear_has_leg_issuer();
  if (leg_issuer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_issuer_;
    leg_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_issuer(::std::string* leg_issuer) {
  if (leg_issuer_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_issuer_;
  }
  if (leg_issuer) {
    set_has_leg_issuer();
    leg_issuer_ = leg_issuer;
  } else {
    clear_has_leg_issuer();
    leg_issuer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_locale_of_issue = 16;
inline bool InstrumentLeg::has_leg_locale_of_issue() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InstrumentLeg::set_has_leg_locale_of_issue() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InstrumentLeg::clear_has_leg_locale_of_issue() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InstrumentLeg::clear_leg_locale_of_issue() {
  if (leg_locale_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    leg_locale_of_issue_->clear();
  }
  clear_has_leg_locale_of_issue();
}
inline const ::std::string& InstrumentLeg::leg_locale_of_issue() const {
  return *leg_locale_of_issue_;
}
inline void InstrumentLeg::set_leg_locale_of_issue(const ::std::string& value) {
  set_has_leg_locale_of_issue();
  if (leg_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_locale_of_issue_ = new ::std::string;
  }
  leg_locale_of_issue_->assign(value);
}
inline void InstrumentLeg::set_leg_locale_of_issue(const char* value) {
  set_has_leg_locale_of_issue();
  if (leg_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_locale_of_issue_ = new ::std::string;
  }
  leg_locale_of_issue_->assign(value);
}
inline void InstrumentLeg::set_leg_locale_of_issue(const char* value, size_t size) {
  set_has_leg_locale_of_issue();
  if (leg_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_locale_of_issue_ = new ::std::string;
  }
  leg_locale_of_issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_locale_of_issue() {
  set_has_leg_locale_of_issue();
  if (leg_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_locale_of_issue_ = new ::std::string;
  }
  return leg_locale_of_issue_;
}
inline ::std::string* InstrumentLeg::release_leg_locale_of_issue() {
  clear_has_leg_locale_of_issue();
  if (leg_locale_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_locale_of_issue_;
    leg_locale_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_locale_of_issue(::std::string* leg_locale_of_issue) {
  if (leg_locale_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_locale_of_issue_;
  }
  if (leg_locale_of_issue) {
    set_has_leg_locale_of_issue();
    leg_locale_of_issue_ = leg_locale_of_issue;
  } else {
    clear_has_leg_locale_of_issue();
    leg_locale_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 leg_maturity_date = 17;
inline bool InstrumentLeg::has_leg_maturity_date() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InstrumentLeg::set_has_leg_maturity_date() {
  _has_bits_[0] |= 0x00010000u;
}
inline void InstrumentLeg::clear_has_leg_maturity_date() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void InstrumentLeg::clear_leg_maturity_date() {
  leg_maturity_date_ = 0;
  clear_has_leg_maturity_date();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_maturity_date() const {
  return leg_maturity_date_;
}
inline void InstrumentLeg::set_leg_maturity_date(::google::protobuf::int32 value) {
  set_has_leg_maturity_date();
  leg_maturity_date_ = value;
}

// optional sfixed32 leg_maturity_month_year = 18;
inline bool InstrumentLeg::has_leg_maturity_month_year() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InstrumentLeg::set_has_leg_maturity_month_year() {
  _has_bits_[0] |= 0x00020000u;
}
inline void InstrumentLeg::clear_has_leg_maturity_month_year() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void InstrumentLeg::clear_leg_maturity_month_year() {
  leg_maturity_month_year_ = 0;
  clear_has_leg_maturity_month_year();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_maturity_month_year() const {
  return leg_maturity_month_year_;
}
inline void InstrumentLeg::set_leg_maturity_month_year(::google::protobuf::int32 value) {
  set_has_leg_maturity_month_year();
  leg_maturity_month_year_ = value;
}

// optional string leg_opt_attribute = 19;
inline bool InstrumentLeg::has_leg_opt_attribute() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void InstrumentLeg::set_has_leg_opt_attribute() {
  _has_bits_[0] |= 0x00040000u;
}
inline void InstrumentLeg::clear_has_leg_opt_attribute() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void InstrumentLeg::clear_leg_opt_attribute() {
  if (leg_opt_attribute_ != &::google::protobuf::internal::kEmptyString) {
    leg_opt_attribute_->clear();
  }
  clear_has_leg_opt_attribute();
}
inline const ::std::string& InstrumentLeg::leg_opt_attribute() const {
  return *leg_opt_attribute_;
}
inline void InstrumentLeg::set_leg_opt_attribute(const ::std::string& value) {
  set_has_leg_opt_attribute();
  if (leg_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    leg_opt_attribute_ = new ::std::string;
  }
  leg_opt_attribute_->assign(value);
}
inline void InstrumentLeg::set_leg_opt_attribute(const char* value) {
  set_has_leg_opt_attribute();
  if (leg_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    leg_opt_attribute_ = new ::std::string;
  }
  leg_opt_attribute_->assign(value);
}
inline void InstrumentLeg::set_leg_opt_attribute(const char* value, size_t size) {
  set_has_leg_opt_attribute();
  if (leg_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    leg_opt_attribute_ = new ::std::string;
  }
  leg_opt_attribute_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_opt_attribute() {
  set_has_leg_opt_attribute();
  if (leg_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    leg_opt_attribute_ = new ::std::string;
  }
  return leg_opt_attribute_;
}
inline ::std::string* InstrumentLeg::release_leg_opt_attribute() {
  clear_has_leg_opt_attribute();
  if (leg_opt_attribute_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_opt_attribute_;
    leg_opt_attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_opt_attribute(::std::string* leg_opt_attribute) {
  if (leg_opt_attribute_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_opt_attribute_;
  }
  if (leg_opt_attribute) {
    set_has_leg_opt_attribute();
    leg_opt_attribute_ = leg_opt_attribute;
  } else {
    clear_has_leg_opt_attribute();
    leg_opt_attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 leg_product = 20;
inline bool InstrumentLeg::has_leg_product() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void InstrumentLeg::set_has_leg_product() {
  _has_bits_[0] |= 0x00080000u;
}
inline void InstrumentLeg::clear_has_leg_product() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void InstrumentLeg::clear_leg_product() {
  leg_product_ = GOOGLE_LONGLONG(0);
  clear_has_leg_product();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_product() const {
  return leg_product_;
}
inline void InstrumentLeg::set_leg_product(::google::protobuf::int64 value) {
  set_has_leg_product();
  leg_product_ = value;
}

// optional double leg_ratio_qty = 21;
inline bool InstrumentLeg::has_leg_ratio_qty() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void InstrumentLeg::set_has_leg_ratio_qty() {
  _has_bits_[0] |= 0x00100000u;
}
inline void InstrumentLeg::clear_has_leg_ratio_qty() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void InstrumentLeg::clear_leg_ratio_qty() {
  leg_ratio_qty_ = 0;
  clear_has_leg_ratio_qty();
}
inline double InstrumentLeg::leg_ratio_qty() const {
  return leg_ratio_qty_;
}
inline void InstrumentLeg::set_leg_ratio_qty(double value) {
  set_has_leg_ratio_qty();
  leg_ratio_qty_ = value;
}

// optional sfixed32 leg_redemption_date = 22;
inline bool InstrumentLeg::has_leg_redemption_date() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void InstrumentLeg::set_has_leg_redemption_date() {
  _has_bits_[0] |= 0x00200000u;
}
inline void InstrumentLeg::clear_has_leg_redemption_date() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void InstrumentLeg::clear_leg_redemption_date() {
  leg_redemption_date_ = 0;
  clear_has_leg_redemption_date();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_redemption_date() const {
  return leg_redemption_date_;
}
inline void InstrumentLeg::set_leg_redemption_date(::google::protobuf::int32 value) {
  set_has_leg_redemption_date();
  leg_redemption_date_ = value;
}

// optional string leg_repo_collateral_security_type = 23;
inline bool InstrumentLeg::has_leg_repo_collateral_security_type() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void InstrumentLeg::set_has_leg_repo_collateral_security_type() {
  _has_bits_[0] |= 0x00400000u;
}
inline void InstrumentLeg::clear_has_leg_repo_collateral_security_type() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void InstrumentLeg::clear_leg_repo_collateral_security_type() {
  if (leg_repo_collateral_security_type_ != &::google::protobuf::internal::kEmptyString) {
    leg_repo_collateral_security_type_->clear();
  }
  clear_has_leg_repo_collateral_security_type();
}
inline const ::std::string& InstrumentLeg::leg_repo_collateral_security_type() const {
  return *leg_repo_collateral_security_type_;
}
inline void InstrumentLeg::set_leg_repo_collateral_security_type(const ::std::string& value) {
  set_has_leg_repo_collateral_security_type();
  if (leg_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_repo_collateral_security_type_ = new ::std::string;
  }
  leg_repo_collateral_security_type_->assign(value);
}
inline void InstrumentLeg::set_leg_repo_collateral_security_type(const char* value) {
  set_has_leg_repo_collateral_security_type();
  if (leg_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_repo_collateral_security_type_ = new ::std::string;
  }
  leg_repo_collateral_security_type_->assign(value);
}
inline void InstrumentLeg::set_leg_repo_collateral_security_type(const char* value, size_t size) {
  set_has_leg_repo_collateral_security_type();
  if (leg_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_repo_collateral_security_type_ = new ::std::string;
  }
  leg_repo_collateral_security_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_repo_collateral_security_type() {
  set_has_leg_repo_collateral_security_type();
  if (leg_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_repo_collateral_security_type_ = new ::std::string;
  }
  return leg_repo_collateral_security_type_;
}
inline ::std::string* InstrumentLeg::release_leg_repo_collateral_security_type() {
  clear_has_leg_repo_collateral_security_type();
  if (leg_repo_collateral_security_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_repo_collateral_security_type_;
    leg_repo_collateral_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_repo_collateral_security_type(::std::string* leg_repo_collateral_security_type) {
  if (leg_repo_collateral_security_type_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_repo_collateral_security_type_;
  }
  if (leg_repo_collateral_security_type) {
    set_has_leg_repo_collateral_security_type();
    leg_repo_collateral_security_type_ = leg_repo_collateral_security_type;
  } else {
    clear_has_leg_repo_collateral_security_type();
    leg_repo_collateral_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 leg_repurchase_rate = 24;
inline bool InstrumentLeg::has_leg_repurchase_rate() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void InstrumentLeg::set_has_leg_repurchase_rate() {
  _has_bits_[0] |= 0x00800000u;
}
inline void InstrumentLeg::clear_has_leg_repurchase_rate() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void InstrumentLeg::clear_leg_repurchase_rate() {
  leg_repurchase_rate_ = GOOGLE_LONGLONG(0);
  clear_has_leg_repurchase_rate();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_repurchase_rate() const {
  return leg_repurchase_rate_;
}
inline void InstrumentLeg::set_leg_repurchase_rate(::google::protobuf::int64 value) {
  set_has_leg_repurchase_rate();
  leg_repurchase_rate_ = value;
}

// optional sfixed32 leg_repurchase_rate_exponent = 25;
inline bool InstrumentLeg::has_leg_repurchase_rate_exponent() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_repurchase_rate_exponent() {
  _has_bits_[0] |= 0x01000000u;
}
inline void InstrumentLeg::clear_has_leg_repurchase_rate_exponent() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void InstrumentLeg::clear_leg_repurchase_rate_exponent() {
  leg_repurchase_rate_exponent_ = 0;
  clear_has_leg_repurchase_rate_exponent();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_repurchase_rate_exponent() const {
  return leg_repurchase_rate_exponent_;
}
inline void InstrumentLeg::set_leg_repurchase_rate_exponent(::google::protobuf::int32 value) {
  set_has_leg_repurchase_rate_exponent();
  leg_repurchase_rate_exponent_ = value;
}

// optional sfixed64 leg_repurchase_term = 26;
inline bool InstrumentLeg::has_leg_repurchase_term() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_repurchase_term() {
  _has_bits_[0] |= 0x02000000u;
}
inline void InstrumentLeg::clear_has_leg_repurchase_term() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void InstrumentLeg::clear_leg_repurchase_term() {
  leg_repurchase_term_ = GOOGLE_LONGLONG(0);
  clear_has_leg_repurchase_term();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_repurchase_term() const {
  return leg_repurchase_term_;
}
inline void InstrumentLeg::set_leg_repurchase_term(::google::protobuf::int64 value) {
  set_has_leg_repurchase_term();
  leg_repurchase_term_ = value;
}

// optional string leg_security_desc = 27;
inline bool InstrumentLeg::has_leg_security_desc() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_security_desc() {
  _has_bits_[0] |= 0x04000000u;
}
inline void InstrumentLeg::clear_has_leg_security_desc() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void InstrumentLeg::clear_leg_security_desc() {
  if (leg_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    leg_security_desc_->clear();
  }
  clear_has_leg_security_desc();
}
inline const ::std::string& InstrumentLeg::leg_security_desc() const {
  return *leg_security_desc_;
}
inline void InstrumentLeg::set_leg_security_desc(const ::std::string& value) {
  set_has_leg_security_desc();
  if (leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_desc_ = new ::std::string;
  }
  leg_security_desc_->assign(value);
}
inline void InstrumentLeg::set_leg_security_desc(const char* value) {
  set_has_leg_security_desc();
  if (leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_desc_ = new ::std::string;
  }
  leg_security_desc_->assign(value);
}
inline void InstrumentLeg::set_leg_security_desc(const char* value, size_t size) {
  set_has_leg_security_desc();
  if (leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_desc_ = new ::std::string;
  }
  leg_security_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_security_desc() {
  set_has_leg_security_desc();
  if (leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_desc_ = new ::std::string;
  }
  return leg_security_desc_;
}
inline ::std::string* InstrumentLeg::release_leg_security_desc() {
  clear_has_leg_security_desc();
  if (leg_security_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_security_desc_;
    leg_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_security_desc(::std::string* leg_security_desc) {
  if (leg_security_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_security_desc_;
  }
  if (leg_security_desc) {
    set_has_leg_security_desc();
    leg_security_desc_ = leg_security_desc;
  } else {
    clear_has_leg_security_desc();
    leg_security_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_security_exchange = 28;
inline bool InstrumentLeg::has_leg_security_exchange() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_security_exchange() {
  _has_bits_[0] |= 0x08000000u;
}
inline void InstrumentLeg::clear_has_leg_security_exchange() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void InstrumentLeg::clear_leg_security_exchange() {
  if (leg_security_exchange_ != &::google::protobuf::internal::kEmptyString) {
    leg_security_exchange_->clear();
  }
  clear_has_leg_security_exchange();
}
inline const ::std::string& InstrumentLeg::leg_security_exchange() const {
  return *leg_security_exchange_;
}
inline void InstrumentLeg::set_leg_security_exchange(const ::std::string& value) {
  set_has_leg_security_exchange();
  if (leg_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_exchange_ = new ::std::string;
  }
  leg_security_exchange_->assign(value);
}
inline void InstrumentLeg::set_leg_security_exchange(const char* value) {
  set_has_leg_security_exchange();
  if (leg_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_exchange_ = new ::std::string;
  }
  leg_security_exchange_->assign(value);
}
inline void InstrumentLeg::set_leg_security_exchange(const char* value, size_t size) {
  set_has_leg_security_exchange();
  if (leg_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_exchange_ = new ::std::string;
  }
  leg_security_exchange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_security_exchange() {
  set_has_leg_security_exchange();
  if (leg_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_exchange_ = new ::std::string;
  }
  return leg_security_exchange_;
}
inline ::std::string* InstrumentLeg::release_leg_security_exchange() {
  clear_has_leg_security_exchange();
  if (leg_security_exchange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_security_exchange_;
    leg_security_exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_security_exchange(::std::string* leg_security_exchange) {
  if (leg_security_exchange_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_security_exchange_;
  }
  if (leg_security_exchange) {
    set_has_leg_security_exchange();
    leg_security_exchange_ = leg_security_exchange;
  } else {
    clear_has_leg_security_exchange();
    leg_security_exchange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_security_id = 29;
inline bool InstrumentLeg::has_leg_security_id() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_security_id() {
  _has_bits_[0] |= 0x10000000u;
}
inline void InstrumentLeg::clear_has_leg_security_id() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void InstrumentLeg::clear_leg_security_id() {
  if (leg_security_id_ != &::google::protobuf::internal::kEmptyString) {
    leg_security_id_->clear();
  }
  clear_has_leg_security_id();
}
inline const ::std::string& InstrumentLeg::leg_security_id() const {
  return *leg_security_id_;
}
inline void InstrumentLeg::set_leg_security_id(const ::std::string& value) {
  set_has_leg_security_id();
  if (leg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_id_ = new ::std::string;
  }
  leg_security_id_->assign(value);
}
inline void InstrumentLeg::set_leg_security_id(const char* value) {
  set_has_leg_security_id();
  if (leg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_id_ = new ::std::string;
  }
  leg_security_id_->assign(value);
}
inline void InstrumentLeg::set_leg_security_id(const char* value, size_t size) {
  set_has_leg_security_id();
  if (leg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_id_ = new ::std::string;
  }
  leg_security_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_security_id() {
  set_has_leg_security_id();
  if (leg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_id_ = new ::std::string;
  }
  return leg_security_id_;
}
inline ::std::string* InstrumentLeg::release_leg_security_id() {
  clear_has_leg_security_id();
  if (leg_security_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_security_id_;
    leg_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_security_id(::std::string* leg_security_id) {
  if (leg_security_id_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_security_id_;
  }
  if (leg_security_id) {
    set_has_leg_security_id();
    leg_security_id_ = leg_security_id;
  } else {
    clear_has_leg_security_id();
    leg_security_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_security_id_source = 30;
inline bool InstrumentLeg::has_leg_security_id_source() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_security_id_source() {
  _has_bits_[0] |= 0x20000000u;
}
inline void InstrumentLeg::clear_has_leg_security_id_source() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void InstrumentLeg::clear_leg_security_id_source() {
  if (leg_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    leg_security_id_source_->clear();
  }
  clear_has_leg_security_id_source();
}
inline const ::std::string& InstrumentLeg::leg_security_id_source() const {
  return *leg_security_id_source_;
}
inline void InstrumentLeg::set_leg_security_id_source(const ::std::string& value) {
  set_has_leg_security_id_source();
  if (leg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_id_source_ = new ::std::string;
  }
  leg_security_id_source_->assign(value);
}
inline void InstrumentLeg::set_leg_security_id_source(const char* value) {
  set_has_leg_security_id_source();
  if (leg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_id_source_ = new ::std::string;
  }
  leg_security_id_source_->assign(value);
}
inline void InstrumentLeg::set_leg_security_id_source(const char* value, size_t size) {
  set_has_leg_security_id_source();
  if (leg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_id_source_ = new ::std::string;
  }
  leg_security_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_security_id_source() {
  set_has_leg_security_id_source();
  if (leg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_id_source_ = new ::std::string;
  }
  return leg_security_id_source_;
}
inline ::std::string* InstrumentLeg::release_leg_security_id_source() {
  clear_has_leg_security_id_source();
  if (leg_security_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_security_id_source_;
    leg_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_security_id_source(::std::string* leg_security_id_source) {
  if (leg_security_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_security_id_source_;
  }
  if (leg_security_id_source) {
    set_has_leg_security_id_source();
    leg_security_id_source_ = leg_security_id_source;
  } else {
    clear_has_leg_security_id_source();
    leg_security_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_security_type = 31;
inline bool InstrumentLeg::has_leg_security_type() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_security_type() {
  _has_bits_[0] |= 0x40000000u;
}
inline void InstrumentLeg::clear_has_leg_security_type() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void InstrumentLeg::clear_leg_security_type() {
  if (leg_security_type_ != &::google::protobuf::internal::kEmptyString) {
    leg_security_type_->clear();
  }
  clear_has_leg_security_type();
}
inline const ::std::string& InstrumentLeg::leg_security_type() const {
  return *leg_security_type_;
}
inline void InstrumentLeg::set_leg_security_type(const ::std::string& value) {
  set_has_leg_security_type();
  if (leg_security_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_type_ = new ::std::string;
  }
  leg_security_type_->assign(value);
}
inline void InstrumentLeg::set_leg_security_type(const char* value) {
  set_has_leg_security_type();
  if (leg_security_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_type_ = new ::std::string;
  }
  leg_security_type_->assign(value);
}
inline void InstrumentLeg::set_leg_security_type(const char* value, size_t size) {
  set_has_leg_security_type();
  if (leg_security_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_type_ = new ::std::string;
  }
  leg_security_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_security_type() {
  set_has_leg_security_type();
  if (leg_security_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_type_ = new ::std::string;
  }
  return leg_security_type_;
}
inline ::std::string* InstrumentLeg::release_leg_security_type() {
  clear_has_leg_security_type();
  if (leg_security_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_security_type_;
    leg_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_security_type(::std::string* leg_security_type) {
  if (leg_security_type_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_security_type_;
  }
  if (leg_security_type) {
    set_has_leg_security_type();
    leg_security_type_ = leg_security_type;
  } else {
    clear_has_leg_security_type();
    leg_security_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_side = 32;
inline bool InstrumentLeg::has_leg_side() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_side() {
  _has_bits_[0] |= 0x80000000u;
}
inline void InstrumentLeg::clear_has_leg_side() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void InstrumentLeg::clear_leg_side() {
  if (leg_side_ != &::google::protobuf::internal::kEmptyString) {
    leg_side_->clear();
  }
  clear_has_leg_side();
}
inline const ::std::string& InstrumentLeg::leg_side() const {
  return *leg_side_;
}
inline void InstrumentLeg::set_leg_side(const ::std::string& value) {
  set_has_leg_side();
  if (leg_side_ == &::google::protobuf::internal::kEmptyString) {
    leg_side_ = new ::std::string;
  }
  leg_side_->assign(value);
}
inline void InstrumentLeg::set_leg_side(const char* value) {
  set_has_leg_side();
  if (leg_side_ == &::google::protobuf::internal::kEmptyString) {
    leg_side_ = new ::std::string;
  }
  leg_side_->assign(value);
}
inline void InstrumentLeg::set_leg_side(const char* value, size_t size) {
  set_has_leg_side();
  if (leg_side_ == &::google::protobuf::internal::kEmptyString) {
    leg_side_ = new ::std::string;
  }
  leg_side_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_side() {
  set_has_leg_side();
  if (leg_side_ == &::google::protobuf::internal::kEmptyString) {
    leg_side_ = new ::std::string;
  }
  return leg_side_;
}
inline ::std::string* InstrumentLeg::release_leg_side() {
  clear_has_leg_side();
  if (leg_side_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_side_;
    leg_side_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_side(::std::string* leg_side) {
  if (leg_side_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_side_;
  }
  if (leg_side) {
    set_has_leg_side();
    leg_side_ = leg_side;
  } else {
    clear_has_leg_side();
    leg_side_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_state_or_province_of_issue = 33;
inline bool InstrumentLeg::has_leg_state_or_province_of_issue() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void InstrumentLeg::set_has_leg_state_or_province_of_issue() {
  _has_bits_[1] |= 0x00000001u;
}
inline void InstrumentLeg::clear_has_leg_state_or_province_of_issue() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void InstrumentLeg::clear_leg_state_or_province_of_issue() {
  if (leg_state_or_province_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    leg_state_or_province_of_issue_->clear();
  }
  clear_has_leg_state_or_province_of_issue();
}
inline const ::std::string& InstrumentLeg::leg_state_or_province_of_issue() const {
  return *leg_state_or_province_of_issue_;
}
inline void InstrumentLeg::set_leg_state_or_province_of_issue(const ::std::string& value) {
  set_has_leg_state_or_province_of_issue();
  if (leg_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_state_or_province_of_issue_ = new ::std::string;
  }
  leg_state_or_province_of_issue_->assign(value);
}
inline void InstrumentLeg::set_leg_state_or_province_of_issue(const char* value) {
  set_has_leg_state_or_province_of_issue();
  if (leg_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_state_or_province_of_issue_ = new ::std::string;
  }
  leg_state_or_province_of_issue_->assign(value);
}
inline void InstrumentLeg::set_leg_state_or_province_of_issue(const char* value, size_t size) {
  set_has_leg_state_or_province_of_issue();
  if (leg_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_state_or_province_of_issue_ = new ::std::string;
  }
  leg_state_or_province_of_issue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_state_or_province_of_issue() {
  set_has_leg_state_or_province_of_issue();
  if (leg_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    leg_state_or_province_of_issue_ = new ::std::string;
  }
  return leg_state_or_province_of_issue_;
}
inline ::std::string* InstrumentLeg::release_leg_state_or_province_of_issue() {
  clear_has_leg_state_or_province_of_issue();
  if (leg_state_or_province_of_issue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_state_or_province_of_issue_;
    leg_state_or_province_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_state_or_province_of_issue(::std::string* leg_state_or_province_of_issue) {
  if (leg_state_or_province_of_issue_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_state_or_province_of_issue_;
  }
  if (leg_state_or_province_of_issue) {
    set_has_leg_state_or_province_of_issue();
    leg_state_or_province_of_issue_ = leg_state_or_province_of_issue;
  } else {
    clear_has_leg_state_or_province_of_issue();
    leg_state_or_province_of_issue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 leg_strike_price = 34;
inline bool InstrumentLeg::has_leg_strike_price() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void InstrumentLeg::set_has_leg_strike_price() {
  _has_bits_[1] |= 0x00000002u;
}
inline void InstrumentLeg::clear_has_leg_strike_price() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void InstrumentLeg::clear_leg_strike_price() {
  leg_strike_price_ = GOOGLE_LONGLONG(0);
  clear_has_leg_strike_price();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_strike_price() const {
  return leg_strike_price_;
}
inline void InstrumentLeg::set_leg_strike_price(::google::protobuf::int64 value) {
  set_has_leg_strike_price();
  leg_strike_price_ = value;
}

// optional sfixed32 leg_strike_price_exponent = 35;
inline bool InstrumentLeg::has_leg_strike_price_exponent() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void InstrumentLeg::set_has_leg_strike_price_exponent() {
  _has_bits_[1] |= 0x00000004u;
}
inline void InstrumentLeg::clear_has_leg_strike_price_exponent() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void InstrumentLeg::clear_leg_strike_price_exponent() {
  leg_strike_price_exponent_ = 0;
  clear_has_leg_strike_price_exponent();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_strike_price_exponent() const {
  return leg_strike_price_exponent_;
}
inline void InstrumentLeg::set_leg_strike_price_exponent(::google::protobuf::int32 value) {
  set_has_leg_strike_price_exponent();
  leg_strike_price_exponent_ = value;
}

// optional string leg_symbol = 36;
inline bool InstrumentLeg::has_leg_symbol() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void InstrumentLeg::set_has_leg_symbol() {
  _has_bits_[1] |= 0x00000008u;
}
inline void InstrumentLeg::clear_has_leg_symbol() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void InstrumentLeg::clear_leg_symbol() {
  if (leg_symbol_ != &::google::protobuf::internal::kEmptyString) {
    leg_symbol_->clear();
  }
  clear_has_leg_symbol();
}
inline const ::std::string& InstrumentLeg::leg_symbol() const {
  return *leg_symbol_;
}
inline void InstrumentLeg::set_leg_symbol(const ::std::string& value) {
  set_has_leg_symbol();
  if (leg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    leg_symbol_ = new ::std::string;
  }
  leg_symbol_->assign(value);
}
inline void InstrumentLeg::set_leg_symbol(const char* value) {
  set_has_leg_symbol();
  if (leg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    leg_symbol_ = new ::std::string;
  }
  leg_symbol_->assign(value);
}
inline void InstrumentLeg::set_leg_symbol(const char* value, size_t size) {
  set_has_leg_symbol();
  if (leg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    leg_symbol_ = new ::std::string;
  }
  leg_symbol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_symbol() {
  set_has_leg_symbol();
  if (leg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    leg_symbol_ = new ::std::string;
  }
  return leg_symbol_;
}
inline ::std::string* InstrumentLeg::release_leg_symbol() {
  clear_has_leg_symbol();
  if (leg_symbol_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_symbol_;
    leg_symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_symbol(::std::string* leg_symbol) {
  if (leg_symbol_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_symbol_;
  }
  if (leg_symbol) {
    set_has_leg_symbol();
    leg_symbol_ = leg_symbol;
  } else {
    clear_has_leg_symbol();
    leg_symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_symbol_sfx = 37;
inline bool InstrumentLeg::has_leg_symbol_sfx() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void InstrumentLeg::set_has_leg_symbol_sfx() {
  _has_bits_[1] |= 0x00000010u;
}
inline void InstrumentLeg::clear_has_leg_symbol_sfx() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void InstrumentLeg::clear_leg_symbol_sfx() {
  if (leg_symbol_sfx_ != &::google::protobuf::internal::kEmptyString) {
    leg_symbol_sfx_->clear();
  }
  clear_has_leg_symbol_sfx();
}
inline const ::std::string& InstrumentLeg::leg_symbol_sfx() const {
  return *leg_symbol_sfx_;
}
inline void InstrumentLeg::set_leg_symbol_sfx(const ::std::string& value) {
  set_has_leg_symbol_sfx();
  if (leg_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    leg_symbol_sfx_ = new ::std::string;
  }
  leg_symbol_sfx_->assign(value);
}
inline void InstrumentLeg::set_leg_symbol_sfx(const char* value) {
  set_has_leg_symbol_sfx();
  if (leg_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    leg_symbol_sfx_ = new ::std::string;
  }
  leg_symbol_sfx_->assign(value);
}
inline void InstrumentLeg::set_leg_symbol_sfx(const char* value, size_t size) {
  set_has_leg_symbol_sfx();
  if (leg_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    leg_symbol_sfx_ = new ::std::string;
  }
  leg_symbol_sfx_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_symbol_sfx() {
  set_has_leg_symbol_sfx();
  if (leg_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    leg_symbol_sfx_ = new ::std::string;
  }
  return leg_symbol_sfx_;
}
inline ::std::string* InstrumentLeg::release_leg_symbol_sfx() {
  clear_has_leg_symbol_sfx();
  if (leg_symbol_sfx_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_symbol_sfx_;
    leg_symbol_sfx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_symbol_sfx(::std::string* leg_symbol_sfx) {
  if (leg_symbol_sfx_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_symbol_sfx_;
  }
  if (leg_symbol_sfx) {
    set_has_leg_symbol_sfx();
    leg_symbol_sfx_ = leg_symbol_sfx;
  } else {
    clear_has_leg_symbol_sfx();
    leg_symbol_sfx_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 leg_contract_settl_month = 38;
inline bool InstrumentLeg::has_leg_contract_settl_month() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void InstrumentLeg::set_has_leg_contract_settl_month() {
  _has_bits_[1] |= 0x00000020u;
}
inline void InstrumentLeg::clear_has_leg_contract_settl_month() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void InstrumentLeg::clear_leg_contract_settl_month() {
  leg_contract_settl_month_ = 0;
  clear_has_leg_contract_settl_month();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_contract_settl_month() const {
  return leg_contract_settl_month_;
}
inline void InstrumentLeg::set_leg_contract_settl_month(::google::protobuf::int32 value) {
  set_has_leg_contract_settl_month();
  leg_contract_settl_month_ = value;
}

// optional string leg_currency = 39;
inline bool InstrumentLeg::has_leg_currency() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void InstrumentLeg::set_has_leg_currency() {
  _has_bits_[1] |= 0x00000040u;
}
inline void InstrumentLeg::clear_has_leg_currency() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void InstrumentLeg::clear_leg_currency() {
  if (leg_currency_ != &::google::protobuf::internal::kEmptyString) {
    leg_currency_->clear();
  }
  clear_has_leg_currency();
}
inline const ::std::string& InstrumentLeg::leg_currency() const {
  return *leg_currency_;
}
inline void InstrumentLeg::set_leg_currency(const ::std::string& value) {
  set_has_leg_currency();
  if (leg_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_currency_ = new ::std::string;
  }
  leg_currency_->assign(value);
}
inline void InstrumentLeg::set_leg_currency(const char* value) {
  set_has_leg_currency();
  if (leg_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_currency_ = new ::std::string;
  }
  leg_currency_->assign(value);
}
inline void InstrumentLeg::set_leg_currency(const char* value, size_t size) {
  set_has_leg_currency();
  if (leg_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_currency_ = new ::std::string;
  }
  leg_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_currency() {
  set_has_leg_currency();
  if (leg_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_currency_ = new ::std::string;
  }
  return leg_currency_;
}
inline ::std::string* InstrumentLeg::release_leg_currency() {
  clear_has_leg_currency();
  if (leg_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_currency_;
    leg_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_currency(::std::string* leg_currency) {
  if (leg_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_currency_;
  }
  if (leg_currency) {
    set_has_leg_currency();
    leg_currency_ = leg_currency;
  } else {
    clear_has_leg_currency();
    leg_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 leg_dated_date = 40;
inline bool InstrumentLeg::has_leg_dated_date() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void InstrumentLeg::set_has_leg_dated_date() {
  _has_bits_[1] |= 0x00000080u;
}
inline void InstrumentLeg::clear_has_leg_dated_date() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void InstrumentLeg::clear_leg_dated_date() {
  leg_dated_date_ = 0;
  clear_has_leg_dated_date();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_dated_date() const {
  return leg_dated_date_;
}
inline void InstrumentLeg::set_leg_dated_date(::google::protobuf::int32 value) {
  set_has_leg_dated_date();
  leg_dated_date_ = value;
}

// optional sfixed32 leg_interest_accrual_date = 41;
inline bool InstrumentLeg::has_leg_interest_accrual_date() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void InstrumentLeg::set_has_leg_interest_accrual_date() {
  _has_bits_[1] |= 0x00000100u;
}
inline void InstrumentLeg::clear_has_leg_interest_accrual_date() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void InstrumentLeg::clear_leg_interest_accrual_date() {
  leg_interest_accrual_date_ = 0;
  clear_has_leg_interest_accrual_date();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_interest_accrual_date() const {
  return leg_interest_accrual_date_;
}
inline void InstrumentLeg::set_leg_interest_accrual_date(::google::protobuf::int32 value) {
  set_has_leg_interest_accrual_date();
  leg_interest_accrual_date_ = value;
}

// optional double leg_option_ratio = 42;
inline bool InstrumentLeg::has_leg_option_ratio() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void InstrumentLeg::set_has_leg_option_ratio() {
  _has_bits_[1] |= 0x00000200u;
}
inline void InstrumentLeg::clear_has_leg_option_ratio() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void InstrumentLeg::clear_leg_option_ratio() {
  leg_option_ratio_ = 0;
  clear_has_leg_option_ratio();
}
inline double InstrumentLeg::leg_option_ratio() const {
  return leg_option_ratio_;
}
inline void InstrumentLeg::set_leg_option_ratio(double value) {
  set_has_leg_option_ratio();
  leg_option_ratio_ = value;
}

// optional string leg_pool = 43;
inline bool InstrumentLeg::has_leg_pool() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void InstrumentLeg::set_has_leg_pool() {
  _has_bits_[1] |= 0x00000400u;
}
inline void InstrumentLeg::clear_has_leg_pool() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void InstrumentLeg::clear_leg_pool() {
  if (leg_pool_ != &::google::protobuf::internal::kEmptyString) {
    leg_pool_->clear();
  }
  clear_has_leg_pool();
}
inline const ::std::string& InstrumentLeg::leg_pool() const {
  return *leg_pool_;
}
inline void InstrumentLeg::set_leg_pool(const ::std::string& value) {
  set_has_leg_pool();
  if (leg_pool_ == &::google::protobuf::internal::kEmptyString) {
    leg_pool_ = new ::std::string;
  }
  leg_pool_->assign(value);
}
inline void InstrumentLeg::set_leg_pool(const char* value) {
  set_has_leg_pool();
  if (leg_pool_ == &::google::protobuf::internal::kEmptyString) {
    leg_pool_ = new ::std::string;
  }
  leg_pool_->assign(value);
}
inline void InstrumentLeg::set_leg_pool(const char* value, size_t size) {
  set_has_leg_pool();
  if (leg_pool_ == &::google::protobuf::internal::kEmptyString) {
    leg_pool_ = new ::std::string;
  }
  leg_pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_pool() {
  set_has_leg_pool();
  if (leg_pool_ == &::google::protobuf::internal::kEmptyString) {
    leg_pool_ = new ::std::string;
  }
  return leg_pool_;
}
inline ::std::string* InstrumentLeg::release_leg_pool() {
  clear_has_leg_pool();
  if (leg_pool_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_pool_;
    leg_pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_pool(::std::string* leg_pool) {
  if (leg_pool_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_pool_;
  }
  if (leg_pool) {
    set_has_leg_pool();
    leg_pool_ = leg_pool;
  } else {
    clear_has_leg_pool();
    leg_pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 leg_price = 44;
inline bool InstrumentLeg::has_leg_price() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void InstrumentLeg::set_has_leg_price() {
  _has_bits_[1] |= 0x00000800u;
}
inline void InstrumentLeg::clear_has_leg_price() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void InstrumentLeg::clear_leg_price() {
  leg_price_ = GOOGLE_LONGLONG(0);
  clear_has_leg_price();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_price() const {
  return leg_price_;
}
inline void InstrumentLeg::set_leg_price(::google::protobuf::int64 value) {
  set_has_leg_price();
  leg_price_ = value;
}

// optional sfixed32 leg_price_exponent = 45;
inline bool InstrumentLeg::has_leg_price_exponent() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void InstrumentLeg::set_has_leg_price_exponent() {
  _has_bits_[1] |= 0x00001000u;
}
inline void InstrumentLeg::clear_has_leg_price_exponent() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void InstrumentLeg::clear_leg_price_exponent() {
  leg_price_exponent_ = 0;
  clear_has_leg_price_exponent();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_price_exponent() const {
  return leg_price_exponent_;
}
inline void InstrumentLeg::set_leg_price_exponent(::google::protobuf::int32 value) {
  set_has_leg_price_exponent();
  leg_price_exponent_ = value;
}

// repeated .Common.LegSecAltIdGrp leg_sec_alt_id_grp = 46;
inline int InstrumentLeg::leg_sec_alt_id_grp_size() const {
  return leg_sec_alt_id_grp_.size();
}
inline void InstrumentLeg::clear_leg_sec_alt_id_grp() {
  leg_sec_alt_id_grp_.Clear();
}
inline const ::Common::LegSecAltIdGrp& InstrumentLeg::leg_sec_alt_id_grp(int index) const {
  return leg_sec_alt_id_grp_.Get(index);
}
inline ::Common::LegSecAltIdGrp* InstrumentLeg::mutable_leg_sec_alt_id_grp(int index) {
  return leg_sec_alt_id_grp_.Mutable(index);
}
inline ::Common::LegSecAltIdGrp* InstrumentLeg::add_leg_sec_alt_id_grp() {
  return leg_sec_alt_id_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::LegSecAltIdGrp >&
InstrumentLeg::leg_sec_alt_id_grp() const {
  return leg_sec_alt_id_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::LegSecAltIdGrp >*
InstrumentLeg::mutable_leg_sec_alt_id_grp() {
  return &leg_sec_alt_id_grp_;
}

// optional string leg_security_sub_type = 47;
inline bool InstrumentLeg::has_leg_security_sub_type() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void InstrumentLeg::set_has_leg_security_sub_type() {
  _has_bits_[1] |= 0x00004000u;
}
inline void InstrumentLeg::clear_has_leg_security_sub_type() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void InstrumentLeg::clear_leg_security_sub_type() {
  if (leg_security_sub_type_ != &::google::protobuf::internal::kEmptyString) {
    leg_security_sub_type_->clear();
  }
  clear_has_leg_security_sub_type();
}
inline const ::std::string& InstrumentLeg::leg_security_sub_type() const {
  return *leg_security_sub_type_;
}
inline void InstrumentLeg::set_leg_security_sub_type(const ::std::string& value) {
  set_has_leg_security_sub_type();
  if (leg_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_sub_type_ = new ::std::string;
  }
  leg_security_sub_type_->assign(value);
}
inline void InstrumentLeg::set_leg_security_sub_type(const char* value) {
  set_has_leg_security_sub_type();
  if (leg_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_sub_type_ = new ::std::string;
  }
  leg_security_sub_type_->assign(value);
}
inline void InstrumentLeg::set_leg_security_sub_type(const char* value, size_t size) {
  set_has_leg_security_sub_type();
  if (leg_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_sub_type_ = new ::std::string;
  }
  leg_security_sub_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_security_sub_type() {
  set_has_leg_security_sub_type();
  if (leg_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_security_sub_type_ = new ::std::string;
  }
  return leg_security_sub_type_;
}
inline ::std::string* InstrumentLeg::release_leg_security_sub_type() {
  clear_has_leg_security_sub_type();
  if (leg_security_sub_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_security_sub_type_;
    leg_security_sub_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_security_sub_type(::std::string* leg_security_sub_type) {
  if (leg_security_sub_type_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_security_sub_type_;
  }
  if (leg_security_sub_type) {
    set_has_leg_security_sub_type();
    leg_security_sub_type_ = leg_security_sub_type;
  } else {
    clear_has_leg_security_sub_type();
    leg_security_sub_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_strike_currency = 48;
inline bool InstrumentLeg::has_leg_strike_currency() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void InstrumentLeg::set_has_leg_strike_currency() {
  _has_bits_[1] |= 0x00008000u;
}
inline void InstrumentLeg::clear_has_leg_strike_currency() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void InstrumentLeg::clear_leg_strike_currency() {
  if (leg_strike_currency_ != &::google::protobuf::internal::kEmptyString) {
    leg_strike_currency_->clear();
  }
  clear_has_leg_strike_currency();
}
inline const ::std::string& InstrumentLeg::leg_strike_currency() const {
  return *leg_strike_currency_;
}
inline void InstrumentLeg::set_leg_strike_currency(const ::std::string& value) {
  set_has_leg_strike_currency();
  if (leg_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_strike_currency_ = new ::std::string;
  }
  leg_strike_currency_->assign(value);
}
inline void InstrumentLeg::set_leg_strike_currency(const char* value) {
  set_has_leg_strike_currency();
  if (leg_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_strike_currency_ = new ::std::string;
  }
  leg_strike_currency_->assign(value);
}
inline void InstrumentLeg::set_leg_strike_currency(const char* value, size_t size) {
  set_has_leg_strike_currency();
  if (leg_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_strike_currency_ = new ::std::string;
  }
  leg_strike_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_strike_currency() {
  set_has_leg_strike_currency();
  if (leg_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_strike_currency_ = new ::std::string;
  }
  return leg_strike_currency_;
}
inline ::std::string* InstrumentLeg::release_leg_strike_currency() {
  clear_has_leg_strike_currency();
  if (leg_strike_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_strike_currency_;
    leg_strike_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_strike_currency(::std::string* leg_strike_currency) {
  if (leg_strike_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_strike_currency_;
  }
  if (leg_strike_currency) {
    set_has_leg_strike_currency();
    leg_strike_currency_ = leg_strike_currency;
  } else {
    clear_has_leg_strike_currency();
    leg_strike_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_time_unit = 49;
inline bool InstrumentLeg::has_leg_time_unit() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void InstrumentLeg::set_has_leg_time_unit() {
  _has_bits_[1] |= 0x00010000u;
}
inline void InstrumentLeg::clear_has_leg_time_unit() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void InstrumentLeg::clear_leg_time_unit() {
  if (leg_time_unit_ != &::google::protobuf::internal::kEmptyString) {
    leg_time_unit_->clear();
  }
  clear_has_leg_time_unit();
}
inline const ::std::string& InstrumentLeg::leg_time_unit() const {
  return *leg_time_unit_;
}
inline void InstrumentLeg::set_leg_time_unit(const ::std::string& value) {
  set_has_leg_time_unit();
  if (leg_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    leg_time_unit_ = new ::std::string;
  }
  leg_time_unit_->assign(value);
}
inline void InstrumentLeg::set_leg_time_unit(const char* value) {
  set_has_leg_time_unit();
  if (leg_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    leg_time_unit_ = new ::std::string;
  }
  leg_time_unit_->assign(value);
}
inline void InstrumentLeg::set_leg_time_unit(const char* value, size_t size) {
  set_has_leg_time_unit();
  if (leg_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    leg_time_unit_ = new ::std::string;
  }
  leg_time_unit_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_time_unit() {
  set_has_leg_time_unit();
  if (leg_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    leg_time_unit_ = new ::std::string;
  }
  return leg_time_unit_;
}
inline ::std::string* InstrumentLeg::release_leg_time_unit() {
  clear_has_leg_time_unit();
  if (leg_time_unit_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_time_unit_;
    leg_time_unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_time_unit(::std::string* leg_time_unit) {
  if (leg_time_unit_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_time_unit_;
  }
  if (leg_time_unit) {
    set_has_leg_time_unit();
    leg_time_unit_ = leg_time_unit;
  } else {
    clear_has_leg_time_unit();
    leg_time_unit_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_unit_of_measure = 50;
inline bool InstrumentLeg::has_leg_unit_of_measure() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void InstrumentLeg::set_has_leg_unit_of_measure() {
  _has_bits_[1] |= 0x00020000u;
}
inline void InstrumentLeg::clear_has_leg_unit_of_measure() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void InstrumentLeg::clear_leg_unit_of_measure() {
  if (leg_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    leg_unit_of_measure_->clear();
  }
  clear_has_leg_unit_of_measure();
}
inline const ::std::string& InstrumentLeg::leg_unit_of_measure() const {
  return *leg_unit_of_measure_;
}
inline void InstrumentLeg::set_leg_unit_of_measure(const ::std::string& value) {
  set_has_leg_unit_of_measure();
  if (leg_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    leg_unit_of_measure_ = new ::std::string;
  }
  leg_unit_of_measure_->assign(value);
}
inline void InstrumentLeg::set_leg_unit_of_measure(const char* value) {
  set_has_leg_unit_of_measure();
  if (leg_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    leg_unit_of_measure_ = new ::std::string;
  }
  leg_unit_of_measure_->assign(value);
}
inline void InstrumentLeg::set_leg_unit_of_measure(const char* value, size_t size) {
  set_has_leg_unit_of_measure();
  if (leg_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    leg_unit_of_measure_ = new ::std::string;
  }
  leg_unit_of_measure_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_unit_of_measure() {
  set_has_leg_unit_of_measure();
  if (leg_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    leg_unit_of_measure_ = new ::std::string;
  }
  return leg_unit_of_measure_;
}
inline ::std::string* InstrumentLeg::release_leg_unit_of_measure() {
  clear_has_leg_unit_of_measure();
  if (leg_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_unit_of_measure_;
    leg_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_unit_of_measure(::std::string* leg_unit_of_measure) {
  if (leg_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_unit_of_measure_;
  }
  if (leg_unit_of_measure) {
    set_has_leg_unit_of_measure();
    leg_unit_of_measure_ = leg_unit_of_measure;
  } else {
    clear_has_leg_unit_of_measure();
    leg_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 leg_exercise_style = 51;
inline bool InstrumentLeg::has_leg_exercise_style() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void InstrumentLeg::set_has_leg_exercise_style() {
  _has_bits_[1] |= 0x00040000u;
}
inline void InstrumentLeg::clear_has_leg_exercise_style() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void InstrumentLeg::clear_leg_exercise_style() {
  leg_exercise_style_ = GOOGLE_LONGLONG(0);
  clear_has_leg_exercise_style();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_exercise_style() const {
  return leg_exercise_style_;
}
inline void InstrumentLeg::set_leg_exercise_style(::google::protobuf::int64 value) {
  set_has_leg_exercise_style();
  leg_exercise_style_ = value;
}

// optional string leg_maturity_time = 52;
inline bool InstrumentLeg::has_leg_maturity_time() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void InstrumentLeg::set_has_leg_maturity_time() {
  _has_bits_[1] |= 0x00080000u;
}
inline void InstrumentLeg::clear_has_leg_maturity_time() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void InstrumentLeg::clear_leg_maturity_time() {
  if (leg_maturity_time_ != &::google::protobuf::internal::kEmptyString) {
    leg_maturity_time_->clear();
  }
  clear_has_leg_maturity_time();
}
inline const ::std::string& InstrumentLeg::leg_maturity_time() const {
  return *leg_maturity_time_;
}
inline void InstrumentLeg::set_leg_maturity_time(const ::std::string& value) {
  set_has_leg_maturity_time();
  if (leg_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    leg_maturity_time_ = new ::std::string;
  }
  leg_maturity_time_->assign(value);
}
inline void InstrumentLeg::set_leg_maturity_time(const char* value) {
  set_has_leg_maturity_time();
  if (leg_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    leg_maturity_time_ = new ::std::string;
  }
  leg_maturity_time_->assign(value);
}
inline void InstrumentLeg::set_leg_maturity_time(const char* value, size_t size) {
  set_has_leg_maturity_time();
  if (leg_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    leg_maturity_time_ = new ::std::string;
  }
  leg_maturity_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_maturity_time() {
  set_has_leg_maturity_time();
  if (leg_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    leg_maturity_time_ = new ::std::string;
  }
  return leg_maturity_time_;
}
inline ::std::string* InstrumentLeg::release_leg_maturity_time() {
  clear_has_leg_maturity_time();
  if (leg_maturity_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_maturity_time_;
    leg_maturity_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_maturity_time(::std::string* leg_maturity_time) {
  if (leg_maturity_time_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_maturity_time_;
  }
  if (leg_maturity_time) {
    set_has_leg_maturity_time();
    leg_maturity_time_ = leg_maturity_time;
  } else {
    clear_has_leg_maturity_time();
    leg_maturity_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_price_unit_of_measure = 53;
inline bool InstrumentLeg::has_leg_price_unit_of_measure() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void InstrumentLeg::set_has_leg_price_unit_of_measure() {
  _has_bits_[1] |= 0x00100000u;
}
inline void InstrumentLeg::clear_has_leg_price_unit_of_measure() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void InstrumentLeg::clear_leg_price_unit_of_measure() {
  if (leg_price_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    leg_price_unit_of_measure_->clear();
  }
  clear_has_leg_price_unit_of_measure();
}
inline const ::std::string& InstrumentLeg::leg_price_unit_of_measure() const {
  return *leg_price_unit_of_measure_;
}
inline void InstrumentLeg::set_leg_price_unit_of_measure(const ::std::string& value) {
  set_has_leg_price_unit_of_measure();
  if (leg_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    leg_price_unit_of_measure_ = new ::std::string;
  }
  leg_price_unit_of_measure_->assign(value);
}
inline void InstrumentLeg::set_leg_price_unit_of_measure(const char* value) {
  set_has_leg_price_unit_of_measure();
  if (leg_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    leg_price_unit_of_measure_ = new ::std::string;
  }
  leg_price_unit_of_measure_->assign(value);
}
inline void InstrumentLeg::set_leg_price_unit_of_measure(const char* value, size_t size) {
  set_has_leg_price_unit_of_measure();
  if (leg_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    leg_price_unit_of_measure_ = new ::std::string;
  }
  leg_price_unit_of_measure_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrumentLeg::mutable_leg_price_unit_of_measure() {
  set_has_leg_price_unit_of_measure();
  if (leg_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    leg_price_unit_of_measure_ = new ::std::string;
  }
  return leg_price_unit_of_measure_;
}
inline ::std::string* InstrumentLeg::release_leg_price_unit_of_measure() {
  clear_has_leg_price_unit_of_measure();
  if (leg_price_unit_of_measure_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_price_unit_of_measure_;
    leg_price_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrumentLeg::set_allocated_leg_price_unit_of_measure(::std::string* leg_price_unit_of_measure) {
  if (leg_price_unit_of_measure_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_price_unit_of_measure_;
  }
  if (leg_price_unit_of_measure) {
    set_has_leg_price_unit_of_measure();
    leg_price_unit_of_measure_ = leg_price_unit_of_measure;
  } else {
    clear_has_leg_price_unit_of_measure();
    leg_price_unit_of_measure_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 leg_price_unit_of_measure_qty = 54;
inline bool InstrumentLeg::has_leg_price_unit_of_measure_qty() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void InstrumentLeg::set_has_leg_price_unit_of_measure_qty() {
  _has_bits_[1] |= 0x00200000u;
}
inline void InstrumentLeg::clear_has_leg_price_unit_of_measure_qty() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void InstrumentLeg::clear_leg_price_unit_of_measure_qty() {
  leg_price_unit_of_measure_qty_ = GOOGLE_LONGLONG(0);
  clear_has_leg_price_unit_of_measure_qty();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_price_unit_of_measure_qty() const {
  return leg_price_unit_of_measure_qty_;
}
inline void InstrumentLeg::set_leg_price_unit_of_measure_qty(::google::protobuf::int64 value) {
  set_has_leg_price_unit_of_measure_qty();
  leg_price_unit_of_measure_qty_ = value;
}

// optional sfixed32 leg_price_unit_of_measure_qty_exponent = 55;
inline bool InstrumentLeg::has_leg_price_unit_of_measure_qty_exponent() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void InstrumentLeg::set_has_leg_price_unit_of_measure_qty_exponent() {
  _has_bits_[1] |= 0x00400000u;
}
inline void InstrumentLeg::clear_has_leg_price_unit_of_measure_qty_exponent() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void InstrumentLeg::clear_leg_price_unit_of_measure_qty_exponent() {
  leg_price_unit_of_measure_qty_exponent_ = 0;
  clear_has_leg_price_unit_of_measure_qty_exponent();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_price_unit_of_measure_qty_exponent() const {
  return leg_price_unit_of_measure_qty_exponent_;
}
inline void InstrumentLeg::set_leg_price_unit_of_measure_qty_exponent(::google::protobuf::int32 value) {
  set_has_leg_price_unit_of_measure_qty_exponent();
  leg_price_unit_of_measure_qty_exponent_ = value;
}

// optional sfixed64 leg_put_or_call = 56;
inline bool InstrumentLeg::has_leg_put_or_call() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void InstrumentLeg::set_has_leg_put_or_call() {
  _has_bits_[1] |= 0x00800000u;
}
inline void InstrumentLeg::clear_has_leg_put_or_call() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void InstrumentLeg::clear_leg_put_or_call() {
  leg_put_or_call_ = GOOGLE_LONGLONG(0);
  clear_has_leg_put_or_call();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_put_or_call() const {
  return leg_put_or_call_;
}
inline void InstrumentLeg::set_leg_put_or_call(::google::protobuf::int64 value) {
  set_has_leg_put_or_call();
  leg_put_or_call_ = value;
}

// optional sfixed64 leg_unit_of_measure_qty = 57;
inline bool InstrumentLeg::has_leg_unit_of_measure_qty() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_unit_of_measure_qty() {
  _has_bits_[1] |= 0x01000000u;
}
inline void InstrumentLeg::clear_has_leg_unit_of_measure_qty() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void InstrumentLeg::clear_leg_unit_of_measure_qty() {
  leg_unit_of_measure_qty_ = GOOGLE_LONGLONG(0);
  clear_has_leg_unit_of_measure_qty();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_unit_of_measure_qty() const {
  return leg_unit_of_measure_qty_;
}
inline void InstrumentLeg::set_leg_unit_of_measure_qty(::google::protobuf::int64 value) {
  set_has_leg_unit_of_measure_qty();
  leg_unit_of_measure_qty_ = value;
}

// optional sfixed32 leg_unit_of_measure_qty_exponent = 58;
inline bool InstrumentLeg::has_leg_unit_of_measure_qty_exponent() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_unit_of_measure_qty_exponent() {
  _has_bits_[1] |= 0x02000000u;
}
inline void InstrumentLeg::clear_has_leg_unit_of_measure_qty_exponent() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void InstrumentLeg::clear_leg_unit_of_measure_qty_exponent() {
  leg_unit_of_measure_qty_exponent_ = 0;
  clear_has_leg_unit_of_measure_qty_exponent();
}
inline ::google::protobuf::int32 InstrumentLeg::leg_unit_of_measure_qty_exponent() const {
  return leg_unit_of_measure_qty_exponent_;
}
inline void InstrumentLeg::set_leg_unit_of_measure_qty_exponent(::google::protobuf::int32 value) {
  set_has_leg_unit_of_measure_qty_exponent();
  leg_unit_of_measure_qty_exponent_ = value;
}

// optional sfixed64 leg_contract_multiplier_unit = 59;
inline bool InstrumentLeg::has_leg_contract_multiplier_unit() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_contract_multiplier_unit() {
  _has_bits_[1] |= 0x04000000u;
}
inline void InstrumentLeg::clear_has_leg_contract_multiplier_unit() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void InstrumentLeg::clear_leg_contract_multiplier_unit() {
  leg_contract_multiplier_unit_ = GOOGLE_LONGLONG(0);
  clear_has_leg_contract_multiplier_unit();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_contract_multiplier_unit() const {
  return leg_contract_multiplier_unit_;
}
inline void InstrumentLeg::set_leg_contract_multiplier_unit(::google::protobuf::int64 value) {
  set_has_leg_contract_multiplier_unit();
  leg_contract_multiplier_unit_ = value;
}

// optional sfixed64 leg_flow_schedule_type = 60;
inline bool InstrumentLeg::has_leg_flow_schedule_type() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void InstrumentLeg::set_has_leg_flow_schedule_type() {
  _has_bits_[1] |= 0x08000000u;
}
inline void InstrumentLeg::clear_has_leg_flow_schedule_type() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void InstrumentLeg::clear_leg_flow_schedule_type() {
  leg_flow_schedule_type_ = GOOGLE_LONGLONG(0);
  clear_has_leg_flow_schedule_type();
}
inline ::google::protobuf::int64 InstrumentLeg::leg_flow_schedule_type() const {
  return leg_flow_schedule_type_;
}
inline void InstrumentLeg::set_leg_flow_schedule_type(::google::protobuf::int64 value) {
  set_has_leg_flow_schedule_type();
  leg_flow_schedule_type_ = value;
}

// -------------------------------------------------------------------

// LegStipulations

// optional string leg_stipulation_type = 1;
inline bool LegStipulations::has_leg_stipulation_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegStipulations::set_has_leg_stipulation_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegStipulations::clear_has_leg_stipulation_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegStipulations::clear_leg_stipulation_type() {
  if (leg_stipulation_type_ != &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_type_->clear();
  }
  clear_has_leg_stipulation_type();
}
inline const ::std::string& LegStipulations::leg_stipulation_type() const {
  return *leg_stipulation_type_;
}
inline void LegStipulations::set_leg_stipulation_type(const ::std::string& value) {
  set_has_leg_stipulation_type();
  if (leg_stipulation_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_type_ = new ::std::string;
  }
  leg_stipulation_type_->assign(value);
}
inline void LegStipulations::set_leg_stipulation_type(const char* value) {
  set_has_leg_stipulation_type();
  if (leg_stipulation_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_type_ = new ::std::string;
  }
  leg_stipulation_type_->assign(value);
}
inline void LegStipulations::set_leg_stipulation_type(const char* value, size_t size) {
  set_has_leg_stipulation_type();
  if (leg_stipulation_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_type_ = new ::std::string;
  }
  leg_stipulation_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegStipulations::mutable_leg_stipulation_type() {
  set_has_leg_stipulation_type();
  if (leg_stipulation_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_type_ = new ::std::string;
  }
  return leg_stipulation_type_;
}
inline ::std::string* LegStipulations::release_leg_stipulation_type() {
  clear_has_leg_stipulation_type();
  if (leg_stipulation_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_stipulation_type_;
    leg_stipulation_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegStipulations::set_allocated_leg_stipulation_type(::std::string* leg_stipulation_type) {
  if (leg_stipulation_type_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_stipulation_type_;
  }
  if (leg_stipulation_type) {
    set_has_leg_stipulation_type();
    leg_stipulation_type_ = leg_stipulation_type;
  } else {
    clear_has_leg_stipulation_type();
    leg_stipulation_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_stipulation_value = 2;
inline bool LegStipulations::has_leg_stipulation_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegStipulations::set_has_leg_stipulation_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegStipulations::clear_has_leg_stipulation_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegStipulations::clear_leg_stipulation_value() {
  if (leg_stipulation_value_ != &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_value_->clear();
  }
  clear_has_leg_stipulation_value();
}
inline const ::std::string& LegStipulations::leg_stipulation_value() const {
  return *leg_stipulation_value_;
}
inline void LegStipulations::set_leg_stipulation_value(const ::std::string& value) {
  set_has_leg_stipulation_value();
  if (leg_stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_value_ = new ::std::string;
  }
  leg_stipulation_value_->assign(value);
}
inline void LegStipulations::set_leg_stipulation_value(const char* value) {
  set_has_leg_stipulation_value();
  if (leg_stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_value_ = new ::std::string;
  }
  leg_stipulation_value_->assign(value);
}
inline void LegStipulations::set_leg_stipulation_value(const char* value, size_t size) {
  set_has_leg_stipulation_value();
  if (leg_stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_value_ = new ::std::string;
  }
  leg_stipulation_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegStipulations::mutable_leg_stipulation_value() {
  set_has_leg_stipulation_value();
  if (leg_stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    leg_stipulation_value_ = new ::std::string;
  }
  return leg_stipulation_value_;
}
inline ::std::string* LegStipulations::release_leg_stipulation_value() {
  clear_has_leg_stipulation_value();
  if (leg_stipulation_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_stipulation_value_;
    leg_stipulation_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegStipulations::set_allocated_leg_stipulation_value(::std::string* leg_stipulation_value) {
  if (leg_stipulation_value_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_stipulation_value_;
  }
  if (leg_stipulation_value) {
    set_has_leg_stipulation_value();
    leg_stipulation_value_ = leg_stipulation_value;
  } else {
    clear_has_leg_stipulation_value();
    leg_stipulation_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NstdPtys2SubGrp

// optional string nested2party_sub_id = 1;
inline bool NstdPtys2SubGrp::has_nested2party_sub_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NstdPtys2SubGrp::set_has_nested2party_sub_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NstdPtys2SubGrp::clear_has_nested2party_sub_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NstdPtys2SubGrp::clear_nested2party_sub_id() {
  if (nested2party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    nested2party_sub_id_->clear();
  }
  clear_has_nested2party_sub_id();
}
inline const ::std::string& NstdPtys2SubGrp::nested2party_sub_id() const {
  return *nested2party_sub_id_;
}
inline void NstdPtys2SubGrp::set_nested2party_sub_id(const ::std::string& value) {
  set_has_nested2party_sub_id();
  if (nested2party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_sub_id_ = new ::std::string;
  }
  nested2party_sub_id_->assign(value);
}
inline void NstdPtys2SubGrp::set_nested2party_sub_id(const char* value) {
  set_has_nested2party_sub_id();
  if (nested2party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_sub_id_ = new ::std::string;
  }
  nested2party_sub_id_->assign(value);
}
inline void NstdPtys2SubGrp::set_nested2party_sub_id(const char* value, size_t size) {
  set_has_nested2party_sub_id();
  if (nested2party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_sub_id_ = new ::std::string;
  }
  nested2party_sub_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NstdPtys2SubGrp::mutable_nested2party_sub_id() {
  set_has_nested2party_sub_id();
  if (nested2party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_sub_id_ = new ::std::string;
  }
  return nested2party_sub_id_;
}
inline ::std::string* NstdPtys2SubGrp::release_nested2party_sub_id() {
  clear_has_nested2party_sub_id();
  if (nested2party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested2party_sub_id_;
    nested2party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NstdPtys2SubGrp::set_allocated_nested2party_sub_id(::std::string* nested2party_sub_id) {
  if (nested2party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    delete nested2party_sub_id_;
  }
  if (nested2party_sub_id) {
    set_has_nested2party_sub_id();
    nested2party_sub_id_ = nested2party_sub_id;
  } else {
    clear_has_nested2party_sub_id();
    nested2party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 nested2party_sub_id_type = 2;
inline bool NstdPtys2SubGrp::has_nested2party_sub_id_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NstdPtys2SubGrp::set_has_nested2party_sub_id_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NstdPtys2SubGrp::clear_has_nested2party_sub_id_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NstdPtys2SubGrp::clear_nested2party_sub_id_type() {
  nested2party_sub_id_type_ = GOOGLE_LONGLONG(0);
  clear_has_nested2party_sub_id_type();
}
inline ::google::protobuf::int64 NstdPtys2SubGrp::nested2party_sub_id_type() const {
  return nested2party_sub_id_type_;
}
inline void NstdPtys2SubGrp::set_nested2party_sub_id_type(::google::protobuf::int64 value) {
  set_has_nested2party_sub_id_type();
  nested2party_sub_id_type_ = value;
}

// -------------------------------------------------------------------

// NestedParties2

// optional string nested2party_id = 1;
inline bool NestedParties2::has_nested2party_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NestedParties2::set_has_nested2party_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NestedParties2::clear_has_nested2party_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NestedParties2::clear_nested2party_id() {
  if (nested2party_id_ != &::google::protobuf::internal::kEmptyString) {
    nested2party_id_->clear();
  }
  clear_has_nested2party_id();
}
inline const ::std::string& NestedParties2::nested2party_id() const {
  return *nested2party_id_;
}
inline void NestedParties2::set_nested2party_id(const ::std::string& value) {
  set_has_nested2party_id();
  if (nested2party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_id_ = new ::std::string;
  }
  nested2party_id_->assign(value);
}
inline void NestedParties2::set_nested2party_id(const char* value) {
  set_has_nested2party_id();
  if (nested2party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_id_ = new ::std::string;
  }
  nested2party_id_->assign(value);
}
inline void NestedParties2::set_nested2party_id(const char* value, size_t size) {
  set_has_nested2party_id();
  if (nested2party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_id_ = new ::std::string;
  }
  nested2party_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NestedParties2::mutable_nested2party_id() {
  set_has_nested2party_id();
  if (nested2party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_id_ = new ::std::string;
  }
  return nested2party_id_;
}
inline ::std::string* NestedParties2::release_nested2party_id() {
  clear_has_nested2party_id();
  if (nested2party_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested2party_id_;
    nested2party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NestedParties2::set_allocated_nested2party_id(::std::string* nested2party_id) {
  if (nested2party_id_ != &::google::protobuf::internal::kEmptyString) {
    delete nested2party_id_;
  }
  if (nested2party_id) {
    set_has_nested2party_id();
    nested2party_id_ = nested2party_id;
  } else {
    clear_has_nested2party_id();
    nested2party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nested2party_id_source = 2;
inline bool NestedParties2::has_nested2party_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NestedParties2::set_has_nested2party_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NestedParties2::clear_has_nested2party_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NestedParties2::clear_nested2party_id_source() {
  if (nested2party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    nested2party_id_source_->clear();
  }
  clear_has_nested2party_id_source();
}
inline const ::std::string& NestedParties2::nested2party_id_source() const {
  return *nested2party_id_source_;
}
inline void NestedParties2::set_nested2party_id_source(const ::std::string& value) {
  set_has_nested2party_id_source();
  if (nested2party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_id_source_ = new ::std::string;
  }
  nested2party_id_source_->assign(value);
}
inline void NestedParties2::set_nested2party_id_source(const char* value) {
  set_has_nested2party_id_source();
  if (nested2party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_id_source_ = new ::std::string;
  }
  nested2party_id_source_->assign(value);
}
inline void NestedParties2::set_nested2party_id_source(const char* value, size_t size) {
  set_has_nested2party_id_source();
  if (nested2party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_id_source_ = new ::std::string;
  }
  nested2party_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NestedParties2::mutable_nested2party_id_source() {
  set_has_nested2party_id_source();
  if (nested2party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested2party_id_source_ = new ::std::string;
  }
  return nested2party_id_source_;
}
inline ::std::string* NestedParties2::release_nested2party_id_source() {
  clear_has_nested2party_id_source();
  if (nested2party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested2party_id_source_;
    nested2party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NestedParties2::set_allocated_nested2party_id_source(::std::string* nested2party_id_source) {
  if (nested2party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete nested2party_id_source_;
  }
  if (nested2party_id_source) {
    set_has_nested2party_id_source();
    nested2party_id_source_ = nested2party_id_source;
  } else {
    clear_has_nested2party_id_source();
    nested2party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 nested2party_role = 3;
inline bool NestedParties2::has_nested2party_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NestedParties2::set_has_nested2party_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NestedParties2::clear_has_nested2party_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NestedParties2::clear_nested2party_role() {
  nested2party_role_ = GOOGLE_LONGLONG(0);
  clear_has_nested2party_role();
}
inline ::google::protobuf::int64 NestedParties2::nested2party_role() const {
  return nested2party_role_;
}
inline void NestedParties2::set_nested2party_role(::google::protobuf::int64 value) {
  set_has_nested2party_role();
  nested2party_role_ = value;
}

// repeated .Common.NstdPtys2SubGrp nstd_ptys2sub_grp = 4;
inline int NestedParties2::nstd_ptys2sub_grp_size() const {
  return nstd_ptys2sub_grp_.size();
}
inline void NestedParties2::clear_nstd_ptys2sub_grp() {
  nstd_ptys2sub_grp_.Clear();
}
inline const ::Common::NstdPtys2SubGrp& NestedParties2::nstd_ptys2sub_grp(int index) const {
  return nstd_ptys2sub_grp_.Get(index);
}
inline ::Common::NstdPtys2SubGrp* NestedParties2::mutable_nstd_ptys2sub_grp(int index) {
  return nstd_ptys2sub_grp_.Mutable(index);
}
inline ::Common::NstdPtys2SubGrp* NestedParties2::add_nstd_ptys2sub_grp() {
  return nstd_ptys2sub_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys2SubGrp >&
NestedParties2::nstd_ptys2sub_grp() const {
  return nstd_ptys2sub_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys2SubGrp >*
NestedParties2::mutable_nstd_ptys2sub_grp() {
  return &nstd_ptys2sub_grp_;
}

// -------------------------------------------------------------------

// LegPreAllocGrp

// optional string leg_alloc_account = 1;
inline bool LegPreAllocGrp::has_leg_alloc_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegPreAllocGrp::set_has_leg_alloc_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegPreAllocGrp::clear_has_leg_alloc_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegPreAllocGrp::clear_leg_alloc_account() {
  if (leg_alloc_account_ != &::google::protobuf::internal::kEmptyString) {
    leg_alloc_account_->clear();
  }
  clear_has_leg_alloc_account();
}
inline const ::std::string& LegPreAllocGrp::leg_alloc_account() const {
  return *leg_alloc_account_;
}
inline void LegPreAllocGrp::set_leg_alloc_account(const ::std::string& value) {
  set_has_leg_alloc_account();
  if (leg_alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_account_ = new ::std::string;
  }
  leg_alloc_account_->assign(value);
}
inline void LegPreAllocGrp::set_leg_alloc_account(const char* value) {
  set_has_leg_alloc_account();
  if (leg_alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_account_ = new ::std::string;
  }
  leg_alloc_account_->assign(value);
}
inline void LegPreAllocGrp::set_leg_alloc_account(const char* value, size_t size) {
  set_has_leg_alloc_account();
  if (leg_alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_account_ = new ::std::string;
  }
  leg_alloc_account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegPreAllocGrp::mutable_leg_alloc_account() {
  set_has_leg_alloc_account();
  if (leg_alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_account_ = new ::std::string;
  }
  return leg_alloc_account_;
}
inline ::std::string* LegPreAllocGrp::release_leg_alloc_account() {
  clear_has_leg_alloc_account();
  if (leg_alloc_account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_alloc_account_;
    leg_alloc_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegPreAllocGrp::set_allocated_leg_alloc_account(::std::string* leg_alloc_account) {
  if (leg_alloc_account_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_alloc_account_;
  }
  if (leg_alloc_account) {
    set_has_leg_alloc_account();
    leg_alloc_account_ = leg_alloc_account;
  } else {
    clear_has_leg_alloc_account();
    leg_alloc_account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_alloc_acct_id_source = 2;
inline bool LegPreAllocGrp::has_leg_alloc_acct_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegPreAllocGrp::set_has_leg_alloc_acct_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegPreAllocGrp::clear_has_leg_alloc_acct_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegPreAllocGrp::clear_leg_alloc_acct_id_source() {
  if (leg_alloc_acct_id_source_ != &::google::protobuf::internal::kEmptyString) {
    leg_alloc_acct_id_source_->clear();
  }
  clear_has_leg_alloc_acct_id_source();
}
inline const ::std::string& LegPreAllocGrp::leg_alloc_acct_id_source() const {
  return *leg_alloc_acct_id_source_;
}
inline void LegPreAllocGrp::set_leg_alloc_acct_id_source(const ::std::string& value) {
  set_has_leg_alloc_acct_id_source();
  if (leg_alloc_acct_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_acct_id_source_ = new ::std::string;
  }
  leg_alloc_acct_id_source_->assign(value);
}
inline void LegPreAllocGrp::set_leg_alloc_acct_id_source(const char* value) {
  set_has_leg_alloc_acct_id_source();
  if (leg_alloc_acct_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_acct_id_source_ = new ::std::string;
  }
  leg_alloc_acct_id_source_->assign(value);
}
inline void LegPreAllocGrp::set_leg_alloc_acct_id_source(const char* value, size_t size) {
  set_has_leg_alloc_acct_id_source();
  if (leg_alloc_acct_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_acct_id_source_ = new ::std::string;
  }
  leg_alloc_acct_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegPreAllocGrp::mutable_leg_alloc_acct_id_source() {
  set_has_leg_alloc_acct_id_source();
  if (leg_alloc_acct_id_source_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_acct_id_source_ = new ::std::string;
  }
  return leg_alloc_acct_id_source_;
}
inline ::std::string* LegPreAllocGrp::release_leg_alloc_acct_id_source() {
  clear_has_leg_alloc_acct_id_source();
  if (leg_alloc_acct_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_alloc_acct_id_source_;
    leg_alloc_acct_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegPreAllocGrp::set_allocated_leg_alloc_acct_id_source(::std::string* leg_alloc_acct_id_source) {
  if (leg_alloc_acct_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_alloc_acct_id_source_;
  }
  if (leg_alloc_acct_id_source) {
    set_has_leg_alloc_acct_id_source();
    leg_alloc_acct_id_source_ = leg_alloc_acct_id_source;
  } else {
    clear_has_leg_alloc_acct_id_source();
    leg_alloc_acct_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 leg_alloc_qty = 3;
inline bool LegPreAllocGrp::has_leg_alloc_qty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LegPreAllocGrp::set_has_leg_alloc_qty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LegPreAllocGrp::clear_has_leg_alloc_qty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LegPreAllocGrp::clear_leg_alloc_qty() {
  leg_alloc_qty_ = GOOGLE_LONGLONG(0);
  clear_has_leg_alloc_qty();
}
inline ::google::protobuf::int64 LegPreAllocGrp::leg_alloc_qty() const {
  return leg_alloc_qty_;
}
inline void LegPreAllocGrp::set_leg_alloc_qty(::google::protobuf::int64 value) {
  set_has_leg_alloc_qty();
  leg_alloc_qty_ = value;
}

// optional sfixed32 leg_alloc_qty_exponent = 4;
inline bool LegPreAllocGrp::has_leg_alloc_qty_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LegPreAllocGrp::set_has_leg_alloc_qty_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LegPreAllocGrp::clear_has_leg_alloc_qty_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LegPreAllocGrp::clear_leg_alloc_qty_exponent() {
  leg_alloc_qty_exponent_ = 0;
  clear_has_leg_alloc_qty_exponent();
}
inline ::google::protobuf::int32 LegPreAllocGrp::leg_alloc_qty_exponent() const {
  return leg_alloc_qty_exponent_;
}
inline void LegPreAllocGrp::set_leg_alloc_qty_exponent(::google::protobuf::int32 value) {
  set_has_leg_alloc_qty_exponent();
  leg_alloc_qty_exponent_ = value;
}

// optional string leg_individual_alloc_id = 5;
inline bool LegPreAllocGrp::has_leg_individual_alloc_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LegPreAllocGrp::set_has_leg_individual_alloc_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LegPreAllocGrp::clear_has_leg_individual_alloc_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LegPreAllocGrp::clear_leg_individual_alloc_id() {
  if (leg_individual_alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    leg_individual_alloc_id_->clear();
  }
  clear_has_leg_individual_alloc_id();
}
inline const ::std::string& LegPreAllocGrp::leg_individual_alloc_id() const {
  return *leg_individual_alloc_id_;
}
inline void LegPreAllocGrp::set_leg_individual_alloc_id(const ::std::string& value) {
  set_has_leg_individual_alloc_id();
  if (leg_individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_individual_alloc_id_ = new ::std::string;
  }
  leg_individual_alloc_id_->assign(value);
}
inline void LegPreAllocGrp::set_leg_individual_alloc_id(const char* value) {
  set_has_leg_individual_alloc_id();
  if (leg_individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_individual_alloc_id_ = new ::std::string;
  }
  leg_individual_alloc_id_->assign(value);
}
inline void LegPreAllocGrp::set_leg_individual_alloc_id(const char* value, size_t size) {
  set_has_leg_individual_alloc_id();
  if (leg_individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_individual_alloc_id_ = new ::std::string;
  }
  leg_individual_alloc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegPreAllocGrp::mutable_leg_individual_alloc_id() {
  set_has_leg_individual_alloc_id();
  if (leg_individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_individual_alloc_id_ = new ::std::string;
  }
  return leg_individual_alloc_id_;
}
inline ::std::string* LegPreAllocGrp::release_leg_individual_alloc_id() {
  clear_has_leg_individual_alloc_id();
  if (leg_individual_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_individual_alloc_id_;
    leg_individual_alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegPreAllocGrp::set_allocated_leg_individual_alloc_id(::std::string* leg_individual_alloc_id) {
  if (leg_individual_alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_individual_alloc_id_;
  }
  if (leg_individual_alloc_id) {
    set_has_leg_individual_alloc_id();
    leg_individual_alloc_id_ = leg_individual_alloc_id;
  } else {
    clear_has_leg_individual_alloc_id();
    leg_individual_alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.NestedParties2 nested_parties2 = 6;
inline int LegPreAllocGrp::nested_parties2_size() const {
  return nested_parties2_.size();
}
inline void LegPreAllocGrp::clear_nested_parties2() {
  nested_parties2_.Clear();
}
inline const ::Common::NestedParties2& LegPreAllocGrp::nested_parties2(int index) const {
  return nested_parties2_.Get(index);
}
inline ::Common::NestedParties2* LegPreAllocGrp::mutable_nested_parties2(int index) {
  return nested_parties2_.Mutable(index);
}
inline ::Common::NestedParties2* LegPreAllocGrp::add_nested_parties2() {
  return nested_parties2_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedParties2 >&
LegPreAllocGrp::nested_parties2() const {
  return nested_parties2_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NestedParties2 >*
LegPreAllocGrp::mutable_nested_parties2() {
  return &nested_parties2_;
}

// optional string leg_alloc_settl_currency = 7;
inline bool LegPreAllocGrp::has_leg_alloc_settl_currency() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LegPreAllocGrp::set_has_leg_alloc_settl_currency() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LegPreAllocGrp::clear_has_leg_alloc_settl_currency() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LegPreAllocGrp::clear_leg_alloc_settl_currency() {
  if (leg_alloc_settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    leg_alloc_settl_currency_->clear();
  }
  clear_has_leg_alloc_settl_currency();
}
inline const ::std::string& LegPreAllocGrp::leg_alloc_settl_currency() const {
  return *leg_alloc_settl_currency_;
}
inline void LegPreAllocGrp::set_leg_alloc_settl_currency(const ::std::string& value) {
  set_has_leg_alloc_settl_currency();
  if (leg_alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_settl_currency_ = new ::std::string;
  }
  leg_alloc_settl_currency_->assign(value);
}
inline void LegPreAllocGrp::set_leg_alloc_settl_currency(const char* value) {
  set_has_leg_alloc_settl_currency();
  if (leg_alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_settl_currency_ = new ::std::string;
  }
  leg_alloc_settl_currency_->assign(value);
}
inline void LegPreAllocGrp::set_leg_alloc_settl_currency(const char* value, size_t size) {
  set_has_leg_alloc_settl_currency();
  if (leg_alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_settl_currency_ = new ::std::string;
  }
  leg_alloc_settl_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegPreAllocGrp::mutable_leg_alloc_settl_currency() {
  set_has_leg_alloc_settl_currency();
  if (leg_alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_settl_currency_ = new ::std::string;
  }
  return leg_alloc_settl_currency_;
}
inline ::std::string* LegPreAllocGrp::release_leg_alloc_settl_currency() {
  clear_has_leg_alloc_settl_currency();
  if (leg_alloc_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_alloc_settl_currency_;
    leg_alloc_settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegPreAllocGrp::set_allocated_leg_alloc_settl_currency(::std::string* leg_alloc_settl_currency) {
  if (leg_alloc_settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_alloc_settl_currency_;
  }
  if (leg_alloc_settl_currency) {
    set_has_leg_alloc_settl_currency();
    leg_alloc_settl_currency_ = leg_alloc_settl_currency;
  } else {
    clear_has_leg_alloc_settl_currency();
    leg_alloc_settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// NstdPtys3SubGrp

// optional string nested3party_sub_id = 1;
inline bool NstdPtys3SubGrp::has_nested3party_sub_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NstdPtys3SubGrp::set_has_nested3party_sub_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NstdPtys3SubGrp::clear_has_nested3party_sub_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NstdPtys3SubGrp::clear_nested3party_sub_id() {
  if (nested3party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    nested3party_sub_id_->clear();
  }
  clear_has_nested3party_sub_id();
}
inline const ::std::string& NstdPtys3SubGrp::nested3party_sub_id() const {
  return *nested3party_sub_id_;
}
inline void NstdPtys3SubGrp::set_nested3party_sub_id(const ::std::string& value) {
  set_has_nested3party_sub_id();
  if (nested3party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_sub_id_ = new ::std::string;
  }
  nested3party_sub_id_->assign(value);
}
inline void NstdPtys3SubGrp::set_nested3party_sub_id(const char* value) {
  set_has_nested3party_sub_id();
  if (nested3party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_sub_id_ = new ::std::string;
  }
  nested3party_sub_id_->assign(value);
}
inline void NstdPtys3SubGrp::set_nested3party_sub_id(const char* value, size_t size) {
  set_has_nested3party_sub_id();
  if (nested3party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_sub_id_ = new ::std::string;
  }
  nested3party_sub_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NstdPtys3SubGrp::mutable_nested3party_sub_id() {
  set_has_nested3party_sub_id();
  if (nested3party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_sub_id_ = new ::std::string;
  }
  return nested3party_sub_id_;
}
inline ::std::string* NstdPtys3SubGrp::release_nested3party_sub_id() {
  clear_has_nested3party_sub_id();
  if (nested3party_sub_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested3party_sub_id_;
    nested3party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NstdPtys3SubGrp::set_allocated_nested3party_sub_id(::std::string* nested3party_sub_id) {
  if (nested3party_sub_id_ != &::google::protobuf::internal::kEmptyString) {
    delete nested3party_sub_id_;
  }
  if (nested3party_sub_id) {
    set_has_nested3party_sub_id();
    nested3party_sub_id_ = nested3party_sub_id;
  } else {
    clear_has_nested3party_sub_id();
    nested3party_sub_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 nested3party_sub_id_type = 2;
inline bool NstdPtys3SubGrp::has_nested3party_sub_id_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NstdPtys3SubGrp::set_has_nested3party_sub_id_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NstdPtys3SubGrp::clear_has_nested3party_sub_id_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NstdPtys3SubGrp::clear_nested3party_sub_id_type() {
  nested3party_sub_id_type_ = GOOGLE_LONGLONG(0);
  clear_has_nested3party_sub_id_type();
}
inline ::google::protobuf::int64 NstdPtys3SubGrp::nested3party_sub_id_type() const {
  return nested3party_sub_id_type_;
}
inline void NstdPtys3SubGrp::set_nested3party_sub_id_type(::google::protobuf::int64 value) {
  set_has_nested3party_sub_id_type();
  nested3party_sub_id_type_ = value;
}

// -------------------------------------------------------------------

// NestedParties3

// optional string nested3party_id = 1;
inline bool NestedParties3::has_nested3party_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NestedParties3::set_has_nested3party_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NestedParties3::clear_has_nested3party_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NestedParties3::clear_nested3party_id() {
  if (nested3party_id_ != &::google::protobuf::internal::kEmptyString) {
    nested3party_id_->clear();
  }
  clear_has_nested3party_id();
}
inline const ::std::string& NestedParties3::nested3party_id() const {
  return *nested3party_id_;
}
inline void NestedParties3::set_nested3party_id(const ::std::string& value) {
  set_has_nested3party_id();
  if (nested3party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_id_ = new ::std::string;
  }
  nested3party_id_->assign(value);
}
inline void NestedParties3::set_nested3party_id(const char* value) {
  set_has_nested3party_id();
  if (nested3party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_id_ = new ::std::string;
  }
  nested3party_id_->assign(value);
}
inline void NestedParties3::set_nested3party_id(const char* value, size_t size) {
  set_has_nested3party_id();
  if (nested3party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_id_ = new ::std::string;
  }
  nested3party_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NestedParties3::mutable_nested3party_id() {
  set_has_nested3party_id();
  if (nested3party_id_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_id_ = new ::std::string;
  }
  return nested3party_id_;
}
inline ::std::string* NestedParties3::release_nested3party_id() {
  clear_has_nested3party_id();
  if (nested3party_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested3party_id_;
    nested3party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NestedParties3::set_allocated_nested3party_id(::std::string* nested3party_id) {
  if (nested3party_id_ != &::google::protobuf::internal::kEmptyString) {
    delete nested3party_id_;
  }
  if (nested3party_id) {
    set_has_nested3party_id();
    nested3party_id_ = nested3party_id;
  } else {
    clear_has_nested3party_id();
    nested3party_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nested3party_id_source = 2;
inline bool NestedParties3::has_nested3party_id_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NestedParties3::set_has_nested3party_id_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NestedParties3::clear_has_nested3party_id_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NestedParties3::clear_nested3party_id_source() {
  if (nested3party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    nested3party_id_source_->clear();
  }
  clear_has_nested3party_id_source();
}
inline const ::std::string& NestedParties3::nested3party_id_source() const {
  return *nested3party_id_source_;
}
inline void NestedParties3::set_nested3party_id_source(const ::std::string& value) {
  set_has_nested3party_id_source();
  if (nested3party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_id_source_ = new ::std::string;
  }
  nested3party_id_source_->assign(value);
}
inline void NestedParties3::set_nested3party_id_source(const char* value) {
  set_has_nested3party_id_source();
  if (nested3party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_id_source_ = new ::std::string;
  }
  nested3party_id_source_->assign(value);
}
inline void NestedParties3::set_nested3party_id_source(const char* value, size_t size) {
  set_has_nested3party_id_source();
  if (nested3party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_id_source_ = new ::std::string;
  }
  nested3party_id_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NestedParties3::mutable_nested3party_id_source() {
  set_has_nested3party_id_source();
  if (nested3party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    nested3party_id_source_ = new ::std::string;
  }
  return nested3party_id_source_;
}
inline ::std::string* NestedParties3::release_nested3party_id_source() {
  clear_has_nested3party_id_source();
  if (nested3party_id_source_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested3party_id_source_;
    nested3party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NestedParties3::set_allocated_nested3party_id_source(::std::string* nested3party_id_source) {
  if (nested3party_id_source_ != &::google::protobuf::internal::kEmptyString) {
    delete nested3party_id_source_;
  }
  if (nested3party_id_source) {
    set_has_nested3party_id_source();
    nested3party_id_source_ = nested3party_id_source;
  } else {
    clear_has_nested3party_id_source();
    nested3party_id_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 nested3party_role = 3;
inline bool NestedParties3::has_nested3party_role() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NestedParties3::set_has_nested3party_role() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NestedParties3::clear_has_nested3party_role() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NestedParties3::clear_nested3party_role() {
  nested3party_role_ = GOOGLE_LONGLONG(0);
  clear_has_nested3party_role();
}
inline ::google::protobuf::int64 NestedParties3::nested3party_role() const {
  return nested3party_role_;
}
inline void NestedParties3::set_nested3party_role(::google::protobuf::int64 value) {
  set_has_nested3party_role();
  nested3party_role_ = value;
}

// repeated .Common.NstdPtys3SubGrp nstd_ptys3sub_grp = 4;
inline int NestedParties3::nstd_ptys3sub_grp_size() const {
  return nstd_ptys3sub_grp_.size();
}
inline void NestedParties3::clear_nstd_ptys3sub_grp() {
  nstd_ptys3sub_grp_.Clear();
}
inline const ::Common::NstdPtys3SubGrp& NestedParties3::nstd_ptys3sub_grp(int index) const {
  return nstd_ptys3sub_grp_.Get(index);
}
inline ::Common::NstdPtys3SubGrp* NestedParties3::mutable_nstd_ptys3sub_grp(int index) {
  return nstd_ptys3sub_grp_.Mutable(index);
}
inline ::Common::NstdPtys3SubGrp* NestedParties3::add_nstd_ptys3sub_grp() {
  return nstd_ptys3sub_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys3SubGrp >&
NestedParties3::nstd_ptys3sub_grp() const {
  return nstd_ptys3sub_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NstdPtys3SubGrp >*
NestedParties3::mutable_nstd_ptys3sub_grp() {
  return &nstd_ptys3sub_grp_;
}

// -------------------------------------------------------------------

// InstrmtLegExecGrp

// optional .Common.InstrumentLeg instrument_leg = 1;
inline bool InstrmtLegExecGrp::has_instrument_leg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrmtLegExecGrp::set_has_instrument_leg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrmtLegExecGrp::clear_has_instrument_leg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrmtLegExecGrp::clear_instrument_leg() {
  if (instrument_leg_ != NULL) instrument_leg_->::Common::InstrumentLeg::Clear();
  clear_has_instrument_leg();
}
inline const ::Common::InstrumentLeg& InstrmtLegExecGrp::instrument_leg() const {
  return instrument_leg_ != NULL ? *instrument_leg_ : *default_instance_->instrument_leg_;
}
inline ::Common::InstrumentLeg* InstrmtLegExecGrp::mutable_instrument_leg() {
  set_has_instrument_leg();
  if (instrument_leg_ == NULL) instrument_leg_ = new ::Common::InstrumentLeg;
  return instrument_leg_;
}
inline ::Common::InstrumentLeg* InstrmtLegExecGrp::release_instrument_leg() {
  clear_has_instrument_leg();
  ::Common::InstrumentLeg* temp = instrument_leg_;
  instrument_leg_ = NULL;
  return temp;
}
inline void InstrmtLegExecGrp::set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg) {
  delete instrument_leg_;
  instrument_leg_ = instrument_leg;
  if (instrument_leg) {
    set_has_instrument_leg();
  } else {
    clear_has_instrument_leg();
  }
}

// optional sfixed64 leg_calculated_ccy_last_qty = 2;
inline bool InstrmtLegExecGrp::has_leg_calculated_ccy_last_qty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_calculated_ccy_last_qty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrmtLegExecGrp::clear_has_leg_calculated_ccy_last_qty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrmtLegExecGrp::clear_leg_calculated_ccy_last_qty() {
  leg_calculated_ccy_last_qty_ = GOOGLE_LONGLONG(0);
  clear_has_leg_calculated_ccy_last_qty();
}
inline ::google::protobuf::int64 InstrmtLegExecGrp::leg_calculated_ccy_last_qty() const {
  return leg_calculated_ccy_last_qty_;
}
inline void InstrmtLegExecGrp::set_leg_calculated_ccy_last_qty(::google::protobuf::int64 value) {
  set_has_leg_calculated_ccy_last_qty();
  leg_calculated_ccy_last_qty_ = value;
}

// optional sfixed32 leg_calculated_ccy_last_qty_exponent = 3;
inline bool InstrmtLegExecGrp::has_leg_calculated_ccy_last_qty_exponent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_calculated_ccy_last_qty_exponent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstrmtLegExecGrp::clear_has_leg_calculated_ccy_last_qty_exponent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstrmtLegExecGrp::clear_leg_calculated_ccy_last_qty_exponent() {
  leg_calculated_ccy_last_qty_exponent_ = 0;
  clear_has_leg_calculated_ccy_last_qty_exponent();
}
inline ::google::protobuf::int32 InstrmtLegExecGrp::leg_calculated_ccy_last_qty_exponent() const {
  return leg_calculated_ccy_last_qty_exponent_;
}
inline void InstrmtLegExecGrp::set_leg_calculated_ccy_last_qty_exponent(::google::protobuf::int32 value) {
  set_has_leg_calculated_ccy_last_qty_exponent();
  leg_calculated_ccy_last_qty_exponent_ = value;
}

// optional sfixed64 leg_covered_or_uncovered = 4;
inline bool InstrmtLegExecGrp::has_leg_covered_or_uncovered() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_covered_or_uncovered() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstrmtLegExecGrp::clear_has_leg_covered_or_uncovered() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstrmtLegExecGrp::clear_leg_covered_or_uncovered() {
  leg_covered_or_uncovered_ = GOOGLE_LONGLONG(0);
  clear_has_leg_covered_or_uncovered();
}
inline ::google::protobuf::int64 InstrmtLegExecGrp::leg_covered_or_uncovered() const {
  return leg_covered_or_uncovered_;
}
inline void InstrmtLegExecGrp::set_leg_covered_or_uncovered(::google::protobuf::int64 value) {
  set_has_leg_covered_or_uncovered();
  leg_covered_or_uncovered_ = value;
}

// optional sfixed64 leg_gross_trade_amt = 5;
inline bool InstrmtLegExecGrp::has_leg_gross_trade_amt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_gross_trade_amt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstrmtLegExecGrp::clear_has_leg_gross_trade_amt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstrmtLegExecGrp::clear_leg_gross_trade_amt() {
  leg_gross_trade_amt_ = GOOGLE_LONGLONG(0);
  clear_has_leg_gross_trade_amt();
}
inline ::google::protobuf::int64 InstrmtLegExecGrp::leg_gross_trade_amt() const {
  return leg_gross_trade_amt_;
}
inline void InstrmtLegExecGrp::set_leg_gross_trade_amt(::google::protobuf::int64 value) {
  set_has_leg_gross_trade_amt();
  leg_gross_trade_amt_ = value;
}

// optional sfixed32 leg_gross_trade_amt_exponent = 6;
inline bool InstrmtLegExecGrp::has_leg_gross_trade_amt_exponent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_gross_trade_amt_exponent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InstrmtLegExecGrp::clear_has_leg_gross_trade_amt_exponent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InstrmtLegExecGrp::clear_leg_gross_trade_amt_exponent() {
  leg_gross_trade_amt_exponent_ = 0;
  clear_has_leg_gross_trade_amt_exponent();
}
inline ::google::protobuf::int32 InstrmtLegExecGrp::leg_gross_trade_amt_exponent() const {
  return leg_gross_trade_amt_exponent_;
}
inline void InstrmtLegExecGrp::set_leg_gross_trade_amt_exponent(::google::protobuf::int32 value) {
  set_has_leg_gross_trade_amt_exponent();
  leg_gross_trade_amt_exponent_ = value;
}

// optional sfixed64 leg_last_forward_points = 7;
inline bool InstrmtLegExecGrp::has_leg_last_forward_points() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_last_forward_points() {
  _has_bits_[0] |= 0x00000040u;
}
inline void InstrmtLegExecGrp::clear_has_leg_last_forward_points() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void InstrmtLegExecGrp::clear_leg_last_forward_points() {
  leg_last_forward_points_ = GOOGLE_LONGLONG(0);
  clear_has_leg_last_forward_points();
}
inline ::google::protobuf::int64 InstrmtLegExecGrp::leg_last_forward_points() const {
  return leg_last_forward_points_;
}
inline void InstrmtLegExecGrp::set_leg_last_forward_points(::google::protobuf::int64 value) {
  set_has_leg_last_forward_points();
  leg_last_forward_points_ = value;
}

// optional sfixed32 leg_last_forward_points_exponent = 8;
inline bool InstrmtLegExecGrp::has_leg_last_forward_points_exponent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_last_forward_points_exponent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void InstrmtLegExecGrp::clear_has_leg_last_forward_points_exponent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void InstrmtLegExecGrp::clear_leg_last_forward_points_exponent() {
  leg_last_forward_points_exponent_ = 0;
  clear_has_leg_last_forward_points_exponent();
}
inline ::google::protobuf::int32 InstrmtLegExecGrp::leg_last_forward_points_exponent() const {
  return leg_last_forward_points_exponent_;
}
inline void InstrmtLegExecGrp::set_leg_last_forward_points_exponent(::google::protobuf::int32 value) {
  set_has_leg_last_forward_points_exponent();
  leg_last_forward_points_exponent_ = value;
}

// optional sfixed64 leg_last_px = 9;
inline bool InstrmtLegExecGrp::has_leg_last_px() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_last_px() {
  _has_bits_[0] |= 0x00000100u;
}
inline void InstrmtLegExecGrp::clear_has_leg_last_px() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void InstrmtLegExecGrp::clear_leg_last_px() {
  leg_last_px_ = GOOGLE_LONGLONG(0);
  clear_has_leg_last_px();
}
inline ::google::protobuf::int64 InstrmtLegExecGrp::leg_last_px() const {
  return leg_last_px_;
}
inline void InstrmtLegExecGrp::set_leg_last_px(::google::protobuf::int64 value) {
  set_has_leg_last_px();
  leg_last_px_ = value;
}

// optional sfixed32 leg_last_px_exponent = 10;
inline bool InstrmtLegExecGrp::has_leg_last_px_exponent() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_last_px_exponent() {
  _has_bits_[0] |= 0x00000200u;
}
inline void InstrmtLegExecGrp::clear_has_leg_last_px_exponent() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void InstrmtLegExecGrp::clear_leg_last_px_exponent() {
  leg_last_px_exponent_ = 0;
  clear_has_leg_last_px_exponent();
}
inline ::google::protobuf::int32 InstrmtLegExecGrp::leg_last_px_exponent() const {
  return leg_last_px_exponent_;
}
inline void InstrmtLegExecGrp::set_leg_last_px_exponent(::google::protobuf::int32 value) {
  set_has_leg_last_px_exponent();
  leg_last_px_exponent_ = value;
}

// optional sfixed64 leg_order_qty = 11;
inline bool InstrmtLegExecGrp::has_leg_order_qty() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_order_qty() {
  _has_bits_[0] |= 0x00000400u;
}
inline void InstrmtLegExecGrp::clear_has_leg_order_qty() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void InstrmtLegExecGrp::clear_leg_order_qty() {
  leg_order_qty_ = GOOGLE_LONGLONG(0);
  clear_has_leg_order_qty();
}
inline ::google::protobuf::int64 InstrmtLegExecGrp::leg_order_qty() const {
  return leg_order_qty_;
}
inline void InstrmtLegExecGrp::set_leg_order_qty(::google::protobuf::int64 value) {
  set_has_leg_order_qty();
  leg_order_qty_ = value;
}

// optional sfixed32 leg_order_qty_exponent = 12;
inline bool InstrmtLegExecGrp::has_leg_order_qty_exponent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_order_qty_exponent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void InstrmtLegExecGrp::clear_has_leg_order_qty_exponent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void InstrmtLegExecGrp::clear_leg_order_qty_exponent() {
  leg_order_qty_exponent_ = 0;
  clear_has_leg_order_qty_exponent();
}
inline ::google::protobuf::int32 InstrmtLegExecGrp::leg_order_qty_exponent() const {
  return leg_order_qty_exponent_;
}
inline void InstrmtLegExecGrp::set_leg_order_qty_exponent(::google::protobuf::int32 value) {
  set_has_leg_order_qty_exponent();
  leg_order_qty_exponent_ = value;
}

// optional string leg_position_effect = 13;
inline bool InstrmtLegExecGrp::has_leg_position_effect() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_position_effect() {
  _has_bits_[0] |= 0x00001000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_position_effect() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void InstrmtLegExecGrp::clear_leg_position_effect() {
  if (leg_position_effect_ != &::google::protobuf::internal::kEmptyString) {
    leg_position_effect_->clear();
  }
  clear_has_leg_position_effect();
}
inline const ::std::string& InstrmtLegExecGrp::leg_position_effect() const {
  return *leg_position_effect_;
}
inline void InstrmtLegExecGrp::set_leg_position_effect(const ::std::string& value) {
  set_has_leg_position_effect();
  if (leg_position_effect_ == &::google::protobuf::internal::kEmptyString) {
    leg_position_effect_ = new ::std::string;
  }
  leg_position_effect_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_position_effect(const char* value) {
  set_has_leg_position_effect();
  if (leg_position_effect_ == &::google::protobuf::internal::kEmptyString) {
    leg_position_effect_ = new ::std::string;
  }
  leg_position_effect_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_position_effect(const char* value, size_t size) {
  set_has_leg_position_effect();
  if (leg_position_effect_ == &::google::protobuf::internal::kEmptyString) {
    leg_position_effect_ = new ::std::string;
  }
  leg_position_effect_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrmtLegExecGrp::mutable_leg_position_effect() {
  set_has_leg_position_effect();
  if (leg_position_effect_ == &::google::protobuf::internal::kEmptyString) {
    leg_position_effect_ = new ::std::string;
  }
  return leg_position_effect_;
}
inline ::std::string* InstrmtLegExecGrp::release_leg_position_effect() {
  clear_has_leg_position_effect();
  if (leg_position_effect_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_position_effect_;
    leg_position_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrmtLegExecGrp::set_allocated_leg_position_effect(::std::string* leg_position_effect) {
  if (leg_position_effect_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_position_effect_;
  }
  if (leg_position_effect) {
    set_has_leg_position_effect();
    leg_position_effect_ = leg_position_effect;
  } else {
    clear_has_leg_position_effect();
    leg_position_effect_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 leg_qty = 14;
inline bool InstrmtLegExecGrp::has_leg_qty() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_qty() {
  _has_bits_[0] |= 0x00002000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_qty() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void InstrmtLegExecGrp::clear_leg_qty() {
  leg_qty_ = GOOGLE_LONGLONG(0);
  clear_has_leg_qty();
}
inline ::google::protobuf::int64 InstrmtLegExecGrp::leg_qty() const {
  return leg_qty_;
}
inline void InstrmtLegExecGrp::set_leg_qty(::google::protobuf::int64 value) {
  set_has_leg_qty();
  leg_qty_ = value;
}

// optional sfixed32 leg_qty_exponent = 15;
inline bool InstrmtLegExecGrp::has_leg_qty_exponent() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_qty_exponent() {
  _has_bits_[0] |= 0x00004000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_qty_exponent() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void InstrmtLegExecGrp::clear_leg_qty_exponent() {
  leg_qty_exponent_ = 0;
  clear_has_leg_qty_exponent();
}
inline ::google::protobuf::int32 InstrmtLegExecGrp::leg_qty_exponent() const {
  return leg_qty_exponent_;
}
inline void InstrmtLegExecGrp::set_leg_qty_exponent(::google::protobuf::int32 value) {
  set_has_leg_qty_exponent();
  leg_qty_exponent_ = value;
}

// optional string leg_ref_id = 16;
inline bool InstrmtLegExecGrp::has_leg_ref_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_ref_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_ref_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void InstrmtLegExecGrp::clear_leg_ref_id() {
  if (leg_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    leg_ref_id_->clear();
  }
  clear_has_leg_ref_id();
}
inline const ::std::string& InstrmtLegExecGrp::leg_ref_id() const {
  return *leg_ref_id_;
}
inline void InstrmtLegExecGrp::set_leg_ref_id(const ::std::string& value) {
  set_has_leg_ref_id();
  if (leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_ref_id_ = new ::std::string;
  }
  leg_ref_id_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_ref_id(const char* value) {
  set_has_leg_ref_id();
  if (leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_ref_id_ = new ::std::string;
  }
  leg_ref_id_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_ref_id(const char* value, size_t size) {
  set_has_leg_ref_id();
  if (leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_ref_id_ = new ::std::string;
  }
  leg_ref_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrmtLegExecGrp::mutable_leg_ref_id() {
  set_has_leg_ref_id();
  if (leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_ref_id_ = new ::std::string;
  }
  return leg_ref_id_;
}
inline ::std::string* InstrmtLegExecGrp::release_leg_ref_id() {
  clear_has_leg_ref_id();
  if (leg_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_ref_id_;
    leg_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrmtLegExecGrp::set_allocated_leg_ref_id(::std::string* leg_ref_id) {
  if (leg_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_ref_id_;
  }
  if (leg_ref_id) {
    set_has_leg_ref_id();
    leg_ref_id_ = leg_ref_id;
  } else {
    clear_has_leg_ref_id();
    leg_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_settl_currency = 17;
inline bool InstrmtLegExecGrp::has_leg_settl_currency() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_settl_currency() {
  _has_bits_[0] |= 0x00010000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_settl_currency() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void InstrmtLegExecGrp::clear_leg_settl_currency() {
  if (leg_settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    leg_settl_currency_->clear();
  }
  clear_has_leg_settl_currency();
}
inline const ::std::string& InstrmtLegExecGrp::leg_settl_currency() const {
  return *leg_settl_currency_;
}
inline void InstrmtLegExecGrp::set_leg_settl_currency(const ::std::string& value) {
  set_has_leg_settl_currency();
  if (leg_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_currency_ = new ::std::string;
  }
  leg_settl_currency_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_settl_currency(const char* value) {
  set_has_leg_settl_currency();
  if (leg_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_currency_ = new ::std::string;
  }
  leg_settl_currency_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_settl_currency(const char* value, size_t size) {
  set_has_leg_settl_currency();
  if (leg_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_currency_ = new ::std::string;
  }
  leg_settl_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrmtLegExecGrp::mutable_leg_settl_currency() {
  set_has_leg_settl_currency();
  if (leg_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_currency_ = new ::std::string;
  }
  return leg_settl_currency_;
}
inline ::std::string* InstrmtLegExecGrp::release_leg_settl_currency() {
  clear_has_leg_settl_currency();
  if (leg_settl_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_settl_currency_;
    leg_settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrmtLegExecGrp::set_allocated_leg_settl_currency(::std::string* leg_settl_currency) {
  if (leg_settl_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_settl_currency_;
  }
  if (leg_settl_currency) {
    set_has_leg_settl_currency();
    leg_settl_currency_ = leg_settl_currency;
  } else {
    clear_has_leg_settl_currency();
    leg_settl_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 leg_settl_date = 18;
inline bool InstrmtLegExecGrp::has_leg_settl_date() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_settl_date() {
  _has_bits_[0] |= 0x00020000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_settl_date() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void InstrmtLegExecGrp::clear_leg_settl_date() {
  leg_settl_date_ = 0;
  clear_has_leg_settl_date();
}
inline ::google::protobuf::int32 InstrmtLegExecGrp::leg_settl_date() const {
  return leg_settl_date_;
}
inline void InstrmtLegExecGrp::set_leg_settl_date(::google::protobuf::int32 value) {
  set_has_leg_settl_date();
  leg_settl_date_ = value;
}

// optional string leg_settl_type = 19;
inline bool InstrmtLegExecGrp::has_leg_settl_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_settl_type() {
  _has_bits_[0] |= 0x00040000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_settl_type() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void InstrmtLegExecGrp::clear_leg_settl_type() {
  if (leg_settl_type_ != &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_->clear();
  }
  clear_has_leg_settl_type();
}
inline const ::std::string& InstrmtLegExecGrp::leg_settl_type() const {
  return *leg_settl_type_;
}
inline void InstrmtLegExecGrp::set_leg_settl_type(const ::std::string& value) {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  leg_settl_type_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_settl_type(const char* value) {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  leg_settl_type_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_settl_type(const char* value, size_t size) {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  leg_settl_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrmtLegExecGrp::mutable_leg_settl_type() {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  return leg_settl_type_;
}
inline ::std::string* InstrmtLegExecGrp::release_leg_settl_type() {
  clear_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_settl_type_;
    leg_settl_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrmtLegExecGrp::set_allocated_leg_settl_type(::std::string* leg_settl_type) {
  if (leg_settl_type_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_settl_type_;
  }
  if (leg_settl_type) {
    set_has_leg_settl_type();
    leg_settl_type_ = leg_settl_type;
  } else {
    clear_has_leg_settl_type();
    leg_settl_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.LegStipulations leg_stipulations = 20;
inline int InstrmtLegExecGrp::leg_stipulations_size() const {
  return leg_stipulations_.size();
}
inline void InstrmtLegExecGrp::clear_leg_stipulations() {
  leg_stipulations_.Clear();
}
inline const ::Common::LegStipulations& InstrmtLegExecGrp::leg_stipulations(int index) const {
  return leg_stipulations_.Get(index);
}
inline ::Common::LegStipulations* InstrmtLegExecGrp::mutable_leg_stipulations(int index) {
  return leg_stipulations_.Mutable(index);
}
inline ::Common::LegStipulations* InstrmtLegExecGrp::add_leg_stipulations() {
  return leg_stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >&
InstrmtLegExecGrp::leg_stipulations() const {
  return leg_stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >*
InstrmtLegExecGrp::mutable_leg_stipulations() {
  return &leg_stipulations_;
}

// optional .Common.LegSwapTypeEnum leg_swap_type = 21;
inline bool InstrmtLegExecGrp::has_leg_swap_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_swap_type() {
  _has_bits_[0] |= 0x00100000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_swap_type() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void InstrmtLegExecGrp::clear_leg_swap_type() {
  leg_swap_type_ = 0;
  clear_has_leg_swap_type();
}
inline ::Common::LegSwapTypeEnum InstrmtLegExecGrp::leg_swap_type() const {
  return static_cast< ::Common::LegSwapTypeEnum >(leg_swap_type_);
}
inline void InstrmtLegExecGrp::set_leg_swap_type(::Common::LegSwapTypeEnum value) {
  assert(::Common::LegSwapTypeEnum_IsValid(value));
  set_has_leg_swap_type();
  leg_swap_type_ = value;
}

// optional string leg_alloc_id = 22;
inline bool InstrmtLegExecGrp::has_leg_alloc_id() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_alloc_id() {
  _has_bits_[0] |= 0x00200000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_alloc_id() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void InstrmtLegExecGrp::clear_leg_alloc_id() {
  if (leg_alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    leg_alloc_id_->clear();
  }
  clear_has_leg_alloc_id();
}
inline const ::std::string& InstrmtLegExecGrp::leg_alloc_id() const {
  return *leg_alloc_id_;
}
inline void InstrmtLegExecGrp::set_leg_alloc_id(const ::std::string& value) {
  set_has_leg_alloc_id();
  if (leg_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_id_ = new ::std::string;
  }
  leg_alloc_id_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_alloc_id(const char* value) {
  set_has_leg_alloc_id();
  if (leg_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_id_ = new ::std::string;
  }
  leg_alloc_id_->assign(value);
}
inline void InstrmtLegExecGrp::set_leg_alloc_id(const char* value, size_t size) {
  set_has_leg_alloc_id();
  if (leg_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_id_ = new ::std::string;
  }
  leg_alloc_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrmtLegExecGrp::mutable_leg_alloc_id() {
  set_has_leg_alloc_id();
  if (leg_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    leg_alloc_id_ = new ::std::string;
  }
  return leg_alloc_id_;
}
inline ::std::string* InstrmtLegExecGrp::release_leg_alloc_id() {
  clear_has_leg_alloc_id();
  if (leg_alloc_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_alloc_id_;
    leg_alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrmtLegExecGrp::set_allocated_leg_alloc_id(::std::string* leg_alloc_id) {
  if (leg_alloc_id_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_alloc_id_;
  }
  if (leg_alloc_id) {
    set_has_leg_alloc_id();
    leg_alloc_id_ = leg_alloc_id;
  } else {
    clear_has_leg_alloc_id();
    leg_alloc_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional double leg_currency_ratio = 23;
inline bool InstrmtLegExecGrp::has_leg_currency_ratio() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_currency_ratio() {
  _has_bits_[0] |= 0x00400000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_currency_ratio() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void InstrmtLegExecGrp::clear_leg_currency_ratio() {
  leg_currency_ratio_ = 0;
  clear_has_leg_currency_ratio();
}
inline double InstrmtLegExecGrp::leg_currency_ratio() const {
  return leg_currency_ratio_;
}
inline void InstrmtLegExecGrp::set_leg_currency_ratio(double value) {
  set_has_leg_currency_ratio();
  leg_currency_ratio_ = value;
}

// optional sfixed64 leg_dividend_yield = 24;
inline bool InstrmtLegExecGrp::has_leg_dividend_yield() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_dividend_yield() {
  _has_bits_[0] |= 0x00800000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_dividend_yield() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void InstrmtLegExecGrp::clear_leg_dividend_yield() {
  leg_dividend_yield_ = GOOGLE_LONGLONG(0);
  clear_has_leg_dividend_yield();
}
inline ::google::protobuf::int64 InstrmtLegExecGrp::leg_dividend_yield() const {
  return leg_dividend_yield_;
}
inline void InstrmtLegExecGrp::set_leg_dividend_yield(::google::protobuf::int64 value) {
  set_has_leg_dividend_yield();
  leg_dividend_yield_ = value;
}

// optional sfixed32 leg_dividend_yield_exponent = 25;
inline bool InstrmtLegExecGrp::has_leg_dividend_yield_exponent() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_dividend_yield_exponent() {
  _has_bits_[0] |= 0x01000000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_dividend_yield_exponent() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void InstrmtLegExecGrp::clear_leg_dividend_yield_exponent() {
  leg_dividend_yield_exponent_ = 0;
  clear_has_leg_dividend_yield_exponent();
}
inline ::google::protobuf::int32 InstrmtLegExecGrp::leg_dividend_yield_exponent() const {
  return leg_dividend_yield_exponent_;
}
inline void InstrmtLegExecGrp::set_leg_dividend_yield_exponent(::google::protobuf::int32 value) {
  set_has_leg_dividend_yield_exponent();
  leg_dividend_yield_exponent_ = value;
}

// optional sfixed64 leg_last_qty = 26;
inline bool InstrmtLegExecGrp::has_leg_last_qty() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_last_qty() {
  _has_bits_[0] |= 0x02000000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_last_qty() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void InstrmtLegExecGrp::clear_leg_last_qty() {
  leg_last_qty_ = GOOGLE_LONGLONG(0);
  clear_has_leg_last_qty();
}
inline ::google::protobuf::int64 InstrmtLegExecGrp::leg_last_qty() const {
  return leg_last_qty_;
}
inline void InstrmtLegExecGrp::set_leg_last_qty(::google::protobuf::int64 value) {
  set_has_leg_last_qty();
  leg_last_qty_ = value;
}

// optional sfixed32 leg_last_qty_exponent = 27;
inline bool InstrmtLegExecGrp::has_leg_last_qty_exponent() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_last_qty_exponent() {
  _has_bits_[0] |= 0x04000000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_last_qty_exponent() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void InstrmtLegExecGrp::clear_leg_last_qty_exponent() {
  leg_last_qty_exponent_ = 0;
  clear_has_leg_last_qty_exponent();
}
inline ::google::protobuf::int32 InstrmtLegExecGrp::leg_last_qty_exponent() const {
  return leg_last_qty_exponent_;
}
inline void InstrmtLegExecGrp::set_leg_last_qty_exponent(::google::protobuf::int32 value) {
  set_has_leg_last_qty_exponent();
  leg_last_qty_exponent_ = value;
}

// repeated .Common.LegPreAllocGrp leg_pre_alloc_grp = 28;
inline int InstrmtLegExecGrp::leg_pre_alloc_grp_size() const {
  return leg_pre_alloc_grp_.size();
}
inline void InstrmtLegExecGrp::clear_leg_pre_alloc_grp() {
  leg_pre_alloc_grp_.Clear();
}
inline const ::Common::LegPreAllocGrp& InstrmtLegExecGrp::leg_pre_alloc_grp(int index) const {
  return leg_pre_alloc_grp_.Get(index);
}
inline ::Common::LegPreAllocGrp* InstrmtLegExecGrp::mutable_leg_pre_alloc_grp(int index) {
  return leg_pre_alloc_grp_.Mutable(index);
}
inline ::Common::LegPreAllocGrp* InstrmtLegExecGrp::add_leg_pre_alloc_grp() {
  return leg_pre_alloc_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::LegPreAllocGrp >&
InstrmtLegExecGrp::leg_pre_alloc_grp() const {
  return leg_pre_alloc_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::LegPreAllocGrp >*
InstrmtLegExecGrp::mutable_leg_pre_alloc_grp() {
  return &leg_pre_alloc_grp_;
}

// optional double leg_volatility = 29;
inline bool InstrmtLegExecGrp::has_leg_volatility() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void InstrmtLegExecGrp::set_has_leg_volatility() {
  _has_bits_[0] |= 0x10000000u;
}
inline void InstrmtLegExecGrp::clear_has_leg_volatility() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void InstrmtLegExecGrp::clear_leg_volatility() {
  leg_volatility_ = 0;
  clear_has_leg_volatility();
}
inline double InstrmtLegExecGrp::leg_volatility() const {
  return leg_volatility_;
}
inline void InstrmtLegExecGrp::set_leg_volatility(double value) {
  set_has_leg_volatility();
  leg_volatility_ = value;
}

// repeated .Common.NestedParties3 nested_parties3 = 30;
inline int InstrmtLegExecGrp::nested_parties3_size() const {
  return nested_parties3_.size();
}
inline void InstrmtLegExecGrp::clear_nested_parties3() {
  nested_parties3_.Clear();
}
inline const ::Common::NestedParties3& InstrmtLegExecGrp::nested_parties3(int index) const {
  return nested_parties3_.Get(index);
}
inline ::Common::NestedParties3* InstrmtLegExecGrp::mutable_nested_parties3(int index) {
  return nested_parties3_.Mutable(index);
}
inline ::Common::NestedParties3* InstrmtLegExecGrp::add_nested_parties3() {
  return nested_parties3_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedParties3 >&
InstrmtLegExecGrp::nested_parties3() const {
  return nested_parties3_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NestedParties3 >*
InstrmtLegExecGrp::mutable_nested_parties3() {
  return &nested_parties3_;
}

// -------------------------------------------------------------------

// MiscFeesGrp

// optional sfixed64 misc_fee_amt = 1;
inline bool MiscFeesGrp::has_misc_fee_amt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MiscFeesGrp::set_has_misc_fee_amt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MiscFeesGrp::clear_has_misc_fee_amt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MiscFeesGrp::clear_misc_fee_amt() {
  misc_fee_amt_ = GOOGLE_LONGLONG(0);
  clear_has_misc_fee_amt();
}
inline ::google::protobuf::int64 MiscFeesGrp::misc_fee_amt() const {
  return misc_fee_amt_;
}
inline void MiscFeesGrp::set_misc_fee_amt(::google::protobuf::int64 value) {
  set_has_misc_fee_amt();
  misc_fee_amt_ = value;
}

// optional sfixed32 misc_fee_amt_exponent = 2;
inline bool MiscFeesGrp::has_misc_fee_amt_exponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MiscFeesGrp::set_has_misc_fee_amt_exponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MiscFeesGrp::clear_has_misc_fee_amt_exponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MiscFeesGrp::clear_misc_fee_amt_exponent() {
  misc_fee_amt_exponent_ = 0;
  clear_has_misc_fee_amt_exponent();
}
inline ::google::protobuf::int32 MiscFeesGrp::misc_fee_amt_exponent() const {
  return misc_fee_amt_exponent_;
}
inline void MiscFeesGrp::set_misc_fee_amt_exponent(::google::protobuf::int32 value) {
  set_has_misc_fee_amt_exponent();
  misc_fee_amt_exponent_ = value;
}

// optional .Common.MiscFeeBasisEnum misc_fee_basis = 3;
inline bool MiscFeesGrp::has_misc_fee_basis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MiscFeesGrp::set_has_misc_fee_basis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MiscFeesGrp::clear_has_misc_fee_basis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MiscFeesGrp::clear_misc_fee_basis() {
  misc_fee_basis_ = 0;
  clear_has_misc_fee_basis();
}
inline ::Common::MiscFeeBasisEnum MiscFeesGrp::misc_fee_basis() const {
  return static_cast< ::Common::MiscFeeBasisEnum >(misc_fee_basis_);
}
inline void MiscFeesGrp::set_misc_fee_basis(::Common::MiscFeeBasisEnum value) {
  assert(::Common::MiscFeeBasisEnum_IsValid(value));
  set_has_misc_fee_basis();
  misc_fee_basis_ = value;
}

// optional string misc_fee_curr = 4;
inline bool MiscFeesGrp::has_misc_fee_curr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MiscFeesGrp::set_has_misc_fee_curr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MiscFeesGrp::clear_has_misc_fee_curr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MiscFeesGrp::clear_misc_fee_curr() {
  if (misc_fee_curr_ != &::google::protobuf::internal::kEmptyString) {
    misc_fee_curr_->clear();
  }
  clear_has_misc_fee_curr();
}
inline const ::std::string& MiscFeesGrp::misc_fee_curr() const {
  return *misc_fee_curr_;
}
inline void MiscFeesGrp::set_misc_fee_curr(const ::std::string& value) {
  set_has_misc_fee_curr();
  if (misc_fee_curr_ == &::google::protobuf::internal::kEmptyString) {
    misc_fee_curr_ = new ::std::string;
  }
  misc_fee_curr_->assign(value);
}
inline void MiscFeesGrp::set_misc_fee_curr(const char* value) {
  set_has_misc_fee_curr();
  if (misc_fee_curr_ == &::google::protobuf::internal::kEmptyString) {
    misc_fee_curr_ = new ::std::string;
  }
  misc_fee_curr_->assign(value);
}
inline void MiscFeesGrp::set_misc_fee_curr(const char* value, size_t size) {
  set_has_misc_fee_curr();
  if (misc_fee_curr_ == &::google::protobuf::internal::kEmptyString) {
    misc_fee_curr_ = new ::std::string;
  }
  misc_fee_curr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MiscFeesGrp::mutable_misc_fee_curr() {
  set_has_misc_fee_curr();
  if (misc_fee_curr_ == &::google::protobuf::internal::kEmptyString) {
    misc_fee_curr_ = new ::std::string;
  }
  return misc_fee_curr_;
}
inline ::std::string* MiscFeesGrp::release_misc_fee_curr() {
  clear_has_misc_fee_curr();
  if (misc_fee_curr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = misc_fee_curr_;
    misc_fee_curr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MiscFeesGrp::set_allocated_misc_fee_curr(::std::string* misc_fee_curr) {
  if (misc_fee_curr_ != &::google::protobuf::internal::kEmptyString) {
    delete misc_fee_curr_;
  }
  if (misc_fee_curr) {
    set_has_misc_fee_curr();
    misc_fee_curr_ = misc_fee_curr;
  } else {
    clear_has_misc_fee_curr();
    misc_fee_curr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.MiscFeeTypeEnum misc_fee_type = 5;
inline bool MiscFeesGrp::has_misc_fee_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MiscFeesGrp::set_has_misc_fee_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MiscFeesGrp::clear_has_misc_fee_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MiscFeesGrp::clear_misc_fee_type() {
  misc_fee_type_ = 0;
  clear_has_misc_fee_type();
}
inline ::Common::MiscFeeTypeEnum MiscFeesGrp::misc_fee_type() const {
  return static_cast< ::Common::MiscFeeTypeEnum >(misc_fee_type_);
}
inline void MiscFeesGrp::set_misc_fee_type(::Common::MiscFeeTypeEnum value) {
  assert(::Common::MiscFeeTypeEnum_IsValid(value));
  set_has_misc_fee_type();
  misc_fee_type_ = value;
}

// -------------------------------------------------------------------

// InstrmtLegGrp

// optional .Common.InstrumentLeg instrument_leg = 1;
inline bool InstrmtLegGrp::has_instrument_leg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrmtLegGrp::set_has_instrument_leg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrmtLegGrp::clear_has_instrument_leg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrmtLegGrp::clear_instrument_leg() {
  if (instrument_leg_ != NULL) instrument_leg_->::Common::InstrumentLeg::Clear();
  clear_has_instrument_leg();
}
inline const ::Common::InstrumentLeg& InstrmtLegGrp::instrument_leg() const {
  return instrument_leg_ != NULL ? *instrument_leg_ : *default_instance_->instrument_leg_;
}
inline ::Common::InstrumentLeg* InstrmtLegGrp::mutable_instrument_leg() {
  set_has_instrument_leg();
  if (instrument_leg_ == NULL) instrument_leg_ = new ::Common::InstrumentLeg;
  return instrument_leg_;
}
inline ::Common::InstrumentLeg* InstrmtLegGrp::release_instrument_leg() {
  clear_has_instrument_leg();
  ::Common::InstrumentLeg* temp = instrument_leg_;
  instrument_leg_ = NULL;
  return temp;
}
inline void InstrmtLegGrp::set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg) {
  delete instrument_leg_;
  instrument_leg_ = instrument_leg;
  if (instrument_leg) {
    set_has_instrument_leg();
  } else {
    clear_has_instrument_leg();
  }
}

// -------------------------------------------------------------------

// InstrmtLegIoiGrp

// optional .Common.InstrumentLeg instrument_leg = 1;
inline bool InstrmtLegIoiGrp::has_instrument_leg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrmtLegIoiGrp::set_has_instrument_leg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrmtLegIoiGrp::clear_has_instrument_leg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrmtLegIoiGrp::clear_instrument_leg() {
  if (instrument_leg_ != NULL) instrument_leg_->::Common::InstrumentLeg::Clear();
  clear_has_instrument_leg();
}
inline const ::Common::InstrumentLeg& InstrmtLegIoiGrp::instrument_leg() const {
  return instrument_leg_ != NULL ? *instrument_leg_ : *default_instance_->instrument_leg_;
}
inline ::Common::InstrumentLeg* InstrmtLegIoiGrp::mutable_instrument_leg() {
  set_has_instrument_leg();
  if (instrument_leg_ == NULL) instrument_leg_ = new ::Common::InstrumentLeg;
  return instrument_leg_;
}
inline ::Common::InstrumentLeg* InstrmtLegIoiGrp::release_instrument_leg() {
  clear_has_instrument_leg();
  ::Common::InstrumentLeg* temp = instrument_leg_;
  instrument_leg_ = NULL;
  return temp;
}
inline void InstrmtLegIoiGrp::set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg) {
  delete instrument_leg_;
  instrument_leg_ = instrument_leg;
  if (instrument_leg) {
    set_has_instrument_leg();
  } else {
    clear_has_instrument_leg();
  }
}

// optional string leg_ioi_qty = 2;
inline bool InstrmtLegIoiGrp::has_leg_ioi_qty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrmtLegIoiGrp::set_has_leg_ioi_qty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrmtLegIoiGrp::clear_has_leg_ioi_qty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrmtLegIoiGrp::clear_leg_ioi_qty() {
  if (leg_ioi_qty_ != &::google::protobuf::internal::kEmptyString) {
    leg_ioi_qty_->clear();
  }
  clear_has_leg_ioi_qty();
}
inline const ::std::string& InstrmtLegIoiGrp::leg_ioi_qty() const {
  return *leg_ioi_qty_;
}
inline void InstrmtLegIoiGrp::set_leg_ioi_qty(const ::std::string& value) {
  set_has_leg_ioi_qty();
  if (leg_ioi_qty_ == &::google::protobuf::internal::kEmptyString) {
    leg_ioi_qty_ = new ::std::string;
  }
  leg_ioi_qty_->assign(value);
}
inline void InstrmtLegIoiGrp::set_leg_ioi_qty(const char* value) {
  set_has_leg_ioi_qty();
  if (leg_ioi_qty_ == &::google::protobuf::internal::kEmptyString) {
    leg_ioi_qty_ = new ::std::string;
  }
  leg_ioi_qty_->assign(value);
}
inline void InstrmtLegIoiGrp::set_leg_ioi_qty(const char* value, size_t size) {
  set_has_leg_ioi_qty();
  if (leg_ioi_qty_ == &::google::protobuf::internal::kEmptyString) {
    leg_ioi_qty_ = new ::std::string;
  }
  leg_ioi_qty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrmtLegIoiGrp::mutable_leg_ioi_qty() {
  set_has_leg_ioi_qty();
  if (leg_ioi_qty_ == &::google::protobuf::internal::kEmptyString) {
    leg_ioi_qty_ = new ::std::string;
  }
  return leg_ioi_qty_;
}
inline ::std::string* InstrmtLegIoiGrp::release_leg_ioi_qty() {
  clear_has_leg_ioi_qty();
  if (leg_ioi_qty_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_ioi_qty_;
    leg_ioi_qty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrmtLegIoiGrp::set_allocated_leg_ioi_qty(::std::string* leg_ioi_qty) {
  if (leg_ioi_qty_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_ioi_qty_;
  }
  if (leg_ioi_qty) {
    set_has_leg_ioi_qty();
    leg_ioi_qty_ = leg_ioi_qty;
  } else {
    clear_has_leg_ioi_qty();
    leg_ioi_qty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.LegStipulations leg_stipulations = 3;
inline int InstrmtLegIoiGrp::leg_stipulations_size() const {
  return leg_stipulations_.size();
}
inline void InstrmtLegIoiGrp::clear_leg_stipulations() {
  leg_stipulations_.Clear();
}
inline const ::Common::LegStipulations& InstrmtLegIoiGrp::leg_stipulations(int index) const {
  return leg_stipulations_.Get(index);
}
inline ::Common::LegStipulations* InstrmtLegIoiGrp::mutable_leg_stipulations(int index) {
  return leg_stipulations_.Mutable(index);
}
inline ::Common::LegStipulations* InstrmtLegIoiGrp::add_leg_stipulations() {
  return leg_stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >&
InstrmtLegIoiGrp::leg_stipulations() const {
  return leg_stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >*
InstrmtLegIoiGrp::mutable_leg_stipulations() {
  return &leg_stipulations_;
}

// -------------------------------------------------------------------

// RoutingGrp

// optional string routing_id = 1;
inline bool RoutingGrp::has_routing_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoutingGrp::set_has_routing_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoutingGrp::clear_has_routing_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoutingGrp::clear_routing_id() {
  if (routing_id_ != &::google::protobuf::internal::kEmptyString) {
    routing_id_->clear();
  }
  clear_has_routing_id();
}
inline const ::std::string& RoutingGrp::routing_id() const {
  return *routing_id_;
}
inline void RoutingGrp::set_routing_id(const ::std::string& value) {
  set_has_routing_id();
  if (routing_id_ == &::google::protobuf::internal::kEmptyString) {
    routing_id_ = new ::std::string;
  }
  routing_id_->assign(value);
}
inline void RoutingGrp::set_routing_id(const char* value) {
  set_has_routing_id();
  if (routing_id_ == &::google::protobuf::internal::kEmptyString) {
    routing_id_ = new ::std::string;
  }
  routing_id_->assign(value);
}
inline void RoutingGrp::set_routing_id(const char* value, size_t size) {
  set_has_routing_id();
  if (routing_id_ == &::google::protobuf::internal::kEmptyString) {
    routing_id_ = new ::std::string;
  }
  routing_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoutingGrp::mutable_routing_id() {
  set_has_routing_id();
  if (routing_id_ == &::google::protobuf::internal::kEmptyString) {
    routing_id_ = new ::std::string;
  }
  return routing_id_;
}
inline ::std::string* RoutingGrp::release_routing_id() {
  clear_has_routing_id();
  if (routing_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = routing_id_;
    routing_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoutingGrp::set_allocated_routing_id(::std::string* routing_id) {
  if (routing_id_ != &::google::protobuf::internal::kEmptyString) {
    delete routing_id_;
  }
  if (routing_id) {
    set_has_routing_id();
    routing_id_ = routing_id;
  } else {
    clear_has_routing_id();
    routing_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.RoutingTypeEnum routing_type = 2;
inline bool RoutingGrp::has_routing_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoutingGrp::set_has_routing_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoutingGrp::clear_has_routing_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoutingGrp::clear_routing_type() {
  routing_type_ = 0;
  clear_has_routing_type();
}
inline ::Common::RoutingTypeEnum RoutingGrp::routing_type() const {
  return static_cast< ::Common::RoutingTypeEnum >(routing_type_);
}
inline void RoutingGrp::set_routing_type(::Common::RoutingTypeEnum value) {
  assert(::Common::RoutingTypeEnum_IsValid(value));
  set_has_routing_type();
  routing_type_ = value;
}

// -------------------------------------------------------------------

// InstrAttribTypeUnion

// optional .Common.InstrAttribTypeEnum instr_attrib_type = 1;
inline bool InstrAttribTypeUnion::has_instr_attrib_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrAttribTypeUnion::set_has_instr_attrib_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrAttribTypeUnion::clear_has_instr_attrib_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrAttribTypeUnion::clear_instr_attrib_type() {
  instr_attrib_type_ = 0;
  clear_has_instr_attrib_type();
}
inline ::Common::InstrAttribTypeEnum InstrAttribTypeUnion::instr_attrib_type() const {
  return static_cast< ::Common::InstrAttribTypeEnum >(instr_attrib_type_);
}
inline void InstrAttribTypeUnion::set_instr_attrib_type(::Common::InstrAttribTypeEnum value) {
  assert(::Common::InstrAttribTypeEnum_IsValid(value));
  set_has_instr_attrib_type();
  instr_attrib_type_ = value;
}

// optional sfixed64 instr_attrib_type_sfixed64 = 2;
inline bool InstrAttribTypeUnion::has_instr_attrib_type_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrAttribTypeUnion::set_has_instr_attrib_type_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrAttribTypeUnion::clear_has_instr_attrib_type_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrAttribTypeUnion::clear_instr_attrib_type_sfixed64() {
  instr_attrib_type_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_instr_attrib_type_sfixed64();
}
inline ::google::protobuf::int64 InstrAttribTypeUnion::instr_attrib_type_sfixed64() const {
  return instr_attrib_type_sfixed64_;
}
inline void InstrAttribTypeUnion::set_instr_attrib_type_sfixed64(::google::protobuf::int64 value) {
  set_has_instr_attrib_type_sfixed64();
  instr_attrib_type_sfixed64_ = value;
}

// -------------------------------------------------------------------

// AttrbGrp

// optional .Common.InstrAttribTypeEnum instr_attrib_type = 1;
inline bool AttrbGrp::has_instr_attrib_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AttrbGrp::set_has_instr_attrib_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AttrbGrp::clear_has_instr_attrib_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AttrbGrp::clear_instr_attrib_type() {
  instr_attrib_type_ = 0;
  clear_has_instr_attrib_type();
}
inline ::Common::InstrAttribTypeEnum AttrbGrp::instr_attrib_type() const {
  return static_cast< ::Common::InstrAttribTypeEnum >(instr_attrib_type_);
}
inline void AttrbGrp::set_instr_attrib_type(::Common::InstrAttribTypeEnum value) {
  assert(::Common::InstrAttribTypeEnum_IsValid(value));
  set_has_instr_attrib_type();
  instr_attrib_type_ = value;
}

// optional string instr_attrib_value = 2;
inline bool AttrbGrp::has_instr_attrib_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttrbGrp::set_has_instr_attrib_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttrbGrp::clear_has_instr_attrib_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttrbGrp::clear_instr_attrib_value() {
  if (instr_attrib_value_ != &::google::protobuf::internal::kEmptyString) {
    instr_attrib_value_->clear();
  }
  clear_has_instr_attrib_value();
}
inline const ::std::string& AttrbGrp::instr_attrib_value() const {
  return *instr_attrib_value_;
}
inline void AttrbGrp::set_instr_attrib_value(const ::std::string& value) {
  set_has_instr_attrib_value();
  if (instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    instr_attrib_value_ = new ::std::string;
  }
  instr_attrib_value_->assign(value);
}
inline void AttrbGrp::set_instr_attrib_value(const char* value) {
  set_has_instr_attrib_value();
  if (instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    instr_attrib_value_ = new ::std::string;
  }
  instr_attrib_value_->assign(value);
}
inline void AttrbGrp::set_instr_attrib_value(const char* value, size_t size) {
  set_has_instr_attrib_value();
  if (instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    instr_attrib_value_ = new ::std::string;
  }
  instr_attrib_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AttrbGrp::mutable_instr_attrib_value() {
  set_has_instr_attrib_value();
  if (instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    instr_attrib_value_ = new ::std::string;
  }
  return instr_attrib_value_;
}
inline ::std::string* AttrbGrp::release_instr_attrib_value() {
  clear_has_instr_attrib_value();
  if (instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = instr_attrib_value_;
    instr_attrib_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AttrbGrp::set_allocated_instr_attrib_value(::std::string* instr_attrib_value) {
  if (instr_attrib_value_ != &::google::protobuf::internal::kEmptyString) {
    delete instr_attrib_value_;
  }
  if (instr_attrib_value) {
    set_has_instr_attrib_value();
    instr_attrib_value_ = instr_attrib_value;
  } else {
    clear_has_instr_attrib_value();
    instr_attrib_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// InstrumentExtension

// repeated .Common.AttrbGrp attrb_grp = 1;
inline int InstrumentExtension::attrb_grp_size() const {
  return attrb_grp_.size();
}
inline void InstrumentExtension::clear_attrb_grp() {
  attrb_grp_.Clear();
}
inline const ::Common::AttrbGrp& InstrumentExtension::attrb_grp(int index) const {
  return attrb_grp_.Get(index);
}
inline ::Common::AttrbGrp* InstrumentExtension::mutable_attrb_grp(int index) {
  return attrb_grp_.Mutable(index);
}
inline ::Common::AttrbGrp* InstrumentExtension::add_attrb_grp() {
  return attrb_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::AttrbGrp >&
InstrumentExtension::attrb_grp() const {
  return attrb_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::AttrbGrp >*
InstrumentExtension::mutable_attrb_grp() {
  return &attrb_grp_;
}

// optional .Common.DeliveryFormEnum delivery_form = 2;
inline bool InstrumentExtension::has_delivery_form() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrumentExtension::set_has_delivery_form() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrumentExtension::clear_has_delivery_form() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrumentExtension::clear_delivery_form() {
  delivery_form_ = 0;
  clear_has_delivery_form();
}
inline ::Common::DeliveryFormEnum InstrumentExtension::delivery_form() const {
  return static_cast< ::Common::DeliveryFormEnum >(delivery_form_);
}
inline void InstrumentExtension::set_delivery_form(::Common::DeliveryFormEnum value) {
  assert(::Common::DeliveryFormEnum_IsValid(value));
  set_has_delivery_form();
  delivery_form_ = value;
}

// optional sfixed64 pct_at_risk = 3;
inline bool InstrumentExtension::has_pct_at_risk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstrumentExtension::set_has_pct_at_risk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstrumentExtension::clear_has_pct_at_risk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstrumentExtension::clear_pct_at_risk() {
  pct_at_risk_ = GOOGLE_LONGLONG(0);
  clear_has_pct_at_risk();
}
inline ::google::protobuf::int64 InstrumentExtension::pct_at_risk() const {
  return pct_at_risk_;
}
inline void InstrumentExtension::set_pct_at_risk(::google::protobuf::int64 value) {
  set_has_pct_at_risk();
  pct_at_risk_ = value;
}

// optional sfixed32 pct_at_risk_exponent = 4;
inline bool InstrumentExtension::has_pct_at_risk_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstrumentExtension::set_has_pct_at_risk_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstrumentExtension::clear_has_pct_at_risk_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstrumentExtension::clear_pct_at_risk_exponent() {
  pct_at_risk_exponent_ = 0;
  clear_has_pct_at_risk_exponent();
}
inline ::google::protobuf::int32 InstrumentExtension::pct_at_risk_exponent() const {
  return pct_at_risk_exponent_;
}
inline void InstrumentExtension::set_pct_at_risk_exponent(::google::protobuf::int32 value) {
  set_has_pct_at_risk_exponent();
  pct_at_risk_exponent_ = value;
}

// -------------------------------------------------------------------

// TickRules

// optional sfixed64 end_tick_price_range = 1;
inline bool TickRules::has_end_tick_price_range() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TickRules::set_has_end_tick_price_range() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TickRules::clear_has_end_tick_price_range() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TickRules::clear_end_tick_price_range() {
  end_tick_price_range_ = GOOGLE_LONGLONG(0);
  clear_has_end_tick_price_range();
}
inline ::google::protobuf::int64 TickRules::end_tick_price_range() const {
  return end_tick_price_range_;
}
inline void TickRules::set_end_tick_price_range(::google::protobuf::int64 value) {
  set_has_end_tick_price_range();
  end_tick_price_range_ = value;
}

// optional sfixed32 end_tick_price_range_exponent = 2;
inline bool TickRules::has_end_tick_price_range_exponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TickRules::set_has_end_tick_price_range_exponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TickRules::clear_has_end_tick_price_range_exponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TickRules::clear_end_tick_price_range_exponent() {
  end_tick_price_range_exponent_ = 0;
  clear_has_end_tick_price_range_exponent();
}
inline ::google::protobuf::int32 TickRules::end_tick_price_range_exponent() const {
  return end_tick_price_range_exponent_;
}
inline void TickRules::set_end_tick_price_range_exponent(::google::protobuf::int32 value) {
  set_has_end_tick_price_range_exponent();
  end_tick_price_range_exponent_ = value;
}

// optional sfixed64 start_tick_price_range = 3;
inline bool TickRules::has_start_tick_price_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TickRules::set_has_start_tick_price_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TickRules::clear_has_start_tick_price_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TickRules::clear_start_tick_price_range() {
  start_tick_price_range_ = GOOGLE_LONGLONG(0);
  clear_has_start_tick_price_range();
}
inline ::google::protobuf::int64 TickRules::start_tick_price_range() const {
  return start_tick_price_range_;
}
inline void TickRules::set_start_tick_price_range(::google::protobuf::int64 value) {
  set_has_start_tick_price_range();
  start_tick_price_range_ = value;
}

// optional sfixed32 start_tick_price_range_exponent = 4;
inline bool TickRules::has_start_tick_price_range_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TickRules::set_has_start_tick_price_range_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TickRules::clear_has_start_tick_price_range_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TickRules::clear_start_tick_price_range_exponent() {
  start_tick_price_range_exponent_ = 0;
  clear_has_start_tick_price_range_exponent();
}
inline ::google::protobuf::int32 TickRules::start_tick_price_range_exponent() const {
  return start_tick_price_range_exponent_;
}
inline void TickRules::set_start_tick_price_range_exponent(::google::protobuf::int32 value) {
  set_has_start_tick_price_range_exponent();
  start_tick_price_range_exponent_ = value;
}

// optional sfixed64 tick_increment = 5;
inline bool TickRules::has_tick_increment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TickRules::set_has_tick_increment() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TickRules::clear_has_tick_increment() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TickRules::clear_tick_increment() {
  tick_increment_ = GOOGLE_LONGLONG(0);
  clear_has_tick_increment();
}
inline ::google::protobuf::int64 TickRules::tick_increment() const {
  return tick_increment_;
}
inline void TickRules::set_tick_increment(::google::protobuf::int64 value) {
  set_has_tick_increment();
  tick_increment_ = value;
}

// optional sfixed32 tick_increment_exponent = 6;
inline bool TickRules::has_tick_increment_exponent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TickRules::set_has_tick_increment_exponent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TickRules::clear_has_tick_increment_exponent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TickRules::clear_tick_increment_exponent() {
  tick_increment_exponent_ = 0;
  clear_has_tick_increment_exponent();
}
inline ::google::protobuf::int32 TickRules::tick_increment_exponent() const {
  return tick_increment_exponent_;
}
inline void TickRules::set_tick_increment_exponent(::google::protobuf::int32 value) {
  set_has_tick_increment_exponent();
  tick_increment_exponent_ = value;
}

// optional .Common.TickRuleTypeEnum tick_rule_type = 7;
inline bool TickRules::has_tick_rule_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TickRules::set_has_tick_rule_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TickRules::clear_has_tick_rule_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TickRules::clear_tick_rule_type() {
  tick_rule_type_ = 0;
  clear_has_tick_rule_type();
}
inline ::Common::TickRuleTypeEnum TickRules::tick_rule_type() const {
  return static_cast< ::Common::TickRuleTypeEnum >(tick_rule_type_);
}
inline void TickRules::set_tick_rule_type(::Common::TickRuleTypeEnum value) {
  assert(::Common::TickRuleTypeEnum_IsValid(value));
  set_has_tick_rule_type();
  tick_rule_type_ = value;
}

// -------------------------------------------------------------------

// LotTypeRules

// optional .Common.LotTypeEnum lot_type = 1;
inline bool LotTypeRules::has_lot_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LotTypeRules::set_has_lot_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LotTypeRules::clear_has_lot_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LotTypeRules::clear_lot_type() {
  lot_type_ = 0;
  clear_has_lot_type();
}
inline ::Common::LotTypeEnum LotTypeRules::lot_type() const {
  return static_cast< ::Common::LotTypeEnum >(lot_type_);
}
inline void LotTypeRules::set_lot_type(::Common::LotTypeEnum value) {
  assert(::Common::LotTypeEnum_IsValid(value));
  set_has_lot_type();
  lot_type_ = value;
}

// optional sfixed64 min_lot_size = 2;
inline bool LotTypeRules::has_min_lot_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LotTypeRules::set_has_min_lot_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LotTypeRules::clear_has_min_lot_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LotTypeRules::clear_min_lot_size() {
  min_lot_size_ = GOOGLE_LONGLONG(0);
  clear_has_min_lot_size();
}
inline ::google::protobuf::int64 LotTypeRules::min_lot_size() const {
  return min_lot_size_;
}
inline void LotTypeRules::set_min_lot_size(::google::protobuf::int64 value) {
  set_has_min_lot_size();
  min_lot_size_ = value;
}

// optional sfixed32 min_lot_size_exponent = 3;
inline bool LotTypeRules::has_min_lot_size_exponent() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LotTypeRules::set_has_min_lot_size_exponent() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LotTypeRules::clear_has_min_lot_size_exponent() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LotTypeRules::clear_min_lot_size_exponent() {
  min_lot_size_exponent_ = 0;
  clear_has_min_lot_size_exponent();
}
inline ::google::protobuf::int32 LotTypeRules::min_lot_size_exponent() const {
  return min_lot_size_exponent_;
}
inline void LotTypeRules::set_min_lot_size_exponent(::google::protobuf::int32 value) {
  set_has_min_lot_size_exponent();
  min_lot_size_exponent_ = value;
}

// -------------------------------------------------------------------

// PriceLimits

// optional sfixed64 high_limit_price = 1;
inline bool PriceLimits::has_high_limit_price() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PriceLimits::set_has_high_limit_price() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PriceLimits::clear_has_high_limit_price() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PriceLimits::clear_high_limit_price() {
  high_limit_price_ = GOOGLE_LONGLONG(0);
  clear_has_high_limit_price();
}
inline ::google::protobuf::int64 PriceLimits::high_limit_price() const {
  return high_limit_price_;
}
inline void PriceLimits::set_high_limit_price(::google::protobuf::int64 value) {
  set_has_high_limit_price();
  high_limit_price_ = value;
}

// optional sfixed32 high_limit_price_exponent = 2;
inline bool PriceLimits::has_high_limit_price_exponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PriceLimits::set_has_high_limit_price_exponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PriceLimits::clear_has_high_limit_price_exponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PriceLimits::clear_high_limit_price_exponent() {
  high_limit_price_exponent_ = 0;
  clear_has_high_limit_price_exponent();
}
inline ::google::protobuf::int32 PriceLimits::high_limit_price_exponent() const {
  return high_limit_price_exponent_;
}
inline void PriceLimits::set_high_limit_price_exponent(::google::protobuf::int32 value) {
  set_has_high_limit_price_exponent();
  high_limit_price_exponent_ = value;
}

// optional sfixed64 low_limit_price = 3;
inline bool PriceLimits::has_low_limit_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PriceLimits::set_has_low_limit_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PriceLimits::clear_has_low_limit_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PriceLimits::clear_low_limit_price() {
  low_limit_price_ = GOOGLE_LONGLONG(0);
  clear_has_low_limit_price();
}
inline ::google::protobuf::int64 PriceLimits::low_limit_price() const {
  return low_limit_price_;
}
inline void PriceLimits::set_low_limit_price(::google::protobuf::int64 value) {
  set_has_low_limit_price();
  low_limit_price_ = value;
}

// optional sfixed32 low_limit_price_exponent = 4;
inline bool PriceLimits::has_low_limit_price_exponent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PriceLimits::set_has_low_limit_price_exponent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PriceLimits::clear_has_low_limit_price_exponent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PriceLimits::clear_low_limit_price_exponent() {
  low_limit_price_exponent_ = 0;
  clear_has_low_limit_price_exponent();
}
inline ::google::protobuf::int32 PriceLimits::low_limit_price_exponent() const {
  return low_limit_price_exponent_;
}
inline void PriceLimits::set_low_limit_price_exponent(::google::protobuf::int32 value) {
  set_has_low_limit_price_exponent();
  low_limit_price_exponent_ = value;
}

// optional .Common.PriceLimitTypeEnum price_limit_type = 5;
inline bool PriceLimits::has_price_limit_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PriceLimits::set_has_price_limit_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PriceLimits::clear_has_price_limit_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PriceLimits::clear_price_limit_type() {
  price_limit_type_ = 0;
  clear_has_price_limit_type();
}
inline ::Common::PriceLimitTypeEnum PriceLimits::price_limit_type() const {
  return static_cast< ::Common::PriceLimitTypeEnum >(price_limit_type_);
}
inline void PriceLimits::set_price_limit_type(::Common::PriceLimitTypeEnum value) {
  assert(::Common::PriceLimitTypeEnum_IsValid(value));
  set_has_price_limit_type();
  price_limit_type_ = value;
}

// optional sfixed64 trading_reference_price = 6;
inline bool PriceLimits::has_trading_reference_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PriceLimits::set_has_trading_reference_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PriceLimits::clear_has_trading_reference_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PriceLimits::clear_trading_reference_price() {
  trading_reference_price_ = GOOGLE_LONGLONG(0);
  clear_has_trading_reference_price();
}
inline ::google::protobuf::int64 PriceLimits::trading_reference_price() const {
  return trading_reference_price_;
}
inline void PriceLimits::set_trading_reference_price(::google::protobuf::int64 value) {
  set_has_trading_reference_price();
  trading_reference_price_ = value;
}

// optional sfixed32 trading_reference_price_exponent = 7;
inline bool PriceLimits::has_trading_reference_price_exponent() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PriceLimits::set_has_trading_reference_price_exponent() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PriceLimits::clear_has_trading_reference_price_exponent() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PriceLimits::clear_trading_reference_price_exponent() {
  trading_reference_price_exponent_ = 0;
  clear_has_trading_reference_price_exponent();
}
inline ::google::protobuf::int32 PriceLimits::trading_reference_price_exponent() const {
  return trading_reference_price_exponent_;
}
inline void PriceLimits::set_trading_reference_price_exponent(::google::protobuf::int32 value) {
  set_has_trading_reference_price_exponent();
  trading_reference_price_exponent_ = value;
}

// -------------------------------------------------------------------

// BaseTradingRules

// optional .Common.ExpirationCycleEnum expiration_cycle = 1;
inline bool BaseTradingRules::has_expiration_cycle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BaseTradingRules::set_has_expiration_cycle() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BaseTradingRules::clear_has_expiration_cycle() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BaseTradingRules::clear_expiration_cycle() {
  expiration_cycle_ = 0;
  clear_has_expiration_cycle();
}
inline ::Common::ExpirationCycleEnum BaseTradingRules::expiration_cycle() const {
  return static_cast< ::Common::ExpirationCycleEnum >(expiration_cycle_);
}
inline void BaseTradingRules::set_expiration_cycle(::Common::ExpirationCycleEnum value) {
  assert(::Common::ExpirationCycleEnum_IsValid(value));
  set_has_expiration_cycle();
  expiration_cycle_ = value;
}

// optional .Common.ImpliedMarketIndicatorEnum implied_market_indicator = 2;
inline bool BaseTradingRules::has_implied_market_indicator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BaseTradingRules::set_has_implied_market_indicator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BaseTradingRules::clear_has_implied_market_indicator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BaseTradingRules::clear_implied_market_indicator() {
  implied_market_indicator_ = 0;
  clear_has_implied_market_indicator();
}
inline ::Common::ImpliedMarketIndicatorEnum BaseTradingRules::implied_market_indicator() const {
  return static_cast< ::Common::ImpliedMarketIndicatorEnum >(implied_market_indicator_);
}
inline void BaseTradingRules::set_implied_market_indicator(::Common::ImpliedMarketIndicatorEnum value) {
  assert(::Common::ImpliedMarketIndicatorEnum_IsValid(value));
  set_has_implied_market_indicator();
  implied_market_indicator_ = value;
}

// repeated .Common.LotTypeRules lot_type_rules = 3;
inline int BaseTradingRules::lot_type_rules_size() const {
  return lot_type_rules_.size();
}
inline void BaseTradingRules::clear_lot_type_rules() {
  lot_type_rules_.Clear();
}
inline const ::Common::LotTypeRules& BaseTradingRules::lot_type_rules(int index) const {
  return lot_type_rules_.Get(index);
}
inline ::Common::LotTypeRules* BaseTradingRules::mutable_lot_type_rules(int index) {
  return lot_type_rules_.Mutable(index);
}
inline ::Common::LotTypeRules* BaseTradingRules::add_lot_type_rules() {
  return lot_type_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::LotTypeRules >&
BaseTradingRules::lot_type_rules() const {
  return lot_type_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::LotTypeRules >*
BaseTradingRules::mutable_lot_type_rules() {
  return &lot_type_rules_;
}

// optional double max_price_variation = 4;
inline bool BaseTradingRules::has_max_price_variation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BaseTradingRules::set_has_max_price_variation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BaseTradingRules::clear_has_max_price_variation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BaseTradingRules::clear_max_price_variation() {
  max_price_variation_ = 0;
  clear_has_max_price_variation();
}
inline double BaseTradingRules::max_price_variation() const {
  return max_price_variation_;
}
inline void BaseTradingRules::set_max_price_variation(double value) {
  set_has_max_price_variation();
  max_price_variation_ = value;
}

// optional sfixed64 max_trade_vol = 5;
inline bool BaseTradingRules::has_max_trade_vol() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BaseTradingRules::set_has_max_trade_vol() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BaseTradingRules::clear_has_max_trade_vol() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BaseTradingRules::clear_max_trade_vol() {
  max_trade_vol_ = GOOGLE_LONGLONG(0);
  clear_has_max_trade_vol();
}
inline ::google::protobuf::int64 BaseTradingRules::max_trade_vol() const {
  return max_trade_vol_;
}
inline void BaseTradingRules::set_max_trade_vol(::google::protobuf::int64 value) {
  set_has_max_trade_vol();
  max_trade_vol_ = value;
}

// optional sfixed32 max_trade_vol_exponent = 6;
inline bool BaseTradingRules::has_max_trade_vol_exponent() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BaseTradingRules::set_has_max_trade_vol_exponent() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BaseTradingRules::clear_has_max_trade_vol_exponent() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BaseTradingRules::clear_max_trade_vol_exponent() {
  max_trade_vol_exponent_ = 0;
  clear_has_max_trade_vol_exponent();
}
inline ::google::protobuf::int32 BaseTradingRules::max_trade_vol_exponent() const {
  return max_trade_vol_exponent_;
}
inline void BaseTradingRules::set_max_trade_vol_exponent(::google::protobuf::int32 value) {
  set_has_max_trade_vol_exponent();
  max_trade_vol_exponent_ = value;
}

// optional sfixed64 min_trade_vol = 7;
inline bool BaseTradingRules::has_min_trade_vol() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BaseTradingRules::set_has_min_trade_vol() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BaseTradingRules::clear_has_min_trade_vol() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BaseTradingRules::clear_min_trade_vol() {
  min_trade_vol_ = GOOGLE_LONGLONG(0);
  clear_has_min_trade_vol();
}
inline ::google::protobuf::int64 BaseTradingRules::min_trade_vol() const {
  return min_trade_vol_;
}
inline void BaseTradingRules::set_min_trade_vol(::google::protobuf::int64 value) {
  set_has_min_trade_vol();
  min_trade_vol_ = value;
}

// optional sfixed32 min_trade_vol_exponent = 8;
inline bool BaseTradingRules::has_min_trade_vol_exponent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BaseTradingRules::set_has_min_trade_vol_exponent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BaseTradingRules::clear_has_min_trade_vol_exponent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BaseTradingRules::clear_min_trade_vol_exponent() {
  min_trade_vol_exponent_ = 0;
  clear_has_min_trade_vol_exponent();
}
inline ::google::protobuf::int32 BaseTradingRules::min_trade_vol_exponent() const {
  return min_trade_vol_exponent_;
}
inline void BaseTradingRules::set_min_trade_vol_exponent(::google::protobuf::int32 value) {
  set_has_min_trade_vol_exponent();
  min_trade_vol_exponent_ = value;
}

// optional .Common.MultilegModelEnum multileg_model = 9;
inline bool BaseTradingRules::has_multileg_model() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BaseTradingRules::set_has_multileg_model() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BaseTradingRules::clear_has_multileg_model() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BaseTradingRules::clear_multileg_model() {
  multileg_model_ = 0;
  clear_has_multileg_model();
}
inline ::Common::MultilegModelEnum BaseTradingRules::multileg_model() const {
  return static_cast< ::Common::MultilegModelEnum >(multileg_model_);
}
inline void BaseTradingRules::set_multileg_model(::Common::MultilegModelEnum value) {
  assert(::Common::MultilegModelEnum_IsValid(value));
  set_has_multileg_model();
  multileg_model_ = value;
}

// optional .Common.MultilegPriceMethodEnum multileg_price_method = 10;
inline bool BaseTradingRules::has_multileg_price_method() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BaseTradingRules::set_has_multileg_price_method() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BaseTradingRules::clear_has_multileg_price_method() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BaseTradingRules::clear_multileg_price_method() {
  multileg_price_method_ = 0;
  clear_has_multileg_price_method();
}
inline ::Common::MultilegPriceMethodEnum BaseTradingRules::multileg_price_method() const {
  return static_cast< ::Common::MultilegPriceMethodEnum >(multileg_price_method_);
}
inline void BaseTradingRules::set_multileg_price_method(::Common::MultilegPriceMethodEnum value) {
  assert(::Common::MultilegPriceMethodEnum_IsValid(value));
  set_has_multileg_price_method();
  multileg_price_method_ = value;
}

// optional .Common.PriceLimits price_limits = 11;
inline bool BaseTradingRules::has_price_limits() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BaseTradingRules::set_has_price_limits() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BaseTradingRules::clear_has_price_limits() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BaseTradingRules::clear_price_limits() {
  if (price_limits_ != NULL) price_limits_->::Common::PriceLimits::Clear();
  clear_has_price_limits();
}
inline const ::Common::PriceLimits& BaseTradingRules::price_limits() const {
  return price_limits_ != NULL ? *price_limits_ : *default_instance_->price_limits_;
}
inline ::Common::PriceLimits* BaseTradingRules::mutable_price_limits() {
  set_has_price_limits();
  if (price_limits_ == NULL) price_limits_ = new ::Common::PriceLimits;
  return price_limits_;
}
inline ::Common::PriceLimits* BaseTradingRules::release_price_limits() {
  clear_has_price_limits();
  ::Common::PriceLimits* temp = price_limits_;
  price_limits_ = NULL;
  return temp;
}
inline void BaseTradingRules::set_allocated_price_limits(::Common::PriceLimits* price_limits) {
  delete price_limits_;
  price_limits_ = price_limits;
  if (price_limits) {
    set_has_price_limits();
  } else {
    clear_has_price_limits();
  }
}

// optional .Common.PriceTypeEnum price_type = 12;
inline bool BaseTradingRules::has_price_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BaseTradingRules::set_has_price_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BaseTradingRules::clear_has_price_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BaseTradingRules::clear_price_type() {
  price_type_ = 0;
  clear_has_price_type();
}
inline ::Common::PriceTypeEnum BaseTradingRules::price_type() const {
  return static_cast< ::Common::PriceTypeEnum >(price_type_);
}
inline void BaseTradingRules::set_price_type(::Common::PriceTypeEnum value) {
  assert(::Common::PriceTypeEnum_IsValid(value));
  set_has_price_type();
  price_type_ = value;
}

// optional sfixed64 round_lot = 13;
inline bool BaseTradingRules::has_round_lot() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BaseTradingRules::set_has_round_lot() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BaseTradingRules::clear_has_round_lot() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BaseTradingRules::clear_round_lot() {
  round_lot_ = GOOGLE_LONGLONG(0);
  clear_has_round_lot();
}
inline ::google::protobuf::int64 BaseTradingRules::round_lot() const {
  return round_lot_;
}
inline void BaseTradingRules::set_round_lot(::google::protobuf::int64 value) {
  set_has_round_lot();
  round_lot_ = value;
}

// optional sfixed32 round_lot_exponent = 14;
inline bool BaseTradingRules::has_round_lot_exponent() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BaseTradingRules::set_has_round_lot_exponent() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BaseTradingRules::clear_has_round_lot_exponent() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BaseTradingRules::clear_round_lot_exponent() {
  round_lot_exponent_ = 0;
  clear_has_round_lot_exponent();
}
inline ::google::protobuf::int32 BaseTradingRules::round_lot_exponent() const {
  return round_lot_exponent_;
}
inline void BaseTradingRules::set_round_lot_exponent(::google::protobuf::int32 value) {
  set_has_round_lot_exponent();
  round_lot_exponent_ = value;
}

// repeated .Common.TickRules tick_rules = 15;
inline int BaseTradingRules::tick_rules_size() const {
  return tick_rules_.size();
}
inline void BaseTradingRules::clear_tick_rules() {
  tick_rules_.Clear();
}
inline const ::Common::TickRules& BaseTradingRules::tick_rules(int index) const {
  return tick_rules_.Get(index);
}
inline ::Common::TickRules* BaseTradingRules::mutable_tick_rules(int index) {
  return tick_rules_.Mutable(index);
}
inline ::Common::TickRules* BaseTradingRules::add_tick_rules() {
  return tick_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::TickRules >&
BaseTradingRules::tick_rules() const {
  return tick_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::TickRules >*
BaseTradingRules::mutable_tick_rules() {
  return &tick_rules_;
}

// optional string trading_currency = 16;
inline bool BaseTradingRules::has_trading_currency() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BaseTradingRules::set_has_trading_currency() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BaseTradingRules::clear_has_trading_currency() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BaseTradingRules::clear_trading_currency() {
  if (trading_currency_ != &::google::protobuf::internal::kEmptyString) {
    trading_currency_->clear();
  }
  clear_has_trading_currency();
}
inline const ::std::string& BaseTradingRules::trading_currency() const {
  return *trading_currency_;
}
inline void BaseTradingRules::set_trading_currency(const ::std::string& value) {
  set_has_trading_currency();
  if (trading_currency_ == &::google::protobuf::internal::kEmptyString) {
    trading_currency_ = new ::std::string;
  }
  trading_currency_->assign(value);
}
inline void BaseTradingRules::set_trading_currency(const char* value) {
  set_has_trading_currency();
  if (trading_currency_ == &::google::protobuf::internal::kEmptyString) {
    trading_currency_ = new ::std::string;
  }
  trading_currency_->assign(value);
}
inline void BaseTradingRules::set_trading_currency(const char* value, size_t size) {
  set_has_trading_currency();
  if (trading_currency_ == &::google::protobuf::internal::kEmptyString) {
    trading_currency_ = new ::std::string;
  }
  trading_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BaseTradingRules::mutable_trading_currency() {
  set_has_trading_currency();
  if (trading_currency_ == &::google::protobuf::internal::kEmptyString) {
    trading_currency_ = new ::std::string;
  }
  return trading_currency_;
}
inline ::std::string* BaseTradingRules::release_trading_currency() {
  clear_has_trading_currency();
  if (trading_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trading_currency_;
    trading_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BaseTradingRules::set_allocated_trading_currency(::std::string* trading_currency) {
  if (trading_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete trading_currency_;
  }
  if (trading_currency) {
    set_has_trading_currency();
    trading_currency_ = trading_currency;
  } else {
    clear_has_trading_currency();
    trading_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// OrdTypeRules

// optional .Common.OrdTypeEnum ord_type = 1;
inline bool OrdTypeRules::has_ord_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OrdTypeRules::set_has_ord_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OrdTypeRules::clear_has_ord_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OrdTypeRules::clear_ord_type() {
  ord_type_ = 0;
  clear_has_ord_type();
}
inline ::Common::OrdTypeEnum OrdTypeRules::ord_type() const {
  return static_cast< ::Common::OrdTypeEnum >(ord_type_);
}
inline void OrdTypeRules::set_ord_type(::Common::OrdTypeEnum value) {
  assert(::Common::OrdTypeEnum_IsValid(value));
  set_has_ord_type();
  ord_type_ = value;
}

// -------------------------------------------------------------------

// TimeInForceRules

// optional .Common.TimeInForceEnum time_in_force = 1;
inline bool TimeInForceRules::has_time_in_force() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeInForceRules::set_has_time_in_force() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeInForceRules::clear_has_time_in_force() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeInForceRules::clear_time_in_force() {
  time_in_force_ = 0;
  clear_has_time_in_force();
}
inline ::Common::TimeInForceEnum TimeInForceRules::time_in_force() const {
  return static_cast< ::Common::TimeInForceEnum >(time_in_force_);
}
inline void TimeInForceRules::set_time_in_force(::Common::TimeInForceEnum value) {
  assert(::Common::TimeInForceEnum_IsValid(value));
  set_has_time_in_force();
  time_in_force_ = value;
}

// -------------------------------------------------------------------

// ExecInstRules

// optional string exec_inst_value = 1;
inline bool ExecInstRules::has_exec_inst_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecInstRules::set_has_exec_inst_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecInstRules::clear_has_exec_inst_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecInstRules::clear_exec_inst_value() {
  if (exec_inst_value_ != &::google::protobuf::internal::kEmptyString) {
    exec_inst_value_->clear();
  }
  clear_has_exec_inst_value();
}
inline const ::std::string& ExecInstRules::exec_inst_value() const {
  return *exec_inst_value_;
}
inline void ExecInstRules::set_exec_inst_value(const ::std::string& value) {
  set_has_exec_inst_value();
  if (exec_inst_value_ == &::google::protobuf::internal::kEmptyString) {
    exec_inst_value_ = new ::std::string;
  }
  exec_inst_value_->assign(value);
}
inline void ExecInstRules::set_exec_inst_value(const char* value) {
  set_has_exec_inst_value();
  if (exec_inst_value_ == &::google::protobuf::internal::kEmptyString) {
    exec_inst_value_ = new ::std::string;
  }
  exec_inst_value_->assign(value);
}
inline void ExecInstRules::set_exec_inst_value(const char* value, size_t size) {
  set_has_exec_inst_value();
  if (exec_inst_value_ == &::google::protobuf::internal::kEmptyString) {
    exec_inst_value_ = new ::std::string;
  }
  exec_inst_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExecInstRules::mutable_exec_inst_value() {
  set_has_exec_inst_value();
  if (exec_inst_value_ == &::google::protobuf::internal::kEmptyString) {
    exec_inst_value_ = new ::std::string;
  }
  return exec_inst_value_;
}
inline ::std::string* ExecInstRules::release_exec_inst_value() {
  clear_has_exec_inst_value();
  if (exec_inst_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = exec_inst_value_;
    exec_inst_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExecInstRules::set_allocated_exec_inst_value(::std::string* exec_inst_value) {
  if (exec_inst_value_ != &::google::protobuf::internal::kEmptyString) {
    delete exec_inst_value_;
  }
  if (exec_inst_value) {
    set_has_exec_inst_value();
    exec_inst_value_ = exec_inst_value;
  } else {
    clear_has_exec_inst_value();
    exec_inst_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MatchRules

// optional string match_algorithm = 1;
inline bool MatchRules::has_match_algorithm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchRules::set_has_match_algorithm() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchRules::clear_has_match_algorithm() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchRules::clear_match_algorithm() {
  if (match_algorithm_ != &::google::protobuf::internal::kEmptyString) {
    match_algorithm_->clear();
  }
  clear_has_match_algorithm();
}
inline const ::std::string& MatchRules::match_algorithm() const {
  return *match_algorithm_;
}
inline void MatchRules::set_match_algorithm(const ::std::string& value) {
  set_has_match_algorithm();
  if (match_algorithm_ == &::google::protobuf::internal::kEmptyString) {
    match_algorithm_ = new ::std::string;
  }
  match_algorithm_->assign(value);
}
inline void MatchRules::set_match_algorithm(const char* value) {
  set_has_match_algorithm();
  if (match_algorithm_ == &::google::protobuf::internal::kEmptyString) {
    match_algorithm_ = new ::std::string;
  }
  match_algorithm_->assign(value);
}
inline void MatchRules::set_match_algorithm(const char* value, size_t size) {
  set_has_match_algorithm();
  if (match_algorithm_ == &::google::protobuf::internal::kEmptyString) {
    match_algorithm_ = new ::std::string;
  }
  match_algorithm_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchRules::mutable_match_algorithm() {
  set_has_match_algorithm();
  if (match_algorithm_ == &::google::protobuf::internal::kEmptyString) {
    match_algorithm_ = new ::std::string;
  }
  return match_algorithm_;
}
inline ::std::string* MatchRules::release_match_algorithm() {
  clear_has_match_algorithm();
  if (match_algorithm_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = match_algorithm_;
    match_algorithm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchRules::set_allocated_match_algorithm(::std::string* match_algorithm) {
  if (match_algorithm_ != &::google::protobuf::internal::kEmptyString) {
    delete match_algorithm_;
  }
  if (match_algorithm) {
    set_has_match_algorithm();
    match_algorithm_ = match_algorithm;
  } else {
    clear_has_match_algorithm();
    match_algorithm_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.MatchTypeEnum match_type = 2;
inline bool MatchRules::has_match_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchRules::set_has_match_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchRules::clear_has_match_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchRules::clear_match_type() {
  match_type_ = 0;
  clear_has_match_type();
}
inline ::Common::MatchTypeEnum MatchRules::match_type() const {
  return static_cast< ::Common::MatchTypeEnum >(match_type_);
}
inline void MatchRules::set_match_type(::Common::MatchTypeEnum value) {
  assert(::Common::MatchTypeEnum_IsValid(value));
  set_has_match_type();
  match_type_ = value;
}

// -------------------------------------------------------------------

// MarketDataFeedTypes

// optional .Common.MdBookTypeEnum md_book_type = 1;
inline bool MarketDataFeedTypes::has_md_book_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketDataFeedTypes::set_has_md_book_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketDataFeedTypes::clear_has_md_book_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketDataFeedTypes::clear_md_book_type() {
  md_book_type_ = 0;
  clear_has_md_book_type();
}
inline ::Common::MdBookTypeEnum MarketDataFeedTypes::md_book_type() const {
  return static_cast< ::Common::MdBookTypeEnum >(md_book_type_);
}
inline void MarketDataFeedTypes::set_md_book_type(::Common::MdBookTypeEnum value) {
  assert(::Common::MdBookTypeEnum_IsValid(value));
  set_has_md_book_type();
  md_book_type_ = value;
}

// optional string md_feed_type = 2;
inline bool MarketDataFeedTypes::has_md_feed_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketDataFeedTypes::set_has_md_feed_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketDataFeedTypes::clear_has_md_feed_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketDataFeedTypes::clear_md_feed_type() {
  if (md_feed_type_ != &::google::protobuf::internal::kEmptyString) {
    md_feed_type_->clear();
  }
  clear_has_md_feed_type();
}
inline const ::std::string& MarketDataFeedTypes::md_feed_type() const {
  return *md_feed_type_;
}
inline void MarketDataFeedTypes::set_md_feed_type(const ::std::string& value) {
  set_has_md_feed_type();
  if (md_feed_type_ == &::google::protobuf::internal::kEmptyString) {
    md_feed_type_ = new ::std::string;
  }
  md_feed_type_->assign(value);
}
inline void MarketDataFeedTypes::set_md_feed_type(const char* value) {
  set_has_md_feed_type();
  if (md_feed_type_ == &::google::protobuf::internal::kEmptyString) {
    md_feed_type_ = new ::std::string;
  }
  md_feed_type_->assign(value);
}
inline void MarketDataFeedTypes::set_md_feed_type(const char* value, size_t size) {
  set_has_md_feed_type();
  if (md_feed_type_ == &::google::protobuf::internal::kEmptyString) {
    md_feed_type_ = new ::std::string;
  }
  md_feed_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketDataFeedTypes::mutable_md_feed_type() {
  set_has_md_feed_type();
  if (md_feed_type_ == &::google::protobuf::internal::kEmptyString) {
    md_feed_type_ = new ::std::string;
  }
  return md_feed_type_;
}
inline ::std::string* MarketDataFeedTypes::release_md_feed_type() {
  clear_has_md_feed_type();
  if (md_feed_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = md_feed_type_;
    md_feed_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketDataFeedTypes::set_allocated_md_feed_type(::std::string* md_feed_type) {
  if (md_feed_type_ != &::google::protobuf::internal::kEmptyString) {
    delete md_feed_type_;
  }
  if (md_feed_type) {
    set_has_md_feed_type();
    md_feed_type_ = md_feed_type;
  } else {
    clear_has_md_feed_type();
    md_feed_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 market_depth = 3;
inline bool MarketDataFeedTypes::has_market_depth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketDataFeedTypes::set_has_market_depth() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketDataFeedTypes::clear_has_market_depth() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketDataFeedTypes::clear_market_depth() {
  market_depth_ = GOOGLE_LONGLONG(0);
  clear_has_market_depth();
}
inline ::google::protobuf::int64 MarketDataFeedTypes::market_depth() const {
  return market_depth_;
}
inline void MarketDataFeedTypes::set_market_depth(::google::protobuf::int64 value) {
  set_has_market_depth();
  market_depth_ = value;
}

// -------------------------------------------------------------------

// TradingSessionRules

// repeated .Common.ExecInstRules exec_inst_rules = 1;
inline int TradingSessionRules::exec_inst_rules_size() const {
  return exec_inst_rules_.size();
}
inline void TradingSessionRules::clear_exec_inst_rules() {
  exec_inst_rules_.Clear();
}
inline const ::Common::ExecInstRules& TradingSessionRules::exec_inst_rules(int index) const {
  return exec_inst_rules_.Get(index);
}
inline ::Common::ExecInstRules* TradingSessionRules::mutable_exec_inst_rules(int index) {
  return exec_inst_rules_.Mutable(index);
}
inline ::Common::ExecInstRules* TradingSessionRules::add_exec_inst_rules() {
  return exec_inst_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::ExecInstRules >&
TradingSessionRules::exec_inst_rules() const {
  return exec_inst_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::ExecInstRules >*
TradingSessionRules::mutable_exec_inst_rules() {
  return &exec_inst_rules_;
}

// repeated .Common.MarketDataFeedTypes market_data_feed_types = 2;
inline int TradingSessionRules::market_data_feed_types_size() const {
  return market_data_feed_types_.size();
}
inline void TradingSessionRules::clear_market_data_feed_types() {
  market_data_feed_types_.Clear();
}
inline const ::Common::MarketDataFeedTypes& TradingSessionRules::market_data_feed_types(int index) const {
  return market_data_feed_types_.Get(index);
}
inline ::Common::MarketDataFeedTypes* TradingSessionRules::mutable_market_data_feed_types(int index) {
  return market_data_feed_types_.Mutable(index);
}
inline ::Common::MarketDataFeedTypes* TradingSessionRules::add_market_data_feed_types() {
  return market_data_feed_types_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::MarketDataFeedTypes >&
TradingSessionRules::market_data_feed_types() const {
  return market_data_feed_types_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::MarketDataFeedTypes >*
TradingSessionRules::mutable_market_data_feed_types() {
  return &market_data_feed_types_;
}

// repeated .Common.MatchRules match_rules = 3;
inline int TradingSessionRules::match_rules_size() const {
  return match_rules_.size();
}
inline void TradingSessionRules::clear_match_rules() {
  match_rules_.Clear();
}
inline const ::Common::MatchRules& TradingSessionRules::match_rules(int index) const {
  return match_rules_.Get(index);
}
inline ::Common::MatchRules* TradingSessionRules::mutable_match_rules(int index) {
  return match_rules_.Mutable(index);
}
inline ::Common::MatchRules* TradingSessionRules::add_match_rules() {
  return match_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::MatchRules >&
TradingSessionRules::match_rules() const {
  return match_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::MatchRules >*
TradingSessionRules::mutable_match_rules() {
  return &match_rules_;
}

// repeated .Common.OrdTypeRules ord_type_rules = 4;
inline int TradingSessionRules::ord_type_rules_size() const {
  return ord_type_rules_.size();
}
inline void TradingSessionRules::clear_ord_type_rules() {
  ord_type_rules_.Clear();
}
inline const ::Common::OrdTypeRules& TradingSessionRules::ord_type_rules(int index) const {
  return ord_type_rules_.Get(index);
}
inline ::Common::OrdTypeRules* TradingSessionRules::mutable_ord_type_rules(int index) {
  return ord_type_rules_.Mutable(index);
}
inline ::Common::OrdTypeRules* TradingSessionRules::add_ord_type_rules() {
  return ord_type_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::OrdTypeRules >&
TradingSessionRules::ord_type_rules() const {
  return ord_type_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::OrdTypeRules >*
TradingSessionRules::mutable_ord_type_rules() {
  return &ord_type_rules_;
}

// repeated .Common.TimeInForceRules time_in_force_rules = 5;
inline int TradingSessionRules::time_in_force_rules_size() const {
  return time_in_force_rules_.size();
}
inline void TradingSessionRules::clear_time_in_force_rules() {
  time_in_force_rules_.Clear();
}
inline const ::Common::TimeInForceRules& TradingSessionRules::time_in_force_rules(int index) const {
  return time_in_force_rules_.Get(index);
}
inline ::Common::TimeInForceRules* TradingSessionRules::mutable_time_in_force_rules(int index) {
  return time_in_force_rules_.Mutable(index);
}
inline ::Common::TimeInForceRules* TradingSessionRules::add_time_in_force_rules() {
  return time_in_force_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::TimeInForceRules >&
TradingSessionRules::time_in_force_rules() const {
  return time_in_force_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::TimeInForceRules >*
TradingSessionRules::mutable_time_in_force_rules() {
  return &time_in_force_rules_;
}

// -------------------------------------------------------------------

// TradingSessionRulesGrp

// optional .Common.TradingSessionIdEnum trading_session_id = 1;
inline bool TradingSessionRulesGrp::has_trading_session_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TradingSessionRulesGrp::set_has_trading_session_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TradingSessionRulesGrp::clear_has_trading_session_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TradingSessionRulesGrp::clear_trading_session_id() {
  trading_session_id_ = 0;
  clear_has_trading_session_id();
}
inline ::Common::TradingSessionIdEnum TradingSessionRulesGrp::trading_session_id() const {
  return static_cast< ::Common::TradingSessionIdEnum >(trading_session_id_);
}
inline void TradingSessionRulesGrp::set_trading_session_id(::Common::TradingSessionIdEnum value) {
  assert(::Common::TradingSessionIdEnum_IsValid(value));
  set_has_trading_session_id();
  trading_session_id_ = value;
}

// optional .Common.TradingSessionRules trading_session_rules = 2;
inline bool TradingSessionRulesGrp::has_trading_session_rules() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradingSessionRulesGrp::set_has_trading_session_rules() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradingSessionRulesGrp::clear_has_trading_session_rules() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradingSessionRulesGrp::clear_trading_session_rules() {
  if (trading_session_rules_ != NULL) trading_session_rules_->::Common::TradingSessionRules::Clear();
  clear_has_trading_session_rules();
}
inline const ::Common::TradingSessionRules& TradingSessionRulesGrp::trading_session_rules() const {
  return trading_session_rules_ != NULL ? *trading_session_rules_ : *default_instance_->trading_session_rules_;
}
inline ::Common::TradingSessionRules* TradingSessionRulesGrp::mutable_trading_session_rules() {
  set_has_trading_session_rules();
  if (trading_session_rules_ == NULL) trading_session_rules_ = new ::Common::TradingSessionRules;
  return trading_session_rules_;
}
inline ::Common::TradingSessionRules* TradingSessionRulesGrp::release_trading_session_rules() {
  clear_has_trading_session_rules();
  ::Common::TradingSessionRules* temp = trading_session_rules_;
  trading_session_rules_ = NULL;
  return temp;
}
inline void TradingSessionRulesGrp::set_allocated_trading_session_rules(::Common::TradingSessionRules* trading_session_rules) {
  delete trading_session_rules_;
  trading_session_rules_ = trading_session_rules;
  if (trading_session_rules) {
    set_has_trading_session_rules();
  } else {
    clear_has_trading_session_rules();
  }
}

// optional .Common.TradingSessionSubIdEnum trading_session_sub_id = 3;
inline bool TradingSessionRulesGrp::has_trading_session_sub_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TradingSessionRulesGrp::set_has_trading_session_sub_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TradingSessionRulesGrp::clear_has_trading_session_sub_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TradingSessionRulesGrp::clear_trading_session_sub_id() {
  trading_session_sub_id_ = 0;
  clear_has_trading_session_sub_id();
}
inline ::Common::TradingSessionSubIdEnum TradingSessionRulesGrp::trading_session_sub_id() const {
  return static_cast< ::Common::TradingSessionSubIdEnum >(trading_session_sub_id_);
}
inline void TradingSessionRulesGrp::set_trading_session_sub_id(::Common::TradingSessionSubIdEnum value) {
  assert(::Common::TradingSessionSubIdEnum_IsValid(value));
  set_has_trading_session_sub_id();
  trading_session_sub_id_ = value;
}

// -------------------------------------------------------------------

// NestedInstrumentAttribute

// optional sfixed64 nested_instr_attrib_type = 1;
inline bool NestedInstrumentAttribute::has_nested_instr_attrib_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NestedInstrumentAttribute::set_has_nested_instr_attrib_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NestedInstrumentAttribute::clear_has_nested_instr_attrib_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NestedInstrumentAttribute::clear_nested_instr_attrib_type() {
  nested_instr_attrib_type_ = GOOGLE_LONGLONG(0);
  clear_has_nested_instr_attrib_type();
}
inline ::google::protobuf::int64 NestedInstrumentAttribute::nested_instr_attrib_type() const {
  return nested_instr_attrib_type_;
}
inline void NestedInstrumentAttribute::set_nested_instr_attrib_type(::google::protobuf::int64 value) {
  set_has_nested_instr_attrib_type();
  nested_instr_attrib_type_ = value;
}

// optional string nested_instr_attrib_value = 2;
inline bool NestedInstrumentAttribute::has_nested_instr_attrib_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NestedInstrumentAttribute::set_has_nested_instr_attrib_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NestedInstrumentAttribute::clear_has_nested_instr_attrib_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NestedInstrumentAttribute::clear_nested_instr_attrib_value() {
  if (nested_instr_attrib_value_ != &::google::protobuf::internal::kEmptyString) {
    nested_instr_attrib_value_->clear();
  }
  clear_has_nested_instr_attrib_value();
}
inline const ::std::string& NestedInstrumentAttribute::nested_instr_attrib_value() const {
  return *nested_instr_attrib_value_;
}
inline void NestedInstrumentAttribute::set_nested_instr_attrib_value(const ::std::string& value) {
  set_has_nested_instr_attrib_value();
  if (nested_instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    nested_instr_attrib_value_ = new ::std::string;
  }
  nested_instr_attrib_value_->assign(value);
}
inline void NestedInstrumentAttribute::set_nested_instr_attrib_value(const char* value) {
  set_has_nested_instr_attrib_value();
  if (nested_instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    nested_instr_attrib_value_ = new ::std::string;
  }
  nested_instr_attrib_value_->assign(value);
}
inline void NestedInstrumentAttribute::set_nested_instr_attrib_value(const char* value, size_t size) {
  set_has_nested_instr_attrib_value();
  if (nested_instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    nested_instr_attrib_value_ = new ::std::string;
  }
  nested_instr_attrib_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NestedInstrumentAttribute::mutable_nested_instr_attrib_value() {
  set_has_nested_instr_attrib_value();
  if (nested_instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    nested_instr_attrib_value_ = new ::std::string;
  }
  return nested_instr_attrib_value_;
}
inline ::std::string* NestedInstrumentAttribute::release_nested_instr_attrib_value() {
  clear_has_nested_instr_attrib_value();
  if (nested_instr_attrib_value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nested_instr_attrib_value_;
    nested_instr_attrib_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NestedInstrumentAttribute::set_allocated_nested_instr_attrib_value(::std::string* nested_instr_attrib_value) {
  if (nested_instr_attrib_value_ != &::google::protobuf::internal::kEmptyString) {
    delete nested_instr_attrib_value_;
  }
  if (nested_instr_attrib_value) {
    set_has_nested_instr_attrib_value();
    nested_instr_attrib_value_ = nested_instr_attrib_value;
  } else {
    clear_has_nested_instr_attrib_value();
    nested_instr_attrib_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SecurityTradingRules

// optional .Common.BaseTradingRules base_trading_rules = 1;
inline bool SecurityTradingRules::has_base_trading_rules() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityTradingRules::set_has_base_trading_rules() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityTradingRules::clear_has_base_trading_rules() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityTradingRules::clear_base_trading_rules() {
  if (base_trading_rules_ != NULL) base_trading_rules_->::Common::BaseTradingRules::Clear();
  clear_has_base_trading_rules();
}
inline const ::Common::BaseTradingRules& SecurityTradingRules::base_trading_rules() const {
  return base_trading_rules_ != NULL ? *base_trading_rules_ : *default_instance_->base_trading_rules_;
}
inline ::Common::BaseTradingRules* SecurityTradingRules::mutable_base_trading_rules() {
  set_has_base_trading_rules();
  if (base_trading_rules_ == NULL) base_trading_rules_ = new ::Common::BaseTradingRules;
  return base_trading_rules_;
}
inline ::Common::BaseTradingRules* SecurityTradingRules::release_base_trading_rules() {
  clear_has_base_trading_rules();
  ::Common::BaseTradingRules* temp = base_trading_rules_;
  base_trading_rules_ = NULL;
  return temp;
}
inline void SecurityTradingRules::set_allocated_base_trading_rules(::Common::BaseTradingRules* base_trading_rules) {
  delete base_trading_rules_;
  base_trading_rules_ = base_trading_rules;
  if (base_trading_rules) {
    set_has_base_trading_rules();
  } else {
    clear_has_base_trading_rules();
  }
}

// repeated .Common.NestedInstrumentAttribute nested_instrument_attribute = 2;
inline int SecurityTradingRules::nested_instrument_attribute_size() const {
  return nested_instrument_attribute_.size();
}
inline void SecurityTradingRules::clear_nested_instrument_attribute() {
  nested_instrument_attribute_.Clear();
}
inline const ::Common::NestedInstrumentAttribute& SecurityTradingRules::nested_instrument_attribute(int index) const {
  return nested_instrument_attribute_.Get(index);
}
inline ::Common::NestedInstrumentAttribute* SecurityTradingRules::mutable_nested_instrument_attribute(int index) {
  return nested_instrument_attribute_.Mutable(index);
}
inline ::Common::NestedInstrumentAttribute* SecurityTradingRules::add_nested_instrument_attribute() {
  return nested_instrument_attribute_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::NestedInstrumentAttribute >&
SecurityTradingRules::nested_instrument_attribute() const {
  return nested_instrument_attribute_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::NestedInstrumentAttribute >*
SecurityTradingRules::mutable_nested_instrument_attribute() {
  return &nested_instrument_attribute_;
}

// repeated .Common.TradingSessionRulesGrp trading_session_rules_grp = 3;
inline int SecurityTradingRules::trading_session_rules_grp_size() const {
  return trading_session_rules_grp_.size();
}
inline void SecurityTradingRules::clear_trading_session_rules_grp() {
  trading_session_rules_grp_.Clear();
}
inline const ::Common::TradingSessionRulesGrp& SecurityTradingRules::trading_session_rules_grp(int index) const {
  return trading_session_rules_grp_.Get(index);
}
inline ::Common::TradingSessionRulesGrp* SecurityTradingRules::mutable_trading_session_rules_grp(int index) {
  return trading_session_rules_grp_.Mutable(index);
}
inline ::Common::TradingSessionRulesGrp* SecurityTradingRules::add_trading_session_rules_grp() {
  return trading_session_rules_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::TradingSessionRulesGrp >&
SecurityTradingRules::trading_session_rules_grp() const {
  return trading_session_rules_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::TradingSessionRulesGrp >*
SecurityTradingRules::mutable_trading_session_rules_grp() {
  return &trading_session_rules_grp_;
}

// -------------------------------------------------------------------

// MaturityRules

// optional sfixed32 end_maturity_month_year = 1;
inline bool MaturityRules::has_end_maturity_month_year() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MaturityRules::set_has_end_maturity_month_year() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MaturityRules::clear_has_end_maturity_month_year() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MaturityRules::clear_end_maturity_month_year() {
  end_maturity_month_year_ = 0;
  clear_has_end_maturity_month_year();
}
inline ::google::protobuf::int32 MaturityRules::end_maturity_month_year() const {
  return end_maturity_month_year_;
}
inline void MaturityRules::set_end_maturity_month_year(::google::protobuf::int32 value) {
  set_has_end_maturity_month_year();
  end_maturity_month_year_ = value;
}

// optional .Common.MaturityMonthYearFormatEnum maturity_month_year_format = 2;
inline bool MaturityRules::has_maturity_month_year_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MaturityRules::set_has_maturity_month_year_format() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MaturityRules::clear_has_maturity_month_year_format() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MaturityRules::clear_maturity_month_year_format() {
  maturity_month_year_format_ = 0;
  clear_has_maturity_month_year_format();
}
inline ::Common::MaturityMonthYearFormatEnum MaturityRules::maturity_month_year_format() const {
  return static_cast< ::Common::MaturityMonthYearFormatEnum >(maturity_month_year_format_);
}
inline void MaturityRules::set_maturity_month_year_format(::Common::MaturityMonthYearFormatEnum value) {
  assert(::Common::MaturityMonthYearFormatEnum_IsValid(value));
  set_has_maturity_month_year_format();
  maturity_month_year_format_ = value;
}

// optional sfixed64 maturity_month_year_increment = 3;
inline bool MaturityRules::has_maturity_month_year_increment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MaturityRules::set_has_maturity_month_year_increment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MaturityRules::clear_has_maturity_month_year_increment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MaturityRules::clear_maturity_month_year_increment() {
  maturity_month_year_increment_ = GOOGLE_LONGLONG(0);
  clear_has_maturity_month_year_increment();
}
inline ::google::protobuf::int64 MaturityRules::maturity_month_year_increment() const {
  return maturity_month_year_increment_;
}
inline void MaturityRules::set_maturity_month_year_increment(::google::protobuf::int64 value) {
  set_has_maturity_month_year_increment();
  maturity_month_year_increment_ = value;
}

// optional .Common.MaturityMonthYearIncrementUnitsEnum maturity_month_year_increment_units = 4;
inline bool MaturityRules::has_maturity_month_year_increment_units() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MaturityRules::set_has_maturity_month_year_increment_units() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MaturityRules::clear_has_maturity_month_year_increment_units() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MaturityRules::clear_maturity_month_year_increment_units() {
  maturity_month_year_increment_units_ = 0;
  clear_has_maturity_month_year_increment_units();
}
inline ::Common::MaturityMonthYearIncrementUnitsEnum MaturityRules::maturity_month_year_increment_units() const {
  return static_cast< ::Common::MaturityMonthYearIncrementUnitsEnum >(maturity_month_year_increment_units_);
}
inline void MaturityRules::set_maturity_month_year_increment_units(::Common::MaturityMonthYearIncrementUnitsEnum value) {
  assert(::Common::MaturityMonthYearIncrementUnitsEnum_IsValid(value));
  set_has_maturity_month_year_increment_units();
  maturity_month_year_increment_units_ = value;
}

// optional string maturity_rule_id = 5;
inline bool MaturityRules::has_maturity_rule_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MaturityRules::set_has_maturity_rule_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MaturityRules::clear_has_maturity_rule_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MaturityRules::clear_maturity_rule_id() {
  if (maturity_rule_id_ != &::google::protobuf::internal::kEmptyString) {
    maturity_rule_id_->clear();
  }
  clear_has_maturity_rule_id();
}
inline const ::std::string& MaturityRules::maturity_rule_id() const {
  return *maturity_rule_id_;
}
inline void MaturityRules::set_maturity_rule_id(const ::std::string& value) {
  set_has_maturity_rule_id();
  if (maturity_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    maturity_rule_id_ = new ::std::string;
  }
  maturity_rule_id_->assign(value);
}
inline void MaturityRules::set_maturity_rule_id(const char* value) {
  set_has_maturity_rule_id();
  if (maturity_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    maturity_rule_id_ = new ::std::string;
  }
  maturity_rule_id_->assign(value);
}
inline void MaturityRules::set_maturity_rule_id(const char* value, size_t size) {
  set_has_maturity_rule_id();
  if (maturity_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    maturity_rule_id_ = new ::std::string;
  }
  maturity_rule_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MaturityRules::mutable_maturity_rule_id() {
  set_has_maturity_rule_id();
  if (maturity_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    maturity_rule_id_ = new ::std::string;
  }
  return maturity_rule_id_;
}
inline ::std::string* MaturityRules::release_maturity_rule_id() {
  clear_has_maturity_rule_id();
  if (maturity_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = maturity_rule_id_;
    maturity_rule_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MaturityRules::set_allocated_maturity_rule_id(::std::string* maturity_rule_id) {
  if (maturity_rule_id_ != &::google::protobuf::internal::kEmptyString) {
    delete maturity_rule_id_;
  }
  if (maturity_rule_id) {
    set_has_maturity_rule_id();
    maturity_rule_id_ = maturity_rule_id;
  } else {
    clear_has_maturity_rule_id();
    maturity_rule_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed32 start_maturity_month_year = 6;
inline bool MaturityRules::has_start_maturity_month_year() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MaturityRules::set_has_start_maturity_month_year() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MaturityRules::clear_has_start_maturity_month_year() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MaturityRules::clear_start_maturity_month_year() {
  start_maturity_month_year_ = 0;
  clear_has_start_maturity_month_year();
}
inline ::google::protobuf::int32 MaturityRules::start_maturity_month_year() const {
  return start_maturity_month_year_;
}
inline void MaturityRules::set_start_maturity_month_year(::google::protobuf::int32 value) {
  set_has_start_maturity_month_year();
  start_maturity_month_year_ = value;
}

// -------------------------------------------------------------------

// StrikeRules

// optional sfixed64 end_strike_px_range = 1;
inline bool StrikeRules::has_end_strike_px_range() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StrikeRules::set_has_end_strike_px_range() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StrikeRules::clear_has_end_strike_px_range() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StrikeRules::clear_end_strike_px_range() {
  end_strike_px_range_ = GOOGLE_LONGLONG(0);
  clear_has_end_strike_px_range();
}
inline ::google::protobuf::int64 StrikeRules::end_strike_px_range() const {
  return end_strike_px_range_;
}
inline void StrikeRules::set_end_strike_px_range(::google::protobuf::int64 value) {
  set_has_end_strike_px_range();
  end_strike_px_range_ = value;
}

// optional sfixed32 end_strike_px_range_exponent = 2;
inline bool StrikeRules::has_end_strike_px_range_exponent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StrikeRules::set_has_end_strike_px_range_exponent() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StrikeRules::clear_has_end_strike_px_range_exponent() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StrikeRules::clear_end_strike_px_range_exponent() {
  end_strike_px_range_exponent_ = 0;
  clear_has_end_strike_px_range_exponent();
}
inline ::google::protobuf::int32 StrikeRules::end_strike_px_range_exponent() const {
  return end_strike_px_range_exponent_;
}
inline void StrikeRules::set_end_strike_px_range_exponent(::google::protobuf::int32 value) {
  set_has_end_strike_px_range_exponent();
  end_strike_px_range_exponent_ = value;
}

// repeated .Common.MaturityRules maturity_rules = 3;
inline int StrikeRules::maturity_rules_size() const {
  return maturity_rules_.size();
}
inline void StrikeRules::clear_maturity_rules() {
  maturity_rules_.Clear();
}
inline const ::Common::MaturityRules& StrikeRules::maturity_rules(int index) const {
  return maturity_rules_.Get(index);
}
inline ::Common::MaturityRules* StrikeRules::mutable_maturity_rules(int index) {
  return maturity_rules_.Mutable(index);
}
inline ::Common::MaturityRules* StrikeRules::add_maturity_rules() {
  return maturity_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::MaturityRules >&
StrikeRules::maturity_rules() const {
  return maturity_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::MaturityRules >*
StrikeRules::mutable_maturity_rules() {
  return &maturity_rules_;
}

// optional sfixed64 start_strike_px_range = 4;
inline bool StrikeRules::has_start_strike_px_range() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StrikeRules::set_has_start_strike_px_range() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StrikeRules::clear_has_start_strike_px_range() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StrikeRules::clear_start_strike_px_range() {
  start_strike_px_range_ = GOOGLE_LONGLONG(0);
  clear_has_start_strike_px_range();
}
inline ::google::protobuf::int64 StrikeRules::start_strike_px_range() const {
  return start_strike_px_range_;
}
inline void StrikeRules::set_start_strike_px_range(::google::protobuf::int64 value) {
  set_has_start_strike_px_range();
  start_strike_px_range_ = value;
}

// optional sfixed32 start_strike_px_range_exponent = 5;
inline bool StrikeRules::has_start_strike_px_range_exponent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StrikeRules::set_has_start_strike_px_range_exponent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StrikeRules::clear_has_start_strike_px_range_exponent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StrikeRules::clear_start_strike_px_range_exponent() {
  start_strike_px_range_exponent_ = 0;
  clear_has_start_strike_px_range_exponent();
}
inline ::google::protobuf::int32 StrikeRules::start_strike_px_range_exponent() const {
  return start_strike_px_range_exponent_;
}
inline void StrikeRules::set_start_strike_px_range_exponent(::google::protobuf::int32 value) {
  set_has_start_strike_px_range_exponent();
  start_strike_px_range_exponent_ = value;
}

// optional sfixed64 strike_exercise_style = 6;
inline bool StrikeRules::has_strike_exercise_style() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StrikeRules::set_has_strike_exercise_style() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StrikeRules::clear_has_strike_exercise_style() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StrikeRules::clear_strike_exercise_style() {
  strike_exercise_style_ = GOOGLE_LONGLONG(0);
  clear_has_strike_exercise_style();
}
inline ::google::protobuf::int64 StrikeRules::strike_exercise_style() const {
  return strike_exercise_style_;
}
inline void StrikeRules::set_strike_exercise_style(::google::protobuf::int64 value) {
  set_has_strike_exercise_style();
  strike_exercise_style_ = value;
}

// optional double strike_increment = 7;
inline bool StrikeRules::has_strike_increment() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StrikeRules::set_has_strike_increment() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StrikeRules::clear_has_strike_increment() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StrikeRules::clear_strike_increment() {
  strike_increment_ = 0;
  clear_has_strike_increment();
}
inline double StrikeRules::strike_increment() const {
  return strike_increment_;
}
inline void StrikeRules::set_strike_increment(double value) {
  set_has_strike_increment();
  strike_increment_ = value;
}

// optional string strike_rule_id = 8;
inline bool StrikeRules::has_strike_rule_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StrikeRules::set_has_strike_rule_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StrikeRules::clear_has_strike_rule_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StrikeRules::clear_strike_rule_id() {
  if (strike_rule_id_ != &::google::protobuf::internal::kEmptyString) {
    strike_rule_id_->clear();
  }
  clear_has_strike_rule_id();
}
inline const ::std::string& StrikeRules::strike_rule_id() const {
  return *strike_rule_id_;
}
inline void StrikeRules::set_strike_rule_id(const ::std::string& value) {
  set_has_strike_rule_id();
  if (strike_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    strike_rule_id_ = new ::std::string;
  }
  strike_rule_id_->assign(value);
}
inline void StrikeRules::set_strike_rule_id(const char* value) {
  set_has_strike_rule_id();
  if (strike_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    strike_rule_id_ = new ::std::string;
  }
  strike_rule_id_->assign(value);
}
inline void StrikeRules::set_strike_rule_id(const char* value, size_t size) {
  set_has_strike_rule_id();
  if (strike_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    strike_rule_id_ = new ::std::string;
  }
  strike_rule_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StrikeRules::mutable_strike_rule_id() {
  set_has_strike_rule_id();
  if (strike_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    strike_rule_id_ = new ::std::string;
  }
  return strike_rule_id_;
}
inline ::std::string* StrikeRules::release_strike_rule_id() {
  clear_has_strike_rule_id();
  if (strike_rule_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = strike_rule_id_;
    strike_rule_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StrikeRules::set_allocated_strike_rule_id(::std::string* strike_rule_id) {
  if (strike_rule_id_ != &::google::protobuf::internal::kEmptyString) {
    delete strike_rule_id_;
  }
  if (strike_rule_id) {
    set_has_strike_rule_id();
    strike_rule_id_ = strike_rule_id;
  } else {
    clear_has_strike_rule_id();
    strike_rule_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MarketSegmentGrp

// optional string market_id = 1;
inline bool MarketSegmentGrp::has_market_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MarketSegmentGrp::set_has_market_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MarketSegmentGrp::clear_has_market_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MarketSegmentGrp::clear_market_id() {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    market_id_->clear();
  }
  clear_has_market_id();
}
inline const ::std::string& MarketSegmentGrp::market_id() const {
  return *market_id_;
}
inline void MarketSegmentGrp::set_market_id(const ::std::string& value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void MarketSegmentGrp::set_market_id(const char* value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void MarketSegmentGrp::set_market_id(const char* value, size_t size) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketSegmentGrp::mutable_market_id() {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  return market_id_;
}
inline ::std::string* MarketSegmentGrp::release_market_id() {
  clear_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_id_;
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketSegmentGrp::set_allocated_market_id(::std::string* market_id) {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_id_;
  }
  if (market_id) {
    set_has_market_id();
    market_id_ = market_id;
  } else {
    clear_has_market_id();
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string market_segment_id = 2;
inline bool MarketSegmentGrp::has_market_segment_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MarketSegmentGrp::set_has_market_segment_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MarketSegmentGrp::clear_has_market_segment_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MarketSegmentGrp::clear_market_segment_id() {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    market_segment_id_->clear();
  }
  clear_has_market_segment_id();
}
inline const ::std::string& MarketSegmentGrp::market_segment_id() const {
  return *market_segment_id_;
}
inline void MarketSegmentGrp::set_market_segment_id(const ::std::string& value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void MarketSegmentGrp::set_market_segment_id(const char* value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void MarketSegmentGrp::set_market_segment_id(const char* value, size_t size) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MarketSegmentGrp::mutable_market_segment_id() {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  return market_segment_id_;
}
inline ::std::string* MarketSegmentGrp::release_market_segment_id() {
  clear_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_segment_id_;
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MarketSegmentGrp::set_allocated_market_segment_id(::std::string* market_segment_id) {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_segment_id_;
  }
  if (market_segment_id) {
    set_has_market_segment_id();
    market_segment_id_ = market_segment_id;
  } else {
    clear_has_market_segment_id();
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.SecurityTradingRules security_trading_rules = 3;
inline bool MarketSegmentGrp::has_security_trading_rules() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MarketSegmentGrp::set_has_security_trading_rules() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MarketSegmentGrp::clear_has_security_trading_rules() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MarketSegmentGrp::clear_security_trading_rules() {
  if (security_trading_rules_ != NULL) security_trading_rules_->::Common::SecurityTradingRules::Clear();
  clear_has_security_trading_rules();
}
inline const ::Common::SecurityTradingRules& MarketSegmentGrp::security_trading_rules() const {
  return security_trading_rules_ != NULL ? *security_trading_rules_ : *default_instance_->security_trading_rules_;
}
inline ::Common::SecurityTradingRules* MarketSegmentGrp::mutable_security_trading_rules() {
  set_has_security_trading_rules();
  if (security_trading_rules_ == NULL) security_trading_rules_ = new ::Common::SecurityTradingRules;
  return security_trading_rules_;
}
inline ::Common::SecurityTradingRules* MarketSegmentGrp::release_security_trading_rules() {
  clear_has_security_trading_rules();
  ::Common::SecurityTradingRules* temp = security_trading_rules_;
  security_trading_rules_ = NULL;
  return temp;
}
inline void MarketSegmentGrp::set_allocated_security_trading_rules(::Common::SecurityTradingRules* security_trading_rules) {
  delete security_trading_rules_;
  security_trading_rules_ = security_trading_rules;
  if (security_trading_rules) {
    set_has_security_trading_rules();
  } else {
    clear_has_security_trading_rules();
  }
}

// repeated .Common.StrikeRules strike_rules = 4;
inline int MarketSegmentGrp::strike_rules_size() const {
  return strike_rules_.size();
}
inline void MarketSegmentGrp::clear_strike_rules() {
  strike_rules_.Clear();
}
inline const ::Common::StrikeRules& MarketSegmentGrp::strike_rules(int index) const {
  return strike_rules_.Get(index);
}
inline ::Common::StrikeRules* MarketSegmentGrp::mutable_strike_rules(int index) {
  return strike_rules_.Mutable(index);
}
inline ::Common::StrikeRules* MarketSegmentGrp::add_strike_rules() {
  return strike_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >&
MarketSegmentGrp::strike_rules() const {
  return strike_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >*
MarketSegmentGrp::mutable_strike_rules() {
  return &strike_rules_;
}

// -------------------------------------------------------------------

// LegBenchmarkCurveData

// optional string leg_benchmark_curve_currency = 1;
inline bool LegBenchmarkCurveData::has_leg_benchmark_curve_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LegBenchmarkCurveData::set_has_leg_benchmark_curve_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LegBenchmarkCurveData::clear_has_leg_benchmark_curve_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LegBenchmarkCurveData::clear_leg_benchmark_curve_currency() {
  if (leg_benchmark_curve_currency_ != &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_currency_->clear();
  }
  clear_has_leg_benchmark_curve_currency();
}
inline const ::std::string& LegBenchmarkCurveData::leg_benchmark_curve_currency() const {
  return *leg_benchmark_curve_currency_;
}
inline void LegBenchmarkCurveData::set_leg_benchmark_curve_currency(const ::std::string& value) {
  set_has_leg_benchmark_curve_currency();
  if (leg_benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_currency_ = new ::std::string;
  }
  leg_benchmark_curve_currency_->assign(value);
}
inline void LegBenchmarkCurveData::set_leg_benchmark_curve_currency(const char* value) {
  set_has_leg_benchmark_curve_currency();
  if (leg_benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_currency_ = new ::std::string;
  }
  leg_benchmark_curve_currency_->assign(value);
}
inline void LegBenchmarkCurveData::set_leg_benchmark_curve_currency(const char* value, size_t size) {
  set_has_leg_benchmark_curve_currency();
  if (leg_benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_currency_ = new ::std::string;
  }
  leg_benchmark_curve_currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegBenchmarkCurveData::mutable_leg_benchmark_curve_currency() {
  set_has_leg_benchmark_curve_currency();
  if (leg_benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_currency_ = new ::std::string;
  }
  return leg_benchmark_curve_currency_;
}
inline ::std::string* LegBenchmarkCurveData::release_leg_benchmark_curve_currency() {
  clear_has_leg_benchmark_curve_currency();
  if (leg_benchmark_curve_currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_benchmark_curve_currency_;
    leg_benchmark_curve_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegBenchmarkCurveData::set_allocated_leg_benchmark_curve_currency(::std::string* leg_benchmark_curve_currency) {
  if (leg_benchmark_curve_currency_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_benchmark_curve_currency_;
  }
  if (leg_benchmark_curve_currency) {
    set_has_leg_benchmark_curve_currency();
    leg_benchmark_curve_currency_ = leg_benchmark_curve_currency;
  } else {
    clear_has_leg_benchmark_curve_currency();
    leg_benchmark_curve_currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_benchmark_curve_name = 2;
inline bool LegBenchmarkCurveData::has_leg_benchmark_curve_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LegBenchmarkCurveData::set_has_leg_benchmark_curve_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LegBenchmarkCurveData::clear_has_leg_benchmark_curve_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LegBenchmarkCurveData::clear_leg_benchmark_curve_name() {
  if (leg_benchmark_curve_name_ != &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_name_->clear();
  }
  clear_has_leg_benchmark_curve_name();
}
inline const ::std::string& LegBenchmarkCurveData::leg_benchmark_curve_name() const {
  return *leg_benchmark_curve_name_;
}
inline void LegBenchmarkCurveData::set_leg_benchmark_curve_name(const ::std::string& value) {
  set_has_leg_benchmark_curve_name();
  if (leg_benchmark_curve_name_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_name_ = new ::std::string;
  }
  leg_benchmark_curve_name_->assign(value);
}
inline void LegBenchmarkCurveData::set_leg_benchmark_curve_name(const char* value) {
  set_has_leg_benchmark_curve_name();
  if (leg_benchmark_curve_name_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_name_ = new ::std::string;
  }
  leg_benchmark_curve_name_->assign(value);
}
inline void LegBenchmarkCurveData::set_leg_benchmark_curve_name(const char* value, size_t size) {
  set_has_leg_benchmark_curve_name();
  if (leg_benchmark_curve_name_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_name_ = new ::std::string;
  }
  leg_benchmark_curve_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegBenchmarkCurveData::mutable_leg_benchmark_curve_name() {
  set_has_leg_benchmark_curve_name();
  if (leg_benchmark_curve_name_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_name_ = new ::std::string;
  }
  return leg_benchmark_curve_name_;
}
inline ::std::string* LegBenchmarkCurveData::release_leg_benchmark_curve_name() {
  clear_has_leg_benchmark_curve_name();
  if (leg_benchmark_curve_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_benchmark_curve_name_;
    leg_benchmark_curve_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegBenchmarkCurveData::set_allocated_leg_benchmark_curve_name(::std::string* leg_benchmark_curve_name) {
  if (leg_benchmark_curve_name_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_benchmark_curve_name_;
  }
  if (leg_benchmark_curve_name) {
    set_has_leg_benchmark_curve_name();
    leg_benchmark_curve_name_ = leg_benchmark_curve_name;
  } else {
    clear_has_leg_benchmark_curve_name();
    leg_benchmark_curve_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string leg_benchmark_curve_point = 3;
inline bool LegBenchmarkCurveData::has_leg_benchmark_curve_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LegBenchmarkCurveData::set_has_leg_benchmark_curve_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LegBenchmarkCurveData::clear_has_leg_benchmark_curve_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LegBenchmarkCurveData::clear_leg_benchmark_curve_point() {
  if (leg_benchmark_curve_point_ != &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_point_->clear();
  }
  clear_has_leg_benchmark_curve_point();
}
inline const ::std::string& LegBenchmarkCurveData::leg_benchmark_curve_point() const {
  return *leg_benchmark_curve_point_;
}
inline void LegBenchmarkCurveData::set_leg_benchmark_curve_point(const ::std::string& value) {
  set_has_leg_benchmark_curve_point();
  if (leg_benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_point_ = new ::std::string;
  }
  leg_benchmark_curve_point_->assign(value);
}
inline void LegBenchmarkCurveData::set_leg_benchmark_curve_point(const char* value) {
  set_has_leg_benchmark_curve_point();
  if (leg_benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_point_ = new ::std::string;
  }
  leg_benchmark_curve_point_->assign(value);
}
inline void LegBenchmarkCurveData::set_leg_benchmark_curve_point(const char* value, size_t size) {
  set_has_leg_benchmark_curve_point();
  if (leg_benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_point_ = new ::std::string;
  }
  leg_benchmark_curve_point_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LegBenchmarkCurveData::mutable_leg_benchmark_curve_point() {
  set_has_leg_benchmark_curve_point();
  if (leg_benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    leg_benchmark_curve_point_ = new ::std::string;
  }
  return leg_benchmark_curve_point_;
}
inline ::std::string* LegBenchmarkCurveData::release_leg_benchmark_curve_point() {
  clear_has_leg_benchmark_curve_point();
  if (leg_benchmark_curve_point_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_benchmark_curve_point_;
    leg_benchmark_curve_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LegBenchmarkCurveData::set_allocated_leg_benchmark_curve_point(::std::string* leg_benchmark_curve_point) {
  if (leg_benchmark_curve_point_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_benchmark_curve_point_;
  }
  if (leg_benchmark_curve_point) {
    set_has_leg_benchmark_curve_point();
    leg_benchmark_curve_point_ = leg_benchmark_curve_point;
  } else {
    clear_has_leg_benchmark_curve_point();
    leg_benchmark_curve_point_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sfixed64 leg_benchmark_price = 4;
inline bool LegBenchmarkCurveData::has_leg_benchmark_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LegBenchmarkCurveData::set_has_leg_benchmark_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LegBenchmarkCurveData::clear_has_leg_benchmark_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LegBenchmarkCurveData::clear_leg_benchmark_price() {
  leg_benchmark_price_ = GOOGLE_LONGLONG(0);
  clear_has_leg_benchmark_price();
}
inline ::google::protobuf::int64 LegBenchmarkCurveData::leg_benchmark_price() const {
  return leg_benchmark_price_;
}
inline void LegBenchmarkCurveData::set_leg_benchmark_price(::google::protobuf::int64 value) {
  set_has_leg_benchmark_price();
  leg_benchmark_price_ = value;
}

// optional sfixed32 leg_benchmark_price_exponent = 5;
inline bool LegBenchmarkCurveData::has_leg_benchmark_price_exponent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LegBenchmarkCurveData::set_has_leg_benchmark_price_exponent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LegBenchmarkCurveData::clear_has_leg_benchmark_price_exponent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LegBenchmarkCurveData::clear_leg_benchmark_price_exponent() {
  leg_benchmark_price_exponent_ = 0;
  clear_has_leg_benchmark_price_exponent();
}
inline ::google::protobuf::int32 LegBenchmarkCurveData::leg_benchmark_price_exponent() const {
  return leg_benchmark_price_exponent_;
}
inline void LegBenchmarkCurveData::set_leg_benchmark_price_exponent(::google::protobuf::int32 value) {
  set_has_leg_benchmark_price_exponent();
  leg_benchmark_price_exponent_ = value;
}

// optional sfixed64 leg_benchmark_price_type = 6;
inline bool LegBenchmarkCurveData::has_leg_benchmark_price_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LegBenchmarkCurveData::set_has_leg_benchmark_price_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LegBenchmarkCurveData::clear_has_leg_benchmark_price_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LegBenchmarkCurveData::clear_leg_benchmark_price_type() {
  leg_benchmark_price_type_ = GOOGLE_LONGLONG(0);
  clear_has_leg_benchmark_price_type();
}
inline ::google::protobuf::int64 LegBenchmarkCurveData::leg_benchmark_price_type() const {
  return leg_benchmark_price_type_;
}
inline void LegBenchmarkCurveData::set_leg_benchmark_price_type(::google::protobuf::int64 value) {
  set_has_leg_benchmark_price_type();
  leg_benchmark_price_type_ = value;
}

// -------------------------------------------------------------------

// InstrmtLegSecListGrp

// optional .Common.InstrumentLeg instrument_leg = 1;
inline bool InstrmtLegSecListGrp::has_instrument_leg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstrmtLegSecListGrp::set_has_instrument_leg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstrmtLegSecListGrp::clear_has_instrument_leg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstrmtLegSecListGrp::clear_instrument_leg() {
  if (instrument_leg_ != NULL) instrument_leg_->::Common::InstrumentLeg::Clear();
  clear_has_instrument_leg();
}
inline const ::Common::InstrumentLeg& InstrmtLegSecListGrp::instrument_leg() const {
  return instrument_leg_ != NULL ? *instrument_leg_ : *default_instance_->instrument_leg_;
}
inline ::Common::InstrumentLeg* InstrmtLegSecListGrp::mutable_instrument_leg() {
  set_has_instrument_leg();
  if (instrument_leg_ == NULL) instrument_leg_ = new ::Common::InstrumentLeg;
  return instrument_leg_;
}
inline ::Common::InstrumentLeg* InstrmtLegSecListGrp::release_instrument_leg() {
  clear_has_instrument_leg();
  ::Common::InstrumentLeg* temp = instrument_leg_;
  instrument_leg_ = NULL;
  return temp;
}
inline void InstrmtLegSecListGrp::set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg) {
  delete instrument_leg_;
  instrument_leg_ = instrument_leg;
  if (instrument_leg) {
    set_has_instrument_leg();
  } else {
    clear_has_instrument_leg();
  }
}

// optional .Common.LegBenchmarkCurveData leg_benchmark_curve_data = 2;
inline bool InstrmtLegSecListGrp::has_leg_benchmark_curve_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstrmtLegSecListGrp::set_has_leg_benchmark_curve_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstrmtLegSecListGrp::clear_has_leg_benchmark_curve_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstrmtLegSecListGrp::clear_leg_benchmark_curve_data() {
  if (leg_benchmark_curve_data_ != NULL) leg_benchmark_curve_data_->::Common::LegBenchmarkCurveData::Clear();
  clear_has_leg_benchmark_curve_data();
}
inline const ::Common::LegBenchmarkCurveData& InstrmtLegSecListGrp::leg_benchmark_curve_data() const {
  return leg_benchmark_curve_data_ != NULL ? *leg_benchmark_curve_data_ : *default_instance_->leg_benchmark_curve_data_;
}
inline ::Common::LegBenchmarkCurveData* InstrmtLegSecListGrp::mutable_leg_benchmark_curve_data() {
  set_has_leg_benchmark_curve_data();
  if (leg_benchmark_curve_data_ == NULL) leg_benchmark_curve_data_ = new ::Common::LegBenchmarkCurveData;
  return leg_benchmark_curve_data_;
}
inline ::Common::LegBenchmarkCurveData* InstrmtLegSecListGrp::release_leg_benchmark_curve_data() {
  clear_has_leg_benchmark_curve_data();
  ::Common::LegBenchmarkCurveData* temp = leg_benchmark_curve_data_;
  leg_benchmark_curve_data_ = NULL;
  return temp;
}
inline void InstrmtLegSecListGrp::set_allocated_leg_benchmark_curve_data(::Common::LegBenchmarkCurveData* leg_benchmark_curve_data) {
  delete leg_benchmark_curve_data_;
  leg_benchmark_curve_data_ = leg_benchmark_curve_data;
  if (leg_benchmark_curve_data) {
    set_has_leg_benchmark_curve_data();
  } else {
    clear_has_leg_benchmark_curve_data();
  }
}

// optional string leg_settl_type = 3;
inline bool InstrmtLegSecListGrp::has_leg_settl_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstrmtLegSecListGrp::set_has_leg_settl_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstrmtLegSecListGrp::clear_has_leg_settl_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstrmtLegSecListGrp::clear_leg_settl_type() {
  if (leg_settl_type_ != &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_->clear();
  }
  clear_has_leg_settl_type();
}
inline const ::std::string& InstrmtLegSecListGrp::leg_settl_type() const {
  return *leg_settl_type_;
}
inline void InstrmtLegSecListGrp::set_leg_settl_type(const ::std::string& value) {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  leg_settl_type_->assign(value);
}
inline void InstrmtLegSecListGrp::set_leg_settl_type(const char* value) {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  leg_settl_type_->assign(value);
}
inline void InstrmtLegSecListGrp::set_leg_settl_type(const char* value, size_t size) {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  leg_settl_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* InstrmtLegSecListGrp::mutable_leg_settl_type() {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  return leg_settl_type_;
}
inline ::std::string* InstrmtLegSecListGrp::release_leg_settl_type() {
  clear_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_settl_type_;
    leg_settl_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void InstrmtLegSecListGrp::set_allocated_leg_settl_type(::std::string* leg_settl_type) {
  if (leg_settl_type_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_settl_type_;
  }
  if (leg_settl_type) {
    set_has_leg_settl_type();
    leg_settl_type_ = leg_settl_type;
  } else {
    clear_has_leg_settl_type();
    leg_settl_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.LegStipulations leg_stipulations = 4;
inline int InstrmtLegSecListGrp::leg_stipulations_size() const {
  return leg_stipulations_.size();
}
inline void InstrmtLegSecListGrp::clear_leg_stipulations() {
  leg_stipulations_.Clear();
}
inline const ::Common::LegStipulations& InstrmtLegSecListGrp::leg_stipulations(int index) const {
  return leg_stipulations_.Get(index);
}
inline ::Common::LegStipulations* InstrmtLegSecListGrp::mutable_leg_stipulations(int index) {
  return leg_stipulations_.Mutable(index);
}
inline ::Common::LegStipulations* InstrmtLegSecListGrp::add_leg_stipulations() {
  return leg_stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >&
InstrmtLegSecListGrp::leg_stipulations() const {
  return leg_stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >*
InstrmtLegSecListGrp::mutable_leg_stipulations() {
  return &leg_stipulations_;
}

// optional .Common.LegSwapTypeEnum leg_swap_type = 5;
inline bool InstrmtLegSecListGrp::has_leg_swap_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstrmtLegSecListGrp::set_has_leg_swap_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstrmtLegSecListGrp::clear_has_leg_swap_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstrmtLegSecListGrp::clear_leg_swap_type() {
  leg_swap_type_ = 0;
  clear_has_leg_swap_type();
}
inline ::Common::LegSwapTypeEnum InstrmtLegSecListGrp::leg_swap_type() const {
  return static_cast< ::Common::LegSwapTypeEnum >(leg_swap_type_);
}
inline void InstrmtLegSecListGrp::set_leg_swap_type(::Common::LegSwapTypeEnum value) {
  assert(::Common::LegSwapTypeEnum_IsValid(value));
  set_has_leg_swap_type();
  leg_swap_type_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Common

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PartySubIdTypeEnum>() {
  return ::Common::PartySubIdTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PartyIdSourceEnum>() {
  return ::Common::PartyIdSourceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PartyRoleEnum>() {
  return ::Common::PartyRoleEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DisplayWhenEnum>() {
  return ::Common::DisplayWhenEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DisplayMethodEnum>() {
  return ::Common::DisplayMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TradingSessionIdEnum>() {
  return ::Common::TradingSessionIdEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TradingSessionSubIdEnum>() {
  return ::Common::TradingSessionSubIdEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::EventTypeEnum>() {
  return ::Common::EventTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ComplexEventTypeEnum>() {
  return ::Common::ComplexEventTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ComplexEventPriceBoundaryMethodEnum>() {
  return ::Common::ComplexEventPriceBoundaryMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ComplexEventPriceTimeTypeEnum>() {
  return ::Common::ComplexEventPriceTimeTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ComplexEventConditionEnum>() {
  return ::Common::ComplexEventConditionEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::SymbolSfxEnum>() {
  return ::Common::SymbolSfxEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::SecurityIdSourceEnum>() {
  return ::Common::SecurityIdSourceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ProductEnum>() {
  return ::Common::ProductEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::SecurityTypeEnum>() {
  return ::Common::SecurityTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::SecurityStatusEnum>() {
  return ::Common::SecurityStatusEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::RestructuringTypeEnum>() {
  return ::Common::RestructuringTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::SeniorityEnum>() {
  return ::Common::SeniorityEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::StrikePriceDeterminationMethodEnum>() {
  return ::Common::StrikePriceDeterminationMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::StrikePriceBoundaryMethodEnum>() {
  return ::Common::StrikePriceBoundaryMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::UnderlyingPriceDeterminationMethodEnum>() {
  return ::Common::UnderlyingPriceDeterminationMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ContractMultiplierUnitEnum>() {
  return ::Common::ContractMultiplierUnitEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::FlowScheduleTypeEnum>() {
  return ::Common::FlowScheduleTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::UnitOfMeasureEnum>() {
  return ::Common::UnitOfMeasureEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::SettlMethodEnum>() {
  return ::Common::SettlMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ExerciseStyleEnum>() {
  return ::Common::ExerciseStyleEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::OptPayoutTypeEnum>() {
  return ::Common::OptPayoutTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PriceQuoteMethodEnum>() {
  return ::Common::PriceQuoteMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ValuationMethodEnum>() {
  return ::Common::ValuationMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ListMethodEnum>() {
  return ::Common::ListMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PutOrCallEnum>() {
  return ::Common::PutOrCallEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TimeUnitEnum>() {
  return ::Common::TimeUnitEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::CpProgramEnum>() {
  return ::Common::CpProgramEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TerminationTypeEnum>() {
  return ::Common::TerminationTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DeliveryTypeEnum>() {
  return ::Common::DeliveryTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::UnderlyingSettlementTypeEnum>() {
  return ::Common::UnderlyingSettlementTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::UnderlyingCashTypeEnum>() {
  return ::Common::UnderlyingCashTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::UnderlyingFxRateCalcEnum>() {
  return ::Common::UnderlyingFxRateCalcEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::StipulationTypeEnum>() {
  return ::Common::StipulationTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::RoundingDirectionEnum>() {
  return ::Common::RoundingDirectionEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TriggerTypeEnum>() {
  return ::Common::TriggerTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TriggerActionEnum>() {
  return ::Common::TriggerActionEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TriggerPriceTypeEnum>() {
  return ::Common::TriggerPriceTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TriggerPriceTypeScopeEnum>() {
  return ::Common::TriggerPriceTypeScopeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TriggerPriceDirectionEnum>() {
  return ::Common::TriggerPriceDirectionEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TriggerOrderTypeEnum>() {
  return ::Common::TriggerOrderTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::BenchmarkCurveNameEnum>() {
  return ::Common::BenchmarkCurveNameEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::YieldTypeEnum>() {
  return ::Common::YieldTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::CommTypeEnum>() {
  return ::Common::CommTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::FundRenewWaivEnum>() {
  return ::Common::FundRenewWaivEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PegPriceTypeEnum>() {
  return ::Common::PegPriceTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PegMoveTypeEnum>() {
  return ::Common::PegMoveTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PegOffsetTypeEnum>() {
  return ::Common::PegOffsetTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PegLimitTypeEnum>() {
  return ::Common::PegLimitTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PegRoundDirectionEnum>() {
  return ::Common::PegRoundDirectionEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PegScopeEnum>() {
  return ::Common::PegScopeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DiscretionInstEnum>() {
  return ::Common::DiscretionInstEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DiscretionMoveTypeEnum>() {
  return ::Common::DiscretionMoveTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DiscretionOffsetTypeEnum>() {
  return ::Common::DiscretionOffsetTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DiscretionLimitTypeEnum>() {
  return ::Common::DiscretionLimitTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DiscretionRoundDirectionEnum>() {
  return ::Common::DiscretionRoundDirectionEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DiscretionScopeEnum>() {
  return ::Common::DiscretionScopeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::StrategyParameterTypeEnum>() {
  return ::Common::StrategyParameterTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TrdRegTimestampTypeEnum>() {
  return ::Common::TrdRegTimestampTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DeskTypeEnum>() {
  return ::Common::DeskTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DeskTypeSourceEnum>() {
  return ::Common::DeskTypeSourceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DeskOrderHandlingInstEnum>() {
  return ::Common::DeskOrderHandlingInstEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::RateSourceEnum>() {
  return ::Common::RateSourceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::RateSourceTypeEnum>() {
  return ::Common::RateSourceTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ContAmtTypeEnum>() {
  return ::Common::ContAmtTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::LegSwapTypeEnum>() {
  return ::Common::LegSwapTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::MiscFeeTypeEnum>() {
  return ::Common::MiscFeeTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::MiscFeeBasisEnum>() {
  return ::Common::MiscFeeBasisEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::RoutingTypeEnum>() {
  return ::Common::RoutingTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::InstrAttribTypeEnum>() {
  return ::Common::InstrAttribTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::DeliveryFormEnum>() {
  return ::Common::DeliveryFormEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TickRuleTypeEnum>() {
  return ::Common::TickRuleTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::LotTypeEnum>() {
  return ::Common::LotTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PriceLimitTypeEnum>() {
  return ::Common::PriceLimitTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ExpirationCycleEnum>() {
  return ::Common::ExpirationCycleEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::ImpliedMarketIndicatorEnum>() {
  return ::Common::ImpliedMarketIndicatorEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::MultilegModelEnum>() {
  return ::Common::MultilegModelEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::MultilegPriceMethodEnum>() {
  return ::Common::MultilegPriceMethodEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::PriceTypeEnum>() {
  return ::Common::PriceTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::OrdTypeEnum>() {
  return ::Common::OrdTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::TimeInForceEnum>() {
  return ::Common::TimeInForceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::MatchTypeEnum>() {
  return ::Common::MatchTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::MdBookTypeEnum>() {
  return ::Common::MdBookTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::MaturityMonthYearFormatEnum>() {
  return ::Common::MaturityMonthYearFormatEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Common::MaturityMonthYearIncrementUnitsEnum>() {
  return ::Common::MaturityMonthYearIncrementUnitsEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_common_2eproto__INCLUDED
