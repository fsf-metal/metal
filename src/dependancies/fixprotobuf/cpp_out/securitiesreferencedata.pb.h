// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: securitiesreferencedata.proto

#ifndef PROTOBUF_securitiesreferencedata_2eproto__INCLUDED
#define PROTOBUF_securitiesreferencedata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "meta.pb.h"
#include "fix.pb.h"
#include "session.pb.h"
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace SecuritiesReferenceData {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_securitiesreferencedata_2eproto();
void protobuf_AssignDesc_securitiesreferencedata_2eproto();
void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

class SecurityDefinition;
class SecurityDefinitionRequest;
class SecurityDefinitionUpdateReport;
class SecListGrp;
class SecurityListTypeUnion;
class SecurityListTypeSourceUnion;
class SecurityList;
class SecurityListRequest;
class SecLstUpdRelSymsLegGrp;
class SecLstUpdRelSymGrp;
class SecurityListUpdateReport;

enum SecurityResponseTypeEnum {
  SECURITY_RESPONSE_TYPE_ACCEPT_AS_IS = 0,
  SECURITY_RESPONSE_TYPE_ACCEPT_WITH_REVISIONS = 1,
  SECURITY_RESPONSE_TYPE_CANNOT_MATCH_SELECTION_CRITERIA = 2,
  SECURITY_RESPONSE_TYPE_LIST_OF_SECURITIES_RETURNED_PER_REQUEST = 3,
  SECURITY_RESPONSE_TYPE_LIST_OF_SECURITY_TYPES_RETURNED_PER_REQUEST = 4,
  SECURITY_RESPONSE_TYPE_REJECT_SECURITY_PROPOSAL = 5
};
bool SecurityResponseTypeEnum_IsValid(int value);
const SecurityResponseTypeEnum SecurityResponseTypeEnum_MIN = SECURITY_RESPONSE_TYPE_ACCEPT_AS_IS;
const SecurityResponseTypeEnum SecurityResponseTypeEnum_MAX = SECURITY_RESPONSE_TYPE_REJECT_SECURITY_PROPOSAL;
const int SecurityResponseTypeEnum_ARRAYSIZE = SecurityResponseTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityResponseTypeEnum_descriptor();
inline const ::std::string& SecurityResponseTypeEnum_Name(SecurityResponseTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityResponseTypeEnum_descriptor(), value);
}
inline bool SecurityResponseTypeEnum_Parse(
    const ::std::string& name, SecurityResponseTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityResponseTypeEnum>(
    SecurityResponseTypeEnum_descriptor(), name, value);
}
enum CorporateActionEnum {
  CORPORATE_ACTION_EX_DISTRIBUTION = 0,
  CORPORATE_ACTION_EX_DIVIDEND = 1,
  CORPORATE_ACTION_EX_INTEREST = 2,
  CORPORATE_ACTION_EX_RIGHTS = 3,
  CORPORATE_ACTION_NEW = 4,
  CORPORATE_ACTION_CUSIP = 5,
  CORPORATE_ACTION_CASH_DIVIDEND = 6,
  CORPORATE_ACTION_LIQUIDATION_REORGANIZATION = 7,
  CORPORATE_ACTION_MERGER_REORGANIZATION = 8,
  CORPORATE_ACTION_NON_INTEGER_STOCK_SPLIT = 9,
  CORPORATE_ACTION_POSITION_CONSOLIDATION = 10,
  CORPORATE_ACTION_REVERSE_STOCK_SPLIT = 11,
  CORPORATE_ACTION_RIGHTS_OFFERING = 12,
  CORPORATE_ACTION_SHAREHOLDER_MEETING = 13,
  CORPORATE_ACTION_SPECIAL_ACTION = 14,
  CORPORATE_ACTION_SPINOFF = 15,
  CORPORATE_ACTION_STANDARD_INTEGER_STOCK_SPLIT = 16,
  CORPORATE_ACTION_STOCK_DIVIDEND = 17,
  CORPORATE_ACTION_SYMBOL_CONVERSION = 18,
  CORPORATE_ACTION_TENDER_OFFER = 19,
  CORPORATE_ACTION_WARRANT = 20,
  CORPORATE_ACTION_LEAP_ROLLOVER = 21,
  CORPORATE_ACTION_SUCCESSION_EVENT = 22
};
bool CorporateActionEnum_IsValid(int value);
const CorporateActionEnum CorporateActionEnum_MIN = CORPORATE_ACTION_EX_DISTRIBUTION;
const CorporateActionEnum CorporateActionEnum_MAX = CORPORATE_ACTION_SUCCESSION_EVENT;
const int CorporateActionEnum_ARRAYSIZE = CorporateActionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* CorporateActionEnum_descriptor();
inline const ::std::string& CorporateActionEnum_Name(CorporateActionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    CorporateActionEnum_descriptor(), value);
}
inline bool CorporateActionEnum_Parse(
    const ::std::string& name, CorporateActionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CorporateActionEnum>(
    CorporateActionEnum_descriptor(), name, value);
}
enum SecurityRequestTypeEnum {
  SECURITY_REQUEST_TYPE_REQUEST_LIST_SECURITIES = 0,
  SECURITY_REQUEST_TYPE_REQUEST_LIST_SECURITY_TYPES = 1,
  SECURITY_REQUEST_TYPE_REQUEST_SECURITY_IDENTITY_AND_SPECIFICATIONS = 2,
  SECURITY_REQUEST_TYPE_REQUEST_SECURITY_IDENTITY_FOR_SPECIFICATIONS = 3,
  SECURITY_REQUEST_TYPE_ALL_SECURITIES = 4,
  SECURITY_REQUEST_TYPE_MARKET_ID_OR_MARKET_ID = 5,
  SECURITY_REQUEST_TYPE_PRODUCT = 6,
  SECURITY_REQUEST_TYPE_SECURITY_TYPE_AND_OR_CFI_CODE = 7,
  SECURITY_REQUEST_TYPE_SYMBOL = 8,
  SECURITY_REQUEST_TYPE_TRADING_SESSION_ID = 9
};
bool SecurityRequestTypeEnum_IsValid(int value);
const SecurityRequestTypeEnum SecurityRequestTypeEnum_MIN = SECURITY_REQUEST_TYPE_REQUEST_LIST_SECURITIES;
const SecurityRequestTypeEnum SecurityRequestTypeEnum_MAX = SECURITY_REQUEST_TYPE_TRADING_SESSION_ID;
const int SecurityRequestTypeEnum_ARRAYSIZE = SecurityRequestTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityRequestTypeEnum_descriptor();
inline const ::std::string& SecurityRequestTypeEnum_Name(SecurityRequestTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityRequestTypeEnum_descriptor(), value);
}
inline bool SecurityRequestTypeEnum_Parse(
    const ::std::string& name, SecurityRequestTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityRequestTypeEnum>(
    SecurityRequestTypeEnum_descriptor(), name, value);
}
enum TradingSessionIdEnum {
  TRADING_SESSION_ID_AFTER_HOURS = 0,
  TRADING_SESSION_ID_AFTERNOON = 1,
  TRADING_SESSION_ID_DAY = 2,
  TRADING_SESSION_ID_EVENING = 3,
  TRADING_SESSION_ID_HALF_DAY = 4,
  TRADING_SESSION_ID_MORNING = 5
};
bool TradingSessionIdEnum_IsValid(int value);
const TradingSessionIdEnum TradingSessionIdEnum_MIN = TRADING_SESSION_ID_AFTER_HOURS;
const TradingSessionIdEnum TradingSessionIdEnum_MAX = TRADING_SESSION_ID_MORNING;
const int TradingSessionIdEnum_ARRAYSIZE = TradingSessionIdEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradingSessionIdEnum_descriptor();
inline const ::std::string& TradingSessionIdEnum_Name(TradingSessionIdEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradingSessionIdEnum_descriptor(), value);
}
inline bool TradingSessionIdEnum_Parse(
    const ::std::string& name, TradingSessionIdEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradingSessionIdEnum>(
    TradingSessionIdEnum_descriptor(), name, value);
}
enum TradingSessionSubIdEnum {
  TRADING_SESSION_SUB_ID_CLOSING_OR_CLOSING_AUCTION = 0,
  TRADING_SESSION_SUB_ID_CONTINUOUS = 1,
  TRADING_SESSION_SUB_ID_INTRADAY_AUCTION = 2,
  TRADING_SESSION_SUB_ID_OPENING_OR_OPENING_AUCTION = 3,
  TRADING_SESSION_SUB_ID_POST_TRADING = 4,
  TRADING_SESSION_SUB_ID_PRE_TRADING = 5,
  TRADING_SESSION_SUB_ID_QUIESCENT = 6
};
bool TradingSessionSubIdEnum_IsValid(int value);
const TradingSessionSubIdEnum TradingSessionSubIdEnum_MIN = TRADING_SESSION_SUB_ID_CLOSING_OR_CLOSING_AUCTION;
const TradingSessionSubIdEnum TradingSessionSubIdEnum_MAX = TRADING_SESSION_SUB_ID_QUIESCENT;
const int TradingSessionSubIdEnum_ARRAYSIZE = TradingSessionSubIdEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* TradingSessionSubIdEnum_descriptor();
inline const ::std::string& TradingSessionSubIdEnum_Name(TradingSessionSubIdEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    TradingSessionSubIdEnum_descriptor(), value);
}
inline bool TradingSessionSubIdEnum_Parse(
    const ::std::string& name, TradingSessionSubIdEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TradingSessionSubIdEnum>(
    TradingSessionSubIdEnum_descriptor(), name, value);
}
enum ExpirationCycleEnum {
  EXPIRATION_CYCLE_EXPIRE_ON_TRADING_SESSION_CLOSE = 0,
  EXPIRATION_CYCLE_EXPIRE_ON_TRADING_SESSION_OPEN = 1,
  EXPIRATION_CYCLE_SPECIFIED_EXPIRATION = 2
};
bool ExpirationCycleEnum_IsValid(int value);
const ExpirationCycleEnum ExpirationCycleEnum_MIN = EXPIRATION_CYCLE_EXPIRE_ON_TRADING_SESSION_CLOSE;
const ExpirationCycleEnum ExpirationCycleEnum_MAX = EXPIRATION_CYCLE_SPECIFIED_EXPIRATION;
const int ExpirationCycleEnum_ARRAYSIZE = ExpirationCycleEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExpirationCycleEnum_descriptor();
inline const ::std::string& ExpirationCycleEnum_Name(ExpirationCycleEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExpirationCycleEnum_descriptor(), value);
}
inline bool ExpirationCycleEnum_Parse(
    const ::std::string& name, ExpirationCycleEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExpirationCycleEnum>(
    ExpirationCycleEnum_descriptor(), name, value);
}
enum SubscriptionRequestTypeEnum {
  SUBSCRIPTION_REQUEST_TYPE_DISABLE_PREVIOUS_SNAPSHOT = 0,
  SUBSCRIPTION_REQUEST_TYPE_SNAPSHOT = 1,
  SUBSCRIPTION_REQUEST_TYPE_SNAPSHOT_AND_UPDATES = 2
};
bool SubscriptionRequestTypeEnum_IsValid(int value);
const SubscriptionRequestTypeEnum SubscriptionRequestTypeEnum_MIN = SUBSCRIPTION_REQUEST_TYPE_DISABLE_PREVIOUS_SNAPSHOT;
const SubscriptionRequestTypeEnum SubscriptionRequestTypeEnum_MAX = SUBSCRIPTION_REQUEST_TYPE_SNAPSHOT_AND_UPDATES;
const int SubscriptionRequestTypeEnum_ARRAYSIZE = SubscriptionRequestTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SubscriptionRequestTypeEnum_descriptor();
inline const ::std::string& SubscriptionRequestTypeEnum_Name(SubscriptionRequestTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SubscriptionRequestTypeEnum_descriptor(), value);
}
inline bool SubscriptionRequestTypeEnum_Parse(
    const ::std::string& name, SubscriptionRequestTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SubscriptionRequestTypeEnum>(
    SubscriptionRequestTypeEnum_descriptor(), name, value);
}
enum SecurityUpdateActionEnum {
  SECURITY_UPDATE_ACTION_ADD = 0,
  SECURITY_UPDATE_ACTION_DELETE = 1,
  SECURITY_UPDATE_ACTION_MODIFY = 2
};
bool SecurityUpdateActionEnum_IsValid(int value);
const SecurityUpdateActionEnum SecurityUpdateActionEnum_MIN = SECURITY_UPDATE_ACTION_ADD;
const SecurityUpdateActionEnum SecurityUpdateActionEnum_MAX = SECURITY_UPDATE_ACTION_MODIFY;
const int SecurityUpdateActionEnum_ARRAYSIZE = SecurityUpdateActionEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityUpdateActionEnum_descriptor();
inline const ::std::string& SecurityUpdateActionEnum_Name(SecurityUpdateActionEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityUpdateActionEnum_descriptor(), value);
}
inline bool SecurityUpdateActionEnum_Parse(
    const ::std::string& name, SecurityUpdateActionEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityUpdateActionEnum>(
    SecurityUpdateActionEnum_descriptor(), name, value);
}
enum SecurityListTypeEnum {
  SECURITY_LIST_TYPE_INDUSTRY_CLASSIFICATION = 0,
  SECURITY_LIST_TYPE_MARKET = 1,
  SECURITY_LIST_TYPE_NEWSPAPER_LIST = 2,
  SECURITY_LIST_TYPE_TRADING_LIST = 3
};
bool SecurityListTypeEnum_IsValid(int value);
const SecurityListTypeEnum SecurityListTypeEnum_MIN = SECURITY_LIST_TYPE_INDUSTRY_CLASSIFICATION;
const SecurityListTypeEnum SecurityListTypeEnum_MAX = SECURITY_LIST_TYPE_TRADING_LIST;
const int SecurityListTypeEnum_ARRAYSIZE = SecurityListTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityListTypeEnum_descriptor();
inline const ::std::string& SecurityListTypeEnum_Name(SecurityListTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityListTypeEnum_descriptor(), value);
}
inline bool SecurityListTypeEnum_Parse(
    const ::std::string& name, SecurityListTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityListTypeEnum>(
    SecurityListTypeEnum_descriptor(), name, value);
}
enum SecurityListTypeSourceEnum {
  SECURITY_LIST_TYPE_SOURCE_GICS = 0,
  SECURITY_LIST_TYPE_SOURCE_ICB = 1,
  SECURITY_LIST_TYPE_SOURCE_NAICS = 2
};
bool SecurityListTypeSourceEnum_IsValid(int value);
const SecurityListTypeSourceEnum SecurityListTypeSourceEnum_MIN = SECURITY_LIST_TYPE_SOURCE_GICS;
const SecurityListTypeSourceEnum SecurityListTypeSourceEnum_MAX = SECURITY_LIST_TYPE_SOURCE_NAICS;
const int SecurityListTypeSourceEnum_ARRAYSIZE = SecurityListTypeSourceEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityListTypeSourceEnum_descriptor();
inline const ::std::string& SecurityListTypeSourceEnum_Name(SecurityListTypeSourceEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityListTypeSourceEnum_descriptor(), value);
}
inline bool SecurityListTypeSourceEnum_Parse(
    const ::std::string& name, SecurityListTypeSourceEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityListTypeSourceEnum>(
    SecurityListTypeSourceEnum_descriptor(), name, value);
}
enum SecurityRequestResultEnum {
  SECURITY_REQUEST_RESULT_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE = 0,
  SECURITY_REQUEST_RESULT_INVALID_OR_UNSUPPORTED_REQUEST = 1,
  SECURITY_REQUEST_RESULT_NO_INSTRUMENTS_FOUND = 2,
  SECURITY_REQUEST_RESULT_NOT_AUTHORIZED_TO_RETRIEVE_INSTRUMENT_DATA = 3,
  SECURITY_REQUEST_RESULT_REQUEST_FOR_INSTRUMENT_DATA_NOT_SUPPORTED = 4,
  SECURITY_REQUEST_RESULT_VALID_REQUEST = 5
};
bool SecurityRequestResultEnum_IsValid(int value);
const SecurityRequestResultEnum SecurityRequestResultEnum_MIN = SECURITY_REQUEST_RESULT_INSTRUMENT_DATA_TEMPORARILY_UNAVAILABLE;
const SecurityRequestResultEnum SecurityRequestResultEnum_MAX = SECURITY_REQUEST_RESULT_VALID_REQUEST;
const int SecurityRequestResultEnum_ARRAYSIZE = SecurityRequestResultEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityRequestResultEnum_descriptor();
inline const ::std::string& SecurityRequestResultEnum_Name(SecurityRequestResultEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityRequestResultEnum_descriptor(), value);
}
inline bool SecurityRequestResultEnum_Parse(
    const ::std::string& name, SecurityRequestResultEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityRequestResultEnum>(
    SecurityRequestResultEnum_descriptor(), name, value);
}
enum LastFragmentEnum {
  LAST_FRAGMENT_LAST_MESSAGE = 0,
  LAST_FRAGMENT_NOT_LAST_MESSAGE = 1
};
bool LastFragmentEnum_IsValid(int value);
const LastFragmentEnum LastFragmentEnum_MIN = LAST_FRAGMENT_LAST_MESSAGE;
const LastFragmentEnum LastFragmentEnum_MAX = LAST_FRAGMENT_NOT_LAST_MESSAGE;
const int LastFragmentEnum_ARRAYSIZE = LastFragmentEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LastFragmentEnum_descriptor();
inline const ::std::string& LastFragmentEnum_Name(LastFragmentEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LastFragmentEnum_descriptor(), value);
}
inline bool LastFragmentEnum_Parse(
    const ::std::string& name, LastFragmentEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LastFragmentEnum>(
    LastFragmentEnum_descriptor(), name, value);
}
enum SecurityListRequestTypeEnum {
  SECURITY_LIST_REQUEST_TYPE_ALL_SECURITIES = 0,
  SECURITY_LIST_REQUEST_TYPE_PRODUCT = 1,
  SECURITY_LIST_REQUEST_TYPE_SECURITY_TYPE_AND = 2,
  SECURITY_LIST_REQUEST_TYPE_SYMBOL = 3,
  SECURITY_LIST_REQUEST_TYPE_TRADING_SESSION_ID = 4,
  SECURITY_LIST_REQUEST_TYPE_MARKET_ID_OR_MARKET_ID = 5
};
bool SecurityListRequestTypeEnum_IsValid(int value);
const SecurityListRequestTypeEnum SecurityListRequestTypeEnum_MIN = SECURITY_LIST_REQUEST_TYPE_ALL_SECURITIES;
const SecurityListRequestTypeEnum SecurityListRequestTypeEnum_MAX = SECURITY_LIST_REQUEST_TYPE_MARKET_ID_OR_MARKET_ID;
const int SecurityListRequestTypeEnum_ARRAYSIZE = SecurityListRequestTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* SecurityListRequestTypeEnum_descriptor();
inline const ::std::string& SecurityListRequestTypeEnum_Name(SecurityListRequestTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    SecurityListRequestTypeEnum_descriptor(), value);
}
inline bool SecurityListRequestTypeEnum_Parse(
    const ::std::string& name, SecurityListRequestTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SecurityListRequestTypeEnum>(
    SecurityListRequestTypeEnum_descriptor(), name, value);
}
enum LegSwapTypeEnum {
  LEG_SWAP_TYPE_MODIFIED_DURATION = 0,
  LEG_SWAP_TYPE_PAR_FOR_PAR = 1,
  LEG_SWAP_TYPE_PROCEEDS = 2,
  LEG_SWAP_TYPE_RISK = 3
};
bool LegSwapTypeEnum_IsValid(int value);
const LegSwapTypeEnum LegSwapTypeEnum_MIN = LEG_SWAP_TYPE_MODIFIED_DURATION;
const LegSwapTypeEnum LegSwapTypeEnum_MAX = LEG_SWAP_TYPE_RISK;
const int LegSwapTypeEnum_ARRAYSIZE = LegSwapTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LegSwapTypeEnum_descriptor();
inline const ::std::string& LegSwapTypeEnum_Name(LegSwapTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LegSwapTypeEnum_descriptor(), value);
}
inline bool LegSwapTypeEnum_Parse(
    const ::std::string& name, LegSwapTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LegSwapTypeEnum>(
    LegSwapTypeEnum_descriptor(), name, value);
}
// ===================================================================

class SecurityDefinition : public ::google::protobuf::Message {
 public:
  SecurityDefinition();
  virtual ~SecurityDefinition();

  SecurityDefinition(const SecurityDefinition& from);

  inline SecurityDefinition& operator=(const SecurityDefinition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityDefinition& default_instance();

  void Swap(SecurityDefinition* other);

  // implements Message ----------------------------------------------

  SecurityDefinition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityDefinition& from);
  void MergeFrom(const SecurityDefinition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string currency = 1;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 1;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional bytes encoded_text = 2;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 2;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 3;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 3;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional string security_req_id = 4;
  inline bool has_security_req_id() const;
  inline void clear_security_req_id();
  static const int kSecurityReqIdFieldNumber = 4;
  inline const ::std::string& security_req_id() const;
  inline void set_security_req_id(const ::std::string& value);
  inline void set_security_req_id(const char* value);
  inline void set_security_req_id(const char* value, size_t size);
  inline ::std::string* mutable_security_req_id();
  inline ::std::string* release_security_req_id();
  inline void set_allocated_security_req_id(::std::string* security_req_id);

  // optional string security_response_id = 5;
  inline bool has_security_response_id() const;
  inline void clear_security_response_id();
  static const int kSecurityResponseIdFieldNumber = 5;
  inline const ::std::string& security_response_id() const;
  inline void set_security_response_id(const ::std::string& value);
  inline void set_security_response_id(const char* value);
  inline void set_security_response_id(const char* value, size_t size);
  inline ::std::string* mutable_security_response_id();
  inline ::std::string* release_security_response_id();
  inline void set_allocated_security_response_id(::std::string* security_response_id);

  // optional .SecuritiesReferenceData.SecurityResponseTypeEnum security_response_type = 6;
  inline bool has_security_response_type() const;
  inline void clear_security_response_type();
  static const int kSecurityResponseTypeFieldNumber = 6;
  inline ::SecuritiesReferenceData::SecurityResponseTypeEnum security_response_type() const;
  inline void set_security_response_type(::SecuritiesReferenceData::SecurityResponseTypeEnum value);

  // optional .Session.StandardHeader standard_header = 7;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 7;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 8;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 8;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional string text = 9;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 9;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .Common.Instrument instrument = 10;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 10;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional sfixed32 clearing_business_date = 11;
  inline bool has_clearing_business_date() const;
  inline void clear_clearing_business_date();
  static const int kClearingBusinessDateFieldNumber = 11;
  inline ::google::protobuf::int32 clearing_business_date() const;
  inline void set_clearing_business_date(::google::protobuf::int32 value);

  // repeated .Common.InstrmtLegGrp instrmt_leg_grp = 12;
  inline int instrmt_leg_grp_size() const;
  inline void clear_instrmt_leg_grp();
  static const int kInstrmtLegGrpFieldNumber = 12;
  inline const ::Common::InstrmtLegGrp& instrmt_leg_grp(int index) const;
  inline ::Common::InstrmtLegGrp* mutable_instrmt_leg_grp(int index);
  inline ::Common::InstrmtLegGrp* add_instrmt_leg_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
      instrmt_leg_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
      mutable_instrmt_leg_grp();

  // optional .Common.InstrumentExtension instrument_extension = 13;
  inline bool has_instrument_extension() const;
  inline void clear_instrument_extension();
  static const int kInstrumentExtensionFieldNumber = 13;
  inline const ::Common::InstrumentExtension& instrument_extension() const;
  inline ::Common::InstrumentExtension* mutable_instrument_extension();
  inline ::Common::InstrumentExtension* release_instrument_extension();
  inline void set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension);

  // optional sfixed64 security_report_id = 14;
  inline bool has_security_report_id() const;
  inline void clear_security_report_id();
  static const int kSecurityReportIdFieldNumber = 14;
  inline ::google::protobuf::int64 security_report_id() const;
  inline void set_security_report_id(::google::protobuf::int64 value);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 15;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 15;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // optional .Common.ApplicationSequenceControl application_sequence_control = 16;
  inline bool has_application_sequence_control() const;
  inline void clear_application_sequence_control();
  static const int kApplicationSequenceControlFieldNumber = 16;
  inline const ::Common::ApplicationSequenceControl& application_sequence_control() const;
  inline ::Common::ApplicationSequenceControl* mutable_application_sequence_control();
  inline ::Common::ApplicationSequenceControl* release_application_sequence_control();
  inline void set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control);

  // repeated .SecuritiesReferenceData.CorporateActionEnum corporate_action = 17 [packed = true];
  inline int corporate_action_size() const;
  inline void clear_corporate_action();
  static const int kCorporateActionFieldNumber = 17;
  inline ::SecuritiesReferenceData::CorporateActionEnum corporate_action(int index) const;
  inline void set_corporate_action(int index, ::SecuritiesReferenceData::CorporateActionEnum value);
  inline void add_corporate_action(::SecuritiesReferenceData::CorporateActionEnum value);
  inline const ::google::protobuf::RepeatedField<int>& corporate_action() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_corporate_action();

  // repeated .Common.MarketSegmentGrp market_segment_grp = 18;
  inline int market_segment_grp_size() const;
  inline void clear_market_segment_grp();
  static const int kMarketSegmentGrpFieldNumber = 18;
  inline const ::Common::MarketSegmentGrp& market_segment_grp(int index) const;
  inline ::Common::MarketSegmentGrp* mutable_market_segment_grp(int index);
  inline ::Common::MarketSegmentGrp* add_market_segment_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp >&
      market_segment_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp >*
      mutable_market_segment_grp();

  // optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 19;
  inline bool has_spread_or_benchmark_curve_data() const;
  inline void clear_spread_or_benchmark_curve_data();
  static const int kSpreadOrBenchmarkCurveDataFieldNumber = 19;
  inline const ::Common::SpreadOrBenchmarkCurveData& spread_or_benchmark_curve_data() const;
  inline ::Common::SpreadOrBenchmarkCurveData* mutable_spread_or_benchmark_curve_data();
  inline ::Common::SpreadOrBenchmarkCurveData* release_spread_or_benchmark_curve_data();
  inline void set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data);

  // repeated .Common.Stipulations stipulations = 20;
  inline int stipulations_size() const;
  inline void clear_stipulations();
  static const int kStipulationsFieldNumber = 20;
  inline const ::Common::Stipulations& stipulations(int index) const;
  inline ::Common::Stipulations* mutable_stipulations(int index);
  inline ::Common::Stipulations* add_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
      stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
      mutable_stipulations();

  // optional .Common.YieldData yield_data = 21;
  inline bool has_yield_data() const;
  inline void clear_yield_data();
  static const int kYieldDataFieldNumber = 21;
  inline const ::Common::YieldData& yield_data() const;
  inline ::Common::YieldData* mutable_yield_data();
  inline ::Common::YieldData* release_yield_data();
  inline void set_allocated_yield_data(::Common::YieldData* yield_data);

  // optional sfixed64 transact_time = 22;
  inline bool has_transact_time() const;
  inline void clear_transact_time();
  static const int kTransactTimeFieldNumber = 22;
  inline ::google::protobuf::int64 transact_time() const;
  inline void set_transact_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecurityDefinition)
 private:
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_security_req_id();
  inline void clear_has_security_req_id();
  inline void set_has_security_response_id();
  inline void clear_has_security_response_id();
  inline void set_has_security_response_type();
  inline void clear_has_security_response_type();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_clearing_business_date();
  inline void clear_has_clearing_business_date();
  inline void set_has_instrument_extension();
  inline void clear_has_instrument_extension();
  inline void set_has_security_report_id();
  inline void clear_has_security_report_id();
  inline void set_has_application_sequence_control();
  inline void clear_has_application_sequence_control();
  inline void set_has_spread_or_benchmark_curve_data();
  inline void clear_has_spread_or_benchmark_curve_data();
  inline void set_has_yield_data();
  inline void clear_has_yield_data();
  inline void set_has_transact_time();
  inline void clear_has_transact_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* currency_;
  ::std::string* encoded_text_;
  ::std::string* security_req_id_;
  ::google::protobuf::uint32 encoded_text_len_;
  int security_response_type_;
  ::std::string* security_response_id_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::std::string* text_;
  ::Common::Instrument* instrument_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp > instrmt_leg_grp_;
  ::Common::InstrumentExtension* instrument_extension_;
  ::google::protobuf::int64 security_report_id_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;
  ::Common::ApplicationSequenceControl* application_sequence_control_;
  ::google::protobuf::RepeatedField<int> corporate_action_;
  mutable int _corporate_action_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp > market_segment_grp_;
  ::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data_;
  ::google::protobuf::RepeatedPtrField< ::Common::Stipulations > stipulations_;
  ::Common::YieldData* yield_data_;
  ::google::protobuf::int64 transact_time_;
  ::google::protobuf::int32 clearing_business_date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecurityDefinition* default_instance_;
};
// -------------------------------------------------------------------

class SecurityDefinitionRequest : public ::google::protobuf::Message {
 public:
  SecurityDefinitionRequest();
  virtual ~SecurityDefinitionRequest();

  SecurityDefinitionRequest(const SecurityDefinitionRequest& from);

  inline SecurityDefinitionRequest& operator=(const SecurityDefinitionRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityDefinitionRequest& default_instance();

  void Swap(SecurityDefinitionRequest* other);

  // implements Message ----------------------------------------------

  SecurityDefinitionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityDefinitionRequest& from);
  void MergeFrom(const SecurityDefinitionRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string currency = 1;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 1;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional bytes encoded_text = 2;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 2;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 3;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 3;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional string security_req_id = 4;
  inline bool has_security_req_id() const;
  inline void clear_security_req_id();
  static const int kSecurityReqIdFieldNumber = 4;
  inline const ::std::string& security_req_id() const;
  inline void set_security_req_id(const ::std::string& value);
  inline void set_security_req_id(const char* value);
  inline void set_security_req_id(const char* value, size_t size);
  inline ::std::string* mutable_security_req_id();
  inline ::std::string* release_security_req_id();
  inline void set_allocated_security_req_id(::std::string* security_req_id);

  // optional .SecuritiesReferenceData.SecurityRequestTypeEnum security_request_type = 5;
  inline bool has_security_request_type() const;
  inline void clear_security_request_type();
  static const int kSecurityRequestTypeFieldNumber = 5;
  inline ::SecuritiesReferenceData::SecurityRequestTypeEnum security_request_type() const;
  inline void set_security_request_type(::SecuritiesReferenceData::SecurityRequestTypeEnum value);

  // optional .Session.StandardHeader standard_header = 6;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 6;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 7;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 7;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional string text = 8;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 8;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .SecuritiesReferenceData.TradingSessionIdEnum trading_session_id = 9;
  inline bool has_trading_session_id() const;
  inline void clear_trading_session_id();
  static const int kTradingSessionIdFieldNumber = 9;
  inline ::SecuritiesReferenceData::TradingSessionIdEnum trading_session_id() const;
  inline void set_trading_session_id(::SecuritiesReferenceData::TradingSessionIdEnum value);

  // optional .Common.Instrument instrument = 10;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 10;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional .SecuritiesReferenceData.SubscriptionRequestTypeEnum subscription_request_type = 11;
  inline bool has_subscription_request_type() const;
  inline void clear_subscription_request_type();
  static const int kSubscriptionRequestTypeFieldNumber = 11;
  inline ::SecuritiesReferenceData::SubscriptionRequestTypeEnum subscription_request_type() const;
  inline void set_subscription_request_type(::SecuritiesReferenceData::SubscriptionRequestTypeEnum value);

  // optional .SecuritiesReferenceData.TradingSessionSubIdEnum trading_session_sub_id = 12;
  inline bool has_trading_session_sub_id() const;
  inline void clear_trading_session_sub_id();
  static const int kTradingSessionSubIdFieldNumber = 12;
  inline ::SecuritiesReferenceData::TradingSessionSubIdEnum trading_session_sub_id() const;
  inline void set_trading_session_sub_id(::SecuritiesReferenceData::TradingSessionSubIdEnum value);

  // optional .SecuritiesReferenceData.ExpirationCycleEnum expiration_cycle = 13;
  inline bool has_expiration_cycle() const;
  inline void clear_expiration_cycle();
  static const int kExpirationCycleFieldNumber = 13;
  inline ::SecuritiesReferenceData::ExpirationCycleEnum expiration_cycle() const;
  inline void set_expiration_cycle(::SecuritiesReferenceData::ExpirationCycleEnum value);

  // repeated .Common.InstrmtLegGrp instrmt_leg_grp = 14;
  inline int instrmt_leg_grp_size() const;
  inline void clear_instrmt_leg_grp();
  static const int kInstrmtLegGrpFieldNumber = 14;
  inline const ::Common::InstrmtLegGrp& instrmt_leg_grp(int index) const;
  inline ::Common::InstrmtLegGrp* mutable_instrmt_leg_grp(int index);
  inline ::Common::InstrmtLegGrp* add_instrmt_leg_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
      instrmt_leg_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
      mutable_instrmt_leg_grp();

  // optional .Common.InstrumentExtension instrument_extension = 15;
  inline bool has_instrument_extension() const;
  inline void clear_instrument_extension();
  static const int kInstrumentExtensionFieldNumber = 15;
  inline const ::Common::InstrumentExtension& instrument_extension() const;
  inline ::Common::InstrumentExtension* mutable_instrument_extension();
  inline ::Common::InstrumentExtension* release_instrument_extension();
  inline void set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 16;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 16;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // optional string market_id = 17;
  inline bool has_market_id() const;
  inline void clear_market_id();
  static const int kMarketIdFieldNumber = 17;
  inline const ::std::string& market_id() const;
  inline void set_market_id(const ::std::string& value);
  inline void set_market_id(const char* value);
  inline void set_market_id(const char* value, size_t size);
  inline ::std::string* mutable_market_id();
  inline ::std::string* release_market_id();
  inline void set_allocated_market_id(::std::string* market_id);

  // optional string market_segment_id = 18;
  inline bool has_market_segment_id() const;
  inline void clear_market_segment_id();
  static const int kMarketSegmentIdFieldNumber = 18;
  inline const ::std::string& market_segment_id() const;
  inline void set_market_segment_id(const ::std::string& value);
  inline void set_market_segment_id(const char* value);
  inline void set_market_segment_id(const char* value, size_t size);
  inline ::std::string* mutable_market_segment_id();
  inline ::std::string* release_market_segment_id();
  inline void set_allocated_market_segment_id(::std::string* market_segment_id);

  // optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 19;
  inline bool has_spread_or_benchmark_curve_data() const;
  inline void clear_spread_or_benchmark_curve_data();
  static const int kSpreadOrBenchmarkCurveDataFieldNumber = 19;
  inline const ::Common::SpreadOrBenchmarkCurveData& spread_or_benchmark_curve_data() const;
  inline ::Common::SpreadOrBenchmarkCurveData* mutable_spread_or_benchmark_curve_data();
  inline ::Common::SpreadOrBenchmarkCurveData* release_spread_or_benchmark_curve_data();
  inline void set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data);

  // repeated .Common.Stipulations stipulations = 20;
  inline int stipulations_size() const;
  inline void clear_stipulations();
  static const int kStipulationsFieldNumber = 20;
  inline const ::Common::Stipulations& stipulations(int index) const;
  inline ::Common::Stipulations* mutable_stipulations(int index);
  inline ::Common::Stipulations* add_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
      stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
      mutable_stipulations();

  // optional .Common.YieldData yield_data = 21;
  inline bool has_yield_data() const;
  inline void clear_yield_data();
  static const int kYieldDataFieldNumber = 21;
  inline const ::Common::YieldData& yield_data() const;
  inline ::Common::YieldData* mutable_yield_data();
  inline ::Common::YieldData* release_yield_data();
  inline void set_allocated_yield_data(::Common::YieldData* yield_data);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecurityDefinitionRequest)
 private:
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_security_req_id();
  inline void clear_has_security_req_id();
  inline void set_has_security_request_type();
  inline void clear_has_security_request_type();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_trading_session_id();
  inline void clear_has_trading_session_id();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_subscription_request_type();
  inline void clear_has_subscription_request_type();
  inline void set_has_trading_session_sub_id();
  inline void clear_has_trading_session_sub_id();
  inline void set_has_expiration_cycle();
  inline void clear_has_expiration_cycle();
  inline void set_has_instrument_extension();
  inline void clear_has_instrument_extension();
  inline void set_has_market_id();
  inline void clear_has_market_id();
  inline void set_has_market_segment_id();
  inline void clear_has_market_segment_id();
  inline void set_has_spread_or_benchmark_curve_data();
  inline void clear_has_spread_or_benchmark_curve_data();
  inline void set_has_yield_data();
  inline void clear_has_yield_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* currency_;
  ::std::string* encoded_text_;
  ::std::string* security_req_id_;
  ::google::protobuf::uint32 encoded_text_len_;
  int security_request_type_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::std::string* text_;
  ::Common::Instrument* instrument_;
  int trading_session_id_;
  int subscription_request_type_;
  int trading_session_sub_id_;
  int expiration_cycle_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp > instrmt_leg_grp_;
  ::Common::InstrumentExtension* instrument_extension_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;
  ::std::string* market_id_;
  ::std::string* market_segment_id_;
  ::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data_;
  ::google::protobuf::RepeatedPtrField< ::Common::Stipulations > stipulations_;
  ::Common::YieldData* yield_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecurityDefinitionRequest* default_instance_;
};
// -------------------------------------------------------------------

class SecurityDefinitionUpdateReport : public ::google::protobuf::Message {
 public:
  SecurityDefinitionUpdateReport();
  virtual ~SecurityDefinitionUpdateReport();

  SecurityDefinitionUpdateReport(const SecurityDefinitionUpdateReport& from);

  inline SecurityDefinitionUpdateReport& operator=(const SecurityDefinitionUpdateReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityDefinitionUpdateReport& default_instance();

  void Swap(SecurityDefinitionUpdateReport* other);

  // implements Message ----------------------------------------------

  SecurityDefinitionUpdateReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityDefinitionUpdateReport& from);
  void MergeFrom(const SecurityDefinitionUpdateReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed32 clearing_business_date = 1;
  inline bool has_clearing_business_date() const;
  inline void clear_clearing_business_date();
  static const int kClearingBusinessDateFieldNumber = 1;
  inline ::google::protobuf::int32 clearing_business_date() const;
  inline void set_clearing_business_date(::google::protobuf::int32 value);

  // repeated .SecuritiesReferenceData.CorporateActionEnum corporate_action = 2 [packed = true];
  inline int corporate_action_size() const;
  inline void clear_corporate_action();
  static const int kCorporateActionFieldNumber = 2;
  inline ::SecuritiesReferenceData::CorporateActionEnum corporate_action(int index) const;
  inline void set_corporate_action(int index, ::SecuritiesReferenceData::CorporateActionEnum value);
  inline void add_corporate_action(::SecuritiesReferenceData::CorporateActionEnum value);
  inline const ::google::protobuf::RepeatedField<int>& corporate_action() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_corporate_action();

  // optional string currency = 3;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 3;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional bytes encoded_text = 4;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 4;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 5;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 5;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // repeated .Common.InstrmtLegGrp instrmt_leg_grp = 6;
  inline int instrmt_leg_grp_size() const;
  inline void clear_instrmt_leg_grp();
  static const int kInstrmtLegGrpFieldNumber = 6;
  inline const ::Common::InstrmtLegGrp& instrmt_leg_grp(int index) const;
  inline ::Common::InstrmtLegGrp* mutable_instrmt_leg_grp(int index);
  inline ::Common::InstrmtLegGrp* add_instrmt_leg_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
      instrmt_leg_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
      mutable_instrmt_leg_grp();

  // optional .Common.Instrument instrument = 7;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 7;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional sfixed64 security_report_id = 8;
  inline bool has_security_report_id() const;
  inline void clear_security_report_id();
  static const int kSecurityReportIdFieldNumber = 8;
  inline ::google::protobuf::int64 security_report_id() const;
  inline void set_security_report_id(::google::protobuf::int64 value);

  // optional string security_req_id = 9;
  inline bool has_security_req_id() const;
  inline void clear_security_req_id();
  static const int kSecurityReqIdFieldNumber = 9;
  inline const ::std::string& security_req_id() const;
  inline void set_security_req_id(const ::std::string& value);
  inline void set_security_req_id(const char* value);
  inline void set_security_req_id(const char* value, size_t size);
  inline ::std::string* mutable_security_req_id();
  inline ::std::string* release_security_req_id();
  inline void set_allocated_security_req_id(::std::string* security_req_id);

  // optional string security_response_id = 10;
  inline bool has_security_response_id() const;
  inline void clear_security_response_id();
  static const int kSecurityResponseIdFieldNumber = 10;
  inline const ::std::string& security_response_id() const;
  inline void set_security_response_id(const ::std::string& value);
  inline void set_security_response_id(const char* value);
  inline void set_security_response_id(const char* value, size_t size);
  inline ::std::string* mutable_security_response_id();
  inline ::std::string* release_security_response_id();
  inline void set_allocated_security_response_id(::std::string* security_response_id);

  // optional .SecuritiesReferenceData.SecurityResponseTypeEnum security_response_type = 11;
  inline bool has_security_response_type() const;
  inline void clear_security_response_type();
  static const int kSecurityResponseTypeFieldNumber = 11;
  inline ::SecuritiesReferenceData::SecurityResponseTypeEnum security_response_type() const;
  inline void set_security_response_type(::SecuritiesReferenceData::SecurityResponseTypeEnum value);

  // optional .SecuritiesReferenceData.SecurityUpdateActionEnum security_update_action = 12;
  inline bool has_security_update_action() const;
  inline void clear_security_update_action();
  static const int kSecurityUpdateActionFieldNumber = 12;
  inline ::SecuritiesReferenceData::SecurityUpdateActionEnum security_update_action() const;
  inline void set_security_update_action(::SecuritiesReferenceData::SecurityUpdateActionEnum value);

  // optional .Session.StandardHeader standard_header = 13;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 13;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 14;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 14;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional string text = 15;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 15;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .Common.ApplicationSequenceControl application_sequence_control = 16;
  inline bool has_application_sequence_control() const;
  inline void clear_application_sequence_control();
  static const int kApplicationSequenceControlFieldNumber = 16;
  inline const ::Common::ApplicationSequenceControl& application_sequence_control() const;
  inline ::Common::ApplicationSequenceControl* mutable_application_sequence_control();
  inline ::Common::ApplicationSequenceControl* release_application_sequence_control();
  inline void set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control);

  // optional .Common.InstrumentExtension instrument_extension = 17;
  inline bool has_instrument_extension() const;
  inline void clear_instrument_extension();
  static const int kInstrumentExtensionFieldNumber = 17;
  inline const ::Common::InstrumentExtension& instrument_extension() const;
  inline ::Common::InstrumentExtension* mutable_instrument_extension();
  inline ::Common::InstrumentExtension* release_instrument_extension();
  inline void set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension);

  // repeated .Common.MarketSegmentGrp market_segment_grp = 18;
  inline int market_segment_grp_size() const;
  inline void clear_market_segment_grp();
  static const int kMarketSegmentGrpFieldNumber = 18;
  inline const ::Common::MarketSegmentGrp& market_segment_grp(int index) const;
  inline ::Common::MarketSegmentGrp* mutable_market_segment_grp(int index);
  inline ::Common::MarketSegmentGrp* add_market_segment_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp >&
      market_segment_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp >*
      mutable_market_segment_grp();

  // optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 19;
  inline bool has_spread_or_benchmark_curve_data() const;
  inline void clear_spread_or_benchmark_curve_data();
  static const int kSpreadOrBenchmarkCurveDataFieldNumber = 19;
  inline const ::Common::SpreadOrBenchmarkCurveData& spread_or_benchmark_curve_data() const;
  inline ::Common::SpreadOrBenchmarkCurveData* mutable_spread_or_benchmark_curve_data();
  inline ::Common::SpreadOrBenchmarkCurveData* release_spread_or_benchmark_curve_data();
  inline void set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data);

  // repeated .Common.Stipulations stipulations = 20;
  inline int stipulations_size() const;
  inline void clear_stipulations();
  static const int kStipulationsFieldNumber = 20;
  inline const ::Common::Stipulations& stipulations(int index) const;
  inline ::Common::Stipulations* mutable_stipulations(int index);
  inline ::Common::Stipulations* add_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
      stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
      mutable_stipulations();

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 21;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 21;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // optional .Common.YieldData yield_data = 22;
  inline bool has_yield_data() const;
  inline void clear_yield_data();
  static const int kYieldDataFieldNumber = 22;
  inline const ::Common::YieldData& yield_data() const;
  inline ::Common::YieldData* mutable_yield_data();
  inline ::Common::YieldData* release_yield_data();
  inline void set_allocated_yield_data(::Common::YieldData* yield_data);

  // optional sfixed64 transact_time = 23;
  inline bool has_transact_time() const;
  inline void clear_transact_time();
  static const int kTransactTimeFieldNumber = 23;
  inline ::google::protobuf::int64 transact_time() const;
  inline void set_transact_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecurityDefinitionUpdateReport)
 private:
  inline void set_has_clearing_business_date();
  inline void clear_has_clearing_business_date();
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_security_report_id();
  inline void clear_has_security_report_id();
  inline void set_has_security_req_id();
  inline void clear_has_security_req_id();
  inline void set_has_security_response_id();
  inline void clear_has_security_response_id();
  inline void set_has_security_response_type();
  inline void clear_has_security_response_type();
  inline void set_has_security_update_action();
  inline void clear_has_security_update_action();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_application_sequence_control();
  inline void clear_has_application_sequence_control();
  inline void set_has_instrument_extension();
  inline void clear_has_instrument_extension();
  inline void set_has_spread_or_benchmark_curve_data();
  inline void clear_has_spread_or_benchmark_curve_data();
  inline void set_has_yield_data();
  inline void clear_has_yield_data();
  inline void set_has_transact_time();
  inline void clear_has_transact_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> corporate_action_;
  mutable int _corporate_action_cached_byte_size_;
  ::std::string* currency_;
  ::google::protobuf::int32 clearing_business_date_;
  ::google::protobuf::uint32 encoded_text_len_;
  ::std::string* encoded_text_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp > instrmt_leg_grp_;
  ::Common::Instrument* instrument_;
  ::google::protobuf::int64 security_report_id_;
  ::std::string* security_req_id_;
  ::std::string* security_response_id_;
  int security_response_type_;
  int security_update_action_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::std::string* text_;
  ::Common::ApplicationSequenceControl* application_sequence_control_;
  ::Common::InstrumentExtension* instrument_extension_;
  ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp > market_segment_grp_;
  ::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data_;
  ::google::protobuf::RepeatedPtrField< ::Common::Stipulations > stipulations_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;
  ::Common::YieldData* yield_data_;
  ::google::protobuf::int64 transact_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecurityDefinitionUpdateReport* default_instance_;
};
// -------------------------------------------------------------------

class SecListGrp : public ::google::protobuf::Message {
 public:
  SecListGrp();
  virtual ~SecListGrp();

  SecListGrp(const SecListGrp& from);

  inline SecListGrp& operator=(const SecListGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecListGrp& default_instance();

  void Swap(SecListGrp* other);

  // implements Message ----------------------------------------------

  SecListGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecListGrp& from);
  void MergeFrom(const SecListGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string currency = 1;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 1;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional bytes encoded_text = 2;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 2;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 3;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 3;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional .Common.FinancingDetails financing_details = 4;
  inline bool has_financing_details() const;
  inline void clear_financing_details();
  static const int kFinancingDetailsFieldNumber = 4;
  inline const ::Common::FinancingDetails& financing_details() const;
  inline ::Common::FinancingDetails* mutable_financing_details();
  inline ::Common::FinancingDetails* release_financing_details();
  inline void set_allocated_financing_details(::Common::FinancingDetails* financing_details);

  // repeated .Common.InstrmtLegSecListGrp instrmt_leg_sec_list_grp = 5;
  inline int instrmt_leg_sec_list_grp_size() const;
  inline void clear_instrmt_leg_sec_list_grp();
  static const int kInstrmtLegSecListGrpFieldNumber = 5;
  inline const ::Common::InstrmtLegSecListGrp& instrmt_leg_sec_list_grp(int index) const;
  inline ::Common::InstrmtLegSecListGrp* mutable_instrmt_leg_sec_list_grp(int index);
  inline ::Common::InstrmtLegSecListGrp* add_instrmt_leg_sec_list_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegSecListGrp >&
      instrmt_leg_sec_list_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegSecListGrp >*
      mutable_instrmt_leg_sec_list_grp();

  // optional .Common.Instrument instrument = 6;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 6;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional .Common.InstrumentExtension instrument_extension = 7;
  inline bool has_instrument_extension() const;
  inline void clear_instrument_extension();
  static const int kInstrumentExtensionFieldNumber = 7;
  inline const ::Common::InstrumentExtension& instrument_extension() const;
  inline ::Common::InstrumentExtension* mutable_instrument_extension();
  inline ::Common::InstrumentExtension* release_instrument_extension();
  inline void set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension);

  // optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 8;
  inline bool has_spread_or_benchmark_curve_data() const;
  inline void clear_spread_or_benchmark_curve_data();
  static const int kSpreadOrBenchmarkCurveDataFieldNumber = 8;
  inline const ::Common::SpreadOrBenchmarkCurveData& spread_or_benchmark_curve_data() const;
  inline ::Common::SpreadOrBenchmarkCurveData* mutable_spread_or_benchmark_curve_data();
  inline ::Common::SpreadOrBenchmarkCurveData* release_spread_or_benchmark_curve_data();
  inline void set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data);

  // repeated .Common.Stipulations stipulations = 9;
  inline int stipulations_size() const;
  inline void clear_stipulations();
  static const int kStipulationsFieldNumber = 9;
  inline const ::Common::Stipulations& stipulations(int index) const;
  inline ::Common::Stipulations* mutable_stipulations(int index);
  inline ::Common::Stipulations* add_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
      stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
      mutable_stipulations();

  // optional string text = 10;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 10;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 11;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 11;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // optional .Common.YieldData yield_data = 12;
  inline bool has_yield_data() const;
  inline void clear_yield_data();
  static const int kYieldDataFieldNumber = 12;
  inline const ::Common::YieldData& yield_data() const;
  inline ::Common::YieldData* mutable_yield_data();
  inline ::Common::YieldData* release_yield_data();
  inline void set_allocated_yield_data(::Common::YieldData* yield_data);

  // optional .Common.SecurityTradingRules security_trading_rules = 13;
  inline bool has_security_trading_rules() const;
  inline void clear_security_trading_rules();
  static const int kSecurityTradingRulesFieldNumber = 13;
  inline const ::Common::SecurityTradingRules& security_trading_rules() const;
  inline ::Common::SecurityTradingRules* mutable_security_trading_rules();
  inline ::Common::SecurityTradingRules* release_security_trading_rules();
  inline void set_allocated_security_trading_rules(::Common::SecurityTradingRules* security_trading_rules);

  // repeated .Common.StrikeRules strike_rules = 14;
  inline int strike_rules_size() const;
  inline void clear_strike_rules();
  static const int kStrikeRulesFieldNumber = 14;
  inline const ::Common::StrikeRules& strike_rules(int index) const;
  inline ::Common::StrikeRules* mutable_strike_rules(int index);
  inline ::Common::StrikeRules* add_strike_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >&
      strike_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >*
      mutable_strike_rules();

  // optional sfixed64 rel_sym_transact_time = 15;
  inline bool has_rel_sym_transact_time() const;
  inline void clear_rel_sym_transact_time();
  static const int kRelSymTransactTimeFieldNumber = 15;
  inline ::google::protobuf::int64 rel_sym_transact_time() const;
  inline void set_rel_sym_transact_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecListGrp)
 private:
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_financing_details();
  inline void clear_has_financing_details();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_instrument_extension();
  inline void clear_has_instrument_extension();
  inline void set_has_spread_or_benchmark_curve_data();
  inline void clear_has_spread_or_benchmark_curve_data();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_yield_data();
  inline void clear_has_yield_data();
  inline void set_has_security_trading_rules();
  inline void clear_has_security_trading_rules();
  inline void set_has_rel_sym_transact_time();
  inline void clear_has_rel_sym_transact_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* currency_;
  ::std::string* encoded_text_;
  ::Common::FinancingDetails* financing_details_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegSecListGrp > instrmt_leg_sec_list_grp_;
  ::Common::Instrument* instrument_;
  ::Common::InstrumentExtension* instrument_extension_;
  ::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data_;
  ::google::protobuf::RepeatedPtrField< ::Common::Stipulations > stipulations_;
  ::std::string* text_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;
  ::Common::YieldData* yield_data_;
  ::Common::SecurityTradingRules* security_trading_rules_;
  ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules > strike_rules_;
  ::google::protobuf::int64 rel_sym_transact_time_;
  ::google::protobuf::uint32 encoded_text_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecListGrp* default_instance_;
};
// -------------------------------------------------------------------

class SecurityListTypeUnion : public ::google::protobuf::Message {
 public:
  SecurityListTypeUnion();
  virtual ~SecurityListTypeUnion();

  SecurityListTypeUnion(const SecurityListTypeUnion& from);

  inline SecurityListTypeUnion& operator=(const SecurityListTypeUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityListTypeUnion& default_instance();

  void Swap(SecurityListTypeUnion* other);

  // implements Message ----------------------------------------------

  SecurityListTypeUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityListTypeUnion& from);
  void MergeFrom(const SecurityListTypeUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SecuritiesReferenceData.SecurityListTypeEnum security_list_type = 1;
  inline bool has_security_list_type() const;
  inline void clear_security_list_type();
  static const int kSecurityListTypeFieldNumber = 1;
  inline ::SecuritiesReferenceData::SecurityListTypeEnum security_list_type() const;
  inline void set_security_list_type(::SecuritiesReferenceData::SecurityListTypeEnum value);

  // optional sfixed64 security_list_type_sfixed64 = 2;
  inline bool has_security_list_type_sfixed64() const;
  inline void clear_security_list_type_sfixed64();
  static const int kSecurityListTypeSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 security_list_type_sfixed64() const;
  inline void set_security_list_type_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecurityListTypeUnion)
 private:
  inline void set_has_security_list_type();
  inline void clear_has_security_list_type();
  inline void set_has_security_list_type_sfixed64();
  inline void clear_has_security_list_type_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 security_list_type_sfixed64_;
  int security_list_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecurityListTypeUnion* default_instance_;
};
// -------------------------------------------------------------------

class SecurityListTypeSourceUnion : public ::google::protobuf::Message {
 public:
  SecurityListTypeSourceUnion();
  virtual ~SecurityListTypeSourceUnion();

  SecurityListTypeSourceUnion(const SecurityListTypeSourceUnion& from);

  inline SecurityListTypeSourceUnion& operator=(const SecurityListTypeSourceUnion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityListTypeSourceUnion& default_instance();

  void Swap(SecurityListTypeSourceUnion* other);

  // implements Message ----------------------------------------------

  SecurityListTypeSourceUnion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityListTypeSourceUnion& from);
  void MergeFrom(const SecurityListTypeSourceUnion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .SecuritiesReferenceData.SecurityListTypeSourceEnum security_list_type_source = 1;
  inline bool has_security_list_type_source() const;
  inline void clear_security_list_type_source();
  static const int kSecurityListTypeSourceFieldNumber = 1;
  inline ::SecuritiesReferenceData::SecurityListTypeSourceEnum security_list_type_source() const;
  inline void set_security_list_type_source(::SecuritiesReferenceData::SecurityListTypeSourceEnum value);

  // optional sfixed64 security_list_type_source_sfixed64 = 2;
  inline bool has_security_list_type_source_sfixed64() const;
  inline void clear_security_list_type_source_sfixed64();
  static const int kSecurityListTypeSourceSfixed64FieldNumber = 2;
  inline ::google::protobuf::int64 security_list_type_source_sfixed64() const;
  inline void set_security_list_type_source_sfixed64(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecurityListTypeSourceUnion)
 private:
  inline void set_has_security_list_type_source();
  inline void clear_has_security_list_type_source();
  inline void set_has_security_list_type_source_sfixed64();
  inline void clear_has_security_list_type_source_sfixed64();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 security_list_type_source_sfixed64_;
  int security_list_type_source_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecurityListTypeSourceUnion* default_instance_;
};
// -------------------------------------------------------------------

class SecurityList : public ::google::protobuf::Message {
 public:
  SecurityList();
  virtual ~SecurityList();

  SecurityList(const SecurityList& from);

  inline SecurityList& operator=(const SecurityList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityList& default_instance();

  void Swap(SecurityList* other);

  // implements Message ----------------------------------------------

  SecurityList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityList& from);
  void MergeFrom(const SecurityList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string security_req_id = 1;
  inline bool has_security_req_id() const;
  inline void clear_security_req_id();
  static const int kSecurityReqIdFieldNumber = 1;
  inline const ::std::string& security_req_id() const;
  inline void set_security_req_id(const ::std::string& value);
  inline void set_security_req_id(const char* value);
  inline void set_security_req_id(const char* value, size_t size);
  inline ::std::string* mutable_security_req_id();
  inline ::std::string* release_security_req_id();
  inline void set_allocated_security_req_id(::std::string* security_req_id);

  // optional .SecuritiesReferenceData.SecurityRequestResultEnum security_request_result = 2;
  inline bool has_security_request_result() const;
  inline void clear_security_request_result();
  static const int kSecurityRequestResultFieldNumber = 2;
  inline ::SecuritiesReferenceData::SecurityRequestResultEnum security_request_result() const;
  inline void set_security_request_result(::SecuritiesReferenceData::SecurityRequestResultEnum value);

  // optional string security_response_id = 3;
  inline bool has_security_response_id() const;
  inline void clear_security_response_id();
  static const int kSecurityResponseIdFieldNumber = 3;
  inline const ::std::string& security_response_id() const;
  inline void set_security_response_id(const ::std::string& value);
  inline void set_security_response_id(const char* value);
  inline void set_security_response_id(const char* value, size_t size);
  inline ::std::string* mutable_security_response_id();
  inline ::std::string* release_security_response_id();
  inline void set_allocated_security_response_id(::std::string* security_response_id);

  // optional .Session.StandardHeader standard_header = 4;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 4;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 5;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 5;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional sfixed64 tot_no_related_sym = 6;
  inline bool has_tot_no_related_sym() const;
  inline void clear_tot_no_related_sym();
  static const int kTotNoRelatedSymFieldNumber = 6;
  inline ::google::protobuf::int64 tot_no_related_sym() const;
  inline void set_tot_no_related_sym(::google::protobuf::int64 value);

  // optional sfixed32 clearing_business_date = 7;
  inline bool has_clearing_business_date() const;
  inline void clear_clearing_business_date();
  static const int kClearingBusinessDateFieldNumber = 7;
  inline ::google::protobuf::int32 clearing_business_date() const;
  inline void set_clearing_business_date(::google::protobuf::int32 value);

  // optional bool last_fragment = 8;
  inline bool has_last_fragment() const;
  inline void clear_last_fragment();
  static const int kLastFragmentFieldNumber = 8;
  inline bool last_fragment() const;
  inline void set_last_fragment(bool value);

  // repeated .SecuritiesReferenceData.SecListGrp sec_list_grp = 9;
  inline int sec_list_grp_size() const;
  inline void clear_sec_list_grp();
  static const int kSecListGrpFieldNumber = 9;
  inline const ::SecuritiesReferenceData::SecListGrp& sec_list_grp(int index) const;
  inline ::SecuritiesReferenceData::SecListGrp* mutable_sec_list_grp(int index);
  inline ::SecuritiesReferenceData::SecListGrp* add_sec_list_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecListGrp >&
      sec_list_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecListGrp >*
      mutable_sec_list_grp();

  // optional sfixed64 security_report_id = 10;
  inline bool has_security_report_id() const;
  inline void clear_security_report_id();
  static const int kSecurityReportIdFieldNumber = 10;
  inline ::google::protobuf::int64 security_report_id() const;
  inline void set_security_report_id(::google::protobuf::int64 value);

  // optional .Common.ApplicationSequenceControl application_sequence_control = 11;
  inline bool has_application_sequence_control() const;
  inline void clear_application_sequence_control();
  static const int kApplicationSequenceControlFieldNumber = 11;
  inline const ::Common::ApplicationSequenceControl& application_sequence_control() const;
  inline ::Common::ApplicationSequenceControl* mutable_application_sequence_control();
  inline ::Common::ApplicationSequenceControl* release_application_sequence_control();
  inline void set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control);

  // optional string market_id = 12;
  inline bool has_market_id() const;
  inline void clear_market_id();
  static const int kMarketIdFieldNumber = 12;
  inline const ::std::string& market_id() const;
  inline void set_market_id(const ::std::string& value);
  inline void set_market_id(const char* value);
  inline void set_market_id(const char* value, size_t size);
  inline ::std::string* mutable_market_id();
  inline ::std::string* release_market_id();
  inline void set_allocated_market_id(::std::string* market_id);

  // optional string market_segment_id = 13;
  inline bool has_market_segment_id() const;
  inline void clear_market_segment_id();
  static const int kMarketSegmentIdFieldNumber = 13;
  inline const ::std::string& market_segment_id() const;
  inline void set_market_segment_id(const ::std::string& value);
  inline void set_market_segment_id(const char* value);
  inline void set_market_segment_id(const char* value, size_t size);
  inline ::std::string* mutable_market_segment_id();
  inline ::std::string* release_market_segment_id();
  inline void set_allocated_market_segment_id(::std::string* market_segment_id);

  // optional bytes encoded_security_list_desc = 14;
  inline bool has_encoded_security_list_desc() const;
  inline void clear_encoded_security_list_desc();
  static const int kEncodedSecurityListDescFieldNumber = 14;
  inline const ::std::string& encoded_security_list_desc() const;
  inline void set_encoded_security_list_desc(const ::std::string& value);
  inline void set_encoded_security_list_desc(const char* value);
  inline void set_encoded_security_list_desc(const void* value, size_t size);
  inline ::std::string* mutable_encoded_security_list_desc();
  inline ::std::string* release_encoded_security_list_desc();
  inline void set_allocated_encoded_security_list_desc(::std::string* encoded_security_list_desc);

  // optional fixed32 encoded_security_list_desc_len = 15;
  inline bool has_encoded_security_list_desc_len() const;
  inline void clear_encoded_security_list_desc_len();
  static const int kEncodedSecurityListDescLenFieldNumber = 15;
  inline ::google::protobuf::uint32 encoded_security_list_desc_len() const;
  inline void set_encoded_security_list_desc_len(::google::protobuf::uint32 value);

  // optional string security_list_desc = 16;
  inline bool has_security_list_desc() const;
  inline void clear_security_list_desc();
  static const int kSecurityListDescFieldNumber = 16;
  inline const ::std::string& security_list_desc() const;
  inline void set_security_list_desc(const ::std::string& value);
  inline void set_security_list_desc(const char* value);
  inline void set_security_list_desc(const char* value, size_t size);
  inline ::std::string* mutable_security_list_desc();
  inline ::std::string* release_security_list_desc();
  inline void set_allocated_security_list_desc(::std::string* security_list_desc);

  // optional string security_list_id = 17;
  inline bool has_security_list_id() const;
  inline void clear_security_list_id();
  static const int kSecurityListIdFieldNumber = 17;
  inline const ::std::string& security_list_id() const;
  inline void set_security_list_id(const ::std::string& value);
  inline void set_security_list_id(const char* value);
  inline void set_security_list_id(const char* value, size_t size);
  inline ::std::string* mutable_security_list_id();
  inline ::std::string* release_security_list_id();
  inline void set_allocated_security_list_id(::std::string* security_list_id);

  // optional string security_list_ref_id = 18;
  inline bool has_security_list_ref_id() const;
  inline void clear_security_list_ref_id();
  static const int kSecurityListRefIdFieldNumber = 18;
  inline const ::std::string& security_list_ref_id() const;
  inline void set_security_list_ref_id(const ::std::string& value);
  inline void set_security_list_ref_id(const char* value);
  inline void set_security_list_ref_id(const char* value, size_t size);
  inline ::std::string* mutable_security_list_ref_id();
  inline ::std::string* release_security_list_ref_id();
  inline void set_allocated_security_list_ref_id(::std::string* security_list_ref_id);

  // optional .SecuritiesReferenceData.SecurityListTypeEnum security_list_type = 19;
  inline bool has_security_list_type() const;
  inline void clear_security_list_type();
  static const int kSecurityListTypeFieldNumber = 19;
  inline ::SecuritiesReferenceData::SecurityListTypeEnum security_list_type() const;
  inline void set_security_list_type(::SecuritiesReferenceData::SecurityListTypeEnum value);

  // optional .SecuritiesReferenceData.SecurityListTypeSourceEnum security_list_type_source = 20;
  inline bool has_security_list_type_source() const;
  inline void clear_security_list_type_source();
  static const int kSecurityListTypeSourceFieldNumber = 20;
  inline ::SecuritiesReferenceData::SecurityListTypeSourceEnum security_list_type_source() const;
  inline void set_security_list_type_source(::SecuritiesReferenceData::SecurityListTypeSourceEnum value);

  // optional sfixed64 transact_time = 21;
  inline bool has_transact_time() const;
  inline void clear_transact_time();
  static const int kTransactTimeFieldNumber = 21;
  inline ::google::protobuf::int64 transact_time() const;
  inline void set_transact_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecurityList)
 private:
  inline void set_has_security_req_id();
  inline void clear_has_security_req_id();
  inline void set_has_security_request_result();
  inline void clear_has_security_request_result();
  inline void set_has_security_response_id();
  inline void clear_has_security_response_id();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_tot_no_related_sym();
  inline void clear_has_tot_no_related_sym();
  inline void set_has_clearing_business_date();
  inline void clear_has_clearing_business_date();
  inline void set_has_last_fragment();
  inline void clear_has_last_fragment();
  inline void set_has_security_report_id();
  inline void clear_has_security_report_id();
  inline void set_has_application_sequence_control();
  inline void clear_has_application_sequence_control();
  inline void set_has_market_id();
  inline void clear_has_market_id();
  inline void set_has_market_segment_id();
  inline void clear_has_market_segment_id();
  inline void set_has_encoded_security_list_desc();
  inline void clear_has_encoded_security_list_desc();
  inline void set_has_encoded_security_list_desc_len();
  inline void clear_has_encoded_security_list_desc_len();
  inline void set_has_security_list_desc();
  inline void clear_has_security_list_desc();
  inline void set_has_security_list_id();
  inline void clear_has_security_list_id();
  inline void set_has_security_list_ref_id();
  inline void clear_has_security_list_ref_id();
  inline void set_has_security_list_type();
  inline void clear_has_security_list_type();
  inline void set_has_security_list_type_source();
  inline void clear_has_security_list_type_source();
  inline void set_has_transact_time();
  inline void clear_has_transact_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* security_req_id_;
  ::std::string* security_response_id_;
  ::Session::StandardHeader* standard_header_;
  int security_request_result_;
  ::google::protobuf::int32 clearing_business_date_;
  ::Session::StandardTrailer* standard_trailer_;
  ::google::protobuf::int64 tot_no_related_sym_;
  ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecListGrp > sec_list_grp_;
  ::google::protobuf::int64 security_report_id_;
  ::Common::ApplicationSequenceControl* application_sequence_control_;
  bool last_fragment_;
  ::google::protobuf::uint32 encoded_security_list_desc_len_;
  ::std::string* market_id_;
  ::std::string* market_segment_id_;
  ::std::string* encoded_security_list_desc_;
  ::std::string* security_list_desc_;
  ::std::string* security_list_id_;
  ::std::string* security_list_ref_id_;
  int security_list_type_;
  int security_list_type_source_;
  ::google::protobuf::int64 transact_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecurityList* default_instance_;
};
// -------------------------------------------------------------------

class SecurityListRequest : public ::google::protobuf::Message {
 public:
  SecurityListRequest();
  virtual ~SecurityListRequest();

  SecurityListRequest(const SecurityListRequest& from);

  inline SecurityListRequest& operator=(const SecurityListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityListRequest& default_instance();

  void Swap(SecurityListRequest* other);

  // implements Message ----------------------------------------------

  SecurityListRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityListRequest& from);
  void MergeFrom(const SecurityListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string currency = 1;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 1;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional bytes encoded_text = 2;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 2;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 3;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 3;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional .Common.Instrument instrument = 4;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 4;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional .SecuritiesReferenceData.SecurityListRequestTypeEnum security_list_request_type = 5;
  inline bool has_security_list_request_type() const;
  inline void clear_security_list_request_type();
  static const int kSecurityListRequestTypeFieldNumber = 5;
  inline ::SecuritiesReferenceData::SecurityListRequestTypeEnum security_list_request_type() const;
  inline void set_security_list_request_type(::SecuritiesReferenceData::SecurityListRequestTypeEnum value);

  // optional string security_req_id = 6;
  inline bool has_security_req_id() const;
  inline void clear_security_req_id();
  static const int kSecurityReqIdFieldNumber = 6;
  inline const ::std::string& security_req_id() const;
  inline void set_security_req_id(const ::std::string& value);
  inline void set_security_req_id(const char* value);
  inline void set_security_req_id(const char* value, size_t size);
  inline ::std::string* mutable_security_req_id();
  inline ::std::string* release_security_req_id();
  inline void set_allocated_security_req_id(::std::string* security_req_id);

  // optional .Session.StandardHeader standard_header = 7;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 7;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 8;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 8;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional .SecuritiesReferenceData.SubscriptionRequestTypeEnum subscription_request_type = 9;
  inline bool has_subscription_request_type() const;
  inline void clear_subscription_request_type();
  static const int kSubscriptionRequestTypeFieldNumber = 9;
  inline ::SecuritiesReferenceData::SubscriptionRequestTypeEnum subscription_request_type() const;
  inline void set_subscription_request_type(::SecuritiesReferenceData::SubscriptionRequestTypeEnum value);

  // optional string text = 10;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 10;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .SecuritiesReferenceData.TradingSessionIdEnum trading_session_id = 11;
  inline bool has_trading_session_id() const;
  inline void clear_trading_session_id();
  static const int kTradingSessionIdFieldNumber = 11;
  inline ::SecuritiesReferenceData::TradingSessionIdEnum trading_session_id() const;
  inline void set_trading_session_id(::SecuritiesReferenceData::TradingSessionIdEnum value);

  // optional .SecuritiesReferenceData.TradingSessionSubIdEnum trading_session_sub_id = 12;
  inline bool has_trading_session_sub_id() const;
  inline void clear_trading_session_sub_id();
  static const int kTradingSessionSubIdFieldNumber = 12;
  inline ::SecuritiesReferenceData::TradingSessionSubIdEnum trading_session_sub_id() const;
  inline void set_trading_session_sub_id(::SecuritiesReferenceData::TradingSessionSubIdEnum value);

  // optional .Common.FinancingDetails financing_details = 13;
  inline bool has_financing_details() const;
  inline void clear_financing_details();
  static const int kFinancingDetailsFieldNumber = 13;
  inline const ::Common::FinancingDetails& financing_details() const;
  inline ::Common::FinancingDetails* mutable_financing_details();
  inline ::Common::FinancingDetails* release_financing_details();
  inline void set_allocated_financing_details(::Common::FinancingDetails* financing_details);

  // repeated .Common.InstrmtLegGrp instrmt_leg_grp = 14;
  inline int instrmt_leg_grp_size() const;
  inline void clear_instrmt_leg_grp();
  static const int kInstrmtLegGrpFieldNumber = 14;
  inline const ::Common::InstrmtLegGrp& instrmt_leg_grp(int index) const;
  inline ::Common::InstrmtLegGrp* mutable_instrmt_leg_grp(int index);
  inline ::Common::InstrmtLegGrp* add_instrmt_leg_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
      instrmt_leg_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
      mutable_instrmt_leg_grp();

  // optional .Common.InstrumentExtension instrument_extension = 15;
  inline bool has_instrument_extension() const;
  inline void clear_instrument_extension();
  static const int kInstrumentExtensionFieldNumber = 15;
  inline const ::Common::InstrumentExtension& instrument_extension() const;
  inline ::Common::InstrumentExtension* mutable_instrument_extension();
  inline ::Common::InstrumentExtension* release_instrument_extension();
  inline void set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension);

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 16;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 16;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // optional string market_id = 17;
  inline bool has_market_id() const;
  inline void clear_market_id();
  static const int kMarketIdFieldNumber = 17;
  inline const ::std::string& market_id() const;
  inline void set_market_id(const ::std::string& value);
  inline void set_market_id(const char* value);
  inline void set_market_id(const char* value, size_t size);
  inline ::std::string* mutable_market_id();
  inline ::std::string* release_market_id();
  inline void set_allocated_market_id(::std::string* market_id);

  // optional string market_segment_id = 18;
  inline bool has_market_segment_id() const;
  inline void clear_market_segment_id();
  static const int kMarketSegmentIdFieldNumber = 18;
  inline const ::std::string& market_segment_id() const;
  inline void set_market_segment_id(const ::std::string& value);
  inline void set_market_segment_id(const char* value);
  inline void set_market_segment_id(const char* value, size_t size);
  inline ::std::string* mutable_market_segment_id();
  inline ::std::string* release_market_segment_id();
  inline void set_allocated_market_segment_id(::std::string* market_segment_id);

  // optional string security_list_id = 19;
  inline bool has_security_list_id() const;
  inline void clear_security_list_id();
  static const int kSecurityListIdFieldNumber = 19;
  inline const ::std::string& security_list_id() const;
  inline void set_security_list_id(const ::std::string& value);
  inline void set_security_list_id(const char* value);
  inline void set_security_list_id(const char* value, size_t size);
  inline ::std::string* mutable_security_list_id();
  inline ::std::string* release_security_list_id();
  inline void set_allocated_security_list_id(::std::string* security_list_id);

  // optional .SecuritiesReferenceData.SecurityListTypeEnum security_list_type = 20;
  inline bool has_security_list_type() const;
  inline void clear_security_list_type();
  static const int kSecurityListTypeFieldNumber = 20;
  inline ::SecuritiesReferenceData::SecurityListTypeEnum security_list_type() const;
  inline void set_security_list_type(::SecuritiesReferenceData::SecurityListTypeEnum value);

  // optional .SecuritiesReferenceData.SecurityListTypeSourceEnum security_list_type_source = 21;
  inline bool has_security_list_type_source() const;
  inline void clear_security_list_type_source();
  static const int kSecurityListTypeSourceFieldNumber = 21;
  inline ::SecuritiesReferenceData::SecurityListTypeSourceEnum security_list_type_source() const;
  inline void set_security_list_type_source(::SecuritiesReferenceData::SecurityListTypeSourceEnum value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecurityListRequest)
 private:
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_security_list_request_type();
  inline void clear_has_security_list_request_type();
  inline void set_has_security_req_id();
  inline void clear_has_security_req_id();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_subscription_request_type();
  inline void clear_has_subscription_request_type();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_trading_session_id();
  inline void clear_has_trading_session_id();
  inline void set_has_trading_session_sub_id();
  inline void clear_has_trading_session_sub_id();
  inline void set_has_financing_details();
  inline void clear_has_financing_details();
  inline void set_has_instrument_extension();
  inline void clear_has_instrument_extension();
  inline void set_has_market_id();
  inline void clear_has_market_id();
  inline void set_has_market_segment_id();
  inline void clear_has_market_segment_id();
  inline void set_has_security_list_id();
  inline void clear_has_security_list_id();
  inline void set_has_security_list_type();
  inline void clear_has_security_list_type();
  inline void set_has_security_list_type_source();
  inline void clear_has_security_list_type_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* currency_;
  ::std::string* encoded_text_;
  ::Common::Instrument* instrument_;
  ::google::protobuf::uint32 encoded_text_len_;
  int security_list_request_type_;
  ::std::string* security_req_id_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::std::string* text_;
  int subscription_request_type_;
  int trading_session_id_;
  ::Common::FinancingDetails* financing_details_;
  ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp > instrmt_leg_grp_;
  ::Common::InstrumentExtension* instrument_extension_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;
  int trading_session_sub_id_;
  int security_list_type_;
  ::std::string* market_id_;
  ::std::string* market_segment_id_;
  ::std::string* security_list_id_;
  int security_list_type_source_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecurityListRequest* default_instance_;
};
// -------------------------------------------------------------------

class SecLstUpdRelSymsLegGrp : public ::google::protobuf::Message {
 public:
  SecLstUpdRelSymsLegGrp();
  virtual ~SecLstUpdRelSymsLegGrp();

  SecLstUpdRelSymsLegGrp(const SecLstUpdRelSymsLegGrp& from);

  inline SecLstUpdRelSymsLegGrp& operator=(const SecLstUpdRelSymsLegGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecLstUpdRelSymsLegGrp& default_instance();

  void Swap(SecLstUpdRelSymsLegGrp* other);

  // implements Message ----------------------------------------------

  SecLstUpdRelSymsLegGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecLstUpdRelSymsLegGrp& from);
  void MergeFrom(const SecLstUpdRelSymsLegGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Common.InstrumentLeg instrument_leg = 1;
  inline bool has_instrument_leg() const;
  inline void clear_instrument_leg();
  static const int kInstrumentLegFieldNumber = 1;
  inline const ::Common::InstrumentLeg& instrument_leg() const;
  inline ::Common::InstrumentLeg* mutable_instrument_leg();
  inline ::Common::InstrumentLeg* release_instrument_leg();
  inline void set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg);

  // optional .Common.LegBenchmarkCurveData leg_benchmark_curve_data = 2;
  inline bool has_leg_benchmark_curve_data() const;
  inline void clear_leg_benchmark_curve_data();
  static const int kLegBenchmarkCurveDataFieldNumber = 2;
  inline const ::Common::LegBenchmarkCurveData& leg_benchmark_curve_data() const;
  inline ::Common::LegBenchmarkCurveData* mutable_leg_benchmark_curve_data();
  inline ::Common::LegBenchmarkCurveData* release_leg_benchmark_curve_data();
  inline void set_allocated_leg_benchmark_curve_data(::Common::LegBenchmarkCurveData* leg_benchmark_curve_data);

  // optional string leg_settl_type = 3;
  inline bool has_leg_settl_type() const;
  inline void clear_leg_settl_type();
  static const int kLegSettlTypeFieldNumber = 3;
  inline const ::std::string& leg_settl_type() const;
  inline void set_leg_settl_type(const ::std::string& value);
  inline void set_leg_settl_type(const char* value);
  inline void set_leg_settl_type(const char* value, size_t size);
  inline ::std::string* mutable_leg_settl_type();
  inline ::std::string* release_leg_settl_type();
  inline void set_allocated_leg_settl_type(::std::string* leg_settl_type);

  // repeated .Common.LegStipulations leg_stipulations = 4;
  inline int leg_stipulations_size() const;
  inline void clear_leg_stipulations();
  static const int kLegStipulationsFieldNumber = 4;
  inline const ::Common::LegStipulations& leg_stipulations(int index) const;
  inline ::Common::LegStipulations* mutable_leg_stipulations(int index);
  inline ::Common::LegStipulations* add_leg_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >&
      leg_stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >*
      mutable_leg_stipulations();

  // optional .SecuritiesReferenceData.LegSwapTypeEnum leg_swap_type = 5;
  inline bool has_leg_swap_type() const;
  inline void clear_leg_swap_type();
  static const int kLegSwapTypeFieldNumber = 5;
  inline ::SecuritiesReferenceData::LegSwapTypeEnum leg_swap_type() const;
  inline void set_leg_swap_type(::SecuritiesReferenceData::LegSwapTypeEnum value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecLstUpdRelSymsLegGrp)
 private:
  inline void set_has_instrument_leg();
  inline void clear_has_instrument_leg();
  inline void set_has_leg_benchmark_curve_data();
  inline void clear_has_leg_benchmark_curve_data();
  inline void set_has_leg_settl_type();
  inline void clear_has_leg_settl_type();
  inline void set_has_leg_swap_type();
  inline void clear_has_leg_swap_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Common::InstrumentLeg* instrument_leg_;
  ::Common::LegBenchmarkCurveData* leg_benchmark_curve_data_;
  ::std::string* leg_settl_type_;
  ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations > leg_stipulations_;
  int leg_swap_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecLstUpdRelSymsLegGrp* default_instance_;
};
// -------------------------------------------------------------------

class SecLstUpdRelSymGrp : public ::google::protobuf::Message {
 public:
  SecLstUpdRelSymGrp();
  virtual ~SecLstUpdRelSymGrp();

  SecLstUpdRelSymGrp(const SecLstUpdRelSymGrp& from);

  inline SecLstUpdRelSymGrp& operator=(const SecLstUpdRelSymGrp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecLstUpdRelSymGrp& default_instance();

  void Swap(SecLstUpdRelSymGrp* other);

  // implements Message ----------------------------------------------

  SecLstUpdRelSymGrp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecLstUpdRelSymGrp& from);
  void MergeFrom(const SecLstUpdRelSymGrp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string currency = 1;
  inline bool has_currency() const;
  inline void clear_currency();
  static const int kCurrencyFieldNumber = 1;
  inline const ::std::string& currency() const;
  inline void set_currency(const ::std::string& value);
  inline void set_currency(const char* value);
  inline void set_currency(const char* value, size_t size);
  inline ::std::string* mutable_currency();
  inline ::std::string* release_currency();
  inline void set_allocated_currency(::std::string* currency);

  // optional bytes encoded_text = 2;
  inline bool has_encoded_text() const;
  inline void clear_encoded_text();
  static const int kEncodedTextFieldNumber = 2;
  inline const ::std::string& encoded_text() const;
  inline void set_encoded_text(const ::std::string& value);
  inline void set_encoded_text(const char* value);
  inline void set_encoded_text(const void* value, size_t size);
  inline ::std::string* mutable_encoded_text();
  inline ::std::string* release_encoded_text();
  inline void set_allocated_encoded_text(::std::string* encoded_text);

  // optional fixed32 encoded_text_len = 3;
  inline bool has_encoded_text_len() const;
  inline void clear_encoded_text_len();
  static const int kEncodedTextLenFieldNumber = 3;
  inline ::google::protobuf::uint32 encoded_text_len() const;
  inline void set_encoded_text_len(::google::protobuf::uint32 value);

  // optional .Common.FinancingDetails financing_details = 4;
  inline bool has_financing_details() const;
  inline void clear_financing_details();
  static const int kFinancingDetailsFieldNumber = 4;
  inline const ::Common::FinancingDetails& financing_details() const;
  inline ::Common::FinancingDetails* mutable_financing_details();
  inline ::Common::FinancingDetails* release_financing_details();
  inline void set_allocated_financing_details(::Common::FinancingDetails* financing_details);

  // optional .Common.Instrument instrument = 5;
  inline bool has_instrument() const;
  inline void clear_instrument();
  static const int kInstrumentFieldNumber = 5;
  inline const ::Common::Instrument& instrument() const;
  inline ::Common::Instrument* mutable_instrument();
  inline ::Common::Instrument* release_instrument();
  inline void set_allocated_instrument(::Common::Instrument* instrument);

  // optional .Common.InstrumentExtension instrument_extension = 6;
  inline bool has_instrument_extension() const;
  inline void clear_instrument_extension();
  static const int kInstrumentExtensionFieldNumber = 6;
  inline const ::Common::InstrumentExtension& instrument_extension() const;
  inline ::Common::InstrumentExtension* mutable_instrument_extension();
  inline ::Common::InstrumentExtension* release_instrument_extension();
  inline void set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension);

  // repeated .SecuritiesReferenceData.SecLstUpdRelSymsLegGrp sec_lst_upd_rel_syms_leg_grp = 7;
  inline int sec_lst_upd_rel_syms_leg_grp_size() const;
  inline void clear_sec_lst_upd_rel_syms_leg_grp();
  static const int kSecLstUpdRelSymsLegGrpFieldNumber = 7;
  inline const ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp& sec_lst_upd_rel_syms_leg_grp(int index) const;
  inline ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp* mutable_sec_lst_upd_rel_syms_leg_grp(int index);
  inline ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp* add_sec_lst_upd_rel_syms_leg_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp >&
      sec_lst_upd_rel_syms_leg_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp >*
      mutable_sec_lst_upd_rel_syms_leg_grp();

  // optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 8;
  inline bool has_spread_or_benchmark_curve_data() const;
  inline void clear_spread_or_benchmark_curve_data();
  static const int kSpreadOrBenchmarkCurveDataFieldNumber = 8;
  inline const ::Common::SpreadOrBenchmarkCurveData& spread_or_benchmark_curve_data() const;
  inline ::Common::SpreadOrBenchmarkCurveData* mutable_spread_or_benchmark_curve_data();
  inline ::Common::SpreadOrBenchmarkCurveData* release_spread_or_benchmark_curve_data();
  inline void set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data);

  // repeated .Common.Stipulations stipulations = 9;
  inline int stipulations_size() const;
  inline void clear_stipulations();
  static const int kStipulationsFieldNumber = 9;
  inline const ::Common::Stipulations& stipulations(int index) const;
  inline ::Common::Stipulations* mutable_stipulations(int index);
  inline ::Common::Stipulations* add_stipulations();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
      stipulations() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
      mutable_stipulations();

  // optional string text = 10;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 10;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .Common.YieldData yield_data = 11;
  inline bool has_yield_data() const;
  inline void clear_yield_data();
  static const int kYieldDataFieldNumber = 11;
  inline const ::Common::YieldData& yield_data() const;
  inline ::Common::YieldData* mutable_yield_data();
  inline ::Common::YieldData* release_yield_data();
  inline void set_allocated_yield_data(::Common::YieldData* yield_data);

  // optional string list_update_action = 12;
  inline bool has_list_update_action() const;
  inline void clear_list_update_action();
  static const int kListUpdateActionFieldNumber = 12;
  inline const ::std::string& list_update_action() const;
  inline void set_list_update_action(const ::std::string& value);
  inline void set_list_update_action(const char* value);
  inline void set_list_update_action(const char* value, size_t size);
  inline ::std::string* mutable_list_update_action();
  inline ::std::string* release_list_update_action();
  inline void set_allocated_list_update_action(::std::string* list_update_action);

  // optional .Common.SecurityTradingRules security_trading_rules = 13;
  inline bool has_security_trading_rules() const;
  inline void clear_security_trading_rules();
  static const int kSecurityTradingRulesFieldNumber = 13;
  inline const ::Common::SecurityTradingRules& security_trading_rules() const;
  inline ::Common::SecurityTradingRules* mutable_security_trading_rules();
  inline ::Common::SecurityTradingRules* release_security_trading_rules();
  inline void set_allocated_security_trading_rules(::Common::SecurityTradingRules* security_trading_rules);

  // repeated .Common.StrikeRules strike_rules = 14;
  inline int strike_rules_size() const;
  inline void clear_strike_rules();
  static const int kStrikeRulesFieldNumber = 14;
  inline const ::Common::StrikeRules& strike_rules(int index) const;
  inline ::Common::StrikeRules* mutable_strike_rules(int index);
  inline ::Common::StrikeRules* add_strike_rules();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >&
      strike_rules() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >*
      mutable_strike_rules();

  // repeated .Common.UndInstrmtGrp und_instrmt_grp = 15;
  inline int und_instrmt_grp_size() const;
  inline void clear_und_instrmt_grp();
  static const int kUndInstrmtGrpFieldNumber = 15;
  inline const ::Common::UndInstrmtGrp& und_instrmt_grp(int index) const;
  inline ::Common::UndInstrmtGrp* mutable_und_instrmt_grp(int index);
  inline ::Common::UndInstrmtGrp* add_und_instrmt_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
      und_instrmt_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
      mutable_und_instrmt_grp();

  // optional sfixed64 rel_sym_transact_time = 16;
  inline bool has_rel_sym_transact_time() const;
  inline void clear_rel_sym_transact_time();
  static const int kRelSymTransactTimeFieldNumber = 16;
  inline ::google::protobuf::int64 rel_sym_transact_time() const;
  inline void set_rel_sym_transact_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecLstUpdRelSymGrp)
 private:
  inline void set_has_currency();
  inline void clear_has_currency();
  inline void set_has_encoded_text();
  inline void clear_has_encoded_text();
  inline void set_has_encoded_text_len();
  inline void clear_has_encoded_text_len();
  inline void set_has_financing_details();
  inline void clear_has_financing_details();
  inline void set_has_instrument();
  inline void clear_has_instrument();
  inline void set_has_instrument_extension();
  inline void clear_has_instrument_extension();
  inline void set_has_spread_or_benchmark_curve_data();
  inline void clear_has_spread_or_benchmark_curve_data();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_yield_data();
  inline void clear_has_yield_data();
  inline void set_has_list_update_action();
  inline void clear_has_list_update_action();
  inline void set_has_security_trading_rules();
  inline void clear_has_security_trading_rules();
  inline void set_has_rel_sym_transact_time();
  inline void clear_has_rel_sym_transact_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* currency_;
  ::std::string* encoded_text_;
  ::Common::FinancingDetails* financing_details_;
  ::Common::Instrument* instrument_;
  ::Common::InstrumentExtension* instrument_extension_;
  ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp > sec_lst_upd_rel_syms_leg_grp_;
  ::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data_;
  ::google::protobuf::RepeatedPtrField< ::Common::Stipulations > stipulations_;
  ::std::string* text_;
  ::Common::YieldData* yield_data_;
  ::std::string* list_update_action_;
  ::Common::SecurityTradingRules* security_trading_rules_;
  ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules > strike_rules_;
  ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp > und_instrmt_grp_;
  ::google::protobuf::int64 rel_sym_transact_time_;
  ::google::protobuf::uint32 encoded_text_len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecLstUpdRelSymGrp* default_instance_;
};
// -------------------------------------------------------------------

class SecurityListUpdateReport : public ::google::protobuf::Message {
 public:
  SecurityListUpdateReport();
  virtual ~SecurityListUpdateReport();

  SecurityListUpdateReport(const SecurityListUpdateReport& from);

  inline SecurityListUpdateReport& operator=(const SecurityListUpdateReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SecurityListUpdateReport& default_instance();

  void Swap(SecurityListUpdateReport* other);

  // implements Message ----------------------------------------------

  SecurityListUpdateReport* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SecurityListUpdateReport& from);
  void MergeFrom(const SecurityListUpdateReport& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sfixed32 clearing_business_date = 1;
  inline bool has_clearing_business_date() const;
  inline void clear_clearing_business_date();
  static const int kClearingBusinessDateFieldNumber = 1;
  inline ::google::protobuf::int32 clearing_business_date() const;
  inline void set_clearing_business_date(::google::protobuf::int32 value);

  // repeated .SecuritiesReferenceData.CorporateActionEnum corporate_action = 2 [packed = true];
  inline int corporate_action_size() const;
  inline void clear_corporate_action();
  static const int kCorporateActionFieldNumber = 2;
  inline ::SecuritiesReferenceData::CorporateActionEnum corporate_action(int index) const;
  inline void set_corporate_action(int index, ::SecuritiesReferenceData::CorporateActionEnum value);
  inline void add_corporate_action(::SecuritiesReferenceData::CorporateActionEnum value);
  inline const ::google::protobuf::RepeatedField<int>& corporate_action() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_corporate_action();

  // optional bool last_fragment = 3;
  inline bool has_last_fragment() const;
  inline void clear_last_fragment();
  static const int kLastFragmentFieldNumber = 3;
  inline bool last_fragment() const;
  inline void set_last_fragment(bool value);

  // repeated .SecuritiesReferenceData.SecLstUpdRelSymGrp sec_lst_upd_rel_sym_grp = 4;
  inline int sec_lst_upd_rel_sym_grp_size() const;
  inline void clear_sec_lst_upd_rel_sym_grp();
  static const int kSecLstUpdRelSymGrpFieldNumber = 4;
  inline const ::SecuritiesReferenceData::SecLstUpdRelSymGrp& sec_lst_upd_rel_sym_grp(int index) const;
  inline ::SecuritiesReferenceData::SecLstUpdRelSymGrp* mutable_sec_lst_upd_rel_sym_grp(int index);
  inline ::SecuritiesReferenceData::SecLstUpdRelSymGrp* add_sec_lst_upd_rel_sym_grp();
  inline const ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymGrp >&
      sec_lst_upd_rel_sym_grp() const;
  inline ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymGrp >*
      mutable_sec_lst_upd_rel_sym_grp();

  // optional sfixed64 security_report_id = 5;
  inline bool has_security_report_id() const;
  inline void clear_security_report_id();
  static const int kSecurityReportIdFieldNumber = 5;
  inline ::google::protobuf::int64 security_report_id() const;
  inline void set_security_report_id(::google::protobuf::int64 value);

  // optional string security_req_id = 6;
  inline bool has_security_req_id() const;
  inline void clear_security_req_id();
  static const int kSecurityReqIdFieldNumber = 6;
  inline const ::std::string& security_req_id() const;
  inline void set_security_req_id(const ::std::string& value);
  inline void set_security_req_id(const char* value);
  inline void set_security_req_id(const char* value, size_t size);
  inline ::std::string* mutable_security_req_id();
  inline ::std::string* release_security_req_id();
  inline void set_allocated_security_req_id(::std::string* security_req_id);

  // optional .SecuritiesReferenceData.SecurityRequestResultEnum security_request_result = 7;
  inline bool has_security_request_result() const;
  inline void clear_security_request_result();
  static const int kSecurityRequestResultFieldNumber = 7;
  inline ::SecuritiesReferenceData::SecurityRequestResultEnum security_request_result() const;
  inline void set_security_request_result(::SecuritiesReferenceData::SecurityRequestResultEnum value);

  // optional string security_response_id = 8;
  inline bool has_security_response_id() const;
  inline void clear_security_response_id();
  static const int kSecurityResponseIdFieldNumber = 8;
  inline const ::std::string& security_response_id() const;
  inline void set_security_response_id(const ::std::string& value);
  inline void set_security_response_id(const char* value);
  inline void set_security_response_id(const char* value, size_t size);
  inline ::std::string* mutable_security_response_id();
  inline ::std::string* release_security_response_id();
  inline void set_allocated_security_response_id(::std::string* security_response_id);

  // optional .SecuritiesReferenceData.SecurityUpdateActionEnum security_update_action = 9;
  inline bool has_security_update_action() const;
  inline void clear_security_update_action();
  static const int kSecurityUpdateActionFieldNumber = 9;
  inline ::SecuritiesReferenceData::SecurityUpdateActionEnum security_update_action() const;
  inline void set_security_update_action(::SecuritiesReferenceData::SecurityUpdateActionEnum value);

  // optional .Session.StandardHeader standard_header = 10;
  inline bool has_standard_header() const;
  inline void clear_standard_header();
  static const int kStandardHeaderFieldNumber = 10;
  inline const ::Session::StandardHeader& standard_header() const;
  inline ::Session::StandardHeader* mutable_standard_header();
  inline ::Session::StandardHeader* release_standard_header();
  inline void set_allocated_standard_header(::Session::StandardHeader* standard_header);

  // optional .Session.StandardTrailer standard_trailer = 11;
  inline bool has_standard_trailer() const;
  inline void clear_standard_trailer();
  static const int kStandardTrailerFieldNumber = 11;
  inline const ::Session::StandardTrailer& standard_trailer() const;
  inline ::Session::StandardTrailer* mutable_standard_trailer();
  inline ::Session::StandardTrailer* release_standard_trailer();
  inline void set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer);

  // optional sfixed64 tot_no_related_sym = 12;
  inline bool has_tot_no_related_sym() const;
  inline void clear_tot_no_related_sym();
  static const int kTotNoRelatedSymFieldNumber = 12;
  inline ::google::protobuf::int64 tot_no_related_sym() const;
  inline void set_tot_no_related_sym(::google::protobuf::int64 value);

  // optional .Common.ApplicationSequenceControl application_sequence_control = 13;
  inline bool has_application_sequence_control() const;
  inline void clear_application_sequence_control();
  static const int kApplicationSequenceControlFieldNumber = 13;
  inline const ::Common::ApplicationSequenceControl& application_sequence_control() const;
  inline ::Common::ApplicationSequenceControl* mutable_application_sequence_control();
  inline ::Common::ApplicationSequenceControl* release_application_sequence_control();
  inline void set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control);

  // optional string market_id = 14;
  inline bool has_market_id() const;
  inline void clear_market_id();
  static const int kMarketIdFieldNumber = 14;
  inline const ::std::string& market_id() const;
  inline void set_market_id(const ::std::string& value);
  inline void set_market_id(const char* value);
  inline void set_market_id(const char* value, size_t size);
  inline ::std::string* mutable_market_id();
  inline ::std::string* release_market_id();
  inline void set_allocated_market_id(::std::string* market_id);

  // optional string market_segment_id = 15;
  inline bool has_market_segment_id() const;
  inline void clear_market_segment_id();
  static const int kMarketSegmentIdFieldNumber = 15;
  inline const ::std::string& market_segment_id() const;
  inline void set_market_segment_id(const ::std::string& value);
  inline void set_market_segment_id(const char* value);
  inline void set_market_segment_id(const char* value, size_t size);
  inline ::std::string* mutable_market_segment_id();
  inline ::std::string* release_market_segment_id();
  inline void set_allocated_market_segment_id(::std::string* market_segment_id);

  // optional bytes encoded_security_list_desc = 16;
  inline bool has_encoded_security_list_desc() const;
  inline void clear_encoded_security_list_desc();
  static const int kEncodedSecurityListDescFieldNumber = 16;
  inline const ::std::string& encoded_security_list_desc() const;
  inline void set_encoded_security_list_desc(const ::std::string& value);
  inline void set_encoded_security_list_desc(const char* value);
  inline void set_encoded_security_list_desc(const void* value, size_t size);
  inline ::std::string* mutable_encoded_security_list_desc();
  inline ::std::string* release_encoded_security_list_desc();
  inline void set_allocated_encoded_security_list_desc(::std::string* encoded_security_list_desc);

  // optional fixed32 encoded_security_list_desc_len = 17;
  inline bool has_encoded_security_list_desc_len() const;
  inline void clear_encoded_security_list_desc_len();
  static const int kEncodedSecurityListDescLenFieldNumber = 17;
  inline ::google::protobuf::uint32 encoded_security_list_desc_len() const;
  inline void set_encoded_security_list_desc_len(::google::protobuf::uint32 value);

  // optional string security_list_desc = 18;
  inline bool has_security_list_desc() const;
  inline void clear_security_list_desc();
  static const int kSecurityListDescFieldNumber = 18;
  inline const ::std::string& security_list_desc() const;
  inline void set_security_list_desc(const ::std::string& value);
  inline void set_security_list_desc(const char* value);
  inline void set_security_list_desc(const char* value, size_t size);
  inline ::std::string* mutable_security_list_desc();
  inline ::std::string* release_security_list_desc();
  inline void set_allocated_security_list_desc(::std::string* security_list_desc);

  // optional string security_list_id = 19;
  inline bool has_security_list_id() const;
  inline void clear_security_list_id();
  static const int kSecurityListIdFieldNumber = 19;
  inline const ::std::string& security_list_id() const;
  inline void set_security_list_id(const ::std::string& value);
  inline void set_security_list_id(const char* value);
  inline void set_security_list_id(const char* value, size_t size);
  inline ::std::string* mutable_security_list_id();
  inline ::std::string* release_security_list_id();
  inline void set_allocated_security_list_id(::std::string* security_list_id);

  // optional string security_list_ref_id = 20;
  inline bool has_security_list_ref_id() const;
  inline void clear_security_list_ref_id();
  static const int kSecurityListRefIdFieldNumber = 20;
  inline const ::std::string& security_list_ref_id() const;
  inline void set_security_list_ref_id(const ::std::string& value);
  inline void set_security_list_ref_id(const char* value);
  inline void set_security_list_ref_id(const char* value, size_t size);
  inline ::std::string* mutable_security_list_ref_id();
  inline ::std::string* release_security_list_ref_id();
  inline void set_allocated_security_list_ref_id(::std::string* security_list_ref_id);

  // optional .SecuritiesReferenceData.SecurityListTypeEnum security_list_type = 21;
  inline bool has_security_list_type() const;
  inline void clear_security_list_type();
  static const int kSecurityListTypeFieldNumber = 21;
  inline ::SecuritiesReferenceData::SecurityListTypeEnum security_list_type() const;
  inline void set_security_list_type(::SecuritiesReferenceData::SecurityListTypeEnum value);

  // optional .SecuritiesReferenceData.SecurityListTypeSourceEnum security_list_type_source = 22;
  inline bool has_security_list_type_source() const;
  inline void clear_security_list_type_source();
  static const int kSecurityListTypeSourceFieldNumber = 22;
  inline ::SecuritiesReferenceData::SecurityListTypeSourceEnum security_list_type_source() const;
  inline void set_security_list_type_source(::SecuritiesReferenceData::SecurityListTypeSourceEnum value);

  // optional sfixed64 transact_time = 23;
  inline bool has_transact_time() const;
  inline void clear_transact_time();
  static const int kTransactTimeFieldNumber = 23;
  inline ::google::protobuf::int64 transact_time() const;
  inline void set_transact_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:SecuritiesReferenceData.SecurityListUpdateReport)
 private:
  inline void set_has_clearing_business_date();
  inline void clear_has_clearing_business_date();
  inline void set_has_last_fragment();
  inline void clear_has_last_fragment();
  inline void set_has_security_report_id();
  inline void clear_has_security_report_id();
  inline void set_has_security_req_id();
  inline void clear_has_security_req_id();
  inline void set_has_security_request_result();
  inline void clear_has_security_request_result();
  inline void set_has_security_response_id();
  inline void clear_has_security_response_id();
  inline void set_has_security_update_action();
  inline void clear_has_security_update_action();
  inline void set_has_standard_header();
  inline void clear_has_standard_header();
  inline void set_has_standard_trailer();
  inline void clear_has_standard_trailer();
  inline void set_has_tot_no_related_sym();
  inline void clear_has_tot_no_related_sym();
  inline void set_has_application_sequence_control();
  inline void clear_has_application_sequence_control();
  inline void set_has_market_id();
  inline void clear_has_market_id();
  inline void set_has_market_segment_id();
  inline void clear_has_market_segment_id();
  inline void set_has_encoded_security_list_desc();
  inline void clear_has_encoded_security_list_desc();
  inline void set_has_encoded_security_list_desc_len();
  inline void clear_has_encoded_security_list_desc_len();
  inline void set_has_security_list_desc();
  inline void clear_has_security_list_desc();
  inline void set_has_security_list_id();
  inline void clear_has_security_list_id();
  inline void set_has_security_list_ref_id();
  inline void clear_has_security_list_ref_id();
  inline void set_has_security_list_type();
  inline void clear_has_security_list_type();
  inline void set_has_security_list_type_source();
  inline void clear_has_security_list_type_source();
  inline void set_has_transact_time();
  inline void clear_has_transact_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> corporate_action_;
  mutable int _corporate_action_cached_byte_size_;
  ::google::protobuf::int32 clearing_business_date_;
  bool last_fragment_;
  ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymGrp > sec_lst_upd_rel_sym_grp_;
  ::google::protobuf::int64 security_report_id_;
  ::std::string* security_req_id_;
  ::std::string* security_response_id_;
  int security_request_result_;
  int security_update_action_;
  ::Session::StandardHeader* standard_header_;
  ::Session::StandardTrailer* standard_trailer_;
  ::google::protobuf::int64 tot_no_related_sym_;
  ::Common::ApplicationSequenceControl* application_sequence_control_;
  ::std::string* market_id_;
  ::std::string* market_segment_id_;
  ::std::string* encoded_security_list_desc_;
  ::std::string* security_list_desc_;
  ::std::string* security_list_id_;
  ::google::protobuf::uint32 encoded_security_list_desc_len_;
  int security_list_type_;
  ::std::string* security_list_ref_id_;
  ::google::protobuf::int64 transact_time_;
  int security_list_type_source_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  friend void  protobuf_AddDesc_securitiesreferencedata_2eproto();
  friend void protobuf_AssignDesc_securitiesreferencedata_2eproto();
  friend void protobuf_ShutdownFile_securitiesreferencedata_2eproto();

  void InitAsDefaultInstance();
  static SecurityListUpdateReport* default_instance_;
};
// ===================================================================


// ===================================================================

// SecurityDefinition

// optional string currency = 1;
inline bool SecurityDefinition::has_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityDefinition::set_has_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityDefinition::clear_has_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityDefinition::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& SecurityDefinition::currency() const {
  return *currency_;
}
inline void SecurityDefinition::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecurityDefinition::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecurityDefinition::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinition::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* SecurityDefinition::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinition::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_text = 2;
inline bool SecurityDefinition::has_encoded_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityDefinition::set_has_encoded_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityDefinition::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityDefinition::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& SecurityDefinition::encoded_text() const {
  return *encoded_text_;
}
inline void SecurityDefinition::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecurityDefinition::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecurityDefinition::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinition::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* SecurityDefinition::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinition::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 3;
inline bool SecurityDefinition::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityDefinition::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityDefinition::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityDefinition::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 SecurityDefinition::encoded_text_len() const {
  return encoded_text_len_;
}
inline void SecurityDefinition::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional string security_req_id = 4;
inline bool SecurityDefinition::has_security_req_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecurityDefinition::set_has_security_req_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecurityDefinition::clear_has_security_req_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecurityDefinition::clear_security_req_id() {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    security_req_id_->clear();
  }
  clear_has_security_req_id();
}
inline const ::std::string& SecurityDefinition::security_req_id() const {
  return *security_req_id_;
}
inline void SecurityDefinition::set_security_req_id(const ::std::string& value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityDefinition::set_security_req_id(const char* value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityDefinition::set_security_req_id(const char* value, size_t size) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinition::mutable_security_req_id() {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  return security_req_id_;
}
inline ::std::string* SecurityDefinition::release_security_req_id() {
  clear_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_req_id_;
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinition::set_allocated_security_req_id(::std::string* security_req_id) {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_req_id_;
  }
  if (security_req_id) {
    set_has_security_req_id();
    security_req_id_ = security_req_id;
  } else {
    clear_has_security_req_id();
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_response_id = 5;
inline bool SecurityDefinition::has_security_response_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecurityDefinition::set_has_security_response_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecurityDefinition::clear_has_security_response_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecurityDefinition::clear_security_response_id() {
  if (security_response_id_ != &::google::protobuf::internal::kEmptyString) {
    security_response_id_->clear();
  }
  clear_has_security_response_id();
}
inline const ::std::string& SecurityDefinition::security_response_id() const {
  return *security_response_id_;
}
inline void SecurityDefinition::set_security_response_id(const ::std::string& value) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(value);
}
inline void SecurityDefinition::set_security_response_id(const char* value) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(value);
}
inline void SecurityDefinition::set_security_response_id(const char* value, size_t size) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinition::mutable_security_response_id() {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  return security_response_id_;
}
inline ::std::string* SecurityDefinition::release_security_response_id() {
  clear_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_response_id_;
    security_response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinition::set_allocated_security_response_id(::std::string* security_response_id) {
  if (security_response_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_response_id_;
  }
  if (security_response_id) {
    set_has_security_response_id();
    security_response_id_ = security_response_id;
  } else {
    clear_has_security_response_id();
    security_response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.SecurityResponseTypeEnum security_response_type = 6;
inline bool SecurityDefinition::has_security_response_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecurityDefinition::set_has_security_response_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecurityDefinition::clear_has_security_response_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecurityDefinition::clear_security_response_type() {
  security_response_type_ = 0;
  clear_has_security_response_type();
}
inline ::SecuritiesReferenceData::SecurityResponseTypeEnum SecurityDefinition::security_response_type() const {
  return static_cast< ::SecuritiesReferenceData::SecurityResponseTypeEnum >(security_response_type_);
}
inline void SecurityDefinition::set_security_response_type(::SecuritiesReferenceData::SecurityResponseTypeEnum value) {
  assert(::SecuritiesReferenceData::SecurityResponseTypeEnum_IsValid(value));
  set_has_security_response_type();
  security_response_type_ = value;
}

// optional .Session.StandardHeader standard_header = 7;
inline bool SecurityDefinition::has_standard_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecurityDefinition::set_has_standard_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecurityDefinition::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecurityDefinition::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& SecurityDefinition::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* SecurityDefinition::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* SecurityDefinition::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void SecurityDefinition::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 8;
inline bool SecurityDefinition::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecurityDefinition::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecurityDefinition::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecurityDefinition::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& SecurityDefinition::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityDefinition::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityDefinition::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void SecurityDefinition::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional string text = 9;
inline bool SecurityDefinition::has_text() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SecurityDefinition::set_has_text() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SecurityDefinition::clear_has_text() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SecurityDefinition::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SecurityDefinition::text() const {
  return *text_;
}
inline void SecurityDefinition::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecurityDefinition::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecurityDefinition::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinition::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SecurityDefinition::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinition::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.Instrument instrument = 10;
inline bool SecurityDefinition::has_instrument() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecurityDefinition::set_has_instrument() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecurityDefinition::clear_has_instrument() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecurityDefinition::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& SecurityDefinition::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* SecurityDefinition::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* SecurityDefinition::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void SecurityDefinition::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional sfixed32 clearing_business_date = 11;
inline bool SecurityDefinition::has_clearing_business_date() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SecurityDefinition::set_has_clearing_business_date() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SecurityDefinition::clear_has_clearing_business_date() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SecurityDefinition::clear_clearing_business_date() {
  clearing_business_date_ = 0;
  clear_has_clearing_business_date();
}
inline ::google::protobuf::int32 SecurityDefinition::clearing_business_date() const {
  return clearing_business_date_;
}
inline void SecurityDefinition::set_clearing_business_date(::google::protobuf::int32 value) {
  set_has_clearing_business_date();
  clearing_business_date_ = value;
}

// repeated .Common.InstrmtLegGrp instrmt_leg_grp = 12;
inline int SecurityDefinition::instrmt_leg_grp_size() const {
  return instrmt_leg_grp_.size();
}
inline void SecurityDefinition::clear_instrmt_leg_grp() {
  instrmt_leg_grp_.Clear();
}
inline const ::Common::InstrmtLegGrp& SecurityDefinition::instrmt_leg_grp(int index) const {
  return instrmt_leg_grp_.Get(index);
}
inline ::Common::InstrmtLegGrp* SecurityDefinition::mutable_instrmt_leg_grp(int index) {
  return instrmt_leg_grp_.Mutable(index);
}
inline ::Common::InstrmtLegGrp* SecurityDefinition::add_instrmt_leg_grp() {
  return instrmt_leg_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
SecurityDefinition::instrmt_leg_grp() const {
  return instrmt_leg_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
SecurityDefinition::mutable_instrmt_leg_grp() {
  return &instrmt_leg_grp_;
}

// optional .Common.InstrumentExtension instrument_extension = 13;
inline bool SecurityDefinition::has_instrument_extension() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecurityDefinition::set_has_instrument_extension() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecurityDefinition::clear_has_instrument_extension() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecurityDefinition::clear_instrument_extension() {
  if (instrument_extension_ != NULL) instrument_extension_->::Common::InstrumentExtension::Clear();
  clear_has_instrument_extension();
}
inline const ::Common::InstrumentExtension& SecurityDefinition::instrument_extension() const {
  return instrument_extension_ != NULL ? *instrument_extension_ : *default_instance_->instrument_extension_;
}
inline ::Common::InstrumentExtension* SecurityDefinition::mutable_instrument_extension() {
  set_has_instrument_extension();
  if (instrument_extension_ == NULL) instrument_extension_ = new ::Common::InstrumentExtension;
  return instrument_extension_;
}
inline ::Common::InstrumentExtension* SecurityDefinition::release_instrument_extension() {
  clear_has_instrument_extension();
  ::Common::InstrumentExtension* temp = instrument_extension_;
  instrument_extension_ = NULL;
  return temp;
}
inline void SecurityDefinition::set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension) {
  delete instrument_extension_;
  instrument_extension_ = instrument_extension;
  if (instrument_extension) {
    set_has_instrument_extension();
  } else {
    clear_has_instrument_extension();
  }
}

// optional sfixed64 security_report_id = 14;
inline bool SecurityDefinition::has_security_report_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SecurityDefinition::set_has_security_report_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SecurityDefinition::clear_has_security_report_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SecurityDefinition::clear_security_report_id() {
  security_report_id_ = GOOGLE_LONGLONG(0);
  clear_has_security_report_id();
}
inline ::google::protobuf::int64 SecurityDefinition::security_report_id() const {
  return security_report_id_;
}
inline void SecurityDefinition::set_security_report_id(::google::protobuf::int64 value) {
  set_has_security_report_id();
  security_report_id_ = value;
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 15;
inline int SecurityDefinition::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void SecurityDefinition::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& SecurityDefinition::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* SecurityDefinition::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* SecurityDefinition::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
SecurityDefinition::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
SecurityDefinition::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// optional .Common.ApplicationSequenceControl application_sequence_control = 16;
inline bool SecurityDefinition::has_application_sequence_control() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SecurityDefinition::set_has_application_sequence_control() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SecurityDefinition::clear_has_application_sequence_control() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SecurityDefinition::clear_application_sequence_control() {
  if (application_sequence_control_ != NULL) application_sequence_control_->::Common::ApplicationSequenceControl::Clear();
  clear_has_application_sequence_control();
}
inline const ::Common::ApplicationSequenceControl& SecurityDefinition::application_sequence_control() const {
  return application_sequence_control_ != NULL ? *application_sequence_control_ : *default_instance_->application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* SecurityDefinition::mutable_application_sequence_control() {
  set_has_application_sequence_control();
  if (application_sequence_control_ == NULL) application_sequence_control_ = new ::Common::ApplicationSequenceControl;
  return application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* SecurityDefinition::release_application_sequence_control() {
  clear_has_application_sequence_control();
  ::Common::ApplicationSequenceControl* temp = application_sequence_control_;
  application_sequence_control_ = NULL;
  return temp;
}
inline void SecurityDefinition::set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control) {
  delete application_sequence_control_;
  application_sequence_control_ = application_sequence_control;
  if (application_sequence_control) {
    set_has_application_sequence_control();
  } else {
    clear_has_application_sequence_control();
  }
}

// repeated .SecuritiesReferenceData.CorporateActionEnum corporate_action = 17 [packed = true];
inline int SecurityDefinition::corporate_action_size() const {
  return corporate_action_.size();
}
inline void SecurityDefinition::clear_corporate_action() {
  corporate_action_.Clear();
}
inline ::SecuritiesReferenceData::CorporateActionEnum SecurityDefinition::corporate_action(int index) const {
  return static_cast< ::SecuritiesReferenceData::CorporateActionEnum >(corporate_action_.Get(index));
}
inline void SecurityDefinition::set_corporate_action(int index, ::SecuritiesReferenceData::CorporateActionEnum value) {
  assert(::SecuritiesReferenceData::CorporateActionEnum_IsValid(value));
  corporate_action_.Set(index, value);
}
inline void SecurityDefinition::add_corporate_action(::SecuritiesReferenceData::CorporateActionEnum value) {
  assert(::SecuritiesReferenceData::CorporateActionEnum_IsValid(value));
  corporate_action_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
SecurityDefinition::corporate_action() const {
  return corporate_action_;
}
inline ::google::protobuf::RepeatedField<int>*
SecurityDefinition::mutable_corporate_action() {
  return &corporate_action_;
}

// repeated .Common.MarketSegmentGrp market_segment_grp = 18;
inline int SecurityDefinition::market_segment_grp_size() const {
  return market_segment_grp_.size();
}
inline void SecurityDefinition::clear_market_segment_grp() {
  market_segment_grp_.Clear();
}
inline const ::Common::MarketSegmentGrp& SecurityDefinition::market_segment_grp(int index) const {
  return market_segment_grp_.Get(index);
}
inline ::Common::MarketSegmentGrp* SecurityDefinition::mutable_market_segment_grp(int index) {
  return market_segment_grp_.Mutable(index);
}
inline ::Common::MarketSegmentGrp* SecurityDefinition::add_market_segment_grp() {
  return market_segment_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp >&
SecurityDefinition::market_segment_grp() const {
  return market_segment_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp >*
SecurityDefinition::mutable_market_segment_grp() {
  return &market_segment_grp_;
}

// optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 19;
inline bool SecurityDefinition::has_spread_or_benchmark_curve_data() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SecurityDefinition::set_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SecurityDefinition::clear_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SecurityDefinition::clear_spread_or_benchmark_curve_data() {
  if (spread_or_benchmark_curve_data_ != NULL) spread_or_benchmark_curve_data_->::Common::SpreadOrBenchmarkCurveData::Clear();
  clear_has_spread_or_benchmark_curve_data();
}
inline const ::Common::SpreadOrBenchmarkCurveData& SecurityDefinition::spread_or_benchmark_curve_data() const {
  return spread_or_benchmark_curve_data_ != NULL ? *spread_or_benchmark_curve_data_ : *default_instance_->spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecurityDefinition::mutable_spread_or_benchmark_curve_data() {
  set_has_spread_or_benchmark_curve_data();
  if (spread_or_benchmark_curve_data_ == NULL) spread_or_benchmark_curve_data_ = new ::Common::SpreadOrBenchmarkCurveData;
  return spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecurityDefinition::release_spread_or_benchmark_curve_data() {
  clear_has_spread_or_benchmark_curve_data();
  ::Common::SpreadOrBenchmarkCurveData* temp = spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = NULL;
  return temp;
}
inline void SecurityDefinition::set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data) {
  delete spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = spread_or_benchmark_curve_data;
  if (spread_or_benchmark_curve_data) {
    set_has_spread_or_benchmark_curve_data();
  } else {
    clear_has_spread_or_benchmark_curve_data();
  }
}

// repeated .Common.Stipulations stipulations = 20;
inline int SecurityDefinition::stipulations_size() const {
  return stipulations_.size();
}
inline void SecurityDefinition::clear_stipulations() {
  stipulations_.Clear();
}
inline const ::Common::Stipulations& SecurityDefinition::stipulations(int index) const {
  return stipulations_.Get(index);
}
inline ::Common::Stipulations* SecurityDefinition::mutable_stipulations(int index) {
  return stipulations_.Mutable(index);
}
inline ::Common::Stipulations* SecurityDefinition::add_stipulations() {
  return stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
SecurityDefinition::stipulations() const {
  return stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
SecurityDefinition::mutable_stipulations() {
  return &stipulations_;
}

// optional .Common.YieldData yield_data = 21;
inline bool SecurityDefinition::has_yield_data() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SecurityDefinition::set_has_yield_data() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SecurityDefinition::clear_has_yield_data() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SecurityDefinition::clear_yield_data() {
  if (yield_data_ != NULL) yield_data_->::Common::YieldData::Clear();
  clear_has_yield_data();
}
inline const ::Common::YieldData& SecurityDefinition::yield_data() const {
  return yield_data_ != NULL ? *yield_data_ : *default_instance_->yield_data_;
}
inline ::Common::YieldData* SecurityDefinition::mutable_yield_data() {
  set_has_yield_data();
  if (yield_data_ == NULL) yield_data_ = new ::Common::YieldData;
  return yield_data_;
}
inline ::Common::YieldData* SecurityDefinition::release_yield_data() {
  clear_has_yield_data();
  ::Common::YieldData* temp = yield_data_;
  yield_data_ = NULL;
  return temp;
}
inline void SecurityDefinition::set_allocated_yield_data(::Common::YieldData* yield_data) {
  delete yield_data_;
  yield_data_ = yield_data;
  if (yield_data) {
    set_has_yield_data();
  } else {
    clear_has_yield_data();
  }
}

// optional sfixed64 transact_time = 22;
inline bool SecurityDefinition::has_transact_time() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SecurityDefinition::set_has_transact_time() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SecurityDefinition::clear_has_transact_time() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SecurityDefinition::clear_transact_time() {
  transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_transact_time();
}
inline ::google::protobuf::int64 SecurityDefinition::transact_time() const {
  return transact_time_;
}
inline void SecurityDefinition::set_transact_time(::google::protobuf::int64 value) {
  set_has_transact_time();
  transact_time_ = value;
}

// -------------------------------------------------------------------

// SecurityDefinitionRequest

// optional string currency = 1;
inline bool SecurityDefinitionRequest::has_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityDefinitionRequest::set_has_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityDefinitionRequest::clear_has_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityDefinitionRequest::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& SecurityDefinitionRequest::currency() const {
  return *currency_;
}
inline void SecurityDefinitionRequest::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecurityDefinitionRequest::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecurityDefinitionRequest::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionRequest::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* SecurityDefinitionRequest::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionRequest::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_text = 2;
inline bool SecurityDefinitionRequest::has_encoded_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityDefinitionRequest::set_has_encoded_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityDefinitionRequest::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityDefinitionRequest::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& SecurityDefinitionRequest::encoded_text() const {
  return *encoded_text_;
}
inline void SecurityDefinitionRequest::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecurityDefinitionRequest::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecurityDefinitionRequest::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionRequest::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* SecurityDefinitionRequest::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionRequest::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 3;
inline bool SecurityDefinitionRequest::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityDefinitionRequest::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityDefinitionRequest::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityDefinitionRequest::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 SecurityDefinitionRequest::encoded_text_len() const {
  return encoded_text_len_;
}
inline void SecurityDefinitionRequest::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional string security_req_id = 4;
inline bool SecurityDefinitionRequest::has_security_req_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecurityDefinitionRequest::set_has_security_req_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecurityDefinitionRequest::clear_has_security_req_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecurityDefinitionRequest::clear_security_req_id() {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    security_req_id_->clear();
  }
  clear_has_security_req_id();
}
inline const ::std::string& SecurityDefinitionRequest::security_req_id() const {
  return *security_req_id_;
}
inline void SecurityDefinitionRequest::set_security_req_id(const ::std::string& value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityDefinitionRequest::set_security_req_id(const char* value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityDefinitionRequest::set_security_req_id(const char* value, size_t size) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionRequest::mutable_security_req_id() {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  return security_req_id_;
}
inline ::std::string* SecurityDefinitionRequest::release_security_req_id() {
  clear_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_req_id_;
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionRequest::set_allocated_security_req_id(::std::string* security_req_id) {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_req_id_;
  }
  if (security_req_id) {
    set_has_security_req_id();
    security_req_id_ = security_req_id;
  } else {
    clear_has_security_req_id();
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.SecurityRequestTypeEnum security_request_type = 5;
inline bool SecurityDefinitionRequest::has_security_request_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecurityDefinitionRequest::set_has_security_request_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecurityDefinitionRequest::clear_has_security_request_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecurityDefinitionRequest::clear_security_request_type() {
  security_request_type_ = 0;
  clear_has_security_request_type();
}
inline ::SecuritiesReferenceData::SecurityRequestTypeEnum SecurityDefinitionRequest::security_request_type() const {
  return static_cast< ::SecuritiesReferenceData::SecurityRequestTypeEnum >(security_request_type_);
}
inline void SecurityDefinitionRequest::set_security_request_type(::SecuritiesReferenceData::SecurityRequestTypeEnum value) {
  assert(::SecuritiesReferenceData::SecurityRequestTypeEnum_IsValid(value));
  set_has_security_request_type();
  security_request_type_ = value;
}

// optional .Session.StandardHeader standard_header = 6;
inline bool SecurityDefinitionRequest::has_standard_header() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecurityDefinitionRequest::set_has_standard_header() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecurityDefinitionRequest::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecurityDefinitionRequest::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& SecurityDefinitionRequest::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* SecurityDefinitionRequest::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* SecurityDefinitionRequest::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void SecurityDefinitionRequest::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 7;
inline bool SecurityDefinitionRequest::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecurityDefinitionRequest::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecurityDefinitionRequest::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecurityDefinitionRequest::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& SecurityDefinitionRequest::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityDefinitionRequest::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityDefinitionRequest::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void SecurityDefinitionRequest::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional string text = 8;
inline bool SecurityDefinitionRequest::has_text() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecurityDefinitionRequest::set_has_text() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecurityDefinitionRequest::clear_has_text() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecurityDefinitionRequest::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SecurityDefinitionRequest::text() const {
  return *text_;
}
inline void SecurityDefinitionRequest::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecurityDefinitionRequest::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecurityDefinitionRequest::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionRequest::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SecurityDefinitionRequest::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionRequest::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.TradingSessionIdEnum trading_session_id = 9;
inline bool SecurityDefinitionRequest::has_trading_session_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SecurityDefinitionRequest::set_has_trading_session_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SecurityDefinitionRequest::clear_has_trading_session_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SecurityDefinitionRequest::clear_trading_session_id() {
  trading_session_id_ = 0;
  clear_has_trading_session_id();
}
inline ::SecuritiesReferenceData::TradingSessionIdEnum SecurityDefinitionRequest::trading_session_id() const {
  return static_cast< ::SecuritiesReferenceData::TradingSessionIdEnum >(trading_session_id_);
}
inline void SecurityDefinitionRequest::set_trading_session_id(::SecuritiesReferenceData::TradingSessionIdEnum value) {
  assert(::SecuritiesReferenceData::TradingSessionIdEnum_IsValid(value));
  set_has_trading_session_id();
  trading_session_id_ = value;
}

// optional .Common.Instrument instrument = 10;
inline bool SecurityDefinitionRequest::has_instrument() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecurityDefinitionRequest::set_has_instrument() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecurityDefinitionRequest::clear_has_instrument() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecurityDefinitionRequest::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& SecurityDefinitionRequest::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* SecurityDefinitionRequest::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* SecurityDefinitionRequest::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void SecurityDefinitionRequest::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional .SecuritiesReferenceData.SubscriptionRequestTypeEnum subscription_request_type = 11;
inline bool SecurityDefinitionRequest::has_subscription_request_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SecurityDefinitionRequest::set_has_subscription_request_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SecurityDefinitionRequest::clear_has_subscription_request_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SecurityDefinitionRequest::clear_subscription_request_type() {
  subscription_request_type_ = 0;
  clear_has_subscription_request_type();
}
inline ::SecuritiesReferenceData::SubscriptionRequestTypeEnum SecurityDefinitionRequest::subscription_request_type() const {
  return static_cast< ::SecuritiesReferenceData::SubscriptionRequestTypeEnum >(subscription_request_type_);
}
inline void SecurityDefinitionRequest::set_subscription_request_type(::SecuritiesReferenceData::SubscriptionRequestTypeEnum value) {
  assert(::SecuritiesReferenceData::SubscriptionRequestTypeEnum_IsValid(value));
  set_has_subscription_request_type();
  subscription_request_type_ = value;
}

// optional .SecuritiesReferenceData.TradingSessionSubIdEnum trading_session_sub_id = 12;
inline bool SecurityDefinitionRequest::has_trading_session_sub_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SecurityDefinitionRequest::set_has_trading_session_sub_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SecurityDefinitionRequest::clear_has_trading_session_sub_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SecurityDefinitionRequest::clear_trading_session_sub_id() {
  trading_session_sub_id_ = 0;
  clear_has_trading_session_sub_id();
}
inline ::SecuritiesReferenceData::TradingSessionSubIdEnum SecurityDefinitionRequest::trading_session_sub_id() const {
  return static_cast< ::SecuritiesReferenceData::TradingSessionSubIdEnum >(trading_session_sub_id_);
}
inline void SecurityDefinitionRequest::set_trading_session_sub_id(::SecuritiesReferenceData::TradingSessionSubIdEnum value) {
  assert(::SecuritiesReferenceData::TradingSessionSubIdEnum_IsValid(value));
  set_has_trading_session_sub_id();
  trading_session_sub_id_ = value;
}

// optional .SecuritiesReferenceData.ExpirationCycleEnum expiration_cycle = 13;
inline bool SecurityDefinitionRequest::has_expiration_cycle() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecurityDefinitionRequest::set_has_expiration_cycle() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecurityDefinitionRequest::clear_has_expiration_cycle() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecurityDefinitionRequest::clear_expiration_cycle() {
  expiration_cycle_ = 0;
  clear_has_expiration_cycle();
}
inline ::SecuritiesReferenceData::ExpirationCycleEnum SecurityDefinitionRequest::expiration_cycle() const {
  return static_cast< ::SecuritiesReferenceData::ExpirationCycleEnum >(expiration_cycle_);
}
inline void SecurityDefinitionRequest::set_expiration_cycle(::SecuritiesReferenceData::ExpirationCycleEnum value) {
  assert(::SecuritiesReferenceData::ExpirationCycleEnum_IsValid(value));
  set_has_expiration_cycle();
  expiration_cycle_ = value;
}

// repeated .Common.InstrmtLegGrp instrmt_leg_grp = 14;
inline int SecurityDefinitionRequest::instrmt_leg_grp_size() const {
  return instrmt_leg_grp_.size();
}
inline void SecurityDefinitionRequest::clear_instrmt_leg_grp() {
  instrmt_leg_grp_.Clear();
}
inline const ::Common::InstrmtLegGrp& SecurityDefinitionRequest::instrmt_leg_grp(int index) const {
  return instrmt_leg_grp_.Get(index);
}
inline ::Common::InstrmtLegGrp* SecurityDefinitionRequest::mutable_instrmt_leg_grp(int index) {
  return instrmt_leg_grp_.Mutable(index);
}
inline ::Common::InstrmtLegGrp* SecurityDefinitionRequest::add_instrmt_leg_grp() {
  return instrmt_leg_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
SecurityDefinitionRequest::instrmt_leg_grp() const {
  return instrmt_leg_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
SecurityDefinitionRequest::mutable_instrmt_leg_grp() {
  return &instrmt_leg_grp_;
}

// optional .Common.InstrumentExtension instrument_extension = 15;
inline bool SecurityDefinitionRequest::has_instrument_extension() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SecurityDefinitionRequest::set_has_instrument_extension() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SecurityDefinitionRequest::clear_has_instrument_extension() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SecurityDefinitionRequest::clear_instrument_extension() {
  if (instrument_extension_ != NULL) instrument_extension_->::Common::InstrumentExtension::Clear();
  clear_has_instrument_extension();
}
inline const ::Common::InstrumentExtension& SecurityDefinitionRequest::instrument_extension() const {
  return instrument_extension_ != NULL ? *instrument_extension_ : *default_instance_->instrument_extension_;
}
inline ::Common::InstrumentExtension* SecurityDefinitionRequest::mutable_instrument_extension() {
  set_has_instrument_extension();
  if (instrument_extension_ == NULL) instrument_extension_ = new ::Common::InstrumentExtension;
  return instrument_extension_;
}
inline ::Common::InstrumentExtension* SecurityDefinitionRequest::release_instrument_extension() {
  clear_has_instrument_extension();
  ::Common::InstrumentExtension* temp = instrument_extension_;
  instrument_extension_ = NULL;
  return temp;
}
inline void SecurityDefinitionRequest::set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension) {
  delete instrument_extension_;
  instrument_extension_ = instrument_extension;
  if (instrument_extension) {
    set_has_instrument_extension();
  } else {
    clear_has_instrument_extension();
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 16;
inline int SecurityDefinitionRequest::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void SecurityDefinitionRequest::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& SecurityDefinitionRequest::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* SecurityDefinitionRequest::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* SecurityDefinitionRequest::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
SecurityDefinitionRequest::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
SecurityDefinitionRequest::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// optional string market_id = 17;
inline bool SecurityDefinitionRequest::has_market_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SecurityDefinitionRequest::set_has_market_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SecurityDefinitionRequest::clear_has_market_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SecurityDefinitionRequest::clear_market_id() {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    market_id_->clear();
  }
  clear_has_market_id();
}
inline const ::std::string& SecurityDefinitionRequest::market_id() const {
  return *market_id_;
}
inline void SecurityDefinitionRequest::set_market_id(const ::std::string& value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void SecurityDefinitionRequest::set_market_id(const char* value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void SecurityDefinitionRequest::set_market_id(const char* value, size_t size) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionRequest::mutable_market_id() {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  return market_id_;
}
inline ::std::string* SecurityDefinitionRequest::release_market_id() {
  clear_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_id_;
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionRequest::set_allocated_market_id(::std::string* market_id) {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_id_;
  }
  if (market_id) {
    set_has_market_id();
    market_id_ = market_id;
  } else {
    clear_has_market_id();
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string market_segment_id = 18;
inline bool SecurityDefinitionRequest::has_market_segment_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SecurityDefinitionRequest::set_has_market_segment_id() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SecurityDefinitionRequest::clear_has_market_segment_id() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SecurityDefinitionRequest::clear_market_segment_id() {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    market_segment_id_->clear();
  }
  clear_has_market_segment_id();
}
inline const ::std::string& SecurityDefinitionRequest::market_segment_id() const {
  return *market_segment_id_;
}
inline void SecurityDefinitionRequest::set_market_segment_id(const ::std::string& value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void SecurityDefinitionRequest::set_market_segment_id(const char* value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void SecurityDefinitionRequest::set_market_segment_id(const char* value, size_t size) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionRequest::mutable_market_segment_id() {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  return market_segment_id_;
}
inline ::std::string* SecurityDefinitionRequest::release_market_segment_id() {
  clear_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_segment_id_;
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionRequest::set_allocated_market_segment_id(::std::string* market_segment_id) {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_segment_id_;
  }
  if (market_segment_id) {
    set_has_market_segment_id();
    market_segment_id_ = market_segment_id;
  } else {
    clear_has_market_segment_id();
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 19;
inline bool SecurityDefinitionRequest::has_spread_or_benchmark_curve_data() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SecurityDefinitionRequest::set_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SecurityDefinitionRequest::clear_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SecurityDefinitionRequest::clear_spread_or_benchmark_curve_data() {
  if (spread_or_benchmark_curve_data_ != NULL) spread_or_benchmark_curve_data_->::Common::SpreadOrBenchmarkCurveData::Clear();
  clear_has_spread_or_benchmark_curve_data();
}
inline const ::Common::SpreadOrBenchmarkCurveData& SecurityDefinitionRequest::spread_or_benchmark_curve_data() const {
  return spread_or_benchmark_curve_data_ != NULL ? *spread_or_benchmark_curve_data_ : *default_instance_->spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecurityDefinitionRequest::mutable_spread_or_benchmark_curve_data() {
  set_has_spread_or_benchmark_curve_data();
  if (spread_or_benchmark_curve_data_ == NULL) spread_or_benchmark_curve_data_ = new ::Common::SpreadOrBenchmarkCurveData;
  return spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecurityDefinitionRequest::release_spread_or_benchmark_curve_data() {
  clear_has_spread_or_benchmark_curve_data();
  ::Common::SpreadOrBenchmarkCurveData* temp = spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = NULL;
  return temp;
}
inline void SecurityDefinitionRequest::set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data) {
  delete spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = spread_or_benchmark_curve_data;
  if (spread_or_benchmark_curve_data) {
    set_has_spread_or_benchmark_curve_data();
  } else {
    clear_has_spread_or_benchmark_curve_data();
  }
}

// repeated .Common.Stipulations stipulations = 20;
inline int SecurityDefinitionRequest::stipulations_size() const {
  return stipulations_.size();
}
inline void SecurityDefinitionRequest::clear_stipulations() {
  stipulations_.Clear();
}
inline const ::Common::Stipulations& SecurityDefinitionRequest::stipulations(int index) const {
  return stipulations_.Get(index);
}
inline ::Common::Stipulations* SecurityDefinitionRequest::mutable_stipulations(int index) {
  return stipulations_.Mutable(index);
}
inline ::Common::Stipulations* SecurityDefinitionRequest::add_stipulations() {
  return stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
SecurityDefinitionRequest::stipulations() const {
  return stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
SecurityDefinitionRequest::mutable_stipulations() {
  return &stipulations_;
}

// optional .Common.YieldData yield_data = 21;
inline bool SecurityDefinitionRequest::has_yield_data() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SecurityDefinitionRequest::set_has_yield_data() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SecurityDefinitionRequest::clear_has_yield_data() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SecurityDefinitionRequest::clear_yield_data() {
  if (yield_data_ != NULL) yield_data_->::Common::YieldData::Clear();
  clear_has_yield_data();
}
inline const ::Common::YieldData& SecurityDefinitionRequest::yield_data() const {
  return yield_data_ != NULL ? *yield_data_ : *default_instance_->yield_data_;
}
inline ::Common::YieldData* SecurityDefinitionRequest::mutable_yield_data() {
  set_has_yield_data();
  if (yield_data_ == NULL) yield_data_ = new ::Common::YieldData;
  return yield_data_;
}
inline ::Common::YieldData* SecurityDefinitionRequest::release_yield_data() {
  clear_has_yield_data();
  ::Common::YieldData* temp = yield_data_;
  yield_data_ = NULL;
  return temp;
}
inline void SecurityDefinitionRequest::set_allocated_yield_data(::Common::YieldData* yield_data) {
  delete yield_data_;
  yield_data_ = yield_data;
  if (yield_data) {
    set_has_yield_data();
  } else {
    clear_has_yield_data();
  }
}

// -------------------------------------------------------------------

// SecurityDefinitionUpdateReport

// optional sfixed32 clearing_business_date = 1;
inline bool SecurityDefinitionUpdateReport::has_clearing_business_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_clearing_business_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityDefinitionUpdateReport::clear_has_clearing_business_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityDefinitionUpdateReport::clear_clearing_business_date() {
  clearing_business_date_ = 0;
  clear_has_clearing_business_date();
}
inline ::google::protobuf::int32 SecurityDefinitionUpdateReport::clearing_business_date() const {
  return clearing_business_date_;
}
inline void SecurityDefinitionUpdateReport::set_clearing_business_date(::google::protobuf::int32 value) {
  set_has_clearing_business_date();
  clearing_business_date_ = value;
}

// repeated .SecuritiesReferenceData.CorporateActionEnum corporate_action = 2 [packed = true];
inline int SecurityDefinitionUpdateReport::corporate_action_size() const {
  return corporate_action_.size();
}
inline void SecurityDefinitionUpdateReport::clear_corporate_action() {
  corporate_action_.Clear();
}
inline ::SecuritiesReferenceData::CorporateActionEnum SecurityDefinitionUpdateReport::corporate_action(int index) const {
  return static_cast< ::SecuritiesReferenceData::CorporateActionEnum >(corporate_action_.Get(index));
}
inline void SecurityDefinitionUpdateReport::set_corporate_action(int index, ::SecuritiesReferenceData::CorporateActionEnum value) {
  assert(::SecuritiesReferenceData::CorporateActionEnum_IsValid(value));
  corporate_action_.Set(index, value);
}
inline void SecurityDefinitionUpdateReport::add_corporate_action(::SecuritiesReferenceData::CorporateActionEnum value) {
  assert(::SecuritiesReferenceData::CorporateActionEnum_IsValid(value));
  corporate_action_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
SecurityDefinitionUpdateReport::corporate_action() const {
  return corporate_action_;
}
inline ::google::protobuf::RepeatedField<int>*
SecurityDefinitionUpdateReport::mutable_corporate_action() {
  return &corporate_action_;
}

// optional string currency = 3;
inline bool SecurityDefinitionUpdateReport::has_currency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_currency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityDefinitionUpdateReport::clear_has_currency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityDefinitionUpdateReport::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& SecurityDefinitionUpdateReport::currency() const {
  return *currency_;
}
inline void SecurityDefinitionUpdateReport::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionUpdateReport::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* SecurityDefinitionUpdateReport::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionUpdateReport::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_text = 4;
inline bool SecurityDefinitionUpdateReport::has_encoded_text() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_encoded_text() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecurityDefinitionUpdateReport::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecurityDefinitionUpdateReport::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& SecurityDefinitionUpdateReport::encoded_text() const {
  return *encoded_text_;
}
inline void SecurityDefinitionUpdateReport::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionUpdateReport::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* SecurityDefinitionUpdateReport::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionUpdateReport::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 5;
inline bool SecurityDefinitionUpdateReport::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecurityDefinitionUpdateReport::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecurityDefinitionUpdateReport::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 SecurityDefinitionUpdateReport::encoded_text_len() const {
  return encoded_text_len_;
}
inline void SecurityDefinitionUpdateReport::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// repeated .Common.InstrmtLegGrp instrmt_leg_grp = 6;
inline int SecurityDefinitionUpdateReport::instrmt_leg_grp_size() const {
  return instrmt_leg_grp_.size();
}
inline void SecurityDefinitionUpdateReport::clear_instrmt_leg_grp() {
  instrmt_leg_grp_.Clear();
}
inline const ::Common::InstrmtLegGrp& SecurityDefinitionUpdateReport::instrmt_leg_grp(int index) const {
  return instrmt_leg_grp_.Get(index);
}
inline ::Common::InstrmtLegGrp* SecurityDefinitionUpdateReport::mutable_instrmt_leg_grp(int index) {
  return instrmt_leg_grp_.Mutable(index);
}
inline ::Common::InstrmtLegGrp* SecurityDefinitionUpdateReport::add_instrmt_leg_grp() {
  return instrmt_leg_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
SecurityDefinitionUpdateReport::instrmt_leg_grp() const {
  return instrmt_leg_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
SecurityDefinitionUpdateReport::mutable_instrmt_leg_grp() {
  return &instrmt_leg_grp_;
}

// optional .Common.Instrument instrument = 7;
inline bool SecurityDefinitionUpdateReport::has_instrument() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_instrument() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecurityDefinitionUpdateReport::clear_has_instrument() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecurityDefinitionUpdateReport::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& SecurityDefinitionUpdateReport::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* SecurityDefinitionUpdateReport::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* SecurityDefinitionUpdateReport::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void SecurityDefinitionUpdateReport::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional sfixed64 security_report_id = 8;
inline bool SecurityDefinitionUpdateReport::has_security_report_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_security_report_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecurityDefinitionUpdateReport::clear_has_security_report_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecurityDefinitionUpdateReport::clear_security_report_id() {
  security_report_id_ = GOOGLE_LONGLONG(0);
  clear_has_security_report_id();
}
inline ::google::protobuf::int64 SecurityDefinitionUpdateReport::security_report_id() const {
  return security_report_id_;
}
inline void SecurityDefinitionUpdateReport::set_security_report_id(::google::protobuf::int64 value) {
  set_has_security_report_id();
  security_report_id_ = value;
}

// optional string security_req_id = 9;
inline bool SecurityDefinitionUpdateReport::has_security_req_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_security_req_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SecurityDefinitionUpdateReport::clear_has_security_req_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SecurityDefinitionUpdateReport::clear_security_req_id() {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    security_req_id_->clear();
  }
  clear_has_security_req_id();
}
inline const ::std::string& SecurityDefinitionUpdateReport::security_req_id() const {
  return *security_req_id_;
}
inline void SecurityDefinitionUpdateReport::set_security_req_id(const ::std::string& value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_security_req_id(const char* value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_security_req_id(const char* value, size_t size) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionUpdateReport::mutable_security_req_id() {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  return security_req_id_;
}
inline ::std::string* SecurityDefinitionUpdateReport::release_security_req_id() {
  clear_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_req_id_;
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionUpdateReport::set_allocated_security_req_id(::std::string* security_req_id) {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_req_id_;
  }
  if (security_req_id) {
    set_has_security_req_id();
    security_req_id_ = security_req_id;
  } else {
    clear_has_security_req_id();
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_response_id = 10;
inline bool SecurityDefinitionUpdateReport::has_security_response_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_security_response_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecurityDefinitionUpdateReport::clear_has_security_response_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecurityDefinitionUpdateReport::clear_security_response_id() {
  if (security_response_id_ != &::google::protobuf::internal::kEmptyString) {
    security_response_id_->clear();
  }
  clear_has_security_response_id();
}
inline const ::std::string& SecurityDefinitionUpdateReport::security_response_id() const {
  return *security_response_id_;
}
inline void SecurityDefinitionUpdateReport::set_security_response_id(const ::std::string& value) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_security_response_id(const char* value) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_security_response_id(const char* value, size_t size) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionUpdateReport::mutable_security_response_id() {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  return security_response_id_;
}
inline ::std::string* SecurityDefinitionUpdateReport::release_security_response_id() {
  clear_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_response_id_;
    security_response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionUpdateReport::set_allocated_security_response_id(::std::string* security_response_id) {
  if (security_response_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_response_id_;
  }
  if (security_response_id) {
    set_has_security_response_id();
    security_response_id_ = security_response_id;
  } else {
    clear_has_security_response_id();
    security_response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.SecurityResponseTypeEnum security_response_type = 11;
inline bool SecurityDefinitionUpdateReport::has_security_response_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_security_response_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SecurityDefinitionUpdateReport::clear_has_security_response_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SecurityDefinitionUpdateReport::clear_security_response_type() {
  security_response_type_ = 0;
  clear_has_security_response_type();
}
inline ::SecuritiesReferenceData::SecurityResponseTypeEnum SecurityDefinitionUpdateReport::security_response_type() const {
  return static_cast< ::SecuritiesReferenceData::SecurityResponseTypeEnum >(security_response_type_);
}
inline void SecurityDefinitionUpdateReport::set_security_response_type(::SecuritiesReferenceData::SecurityResponseTypeEnum value) {
  assert(::SecuritiesReferenceData::SecurityResponseTypeEnum_IsValid(value));
  set_has_security_response_type();
  security_response_type_ = value;
}

// optional .SecuritiesReferenceData.SecurityUpdateActionEnum security_update_action = 12;
inline bool SecurityDefinitionUpdateReport::has_security_update_action() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_security_update_action() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SecurityDefinitionUpdateReport::clear_has_security_update_action() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SecurityDefinitionUpdateReport::clear_security_update_action() {
  security_update_action_ = 0;
  clear_has_security_update_action();
}
inline ::SecuritiesReferenceData::SecurityUpdateActionEnum SecurityDefinitionUpdateReport::security_update_action() const {
  return static_cast< ::SecuritiesReferenceData::SecurityUpdateActionEnum >(security_update_action_);
}
inline void SecurityDefinitionUpdateReport::set_security_update_action(::SecuritiesReferenceData::SecurityUpdateActionEnum value) {
  assert(::SecuritiesReferenceData::SecurityUpdateActionEnum_IsValid(value));
  set_has_security_update_action();
  security_update_action_ = value;
}

// optional .Session.StandardHeader standard_header = 13;
inline bool SecurityDefinitionUpdateReport::has_standard_header() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_standard_header() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecurityDefinitionUpdateReport::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecurityDefinitionUpdateReport::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& SecurityDefinitionUpdateReport::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* SecurityDefinitionUpdateReport::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* SecurityDefinitionUpdateReport::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void SecurityDefinitionUpdateReport::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 14;
inline bool SecurityDefinitionUpdateReport::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SecurityDefinitionUpdateReport::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SecurityDefinitionUpdateReport::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& SecurityDefinitionUpdateReport::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityDefinitionUpdateReport::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityDefinitionUpdateReport::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void SecurityDefinitionUpdateReport::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional string text = 15;
inline bool SecurityDefinitionUpdateReport::has_text() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_text() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SecurityDefinitionUpdateReport::clear_has_text() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SecurityDefinitionUpdateReport::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SecurityDefinitionUpdateReport::text() const {
  return *text_;
}
inline void SecurityDefinitionUpdateReport::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecurityDefinitionUpdateReport::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityDefinitionUpdateReport::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SecurityDefinitionUpdateReport::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityDefinitionUpdateReport::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.ApplicationSequenceControl application_sequence_control = 16;
inline bool SecurityDefinitionUpdateReport::has_application_sequence_control() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_application_sequence_control() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SecurityDefinitionUpdateReport::clear_has_application_sequence_control() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SecurityDefinitionUpdateReport::clear_application_sequence_control() {
  if (application_sequence_control_ != NULL) application_sequence_control_->::Common::ApplicationSequenceControl::Clear();
  clear_has_application_sequence_control();
}
inline const ::Common::ApplicationSequenceControl& SecurityDefinitionUpdateReport::application_sequence_control() const {
  return application_sequence_control_ != NULL ? *application_sequence_control_ : *default_instance_->application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* SecurityDefinitionUpdateReport::mutable_application_sequence_control() {
  set_has_application_sequence_control();
  if (application_sequence_control_ == NULL) application_sequence_control_ = new ::Common::ApplicationSequenceControl;
  return application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* SecurityDefinitionUpdateReport::release_application_sequence_control() {
  clear_has_application_sequence_control();
  ::Common::ApplicationSequenceControl* temp = application_sequence_control_;
  application_sequence_control_ = NULL;
  return temp;
}
inline void SecurityDefinitionUpdateReport::set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control) {
  delete application_sequence_control_;
  application_sequence_control_ = application_sequence_control;
  if (application_sequence_control) {
    set_has_application_sequence_control();
  } else {
    clear_has_application_sequence_control();
  }
}

// optional .Common.InstrumentExtension instrument_extension = 17;
inline bool SecurityDefinitionUpdateReport::has_instrument_extension() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_instrument_extension() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SecurityDefinitionUpdateReport::clear_has_instrument_extension() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SecurityDefinitionUpdateReport::clear_instrument_extension() {
  if (instrument_extension_ != NULL) instrument_extension_->::Common::InstrumentExtension::Clear();
  clear_has_instrument_extension();
}
inline const ::Common::InstrumentExtension& SecurityDefinitionUpdateReport::instrument_extension() const {
  return instrument_extension_ != NULL ? *instrument_extension_ : *default_instance_->instrument_extension_;
}
inline ::Common::InstrumentExtension* SecurityDefinitionUpdateReport::mutable_instrument_extension() {
  set_has_instrument_extension();
  if (instrument_extension_ == NULL) instrument_extension_ = new ::Common::InstrumentExtension;
  return instrument_extension_;
}
inline ::Common::InstrumentExtension* SecurityDefinitionUpdateReport::release_instrument_extension() {
  clear_has_instrument_extension();
  ::Common::InstrumentExtension* temp = instrument_extension_;
  instrument_extension_ = NULL;
  return temp;
}
inline void SecurityDefinitionUpdateReport::set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension) {
  delete instrument_extension_;
  instrument_extension_ = instrument_extension;
  if (instrument_extension) {
    set_has_instrument_extension();
  } else {
    clear_has_instrument_extension();
  }
}

// repeated .Common.MarketSegmentGrp market_segment_grp = 18;
inline int SecurityDefinitionUpdateReport::market_segment_grp_size() const {
  return market_segment_grp_.size();
}
inline void SecurityDefinitionUpdateReport::clear_market_segment_grp() {
  market_segment_grp_.Clear();
}
inline const ::Common::MarketSegmentGrp& SecurityDefinitionUpdateReport::market_segment_grp(int index) const {
  return market_segment_grp_.Get(index);
}
inline ::Common::MarketSegmentGrp* SecurityDefinitionUpdateReport::mutable_market_segment_grp(int index) {
  return market_segment_grp_.Mutable(index);
}
inline ::Common::MarketSegmentGrp* SecurityDefinitionUpdateReport::add_market_segment_grp() {
  return market_segment_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp >&
SecurityDefinitionUpdateReport::market_segment_grp() const {
  return market_segment_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::MarketSegmentGrp >*
SecurityDefinitionUpdateReport::mutable_market_segment_grp() {
  return &market_segment_grp_;
}

// optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 19;
inline bool SecurityDefinitionUpdateReport::has_spread_or_benchmark_curve_data() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SecurityDefinitionUpdateReport::clear_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SecurityDefinitionUpdateReport::clear_spread_or_benchmark_curve_data() {
  if (spread_or_benchmark_curve_data_ != NULL) spread_or_benchmark_curve_data_->::Common::SpreadOrBenchmarkCurveData::Clear();
  clear_has_spread_or_benchmark_curve_data();
}
inline const ::Common::SpreadOrBenchmarkCurveData& SecurityDefinitionUpdateReport::spread_or_benchmark_curve_data() const {
  return spread_or_benchmark_curve_data_ != NULL ? *spread_or_benchmark_curve_data_ : *default_instance_->spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecurityDefinitionUpdateReport::mutable_spread_or_benchmark_curve_data() {
  set_has_spread_or_benchmark_curve_data();
  if (spread_or_benchmark_curve_data_ == NULL) spread_or_benchmark_curve_data_ = new ::Common::SpreadOrBenchmarkCurveData;
  return spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecurityDefinitionUpdateReport::release_spread_or_benchmark_curve_data() {
  clear_has_spread_or_benchmark_curve_data();
  ::Common::SpreadOrBenchmarkCurveData* temp = spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = NULL;
  return temp;
}
inline void SecurityDefinitionUpdateReport::set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data) {
  delete spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = spread_or_benchmark_curve_data;
  if (spread_or_benchmark_curve_data) {
    set_has_spread_or_benchmark_curve_data();
  } else {
    clear_has_spread_or_benchmark_curve_data();
  }
}

// repeated .Common.Stipulations stipulations = 20;
inline int SecurityDefinitionUpdateReport::stipulations_size() const {
  return stipulations_.size();
}
inline void SecurityDefinitionUpdateReport::clear_stipulations() {
  stipulations_.Clear();
}
inline const ::Common::Stipulations& SecurityDefinitionUpdateReport::stipulations(int index) const {
  return stipulations_.Get(index);
}
inline ::Common::Stipulations* SecurityDefinitionUpdateReport::mutable_stipulations(int index) {
  return stipulations_.Mutable(index);
}
inline ::Common::Stipulations* SecurityDefinitionUpdateReport::add_stipulations() {
  return stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
SecurityDefinitionUpdateReport::stipulations() const {
  return stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
SecurityDefinitionUpdateReport::mutable_stipulations() {
  return &stipulations_;
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 21;
inline int SecurityDefinitionUpdateReport::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void SecurityDefinitionUpdateReport::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& SecurityDefinitionUpdateReport::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* SecurityDefinitionUpdateReport::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* SecurityDefinitionUpdateReport::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
SecurityDefinitionUpdateReport::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
SecurityDefinitionUpdateReport::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// optional .Common.YieldData yield_data = 22;
inline bool SecurityDefinitionUpdateReport::has_yield_data() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_yield_data() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SecurityDefinitionUpdateReport::clear_has_yield_data() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SecurityDefinitionUpdateReport::clear_yield_data() {
  if (yield_data_ != NULL) yield_data_->::Common::YieldData::Clear();
  clear_has_yield_data();
}
inline const ::Common::YieldData& SecurityDefinitionUpdateReport::yield_data() const {
  return yield_data_ != NULL ? *yield_data_ : *default_instance_->yield_data_;
}
inline ::Common::YieldData* SecurityDefinitionUpdateReport::mutable_yield_data() {
  set_has_yield_data();
  if (yield_data_ == NULL) yield_data_ = new ::Common::YieldData;
  return yield_data_;
}
inline ::Common::YieldData* SecurityDefinitionUpdateReport::release_yield_data() {
  clear_has_yield_data();
  ::Common::YieldData* temp = yield_data_;
  yield_data_ = NULL;
  return temp;
}
inline void SecurityDefinitionUpdateReport::set_allocated_yield_data(::Common::YieldData* yield_data) {
  delete yield_data_;
  yield_data_ = yield_data;
  if (yield_data) {
    set_has_yield_data();
  } else {
    clear_has_yield_data();
  }
}

// optional sfixed64 transact_time = 23;
inline bool SecurityDefinitionUpdateReport::has_transact_time() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SecurityDefinitionUpdateReport::set_has_transact_time() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SecurityDefinitionUpdateReport::clear_has_transact_time() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SecurityDefinitionUpdateReport::clear_transact_time() {
  transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_transact_time();
}
inline ::google::protobuf::int64 SecurityDefinitionUpdateReport::transact_time() const {
  return transact_time_;
}
inline void SecurityDefinitionUpdateReport::set_transact_time(::google::protobuf::int64 value) {
  set_has_transact_time();
  transact_time_ = value;
}

// -------------------------------------------------------------------

// SecListGrp

// optional string currency = 1;
inline bool SecListGrp::has_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecListGrp::set_has_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecListGrp::clear_has_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecListGrp::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& SecListGrp::currency() const {
  return *currency_;
}
inline void SecListGrp::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecListGrp::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecListGrp::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecListGrp::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* SecListGrp::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecListGrp::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_text = 2;
inline bool SecListGrp::has_encoded_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecListGrp::set_has_encoded_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecListGrp::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecListGrp::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& SecListGrp::encoded_text() const {
  return *encoded_text_;
}
inline void SecListGrp::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecListGrp::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecListGrp::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecListGrp::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* SecListGrp::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecListGrp::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 3;
inline bool SecListGrp::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecListGrp::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecListGrp::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecListGrp::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 SecListGrp::encoded_text_len() const {
  return encoded_text_len_;
}
inline void SecListGrp::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional .Common.FinancingDetails financing_details = 4;
inline bool SecListGrp::has_financing_details() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecListGrp::set_has_financing_details() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecListGrp::clear_has_financing_details() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecListGrp::clear_financing_details() {
  if (financing_details_ != NULL) financing_details_->::Common::FinancingDetails::Clear();
  clear_has_financing_details();
}
inline const ::Common::FinancingDetails& SecListGrp::financing_details() const {
  return financing_details_ != NULL ? *financing_details_ : *default_instance_->financing_details_;
}
inline ::Common::FinancingDetails* SecListGrp::mutable_financing_details() {
  set_has_financing_details();
  if (financing_details_ == NULL) financing_details_ = new ::Common::FinancingDetails;
  return financing_details_;
}
inline ::Common::FinancingDetails* SecListGrp::release_financing_details() {
  clear_has_financing_details();
  ::Common::FinancingDetails* temp = financing_details_;
  financing_details_ = NULL;
  return temp;
}
inline void SecListGrp::set_allocated_financing_details(::Common::FinancingDetails* financing_details) {
  delete financing_details_;
  financing_details_ = financing_details;
  if (financing_details) {
    set_has_financing_details();
  } else {
    clear_has_financing_details();
  }
}

// repeated .Common.InstrmtLegSecListGrp instrmt_leg_sec_list_grp = 5;
inline int SecListGrp::instrmt_leg_sec_list_grp_size() const {
  return instrmt_leg_sec_list_grp_.size();
}
inline void SecListGrp::clear_instrmt_leg_sec_list_grp() {
  instrmt_leg_sec_list_grp_.Clear();
}
inline const ::Common::InstrmtLegSecListGrp& SecListGrp::instrmt_leg_sec_list_grp(int index) const {
  return instrmt_leg_sec_list_grp_.Get(index);
}
inline ::Common::InstrmtLegSecListGrp* SecListGrp::mutable_instrmt_leg_sec_list_grp(int index) {
  return instrmt_leg_sec_list_grp_.Mutable(index);
}
inline ::Common::InstrmtLegSecListGrp* SecListGrp::add_instrmt_leg_sec_list_grp() {
  return instrmt_leg_sec_list_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegSecListGrp >&
SecListGrp::instrmt_leg_sec_list_grp() const {
  return instrmt_leg_sec_list_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegSecListGrp >*
SecListGrp::mutable_instrmt_leg_sec_list_grp() {
  return &instrmt_leg_sec_list_grp_;
}

// optional .Common.Instrument instrument = 6;
inline bool SecListGrp::has_instrument() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecListGrp::set_has_instrument() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecListGrp::clear_has_instrument() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecListGrp::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& SecListGrp::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* SecListGrp::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* SecListGrp::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void SecListGrp::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional .Common.InstrumentExtension instrument_extension = 7;
inline bool SecListGrp::has_instrument_extension() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecListGrp::set_has_instrument_extension() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecListGrp::clear_has_instrument_extension() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecListGrp::clear_instrument_extension() {
  if (instrument_extension_ != NULL) instrument_extension_->::Common::InstrumentExtension::Clear();
  clear_has_instrument_extension();
}
inline const ::Common::InstrumentExtension& SecListGrp::instrument_extension() const {
  return instrument_extension_ != NULL ? *instrument_extension_ : *default_instance_->instrument_extension_;
}
inline ::Common::InstrumentExtension* SecListGrp::mutable_instrument_extension() {
  set_has_instrument_extension();
  if (instrument_extension_ == NULL) instrument_extension_ = new ::Common::InstrumentExtension;
  return instrument_extension_;
}
inline ::Common::InstrumentExtension* SecListGrp::release_instrument_extension() {
  clear_has_instrument_extension();
  ::Common::InstrumentExtension* temp = instrument_extension_;
  instrument_extension_ = NULL;
  return temp;
}
inline void SecListGrp::set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension) {
  delete instrument_extension_;
  instrument_extension_ = instrument_extension;
  if (instrument_extension) {
    set_has_instrument_extension();
  } else {
    clear_has_instrument_extension();
  }
}

// optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 8;
inline bool SecListGrp::has_spread_or_benchmark_curve_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecListGrp::set_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecListGrp::clear_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecListGrp::clear_spread_or_benchmark_curve_data() {
  if (spread_or_benchmark_curve_data_ != NULL) spread_or_benchmark_curve_data_->::Common::SpreadOrBenchmarkCurveData::Clear();
  clear_has_spread_or_benchmark_curve_data();
}
inline const ::Common::SpreadOrBenchmarkCurveData& SecListGrp::spread_or_benchmark_curve_data() const {
  return spread_or_benchmark_curve_data_ != NULL ? *spread_or_benchmark_curve_data_ : *default_instance_->spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecListGrp::mutable_spread_or_benchmark_curve_data() {
  set_has_spread_or_benchmark_curve_data();
  if (spread_or_benchmark_curve_data_ == NULL) spread_or_benchmark_curve_data_ = new ::Common::SpreadOrBenchmarkCurveData;
  return spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecListGrp::release_spread_or_benchmark_curve_data() {
  clear_has_spread_or_benchmark_curve_data();
  ::Common::SpreadOrBenchmarkCurveData* temp = spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = NULL;
  return temp;
}
inline void SecListGrp::set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data) {
  delete spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = spread_or_benchmark_curve_data;
  if (spread_or_benchmark_curve_data) {
    set_has_spread_or_benchmark_curve_data();
  } else {
    clear_has_spread_or_benchmark_curve_data();
  }
}

// repeated .Common.Stipulations stipulations = 9;
inline int SecListGrp::stipulations_size() const {
  return stipulations_.size();
}
inline void SecListGrp::clear_stipulations() {
  stipulations_.Clear();
}
inline const ::Common::Stipulations& SecListGrp::stipulations(int index) const {
  return stipulations_.Get(index);
}
inline ::Common::Stipulations* SecListGrp::mutable_stipulations(int index) {
  return stipulations_.Mutable(index);
}
inline ::Common::Stipulations* SecListGrp::add_stipulations() {
  return stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
SecListGrp::stipulations() const {
  return stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
SecListGrp::mutable_stipulations() {
  return &stipulations_;
}

// optional string text = 10;
inline bool SecListGrp::has_text() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecListGrp::set_has_text() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecListGrp::clear_has_text() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecListGrp::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SecListGrp::text() const {
  return *text_;
}
inline void SecListGrp::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecListGrp::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecListGrp::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecListGrp::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SecListGrp::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecListGrp::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 11;
inline int SecListGrp::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void SecListGrp::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& SecListGrp::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* SecListGrp::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* SecListGrp::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
SecListGrp::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
SecListGrp::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// optional .Common.YieldData yield_data = 12;
inline bool SecListGrp::has_yield_data() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SecListGrp::set_has_yield_data() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SecListGrp::clear_has_yield_data() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SecListGrp::clear_yield_data() {
  if (yield_data_ != NULL) yield_data_->::Common::YieldData::Clear();
  clear_has_yield_data();
}
inline const ::Common::YieldData& SecListGrp::yield_data() const {
  return yield_data_ != NULL ? *yield_data_ : *default_instance_->yield_data_;
}
inline ::Common::YieldData* SecListGrp::mutable_yield_data() {
  set_has_yield_data();
  if (yield_data_ == NULL) yield_data_ = new ::Common::YieldData;
  return yield_data_;
}
inline ::Common::YieldData* SecListGrp::release_yield_data() {
  clear_has_yield_data();
  ::Common::YieldData* temp = yield_data_;
  yield_data_ = NULL;
  return temp;
}
inline void SecListGrp::set_allocated_yield_data(::Common::YieldData* yield_data) {
  delete yield_data_;
  yield_data_ = yield_data;
  if (yield_data) {
    set_has_yield_data();
  } else {
    clear_has_yield_data();
  }
}

// optional .Common.SecurityTradingRules security_trading_rules = 13;
inline bool SecListGrp::has_security_trading_rules() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecListGrp::set_has_security_trading_rules() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecListGrp::clear_has_security_trading_rules() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecListGrp::clear_security_trading_rules() {
  if (security_trading_rules_ != NULL) security_trading_rules_->::Common::SecurityTradingRules::Clear();
  clear_has_security_trading_rules();
}
inline const ::Common::SecurityTradingRules& SecListGrp::security_trading_rules() const {
  return security_trading_rules_ != NULL ? *security_trading_rules_ : *default_instance_->security_trading_rules_;
}
inline ::Common::SecurityTradingRules* SecListGrp::mutable_security_trading_rules() {
  set_has_security_trading_rules();
  if (security_trading_rules_ == NULL) security_trading_rules_ = new ::Common::SecurityTradingRules;
  return security_trading_rules_;
}
inline ::Common::SecurityTradingRules* SecListGrp::release_security_trading_rules() {
  clear_has_security_trading_rules();
  ::Common::SecurityTradingRules* temp = security_trading_rules_;
  security_trading_rules_ = NULL;
  return temp;
}
inline void SecListGrp::set_allocated_security_trading_rules(::Common::SecurityTradingRules* security_trading_rules) {
  delete security_trading_rules_;
  security_trading_rules_ = security_trading_rules;
  if (security_trading_rules) {
    set_has_security_trading_rules();
  } else {
    clear_has_security_trading_rules();
  }
}

// repeated .Common.StrikeRules strike_rules = 14;
inline int SecListGrp::strike_rules_size() const {
  return strike_rules_.size();
}
inline void SecListGrp::clear_strike_rules() {
  strike_rules_.Clear();
}
inline const ::Common::StrikeRules& SecListGrp::strike_rules(int index) const {
  return strike_rules_.Get(index);
}
inline ::Common::StrikeRules* SecListGrp::mutable_strike_rules(int index) {
  return strike_rules_.Mutable(index);
}
inline ::Common::StrikeRules* SecListGrp::add_strike_rules() {
  return strike_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >&
SecListGrp::strike_rules() const {
  return strike_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >*
SecListGrp::mutable_strike_rules() {
  return &strike_rules_;
}

// optional sfixed64 rel_sym_transact_time = 15;
inline bool SecListGrp::has_rel_sym_transact_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SecListGrp::set_has_rel_sym_transact_time() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SecListGrp::clear_has_rel_sym_transact_time() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SecListGrp::clear_rel_sym_transact_time() {
  rel_sym_transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_rel_sym_transact_time();
}
inline ::google::protobuf::int64 SecListGrp::rel_sym_transact_time() const {
  return rel_sym_transact_time_;
}
inline void SecListGrp::set_rel_sym_transact_time(::google::protobuf::int64 value) {
  set_has_rel_sym_transact_time();
  rel_sym_transact_time_ = value;
}

// -------------------------------------------------------------------

// SecurityListTypeUnion

// optional .SecuritiesReferenceData.SecurityListTypeEnum security_list_type = 1;
inline bool SecurityListTypeUnion::has_security_list_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityListTypeUnion::set_has_security_list_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityListTypeUnion::clear_has_security_list_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityListTypeUnion::clear_security_list_type() {
  security_list_type_ = 0;
  clear_has_security_list_type();
}
inline ::SecuritiesReferenceData::SecurityListTypeEnum SecurityListTypeUnion::security_list_type() const {
  return static_cast< ::SecuritiesReferenceData::SecurityListTypeEnum >(security_list_type_);
}
inline void SecurityListTypeUnion::set_security_list_type(::SecuritiesReferenceData::SecurityListTypeEnum value) {
  assert(::SecuritiesReferenceData::SecurityListTypeEnum_IsValid(value));
  set_has_security_list_type();
  security_list_type_ = value;
}

// optional sfixed64 security_list_type_sfixed64 = 2;
inline bool SecurityListTypeUnion::has_security_list_type_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityListTypeUnion::set_has_security_list_type_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityListTypeUnion::clear_has_security_list_type_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityListTypeUnion::clear_security_list_type_sfixed64() {
  security_list_type_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_security_list_type_sfixed64();
}
inline ::google::protobuf::int64 SecurityListTypeUnion::security_list_type_sfixed64() const {
  return security_list_type_sfixed64_;
}
inline void SecurityListTypeUnion::set_security_list_type_sfixed64(::google::protobuf::int64 value) {
  set_has_security_list_type_sfixed64();
  security_list_type_sfixed64_ = value;
}

// -------------------------------------------------------------------

// SecurityListTypeSourceUnion

// optional .SecuritiesReferenceData.SecurityListTypeSourceEnum security_list_type_source = 1;
inline bool SecurityListTypeSourceUnion::has_security_list_type_source() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityListTypeSourceUnion::set_has_security_list_type_source() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityListTypeSourceUnion::clear_has_security_list_type_source() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityListTypeSourceUnion::clear_security_list_type_source() {
  security_list_type_source_ = 0;
  clear_has_security_list_type_source();
}
inline ::SecuritiesReferenceData::SecurityListTypeSourceEnum SecurityListTypeSourceUnion::security_list_type_source() const {
  return static_cast< ::SecuritiesReferenceData::SecurityListTypeSourceEnum >(security_list_type_source_);
}
inline void SecurityListTypeSourceUnion::set_security_list_type_source(::SecuritiesReferenceData::SecurityListTypeSourceEnum value) {
  assert(::SecuritiesReferenceData::SecurityListTypeSourceEnum_IsValid(value));
  set_has_security_list_type_source();
  security_list_type_source_ = value;
}

// optional sfixed64 security_list_type_source_sfixed64 = 2;
inline bool SecurityListTypeSourceUnion::has_security_list_type_source_sfixed64() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityListTypeSourceUnion::set_has_security_list_type_source_sfixed64() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityListTypeSourceUnion::clear_has_security_list_type_source_sfixed64() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityListTypeSourceUnion::clear_security_list_type_source_sfixed64() {
  security_list_type_source_sfixed64_ = GOOGLE_LONGLONG(0);
  clear_has_security_list_type_source_sfixed64();
}
inline ::google::protobuf::int64 SecurityListTypeSourceUnion::security_list_type_source_sfixed64() const {
  return security_list_type_source_sfixed64_;
}
inline void SecurityListTypeSourceUnion::set_security_list_type_source_sfixed64(::google::protobuf::int64 value) {
  set_has_security_list_type_source_sfixed64();
  security_list_type_source_sfixed64_ = value;
}

// -------------------------------------------------------------------

// SecurityList

// optional string security_req_id = 1;
inline bool SecurityList::has_security_req_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityList::set_has_security_req_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityList::clear_has_security_req_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityList::clear_security_req_id() {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    security_req_id_->clear();
  }
  clear_has_security_req_id();
}
inline const ::std::string& SecurityList::security_req_id() const {
  return *security_req_id_;
}
inline void SecurityList::set_security_req_id(const ::std::string& value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityList::set_security_req_id(const char* value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityList::set_security_req_id(const char* value, size_t size) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityList::mutable_security_req_id() {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  return security_req_id_;
}
inline ::std::string* SecurityList::release_security_req_id() {
  clear_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_req_id_;
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityList::set_allocated_security_req_id(::std::string* security_req_id) {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_req_id_;
  }
  if (security_req_id) {
    set_has_security_req_id();
    security_req_id_ = security_req_id;
  } else {
    clear_has_security_req_id();
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.SecurityRequestResultEnum security_request_result = 2;
inline bool SecurityList::has_security_request_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityList::set_has_security_request_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityList::clear_has_security_request_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityList::clear_security_request_result() {
  security_request_result_ = 0;
  clear_has_security_request_result();
}
inline ::SecuritiesReferenceData::SecurityRequestResultEnum SecurityList::security_request_result() const {
  return static_cast< ::SecuritiesReferenceData::SecurityRequestResultEnum >(security_request_result_);
}
inline void SecurityList::set_security_request_result(::SecuritiesReferenceData::SecurityRequestResultEnum value) {
  assert(::SecuritiesReferenceData::SecurityRequestResultEnum_IsValid(value));
  set_has_security_request_result();
  security_request_result_ = value;
}

// optional string security_response_id = 3;
inline bool SecurityList::has_security_response_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityList::set_has_security_response_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityList::clear_has_security_response_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityList::clear_security_response_id() {
  if (security_response_id_ != &::google::protobuf::internal::kEmptyString) {
    security_response_id_->clear();
  }
  clear_has_security_response_id();
}
inline const ::std::string& SecurityList::security_response_id() const {
  return *security_response_id_;
}
inline void SecurityList::set_security_response_id(const ::std::string& value) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(value);
}
inline void SecurityList::set_security_response_id(const char* value) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(value);
}
inline void SecurityList::set_security_response_id(const char* value, size_t size) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityList::mutable_security_response_id() {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  return security_response_id_;
}
inline ::std::string* SecurityList::release_security_response_id() {
  clear_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_response_id_;
    security_response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityList::set_allocated_security_response_id(::std::string* security_response_id) {
  if (security_response_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_response_id_;
  }
  if (security_response_id) {
    set_has_security_response_id();
    security_response_id_ = security_response_id;
  } else {
    clear_has_security_response_id();
    security_response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Session.StandardHeader standard_header = 4;
inline bool SecurityList::has_standard_header() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecurityList::set_has_standard_header() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecurityList::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecurityList::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& SecurityList::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* SecurityList::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* SecurityList::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void SecurityList::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 5;
inline bool SecurityList::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecurityList::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecurityList::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecurityList::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& SecurityList::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityList::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityList::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void SecurityList::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional sfixed64 tot_no_related_sym = 6;
inline bool SecurityList::has_tot_no_related_sym() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecurityList::set_has_tot_no_related_sym() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecurityList::clear_has_tot_no_related_sym() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecurityList::clear_tot_no_related_sym() {
  tot_no_related_sym_ = GOOGLE_LONGLONG(0);
  clear_has_tot_no_related_sym();
}
inline ::google::protobuf::int64 SecurityList::tot_no_related_sym() const {
  return tot_no_related_sym_;
}
inline void SecurityList::set_tot_no_related_sym(::google::protobuf::int64 value) {
  set_has_tot_no_related_sym();
  tot_no_related_sym_ = value;
}

// optional sfixed32 clearing_business_date = 7;
inline bool SecurityList::has_clearing_business_date() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecurityList::set_has_clearing_business_date() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecurityList::clear_has_clearing_business_date() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecurityList::clear_clearing_business_date() {
  clearing_business_date_ = 0;
  clear_has_clearing_business_date();
}
inline ::google::protobuf::int32 SecurityList::clearing_business_date() const {
  return clearing_business_date_;
}
inline void SecurityList::set_clearing_business_date(::google::protobuf::int32 value) {
  set_has_clearing_business_date();
  clearing_business_date_ = value;
}

// optional bool last_fragment = 8;
inline bool SecurityList::has_last_fragment() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecurityList::set_has_last_fragment() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecurityList::clear_has_last_fragment() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecurityList::clear_last_fragment() {
  last_fragment_ = false;
  clear_has_last_fragment();
}
inline bool SecurityList::last_fragment() const {
  return last_fragment_;
}
inline void SecurityList::set_last_fragment(bool value) {
  set_has_last_fragment();
  last_fragment_ = value;
}

// repeated .SecuritiesReferenceData.SecListGrp sec_list_grp = 9;
inline int SecurityList::sec_list_grp_size() const {
  return sec_list_grp_.size();
}
inline void SecurityList::clear_sec_list_grp() {
  sec_list_grp_.Clear();
}
inline const ::SecuritiesReferenceData::SecListGrp& SecurityList::sec_list_grp(int index) const {
  return sec_list_grp_.Get(index);
}
inline ::SecuritiesReferenceData::SecListGrp* SecurityList::mutable_sec_list_grp(int index) {
  return sec_list_grp_.Mutable(index);
}
inline ::SecuritiesReferenceData::SecListGrp* SecurityList::add_sec_list_grp() {
  return sec_list_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecListGrp >&
SecurityList::sec_list_grp() const {
  return sec_list_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecListGrp >*
SecurityList::mutable_sec_list_grp() {
  return &sec_list_grp_;
}

// optional sfixed64 security_report_id = 10;
inline bool SecurityList::has_security_report_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecurityList::set_has_security_report_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecurityList::clear_has_security_report_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecurityList::clear_security_report_id() {
  security_report_id_ = GOOGLE_LONGLONG(0);
  clear_has_security_report_id();
}
inline ::google::protobuf::int64 SecurityList::security_report_id() const {
  return security_report_id_;
}
inline void SecurityList::set_security_report_id(::google::protobuf::int64 value) {
  set_has_security_report_id();
  security_report_id_ = value;
}

// optional .Common.ApplicationSequenceControl application_sequence_control = 11;
inline bool SecurityList::has_application_sequence_control() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SecurityList::set_has_application_sequence_control() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SecurityList::clear_has_application_sequence_control() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SecurityList::clear_application_sequence_control() {
  if (application_sequence_control_ != NULL) application_sequence_control_->::Common::ApplicationSequenceControl::Clear();
  clear_has_application_sequence_control();
}
inline const ::Common::ApplicationSequenceControl& SecurityList::application_sequence_control() const {
  return application_sequence_control_ != NULL ? *application_sequence_control_ : *default_instance_->application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* SecurityList::mutable_application_sequence_control() {
  set_has_application_sequence_control();
  if (application_sequence_control_ == NULL) application_sequence_control_ = new ::Common::ApplicationSequenceControl;
  return application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* SecurityList::release_application_sequence_control() {
  clear_has_application_sequence_control();
  ::Common::ApplicationSequenceControl* temp = application_sequence_control_;
  application_sequence_control_ = NULL;
  return temp;
}
inline void SecurityList::set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control) {
  delete application_sequence_control_;
  application_sequence_control_ = application_sequence_control;
  if (application_sequence_control) {
    set_has_application_sequence_control();
  } else {
    clear_has_application_sequence_control();
  }
}

// optional string market_id = 12;
inline bool SecurityList::has_market_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SecurityList::set_has_market_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SecurityList::clear_has_market_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SecurityList::clear_market_id() {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    market_id_->clear();
  }
  clear_has_market_id();
}
inline const ::std::string& SecurityList::market_id() const {
  return *market_id_;
}
inline void SecurityList::set_market_id(const ::std::string& value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void SecurityList::set_market_id(const char* value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void SecurityList::set_market_id(const char* value, size_t size) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityList::mutable_market_id() {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  return market_id_;
}
inline ::std::string* SecurityList::release_market_id() {
  clear_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_id_;
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityList::set_allocated_market_id(::std::string* market_id) {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_id_;
  }
  if (market_id) {
    set_has_market_id();
    market_id_ = market_id;
  } else {
    clear_has_market_id();
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string market_segment_id = 13;
inline bool SecurityList::has_market_segment_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecurityList::set_has_market_segment_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecurityList::clear_has_market_segment_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecurityList::clear_market_segment_id() {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    market_segment_id_->clear();
  }
  clear_has_market_segment_id();
}
inline const ::std::string& SecurityList::market_segment_id() const {
  return *market_segment_id_;
}
inline void SecurityList::set_market_segment_id(const ::std::string& value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void SecurityList::set_market_segment_id(const char* value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void SecurityList::set_market_segment_id(const char* value, size_t size) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityList::mutable_market_segment_id() {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  return market_segment_id_;
}
inline ::std::string* SecurityList::release_market_segment_id() {
  clear_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_segment_id_;
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityList::set_allocated_market_segment_id(::std::string* market_segment_id) {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_segment_id_;
  }
  if (market_segment_id) {
    set_has_market_segment_id();
    market_segment_id_ = market_segment_id;
  } else {
    clear_has_market_segment_id();
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_security_list_desc = 14;
inline bool SecurityList::has_encoded_security_list_desc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SecurityList::set_has_encoded_security_list_desc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SecurityList::clear_has_encoded_security_list_desc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SecurityList::clear_encoded_security_list_desc() {
  if (encoded_security_list_desc_ != &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_->clear();
  }
  clear_has_encoded_security_list_desc();
}
inline const ::std::string& SecurityList::encoded_security_list_desc() const {
  return *encoded_security_list_desc_;
}
inline void SecurityList::set_encoded_security_list_desc(const ::std::string& value) {
  set_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_ = new ::std::string;
  }
  encoded_security_list_desc_->assign(value);
}
inline void SecurityList::set_encoded_security_list_desc(const char* value) {
  set_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_ = new ::std::string;
  }
  encoded_security_list_desc_->assign(value);
}
inline void SecurityList::set_encoded_security_list_desc(const void* value, size_t size) {
  set_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_ = new ::std::string;
  }
  encoded_security_list_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityList::mutable_encoded_security_list_desc() {
  set_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_ = new ::std::string;
  }
  return encoded_security_list_desc_;
}
inline ::std::string* SecurityList::release_encoded_security_list_desc() {
  clear_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_security_list_desc_;
    encoded_security_list_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityList::set_allocated_encoded_security_list_desc(::std::string* encoded_security_list_desc) {
  if (encoded_security_list_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_security_list_desc_;
  }
  if (encoded_security_list_desc) {
    set_has_encoded_security_list_desc();
    encoded_security_list_desc_ = encoded_security_list_desc;
  } else {
    clear_has_encoded_security_list_desc();
    encoded_security_list_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_security_list_desc_len = 15;
inline bool SecurityList::has_encoded_security_list_desc_len() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SecurityList::set_has_encoded_security_list_desc_len() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SecurityList::clear_has_encoded_security_list_desc_len() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SecurityList::clear_encoded_security_list_desc_len() {
  encoded_security_list_desc_len_ = 0u;
  clear_has_encoded_security_list_desc_len();
}
inline ::google::protobuf::uint32 SecurityList::encoded_security_list_desc_len() const {
  return encoded_security_list_desc_len_;
}
inline void SecurityList::set_encoded_security_list_desc_len(::google::protobuf::uint32 value) {
  set_has_encoded_security_list_desc_len();
  encoded_security_list_desc_len_ = value;
}

// optional string security_list_desc = 16;
inline bool SecurityList::has_security_list_desc() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SecurityList::set_has_security_list_desc() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SecurityList::clear_has_security_list_desc() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SecurityList::clear_security_list_desc() {
  if (security_list_desc_ != &::google::protobuf::internal::kEmptyString) {
    security_list_desc_->clear();
  }
  clear_has_security_list_desc();
}
inline const ::std::string& SecurityList::security_list_desc() const {
  return *security_list_desc_;
}
inline void SecurityList::set_security_list_desc(const ::std::string& value) {
  set_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_list_desc_ = new ::std::string;
  }
  security_list_desc_->assign(value);
}
inline void SecurityList::set_security_list_desc(const char* value) {
  set_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_list_desc_ = new ::std::string;
  }
  security_list_desc_->assign(value);
}
inline void SecurityList::set_security_list_desc(const char* value, size_t size) {
  set_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_list_desc_ = new ::std::string;
  }
  security_list_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityList::mutable_security_list_desc() {
  set_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_list_desc_ = new ::std::string;
  }
  return security_list_desc_;
}
inline ::std::string* SecurityList::release_security_list_desc() {
  clear_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_list_desc_;
    security_list_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityList::set_allocated_security_list_desc(::std::string* security_list_desc) {
  if (security_list_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete security_list_desc_;
  }
  if (security_list_desc) {
    set_has_security_list_desc();
    security_list_desc_ = security_list_desc;
  } else {
    clear_has_security_list_desc();
    security_list_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_list_id = 17;
inline bool SecurityList::has_security_list_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SecurityList::set_has_security_list_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SecurityList::clear_has_security_list_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SecurityList::clear_security_list_id() {
  if (security_list_id_ != &::google::protobuf::internal::kEmptyString) {
    security_list_id_->clear();
  }
  clear_has_security_list_id();
}
inline const ::std::string& SecurityList::security_list_id() const {
  return *security_list_id_;
}
inline void SecurityList::set_security_list_id(const ::std::string& value) {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  security_list_id_->assign(value);
}
inline void SecurityList::set_security_list_id(const char* value) {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  security_list_id_->assign(value);
}
inline void SecurityList::set_security_list_id(const char* value, size_t size) {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  security_list_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityList::mutable_security_list_id() {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  return security_list_id_;
}
inline ::std::string* SecurityList::release_security_list_id() {
  clear_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_list_id_;
    security_list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityList::set_allocated_security_list_id(::std::string* security_list_id) {
  if (security_list_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_list_id_;
  }
  if (security_list_id) {
    set_has_security_list_id();
    security_list_id_ = security_list_id;
  } else {
    clear_has_security_list_id();
    security_list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_list_ref_id = 18;
inline bool SecurityList::has_security_list_ref_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SecurityList::set_has_security_list_ref_id() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SecurityList::clear_has_security_list_ref_id() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SecurityList::clear_security_list_ref_id() {
  if (security_list_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_->clear();
  }
  clear_has_security_list_ref_id();
}
inline const ::std::string& SecurityList::security_list_ref_id() const {
  return *security_list_ref_id_;
}
inline void SecurityList::set_security_list_ref_id(const ::std::string& value) {
  set_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_ = new ::std::string;
  }
  security_list_ref_id_->assign(value);
}
inline void SecurityList::set_security_list_ref_id(const char* value) {
  set_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_ = new ::std::string;
  }
  security_list_ref_id_->assign(value);
}
inline void SecurityList::set_security_list_ref_id(const char* value, size_t size) {
  set_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_ = new ::std::string;
  }
  security_list_ref_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityList::mutable_security_list_ref_id() {
  set_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_ = new ::std::string;
  }
  return security_list_ref_id_;
}
inline ::std::string* SecurityList::release_security_list_ref_id() {
  clear_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_list_ref_id_;
    security_list_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityList::set_allocated_security_list_ref_id(::std::string* security_list_ref_id) {
  if (security_list_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_list_ref_id_;
  }
  if (security_list_ref_id) {
    set_has_security_list_ref_id();
    security_list_ref_id_ = security_list_ref_id;
  } else {
    clear_has_security_list_ref_id();
    security_list_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.SecurityListTypeEnum security_list_type = 19;
inline bool SecurityList::has_security_list_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SecurityList::set_has_security_list_type() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SecurityList::clear_has_security_list_type() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SecurityList::clear_security_list_type() {
  security_list_type_ = 0;
  clear_has_security_list_type();
}
inline ::SecuritiesReferenceData::SecurityListTypeEnum SecurityList::security_list_type() const {
  return static_cast< ::SecuritiesReferenceData::SecurityListTypeEnum >(security_list_type_);
}
inline void SecurityList::set_security_list_type(::SecuritiesReferenceData::SecurityListTypeEnum value) {
  assert(::SecuritiesReferenceData::SecurityListTypeEnum_IsValid(value));
  set_has_security_list_type();
  security_list_type_ = value;
}

// optional .SecuritiesReferenceData.SecurityListTypeSourceEnum security_list_type_source = 20;
inline bool SecurityList::has_security_list_type_source() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SecurityList::set_has_security_list_type_source() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SecurityList::clear_has_security_list_type_source() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SecurityList::clear_security_list_type_source() {
  security_list_type_source_ = 0;
  clear_has_security_list_type_source();
}
inline ::SecuritiesReferenceData::SecurityListTypeSourceEnum SecurityList::security_list_type_source() const {
  return static_cast< ::SecuritiesReferenceData::SecurityListTypeSourceEnum >(security_list_type_source_);
}
inline void SecurityList::set_security_list_type_source(::SecuritiesReferenceData::SecurityListTypeSourceEnum value) {
  assert(::SecuritiesReferenceData::SecurityListTypeSourceEnum_IsValid(value));
  set_has_security_list_type_source();
  security_list_type_source_ = value;
}

// optional sfixed64 transact_time = 21;
inline bool SecurityList::has_transact_time() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SecurityList::set_has_transact_time() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SecurityList::clear_has_transact_time() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SecurityList::clear_transact_time() {
  transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_transact_time();
}
inline ::google::protobuf::int64 SecurityList::transact_time() const {
  return transact_time_;
}
inline void SecurityList::set_transact_time(::google::protobuf::int64 value) {
  set_has_transact_time();
  transact_time_ = value;
}

// -------------------------------------------------------------------

// SecurityListRequest

// optional string currency = 1;
inline bool SecurityListRequest::has_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityListRequest::set_has_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityListRequest::clear_has_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityListRequest::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& SecurityListRequest::currency() const {
  return *currency_;
}
inline void SecurityListRequest::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecurityListRequest::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecurityListRequest::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListRequest::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* SecurityListRequest::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListRequest::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_text = 2;
inline bool SecurityListRequest::has_encoded_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecurityListRequest::set_has_encoded_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecurityListRequest::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecurityListRequest::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& SecurityListRequest::encoded_text() const {
  return *encoded_text_;
}
inline void SecurityListRequest::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecurityListRequest::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecurityListRequest::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListRequest::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* SecurityListRequest::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListRequest::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 3;
inline bool SecurityListRequest::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityListRequest::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityListRequest::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityListRequest::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 SecurityListRequest::encoded_text_len() const {
  return encoded_text_len_;
}
inline void SecurityListRequest::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional .Common.Instrument instrument = 4;
inline bool SecurityListRequest::has_instrument() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecurityListRequest::set_has_instrument() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecurityListRequest::clear_has_instrument() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecurityListRequest::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& SecurityListRequest::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* SecurityListRequest::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* SecurityListRequest::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void SecurityListRequest::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional .SecuritiesReferenceData.SecurityListRequestTypeEnum security_list_request_type = 5;
inline bool SecurityListRequest::has_security_list_request_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecurityListRequest::set_has_security_list_request_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecurityListRequest::clear_has_security_list_request_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecurityListRequest::clear_security_list_request_type() {
  security_list_request_type_ = 0;
  clear_has_security_list_request_type();
}
inline ::SecuritiesReferenceData::SecurityListRequestTypeEnum SecurityListRequest::security_list_request_type() const {
  return static_cast< ::SecuritiesReferenceData::SecurityListRequestTypeEnum >(security_list_request_type_);
}
inline void SecurityListRequest::set_security_list_request_type(::SecuritiesReferenceData::SecurityListRequestTypeEnum value) {
  assert(::SecuritiesReferenceData::SecurityListRequestTypeEnum_IsValid(value));
  set_has_security_list_request_type();
  security_list_request_type_ = value;
}

// optional string security_req_id = 6;
inline bool SecurityListRequest::has_security_req_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecurityListRequest::set_has_security_req_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecurityListRequest::clear_has_security_req_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecurityListRequest::clear_security_req_id() {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    security_req_id_->clear();
  }
  clear_has_security_req_id();
}
inline const ::std::string& SecurityListRequest::security_req_id() const {
  return *security_req_id_;
}
inline void SecurityListRequest::set_security_req_id(const ::std::string& value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityListRequest::set_security_req_id(const char* value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityListRequest::set_security_req_id(const char* value, size_t size) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListRequest::mutable_security_req_id() {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  return security_req_id_;
}
inline ::std::string* SecurityListRequest::release_security_req_id() {
  clear_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_req_id_;
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListRequest::set_allocated_security_req_id(::std::string* security_req_id) {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_req_id_;
  }
  if (security_req_id) {
    set_has_security_req_id();
    security_req_id_ = security_req_id;
  } else {
    clear_has_security_req_id();
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Session.StandardHeader standard_header = 7;
inline bool SecurityListRequest::has_standard_header() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecurityListRequest::set_has_standard_header() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecurityListRequest::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecurityListRequest::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& SecurityListRequest::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* SecurityListRequest::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* SecurityListRequest::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void SecurityListRequest::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 8;
inline bool SecurityListRequest::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecurityListRequest::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecurityListRequest::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecurityListRequest::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& SecurityListRequest::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityListRequest::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityListRequest::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void SecurityListRequest::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional .SecuritiesReferenceData.SubscriptionRequestTypeEnum subscription_request_type = 9;
inline bool SecurityListRequest::has_subscription_request_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SecurityListRequest::set_has_subscription_request_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SecurityListRequest::clear_has_subscription_request_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SecurityListRequest::clear_subscription_request_type() {
  subscription_request_type_ = 0;
  clear_has_subscription_request_type();
}
inline ::SecuritiesReferenceData::SubscriptionRequestTypeEnum SecurityListRequest::subscription_request_type() const {
  return static_cast< ::SecuritiesReferenceData::SubscriptionRequestTypeEnum >(subscription_request_type_);
}
inline void SecurityListRequest::set_subscription_request_type(::SecuritiesReferenceData::SubscriptionRequestTypeEnum value) {
  assert(::SecuritiesReferenceData::SubscriptionRequestTypeEnum_IsValid(value));
  set_has_subscription_request_type();
  subscription_request_type_ = value;
}

// optional string text = 10;
inline bool SecurityListRequest::has_text() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecurityListRequest::set_has_text() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecurityListRequest::clear_has_text() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecurityListRequest::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SecurityListRequest::text() const {
  return *text_;
}
inline void SecurityListRequest::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecurityListRequest::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecurityListRequest::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListRequest::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SecurityListRequest::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListRequest::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.TradingSessionIdEnum trading_session_id = 11;
inline bool SecurityListRequest::has_trading_session_id() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SecurityListRequest::set_has_trading_session_id() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SecurityListRequest::clear_has_trading_session_id() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SecurityListRequest::clear_trading_session_id() {
  trading_session_id_ = 0;
  clear_has_trading_session_id();
}
inline ::SecuritiesReferenceData::TradingSessionIdEnum SecurityListRequest::trading_session_id() const {
  return static_cast< ::SecuritiesReferenceData::TradingSessionIdEnum >(trading_session_id_);
}
inline void SecurityListRequest::set_trading_session_id(::SecuritiesReferenceData::TradingSessionIdEnum value) {
  assert(::SecuritiesReferenceData::TradingSessionIdEnum_IsValid(value));
  set_has_trading_session_id();
  trading_session_id_ = value;
}

// optional .SecuritiesReferenceData.TradingSessionSubIdEnum trading_session_sub_id = 12;
inline bool SecurityListRequest::has_trading_session_sub_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SecurityListRequest::set_has_trading_session_sub_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SecurityListRequest::clear_has_trading_session_sub_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SecurityListRequest::clear_trading_session_sub_id() {
  trading_session_sub_id_ = 0;
  clear_has_trading_session_sub_id();
}
inline ::SecuritiesReferenceData::TradingSessionSubIdEnum SecurityListRequest::trading_session_sub_id() const {
  return static_cast< ::SecuritiesReferenceData::TradingSessionSubIdEnum >(trading_session_sub_id_);
}
inline void SecurityListRequest::set_trading_session_sub_id(::SecuritiesReferenceData::TradingSessionSubIdEnum value) {
  assert(::SecuritiesReferenceData::TradingSessionSubIdEnum_IsValid(value));
  set_has_trading_session_sub_id();
  trading_session_sub_id_ = value;
}

// optional .Common.FinancingDetails financing_details = 13;
inline bool SecurityListRequest::has_financing_details() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecurityListRequest::set_has_financing_details() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecurityListRequest::clear_has_financing_details() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecurityListRequest::clear_financing_details() {
  if (financing_details_ != NULL) financing_details_->::Common::FinancingDetails::Clear();
  clear_has_financing_details();
}
inline const ::Common::FinancingDetails& SecurityListRequest::financing_details() const {
  return financing_details_ != NULL ? *financing_details_ : *default_instance_->financing_details_;
}
inline ::Common::FinancingDetails* SecurityListRequest::mutable_financing_details() {
  set_has_financing_details();
  if (financing_details_ == NULL) financing_details_ = new ::Common::FinancingDetails;
  return financing_details_;
}
inline ::Common::FinancingDetails* SecurityListRequest::release_financing_details() {
  clear_has_financing_details();
  ::Common::FinancingDetails* temp = financing_details_;
  financing_details_ = NULL;
  return temp;
}
inline void SecurityListRequest::set_allocated_financing_details(::Common::FinancingDetails* financing_details) {
  delete financing_details_;
  financing_details_ = financing_details;
  if (financing_details) {
    set_has_financing_details();
  } else {
    clear_has_financing_details();
  }
}

// repeated .Common.InstrmtLegGrp instrmt_leg_grp = 14;
inline int SecurityListRequest::instrmt_leg_grp_size() const {
  return instrmt_leg_grp_.size();
}
inline void SecurityListRequest::clear_instrmt_leg_grp() {
  instrmt_leg_grp_.Clear();
}
inline const ::Common::InstrmtLegGrp& SecurityListRequest::instrmt_leg_grp(int index) const {
  return instrmt_leg_grp_.Get(index);
}
inline ::Common::InstrmtLegGrp* SecurityListRequest::mutable_instrmt_leg_grp(int index) {
  return instrmt_leg_grp_.Mutable(index);
}
inline ::Common::InstrmtLegGrp* SecurityListRequest::add_instrmt_leg_grp() {
  return instrmt_leg_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >&
SecurityListRequest::instrmt_leg_grp() const {
  return instrmt_leg_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::InstrmtLegGrp >*
SecurityListRequest::mutable_instrmt_leg_grp() {
  return &instrmt_leg_grp_;
}

// optional .Common.InstrumentExtension instrument_extension = 15;
inline bool SecurityListRequest::has_instrument_extension() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SecurityListRequest::set_has_instrument_extension() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SecurityListRequest::clear_has_instrument_extension() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SecurityListRequest::clear_instrument_extension() {
  if (instrument_extension_ != NULL) instrument_extension_->::Common::InstrumentExtension::Clear();
  clear_has_instrument_extension();
}
inline const ::Common::InstrumentExtension& SecurityListRequest::instrument_extension() const {
  return instrument_extension_ != NULL ? *instrument_extension_ : *default_instance_->instrument_extension_;
}
inline ::Common::InstrumentExtension* SecurityListRequest::mutable_instrument_extension() {
  set_has_instrument_extension();
  if (instrument_extension_ == NULL) instrument_extension_ = new ::Common::InstrumentExtension;
  return instrument_extension_;
}
inline ::Common::InstrumentExtension* SecurityListRequest::release_instrument_extension() {
  clear_has_instrument_extension();
  ::Common::InstrumentExtension* temp = instrument_extension_;
  instrument_extension_ = NULL;
  return temp;
}
inline void SecurityListRequest::set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension) {
  delete instrument_extension_;
  instrument_extension_ = instrument_extension;
  if (instrument_extension) {
    set_has_instrument_extension();
  } else {
    clear_has_instrument_extension();
  }
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 16;
inline int SecurityListRequest::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void SecurityListRequest::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& SecurityListRequest::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* SecurityListRequest::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* SecurityListRequest::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
SecurityListRequest::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
SecurityListRequest::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// optional string market_id = 17;
inline bool SecurityListRequest::has_market_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SecurityListRequest::set_has_market_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SecurityListRequest::clear_has_market_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SecurityListRequest::clear_market_id() {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    market_id_->clear();
  }
  clear_has_market_id();
}
inline const ::std::string& SecurityListRequest::market_id() const {
  return *market_id_;
}
inline void SecurityListRequest::set_market_id(const ::std::string& value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void SecurityListRequest::set_market_id(const char* value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void SecurityListRequest::set_market_id(const char* value, size_t size) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListRequest::mutable_market_id() {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  return market_id_;
}
inline ::std::string* SecurityListRequest::release_market_id() {
  clear_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_id_;
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListRequest::set_allocated_market_id(::std::string* market_id) {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_id_;
  }
  if (market_id) {
    set_has_market_id();
    market_id_ = market_id;
  } else {
    clear_has_market_id();
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string market_segment_id = 18;
inline bool SecurityListRequest::has_market_segment_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SecurityListRequest::set_has_market_segment_id() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SecurityListRequest::clear_has_market_segment_id() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SecurityListRequest::clear_market_segment_id() {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    market_segment_id_->clear();
  }
  clear_has_market_segment_id();
}
inline const ::std::string& SecurityListRequest::market_segment_id() const {
  return *market_segment_id_;
}
inline void SecurityListRequest::set_market_segment_id(const ::std::string& value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void SecurityListRequest::set_market_segment_id(const char* value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void SecurityListRequest::set_market_segment_id(const char* value, size_t size) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListRequest::mutable_market_segment_id() {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  return market_segment_id_;
}
inline ::std::string* SecurityListRequest::release_market_segment_id() {
  clear_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_segment_id_;
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListRequest::set_allocated_market_segment_id(::std::string* market_segment_id) {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_segment_id_;
  }
  if (market_segment_id) {
    set_has_market_segment_id();
    market_segment_id_ = market_segment_id;
  } else {
    clear_has_market_segment_id();
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_list_id = 19;
inline bool SecurityListRequest::has_security_list_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SecurityListRequest::set_has_security_list_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SecurityListRequest::clear_has_security_list_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SecurityListRequest::clear_security_list_id() {
  if (security_list_id_ != &::google::protobuf::internal::kEmptyString) {
    security_list_id_->clear();
  }
  clear_has_security_list_id();
}
inline const ::std::string& SecurityListRequest::security_list_id() const {
  return *security_list_id_;
}
inline void SecurityListRequest::set_security_list_id(const ::std::string& value) {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  security_list_id_->assign(value);
}
inline void SecurityListRequest::set_security_list_id(const char* value) {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  security_list_id_->assign(value);
}
inline void SecurityListRequest::set_security_list_id(const char* value, size_t size) {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  security_list_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListRequest::mutable_security_list_id() {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  return security_list_id_;
}
inline ::std::string* SecurityListRequest::release_security_list_id() {
  clear_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_list_id_;
    security_list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListRequest::set_allocated_security_list_id(::std::string* security_list_id) {
  if (security_list_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_list_id_;
  }
  if (security_list_id) {
    set_has_security_list_id();
    security_list_id_ = security_list_id;
  } else {
    clear_has_security_list_id();
    security_list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.SecurityListTypeEnum security_list_type = 20;
inline bool SecurityListRequest::has_security_list_type() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SecurityListRequest::set_has_security_list_type() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SecurityListRequest::clear_has_security_list_type() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SecurityListRequest::clear_security_list_type() {
  security_list_type_ = 0;
  clear_has_security_list_type();
}
inline ::SecuritiesReferenceData::SecurityListTypeEnum SecurityListRequest::security_list_type() const {
  return static_cast< ::SecuritiesReferenceData::SecurityListTypeEnum >(security_list_type_);
}
inline void SecurityListRequest::set_security_list_type(::SecuritiesReferenceData::SecurityListTypeEnum value) {
  assert(::SecuritiesReferenceData::SecurityListTypeEnum_IsValid(value));
  set_has_security_list_type();
  security_list_type_ = value;
}

// optional .SecuritiesReferenceData.SecurityListTypeSourceEnum security_list_type_source = 21;
inline bool SecurityListRequest::has_security_list_type_source() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SecurityListRequest::set_has_security_list_type_source() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SecurityListRequest::clear_has_security_list_type_source() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SecurityListRequest::clear_security_list_type_source() {
  security_list_type_source_ = 0;
  clear_has_security_list_type_source();
}
inline ::SecuritiesReferenceData::SecurityListTypeSourceEnum SecurityListRequest::security_list_type_source() const {
  return static_cast< ::SecuritiesReferenceData::SecurityListTypeSourceEnum >(security_list_type_source_);
}
inline void SecurityListRequest::set_security_list_type_source(::SecuritiesReferenceData::SecurityListTypeSourceEnum value) {
  assert(::SecuritiesReferenceData::SecurityListTypeSourceEnum_IsValid(value));
  set_has_security_list_type_source();
  security_list_type_source_ = value;
}

// -------------------------------------------------------------------

// SecLstUpdRelSymsLegGrp

// optional .Common.InstrumentLeg instrument_leg = 1;
inline bool SecLstUpdRelSymsLegGrp::has_instrument_leg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecLstUpdRelSymsLegGrp::set_has_instrument_leg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecLstUpdRelSymsLegGrp::clear_has_instrument_leg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecLstUpdRelSymsLegGrp::clear_instrument_leg() {
  if (instrument_leg_ != NULL) instrument_leg_->::Common::InstrumentLeg::Clear();
  clear_has_instrument_leg();
}
inline const ::Common::InstrumentLeg& SecLstUpdRelSymsLegGrp::instrument_leg() const {
  return instrument_leg_ != NULL ? *instrument_leg_ : *default_instance_->instrument_leg_;
}
inline ::Common::InstrumentLeg* SecLstUpdRelSymsLegGrp::mutable_instrument_leg() {
  set_has_instrument_leg();
  if (instrument_leg_ == NULL) instrument_leg_ = new ::Common::InstrumentLeg;
  return instrument_leg_;
}
inline ::Common::InstrumentLeg* SecLstUpdRelSymsLegGrp::release_instrument_leg() {
  clear_has_instrument_leg();
  ::Common::InstrumentLeg* temp = instrument_leg_;
  instrument_leg_ = NULL;
  return temp;
}
inline void SecLstUpdRelSymsLegGrp::set_allocated_instrument_leg(::Common::InstrumentLeg* instrument_leg) {
  delete instrument_leg_;
  instrument_leg_ = instrument_leg;
  if (instrument_leg) {
    set_has_instrument_leg();
  } else {
    clear_has_instrument_leg();
  }
}

// optional .Common.LegBenchmarkCurveData leg_benchmark_curve_data = 2;
inline bool SecLstUpdRelSymsLegGrp::has_leg_benchmark_curve_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecLstUpdRelSymsLegGrp::set_has_leg_benchmark_curve_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecLstUpdRelSymsLegGrp::clear_has_leg_benchmark_curve_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecLstUpdRelSymsLegGrp::clear_leg_benchmark_curve_data() {
  if (leg_benchmark_curve_data_ != NULL) leg_benchmark_curve_data_->::Common::LegBenchmarkCurveData::Clear();
  clear_has_leg_benchmark_curve_data();
}
inline const ::Common::LegBenchmarkCurveData& SecLstUpdRelSymsLegGrp::leg_benchmark_curve_data() const {
  return leg_benchmark_curve_data_ != NULL ? *leg_benchmark_curve_data_ : *default_instance_->leg_benchmark_curve_data_;
}
inline ::Common::LegBenchmarkCurveData* SecLstUpdRelSymsLegGrp::mutable_leg_benchmark_curve_data() {
  set_has_leg_benchmark_curve_data();
  if (leg_benchmark_curve_data_ == NULL) leg_benchmark_curve_data_ = new ::Common::LegBenchmarkCurveData;
  return leg_benchmark_curve_data_;
}
inline ::Common::LegBenchmarkCurveData* SecLstUpdRelSymsLegGrp::release_leg_benchmark_curve_data() {
  clear_has_leg_benchmark_curve_data();
  ::Common::LegBenchmarkCurveData* temp = leg_benchmark_curve_data_;
  leg_benchmark_curve_data_ = NULL;
  return temp;
}
inline void SecLstUpdRelSymsLegGrp::set_allocated_leg_benchmark_curve_data(::Common::LegBenchmarkCurveData* leg_benchmark_curve_data) {
  delete leg_benchmark_curve_data_;
  leg_benchmark_curve_data_ = leg_benchmark_curve_data;
  if (leg_benchmark_curve_data) {
    set_has_leg_benchmark_curve_data();
  } else {
    clear_has_leg_benchmark_curve_data();
  }
}

// optional string leg_settl_type = 3;
inline bool SecLstUpdRelSymsLegGrp::has_leg_settl_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecLstUpdRelSymsLegGrp::set_has_leg_settl_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecLstUpdRelSymsLegGrp::clear_has_leg_settl_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecLstUpdRelSymsLegGrp::clear_leg_settl_type() {
  if (leg_settl_type_ != &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_->clear();
  }
  clear_has_leg_settl_type();
}
inline const ::std::string& SecLstUpdRelSymsLegGrp::leg_settl_type() const {
  return *leg_settl_type_;
}
inline void SecLstUpdRelSymsLegGrp::set_leg_settl_type(const ::std::string& value) {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  leg_settl_type_->assign(value);
}
inline void SecLstUpdRelSymsLegGrp::set_leg_settl_type(const char* value) {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  leg_settl_type_->assign(value);
}
inline void SecLstUpdRelSymsLegGrp::set_leg_settl_type(const char* value, size_t size) {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  leg_settl_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecLstUpdRelSymsLegGrp::mutable_leg_settl_type() {
  set_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    leg_settl_type_ = new ::std::string;
  }
  return leg_settl_type_;
}
inline ::std::string* SecLstUpdRelSymsLegGrp::release_leg_settl_type() {
  clear_has_leg_settl_type();
  if (leg_settl_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = leg_settl_type_;
    leg_settl_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecLstUpdRelSymsLegGrp::set_allocated_leg_settl_type(::std::string* leg_settl_type) {
  if (leg_settl_type_ != &::google::protobuf::internal::kEmptyString) {
    delete leg_settl_type_;
  }
  if (leg_settl_type) {
    set_has_leg_settl_type();
    leg_settl_type_ = leg_settl_type;
  } else {
    clear_has_leg_settl_type();
    leg_settl_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Common.LegStipulations leg_stipulations = 4;
inline int SecLstUpdRelSymsLegGrp::leg_stipulations_size() const {
  return leg_stipulations_.size();
}
inline void SecLstUpdRelSymsLegGrp::clear_leg_stipulations() {
  leg_stipulations_.Clear();
}
inline const ::Common::LegStipulations& SecLstUpdRelSymsLegGrp::leg_stipulations(int index) const {
  return leg_stipulations_.Get(index);
}
inline ::Common::LegStipulations* SecLstUpdRelSymsLegGrp::mutable_leg_stipulations(int index) {
  return leg_stipulations_.Mutable(index);
}
inline ::Common::LegStipulations* SecLstUpdRelSymsLegGrp::add_leg_stipulations() {
  return leg_stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >&
SecLstUpdRelSymsLegGrp::leg_stipulations() const {
  return leg_stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::LegStipulations >*
SecLstUpdRelSymsLegGrp::mutable_leg_stipulations() {
  return &leg_stipulations_;
}

// optional .SecuritiesReferenceData.LegSwapTypeEnum leg_swap_type = 5;
inline bool SecLstUpdRelSymsLegGrp::has_leg_swap_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecLstUpdRelSymsLegGrp::set_has_leg_swap_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecLstUpdRelSymsLegGrp::clear_has_leg_swap_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecLstUpdRelSymsLegGrp::clear_leg_swap_type() {
  leg_swap_type_ = 0;
  clear_has_leg_swap_type();
}
inline ::SecuritiesReferenceData::LegSwapTypeEnum SecLstUpdRelSymsLegGrp::leg_swap_type() const {
  return static_cast< ::SecuritiesReferenceData::LegSwapTypeEnum >(leg_swap_type_);
}
inline void SecLstUpdRelSymsLegGrp::set_leg_swap_type(::SecuritiesReferenceData::LegSwapTypeEnum value) {
  assert(::SecuritiesReferenceData::LegSwapTypeEnum_IsValid(value));
  set_has_leg_swap_type();
  leg_swap_type_ = value;
}

// -------------------------------------------------------------------

// SecLstUpdRelSymGrp

// optional string currency = 1;
inline bool SecLstUpdRelSymGrp::has_currency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_currency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecLstUpdRelSymGrp::clear_has_currency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecLstUpdRelSymGrp::clear_currency() {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    currency_->clear();
  }
  clear_has_currency();
}
inline const ::std::string& SecLstUpdRelSymGrp::currency() const {
  return *currency_;
}
inline void SecLstUpdRelSymGrp::set_currency(const ::std::string& value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecLstUpdRelSymGrp::set_currency(const char* value) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(value);
}
inline void SecLstUpdRelSymGrp::set_currency(const char* value, size_t size) {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  currency_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecLstUpdRelSymGrp::mutable_currency() {
  set_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    currency_ = new ::std::string;
  }
  return currency_;
}
inline ::std::string* SecLstUpdRelSymGrp::release_currency() {
  clear_has_currency();
  if (currency_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = currency_;
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecLstUpdRelSymGrp::set_allocated_currency(::std::string* currency) {
  if (currency_ != &::google::protobuf::internal::kEmptyString) {
    delete currency_;
  }
  if (currency) {
    set_has_currency();
    currency_ = currency;
  } else {
    clear_has_currency();
    currency_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_text = 2;
inline bool SecLstUpdRelSymGrp::has_encoded_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_encoded_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SecLstUpdRelSymGrp::clear_has_encoded_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SecLstUpdRelSymGrp::clear_encoded_text() {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    encoded_text_->clear();
  }
  clear_has_encoded_text();
}
inline const ::std::string& SecLstUpdRelSymGrp::encoded_text() const {
  return *encoded_text_;
}
inline void SecLstUpdRelSymGrp::set_encoded_text(const ::std::string& value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecLstUpdRelSymGrp::set_encoded_text(const char* value) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(value);
}
inline void SecLstUpdRelSymGrp::set_encoded_text(const void* value, size_t size) {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  encoded_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecLstUpdRelSymGrp::mutable_encoded_text() {
  set_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    encoded_text_ = new ::std::string;
  }
  return encoded_text_;
}
inline ::std::string* SecLstUpdRelSymGrp::release_encoded_text() {
  clear_has_encoded_text();
  if (encoded_text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_text_;
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecLstUpdRelSymGrp::set_allocated_encoded_text(::std::string* encoded_text) {
  if (encoded_text_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_text_;
  }
  if (encoded_text) {
    set_has_encoded_text();
    encoded_text_ = encoded_text;
  } else {
    clear_has_encoded_text();
    encoded_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_text_len = 3;
inline bool SecLstUpdRelSymGrp::has_encoded_text_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_encoded_text_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecLstUpdRelSymGrp::clear_has_encoded_text_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecLstUpdRelSymGrp::clear_encoded_text_len() {
  encoded_text_len_ = 0u;
  clear_has_encoded_text_len();
}
inline ::google::protobuf::uint32 SecLstUpdRelSymGrp::encoded_text_len() const {
  return encoded_text_len_;
}
inline void SecLstUpdRelSymGrp::set_encoded_text_len(::google::protobuf::uint32 value) {
  set_has_encoded_text_len();
  encoded_text_len_ = value;
}

// optional .Common.FinancingDetails financing_details = 4;
inline bool SecLstUpdRelSymGrp::has_financing_details() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_financing_details() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SecLstUpdRelSymGrp::clear_has_financing_details() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SecLstUpdRelSymGrp::clear_financing_details() {
  if (financing_details_ != NULL) financing_details_->::Common::FinancingDetails::Clear();
  clear_has_financing_details();
}
inline const ::Common::FinancingDetails& SecLstUpdRelSymGrp::financing_details() const {
  return financing_details_ != NULL ? *financing_details_ : *default_instance_->financing_details_;
}
inline ::Common::FinancingDetails* SecLstUpdRelSymGrp::mutable_financing_details() {
  set_has_financing_details();
  if (financing_details_ == NULL) financing_details_ = new ::Common::FinancingDetails;
  return financing_details_;
}
inline ::Common::FinancingDetails* SecLstUpdRelSymGrp::release_financing_details() {
  clear_has_financing_details();
  ::Common::FinancingDetails* temp = financing_details_;
  financing_details_ = NULL;
  return temp;
}
inline void SecLstUpdRelSymGrp::set_allocated_financing_details(::Common::FinancingDetails* financing_details) {
  delete financing_details_;
  financing_details_ = financing_details;
  if (financing_details) {
    set_has_financing_details();
  } else {
    clear_has_financing_details();
  }
}

// optional .Common.Instrument instrument = 5;
inline bool SecLstUpdRelSymGrp::has_instrument() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_instrument() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecLstUpdRelSymGrp::clear_has_instrument() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecLstUpdRelSymGrp::clear_instrument() {
  if (instrument_ != NULL) instrument_->::Common::Instrument::Clear();
  clear_has_instrument();
}
inline const ::Common::Instrument& SecLstUpdRelSymGrp::instrument() const {
  return instrument_ != NULL ? *instrument_ : *default_instance_->instrument_;
}
inline ::Common::Instrument* SecLstUpdRelSymGrp::mutable_instrument() {
  set_has_instrument();
  if (instrument_ == NULL) instrument_ = new ::Common::Instrument;
  return instrument_;
}
inline ::Common::Instrument* SecLstUpdRelSymGrp::release_instrument() {
  clear_has_instrument();
  ::Common::Instrument* temp = instrument_;
  instrument_ = NULL;
  return temp;
}
inline void SecLstUpdRelSymGrp::set_allocated_instrument(::Common::Instrument* instrument) {
  delete instrument_;
  instrument_ = instrument;
  if (instrument) {
    set_has_instrument();
  } else {
    clear_has_instrument();
  }
}

// optional .Common.InstrumentExtension instrument_extension = 6;
inline bool SecLstUpdRelSymGrp::has_instrument_extension() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_instrument_extension() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecLstUpdRelSymGrp::clear_has_instrument_extension() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecLstUpdRelSymGrp::clear_instrument_extension() {
  if (instrument_extension_ != NULL) instrument_extension_->::Common::InstrumentExtension::Clear();
  clear_has_instrument_extension();
}
inline const ::Common::InstrumentExtension& SecLstUpdRelSymGrp::instrument_extension() const {
  return instrument_extension_ != NULL ? *instrument_extension_ : *default_instance_->instrument_extension_;
}
inline ::Common::InstrumentExtension* SecLstUpdRelSymGrp::mutable_instrument_extension() {
  set_has_instrument_extension();
  if (instrument_extension_ == NULL) instrument_extension_ = new ::Common::InstrumentExtension;
  return instrument_extension_;
}
inline ::Common::InstrumentExtension* SecLstUpdRelSymGrp::release_instrument_extension() {
  clear_has_instrument_extension();
  ::Common::InstrumentExtension* temp = instrument_extension_;
  instrument_extension_ = NULL;
  return temp;
}
inline void SecLstUpdRelSymGrp::set_allocated_instrument_extension(::Common::InstrumentExtension* instrument_extension) {
  delete instrument_extension_;
  instrument_extension_ = instrument_extension;
  if (instrument_extension) {
    set_has_instrument_extension();
  } else {
    clear_has_instrument_extension();
  }
}

// repeated .SecuritiesReferenceData.SecLstUpdRelSymsLegGrp sec_lst_upd_rel_syms_leg_grp = 7;
inline int SecLstUpdRelSymGrp::sec_lst_upd_rel_syms_leg_grp_size() const {
  return sec_lst_upd_rel_syms_leg_grp_.size();
}
inline void SecLstUpdRelSymGrp::clear_sec_lst_upd_rel_syms_leg_grp() {
  sec_lst_upd_rel_syms_leg_grp_.Clear();
}
inline const ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp& SecLstUpdRelSymGrp::sec_lst_upd_rel_syms_leg_grp(int index) const {
  return sec_lst_upd_rel_syms_leg_grp_.Get(index);
}
inline ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp* SecLstUpdRelSymGrp::mutable_sec_lst_upd_rel_syms_leg_grp(int index) {
  return sec_lst_upd_rel_syms_leg_grp_.Mutable(index);
}
inline ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp* SecLstUpdRelSymGrp::add_sec_lst_upd_rel_syms_leg_grp() {
  return sec_lst_upd_rel_syms_leg_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp >&
SecLstUpdRelSymGrp::sec_lst_upd_rel_syms_leg_grp() const {
  return sec_lst_upd_rel_syms_leg_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymsLegGrp >*
SecLstUpdRelSymGrp::mutable_sec_lst_upd_rel_syms_leg_grp() {
  return &sec_lst_upd_rel_syms_leg_grp_;
}

// optional .Common.SpreadOrBenchmarkCurveData spread_or_benchmark_curve_data = 8;
inline bool SecLstUpdRelSymGrp::has_spread_or_benchmark_curve_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecLstUpdRelSymGrp::clear_has_spread_or_benchmark_curve_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecLstUpdRelSymGrp::clear_spread_or_benchmark_curve_data() {
  if (spread_or_benchmark_curve_data_ != NULL) spread_or_benchmark_curve_data_->::Common::SpreadOrBenchmarkCurveData::Clear();
  clear_has_spread_or_benchmark_curve_data();
}
inline const ::Common::SpreadOrBenchmarkCurveData& SecLstUpdRelSymGrp::spread_or_benchmark_curve_data() const {
  return spread_or_benchmark_curve_data_ != NULL ? *spread_or_benchmark_curve_data_ : *default_instance_->spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecLstUpdRelSymGrp::mutable_spread_or_benchmark_curve_data() {
  set_has_spread_or_benchmark_curve_data();
  if (spread_or_benchmark_curve_data_ == NULL) spread_or_benchmark_curve_data_ = new ::Common::SpreadOrBenchmarkCurveData;
  return spread_or_benchmark_curve_data_;
}
inline ::Common::SpreadOrBenchmarkCurveData* SecLstUpdRelSymGrp::release_spread_or_benchmark_curve_data() {
  clear_has_spread_or_benchmark_curve_data();
  ::Common::SpreadOrBenchmarkCurveData* temp = spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = NULL;
  return temp;
}
inline void SecLstUpdRelSymGrp::set_allocated_spread_or_benchmark_curve_data(::Common::SpreadOrBenchmarkCurveData* spread_or_benchmark_curve_data) {
  delete spread_or_benchmark_curve_data_;
  spread_or_benchmark_curve_data_ = spread_or_benchmark_curve_data;
  if (spread_or_benchmark_curve_data) {
    set_has_spread_or_benchmark_curve_data();
  } else {
    clear_has_spread_or_benchmark_curve_data();
  }
}

// repeated .Common.Stipulations stipulations = 9;
inline int SecLstUpdRelSymGrp::stipulations_size() const {
  return stipulations_.size();
}
inline void SecLstUpdRelSymGrp::clear_stipulations() {
  stipulations_.Clear();
}
inline const ::Common::Stipulations& SecLstUpdRelSymGrp::stipulations(int index) const {
  return stipulations_.Get(index);
}
inline ::Common::Stipulations* SecLstUpdRelSymGrp::mutable_stipulations(int index) {
  return stipulations_.Mutable(index);
}
inline ::Common::Stipulations* SecLstUpdRelSymGrp::add_stipulations() {
  return stipulations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >&
SecLstUpdRelSymGrp::stipulations() const {
  return stipulations_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::Stipulations >*
SecLstUpdRelSymGrp::mutable_stipulations() {
  return &stipulations_;
}

// optional string text = 10;
inline bool SecLstUpdRelSymGrp::has_text() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_text() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecLstUpdRelSymGrp::clear_has_text() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecLstUpdRelSymGrp::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SecLstUpdRelSymGrp::text() const {
  return *text_;
}
inline void SecLstUpdRelSymGrp::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecLstUpdRelSymGrp::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SecLstUpdRelSymGrp::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecLstUpdRelSymGrp::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SecLstUpdRelSymGrp::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecLstUpdRelSymGrp::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.YieldData yield_data = 11;
inline bool SecLstUpdRelSymGrp::has_yield_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_yield_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SecLstUpdRelSymGrp::clear_has_yield_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SecLstUpdRelSymGrp::clear_yield_data() {
  if (yield_data_ != NULL) yield_data_->::Common::YieldData::Clear();
  clear_has_yield_data();
}
inline const ::Common::YieldData& SecLstUpdRelSymGrp::yield_data() const {
  return yield_data_ != NULL ? *yield_data_ : *default_instance_->yield_data_;
}
inline ::Common::YieldData* SecLstUpdRelSymGrp::mutable_yield_data() {
  set_has_yield_data();
  if (yield_data_ == NULL) yield_data_ = new ::Common::YieldData;
  return yield_data_;
}
inline ::Common::YieldData* SecLstUpdRelSymGrp::release_yield_data() {
  clear_has_yield_data();
  ::Common::YieldData* temp = yield_data_;
  yield_data_ = NULL;
  return temp;
}
inline void SecLstUpdRelSymGrp::set_allocated_yield_data(::Common::YieldData* yield_data) {
  delete yield_data_;
  yield_data_ = yield_data;
  if (yield_data) {
    set_has_yield_data();
  } else {
    clear_has_yield_data();
  }
}

// optional string list_update_action = 12;
inline bool SecLstUpdRelSymGrp::has_list_update_action() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_list_update_action() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SecLstUpdRelSymGrp::clear_has_list_update_action() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SecLstUpdRelSymGrp::clear_list_update_action() {
  if (list_update_action_ != &::google::protobuf::internal::kEmptyString) {
    list_update_action_->clear();
  }
  clear_has_list_update_action();
}
inline const ::std::string& SecLstUpdRelSymGrp::list_update_action() const {
  return *list_update_action_;
}
inline void SecLstUpdRelSymGrp::set_list_update_action(const ::std::string& value) {
  set_has_list_update_action();
  if (list_update_action_ == &::google::protobuf::internal::kEmptyString) {
    list_update_action_ = new ::std::string;
  }
  list_update_action_->assign(value);
}
inline void SecLstUpdRelSymGrp::set_list_update_action(const char* value) {
  set_has_list_update_action();
  if (list_update_action_ == &::google::protobuf::internal::kEmptyString) {
    list_update_action_ = new ::std::string;
  }
  list_update_action_->assign(value);
}
inline void SecLstUpdRelSymGrp::set_list_update_action(const char* value, size_t size) {
  set_has_list_update_action();
  if (list_update_action_ == &::google::protobuf::internal::kEmptyString) {
    list_update_action_ = new ::std::string;
  }
  list_update_action_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecLstUpdRelSymGrp::mutable_list_update_action() {
  set_has_list_update_action();
  if (list_update_action_ == &::google::protobuf::internal::kEmptyString) {
    list_update_action_ = new ::std::string;
  }
  return list_update_action_;
}
inline ::std::string* SecLstUpdRelSymGrp::release_list_update_action() {
  clear_has_list_update_action();
  if (list_update_action_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = list_update_action_;
    list_update_action_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecLstUpdRelSymGrp::set_allocated_list_update_action(::std::string* list_update_action) {
  if (list_update_action_ != &::google::protobuf::internal::kEmptyString) {
    delete list_update_action_;
  }
  if (list_update_action) {
    set_has_list_update_action();
    list_update_action_ = list_update_action;
  } else {
    clear_has_list_update_action();
    list_update_action_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .Common.SecurityTradingRules security_trading_rules = 13;
inline bool SecLstUpdRelSymGrp::has_security_trading_rules() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_security_trading_rules() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecLstUpdRelSymGrp::clear_has_security_trading_rules() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecLstUpdRelSymGrp::clear_security_trading_rules() {
  if (security_trading_rules_ != NULL) security_trading_rules_->::Common::SecurityTradingRules::Clear();
  clear_has_security_trading_rules();
}
inline const ::Common::SecurityTradingRules& SecLstUpdRelSymGrp::security_trading_rules() const {
  return security_trading_rules_ != NULL ? *security_trading_rules_ : *default_instance_->security_trading_rules_;
}
inline ::Common::SecurityTradingRules* SecLstUpdRelSymGrp::mutable_security_trading_rules() {
  set_has_security_trading_rules();
  if (security_trading_rules_ == NULL) security_trading_rules_ = new ::Common::SecurityTradingRules;
  return security_trading_rules_;
}
inline ::Common::SecurityTradingRules* SecLstUpdRelSymGrp::release_security_trading_rules() {
  clear_has_security_trading_rules();
  ::Common::SecurityTradingRules* temp = security_trading_rules_;
  security_trading_rules_ = NULL;
  return temp;
}
inline void SecLstUpdRelSymGrp::set_allocated_security_trading_rules(::Common::SecurityTradingRules* security_trading_rules) {
  delete security_trading_rules_;
  security_trading_rules_ = security_trading_rules;
  if (security_trading_rules) {
    set_has_security_trading_rules();
  } else {
    clear_has_security_trading_rules();
  }
}

// repeated .Common.StrikeRules strike_rules = 14;
inline int SecLstUpdRelSymGrp::strike_rules_size() const {
  return strike_rules_.size();
}
inline void SecLstUpdRelSymGrp::clear_strike_rules() {
  strike_rules_.Clear();
}
inline const ::Common::StrikeRules& SecLstUpdRelSymGrp::strike_rules(int index) const {
  return strike_rules_.Get(index);
}
inline ::Common::StrikeRules* SecLstUpdRelSymGrp::mutable_strike_rules(int index) {
  return strike_rules_.Mutable(index);
}
inline ::Common::StrikeRules* SecLstUpdRelSymGrp::add_strike_rules() {
  return strike_rules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >&
SecLstUpdRelSymGrp::strike_rules() const {
  return strike_rules_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::StrikeRules >*
SecLstUpdRelSymGrp::mutable_strike_rules() {
  return &strike_rules_;
}

// repeated .Common.UndInstrmtGrp und_instrmt_grp = 15;
inline int SecLstUpdRelSymGrp::und_instrmt_grp_size() const {
  return und_instrmt_grp_.size();
}
inline void SecLstUpdRelSymGrp::clear_und_instrmt_grp() {
  und_instrmt_grp_.Clear();
}
inline const ::Common::UndInstrmtGrp& SecLstUpdRelSymGrp::und_instrmt_grp(int index) const {
  return und_instrmt_grp_.Get(index);
}
inline ::Common::UndInstrmtGrp* SecLstUpdRelSymGrp::mutable_und_instrmt_grp(int index) {
  return und_instrmt_grp_.Mutable(index);
}
inline ::Common::UndInstrmtGrp* SecLstUpdRelSymGrp::add_und_instrmt_grp() {
  return und_instrmt_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >&
SecLstUpdRelSymGrp::und_instrmt_grp() const {
  return und_instrmt_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::Common::UndInstrmtGrp >*
SecLstUpdRelSymGrp::mutable_und_instrmt_grp() {
  return &und_instrmt_grp_;
}

// optional sfixed64 rel_sym_transact_time = 16;
inline bool SecLstUpdRelSymGrp::has_rel_sym_transact_time() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SecLstUpdRelSymGrp::set_has_rel_sym_transact_time() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SecLstUpdRelSymGrp::clear_has_rel_sym_transact_time() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SecLstUpdRelSymGrp::clear_rel_sym_transact_time() {
  rel_sym_transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_rel_sym_transact_time();
}
inline ::google::protobuf::int64 SecLstUpdRelSymGrp::rel_sym_transact_time() const {
  return rel_sym_transact_time_;
}
inline void SecLstUpdRelSymGrp::set_rel_sym_transact_time(::google::protobuf::int64 value) {
  set_has_rel_sym_transact_time();
  rel_sym_transact_time_ = value;
}

// -------------------------------------------------------------------

// SecurityListUpdateReport

// optional sfixed32 clearing_business_date = 1;
inline bool SecurityListUpdateReport::has_clearing_business_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SecurityListUpdateReport::set_has_clearing_business_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SecurityListUpdateReport::clear_has_clearing_business_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SecurityListUpdateReport::clear_clearing_business_date() {
  clearing_business_date_ = 0;
  clear_has_clearing_business_date();
}
inline ::google::protobuf::int32 SecurityListUpdateReport::clearing_business_date() const {
  return clearing_business_date_;
}
inline void SecurityListUpdateReport::set_clearing_business_date(::google::protobuf::int32 value) {
  set_has_clearing_business_date();
  clearing_business_date_ = value;
}

// repeated .SecuritiesReferenceData.CorporateActionEnum corporate_action = 2 [packed = true];
inline int SecurityListUpdateReport::corporate_action_size() const {
  return corporate_action_.size();
}
inline void SecurityListUpdateReport::clear_corporate_action() {
  corporate_action_.Clear();
}
inline ::SecuritiesReferenceData::CorporateActionEnum SecurityListUpdateReport::corporate_action(int index) const {
  return static_cast< ::SecuritiesReferenceData::CorporateActionEnum >(corporate_action_.Get(index));
}
inline void SecurityListUpdateReport::set_corporate_action(int index, ::SecuritiesReferenceData::CorporateActionEnum value) {
  assert(::SecuritiesReferenceData::CorporateActionEnum_IsValid(value));
  corporate_action_.Set(index, value);
}
inline void SecurityListUpdateReport::add_corporate_action(::SecuritiesReferenceData::CorporateActionEnum value) {
  assert(::SecuritiesReferenceData::CorporateActionEnum_IsValid(value));
  corporate_action_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
SecurityListUpdateReport::corporate_action() const {
  return corporate_action_;
}
inline ::google::protobuf::RepeatedField<int>*
SecurityListUpdateReport::mutable_corporate_action() {
  return &corporate_action_;
}

// optional bool last_fragment = 3;
inline bool SecurityListUpdateReport::has_last_fragment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SecurityListUpdateReport::set_has_last_fragment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SecurityListUpdateReport::clear_has_last_fragment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SecurityListUpdateReport::clear_last_fragment() {
  last_fragment_ = false;
  clear_has_last_fragment();
}
inline bool SecurityListUpdateReport::last_fragment() const {
  return last_fragment_;
}
inline void SecurityListUpdateReport::set_last_fragment(bool value) {
  set_has_last_fragment();
  last_fragment_ = value;
}

// repeated .SecuritiesReferenceData.SecLstUpdRelSymGrp sec_lst_upd_rel_sym_grp = 4;
inline int SecurityListUpdateReport::sec_lst_upd_rel_sym_grp_size() const {
  return sec_lst_upd_rel_sym_grp_.size();
}
inline void SecurityListUpdateReport::clear_sec_lst_upd_rel_sym_grp() {
  sec_lst_upd_rel_sym_grp_.Clear();
}
inline const ::SecuritiesReferenceData::SecLstUpdRelSymGrp& SecurityListUpdateReport::sec_lst_upd_rel_sym_grp(int index) const {
  return sec_lst_upd_rel_sym_grp_.Get(index);
}
inline ::SecuritiesReferenceData::SecLstUpdRelSymGrp* SecurityListUpdateReport::mutable_sec_lst_upd_rel_sym_grp(int index) {
  return sec_lst_upd_rel_sym_grp_.Mutable(index);
}
inline ::SecuritiesReferenceData::SecLstUpdRelSymGrp* SecurityListUpdateReport::add_sec_lst_upd_rel_sym_grp() {
  return sec_lst_upd_rel_sym_grp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymGrp >&
SecurityListUpdateReport::sec_lst_upd_rel_sym_grp() const {
  return sec_lst_upd_rel_sym_grp_;
}
inline ::google::protobuf::RepeatedPtrField< ::SecuritiesReferenceData::SecLstUpdRelSymGrp >*
SecurityListUpdateReport::mutable_sec_lst_upd_rel_sym_grp() {
  return &sec_lst_upd_rel_sym_grp_;
}

// optional sfixed64 security_report_id = 5;
inline bool SecurityListUpdateReport::has_security_report_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_report_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SecurityListUpdateReport::clear_has_security_report_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SecurityListUpdateReport::clear_security_report_id() {
  security_report_id_ = GOOGLE_LONGLONG(0);
  clear_has_security_report_id();
}
inline ::google::protobuf::int64 SecurityListUpdateReport::security_report_id() const {
  return security_report_id_;
}
inline void SecurityListUpdateReport::set_security_report_id(::google::protobuf::int64 value) {
  set_has_security_report_id();
  security_report_id_ = value;
}

// optional string security_req_id = 6;
inline bool SecurityListUpdateReport::has_security_req_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_req_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SecurityListUpdateReport::clear_has_security_req_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SecurityListUpdateReport::clear_security_req_id() {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    security_req_id_->clear();
  }
  clear_has_security_req_id();
}
inline const ::std::string& SecurityListUpdateReport::security_req_id() const {
  return *security_req_id_;
}
inline void SecurityListUpdateReport::set_security_req_id(const ::std::string& value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityListUpdateReport::set_security_req_id(const char* value) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(value);
}
inline void SecurityListUpdateReport::set_security_req_id(const char* value, size_t size) {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  security_req_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListUpdateReport::mutable_security_req_id() {
  set_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    security_req_id_ = new ::std::string;
  }
  return security_req_id_;
}
inline ::std::string* SecurityListUpdateReport::release_security_req_id() {
  clear_has_security_req_id();
  if (security_req_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_req_id_;
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListUpdateReport::set_allocated_security_req_id(::std::string* security_req_id) {
  if (security_req_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_req_id_;
  }
  if (security_req_id) {
    set_has_security_req_id();
    security_req_id_ = security_req_id;
  } else {
    clear_has_security_req_id();
    security_req_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.SecurityRequestResultEnum security_request_result = 7;
inline bool SecurityListUpdateReport::has_security_request_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_request_result() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SecurityListUpdateReport::clear_has_security_request_result() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SecurityListUpdateReport::clear_security_request_result() {
  security_request_result_ = 0;
  clear_has_security_request_result();
}
inline ::SecuritiesReferenceData::SecurityRequestResultEnum SecurityListUpdateReport::security_request_result() const {
  return static_cast< ::SecuritiesReferenceData::SecurityRequestResultEnum >(security_request_result_);
}
inline void SecurityListUpdateReport::set_security_request_result(::SecuritiesReferenceData::SecurityRequestResultEnum value) {
  assert(::SecuritiesReferenceData::SecurityRequestResultEnum_IsValid(value));
  set_has_security_request_result();
  security_request_result_ = value;
}

// optional string security_response_id = 8;
inline bool SecurityListUpdateReport::has_security_response_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_response_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SecurityListUpdateReport::clear_has_security_response_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SecurityListUpdateReport::clear_security_response_id() {
  if (security_response_id_ != &::google::protobuf::internal::kEmptyString) {
    security_response_id_->clear();
  }
  clear_has_security_response_id();
}
inline const ::std::string& SecurityListUpdateReport::security_response_id() const {
  return *security_response_id_;
}
inline void SecurityListUpdateReport::set_security_response_id(const ::std::string& value) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(value);
}
inline void SecurityListUpdateReport::set_security_response_id(const char* value) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(value);
}
inline void SecurityListUpdateReport::set_security_response_id(const char* value, size_t size) {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  security_response_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListUpdateReport::mutable_security_response_id() {
  set_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    security_response_id_ = new ::std::string;
  }
  return security_response_id_;
}
inline ::std::string* SecurityListUpdateReport::release_security_response_id() {
  clear_has_security_response_id();
  if (security_response_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_response_id_;
    security_response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListUpdateReport::set_allocated_security_response_id(::std::string* security_response_id) {
  if (security_response_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_response_id_;
  }
  if (security_response_id) {
    set_has_security_response_id();
    security_response_id_ = security_response_id;
  } else {
    clear_has_security_response_id();
    security_response_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.SecurityUpdateActionEnum security_update_action = 9;
inline bool SecurityListUpdateReport::has_security_update_action() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_update_action() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SecurityListUpdateReport::clear_has_security_update_action() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SecurityListUpdateReport::clear_security_update_action() {
  security_update_action_ = 0;
  clear_has_security_update_action();
}
inline ::SecuritiesReferenceData::SecurityUpdateActionEnum SecurityListUpdateReport::security_update_action() const {
  return static_cast< ::SecuritiesReferenceData::SecurityUpdateActionEnum >(security_update_action_);
}
inline void SecurityListUpdateReport::set_security_update_action(::SecuritiesReferenceData::SecurityUpdateActionEnum value) {
  assert(::SecuritiesReferenceData::SecurityUpdateActionEnum_IsValid(value));
  set_has_security_update_action();
  security_update_action_ = value;
}

// optional .Session.StandardHeader standard_header = 10;
inline bool SecurityListUpdateReport::has_standard_header() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SecurityListUpdateReport::set_has_standard_header() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SecurityListUpdateReport::clear_has_standard_header() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SecurityListUpdateReport::clear_standard_header() {
  if (standard_header_ != NULL) standard_header_->::Session::StandardHeader::Clear();
  clear_has_standard_header();
}
inline const ::Session::StandardHeader& SecurityListUpdateReport::standard_header() const {
  return standard_header_ != NULL ? *standard_header_ : *default_instance_->standard_header_;
}
inline ::Session::StandardHeader* SecurityListUpdateReport::mutable_standard_header() {
  set_has_standard_header();
  if (standard_header_ == NULL) standard_header_ = new ::Session::StandardHeader;
  return standard_header_;
}
inline ::Session::StandardHeader* SecurityListUpdateReport::release_standard_header() {
  clear_has_standard_header();
  ::Session::StandardHeader* temp = standard_header_;
  standard_header_ = NULL;
  return temp;
}
inline void SecurityListUpdateReport::set_allocated_standard_header(::Session::StandardHeader* standard_header) {
  delete standard_header_;
  standard_header_ = standard_header;
  if (standard_header) {
    set_has_standard_header();
  } else {
    clear_has_standard_header();
  }
}

// optional .Session.StandardTrailer standard_trailer = 11;
inline bool SecurityListUpdateReport::has_standard_trailer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SecurityListUpdateReport::set_has_standard_trailer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SecurityListUpdateReport::clear_has_standard_trailer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SecurityListUpdateReport::clear_standard_trailer() {
  if (standard_trailer_ != NULL) standard_trailer_->::Session::StandardTrailer::Clear();
  clear_has_standard_trailer();
}
inline const ::Session::StandardTrailer& SecurityListUpdateReport::standard_trailer() const {
  return standard_trailer_ != NULL ? *standard_trailer_ : *default_instance_->standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityListUpdateReport::mutable_standard_trailer() {
  set_has_standard_trailer();
  if (standard_trailer_ == NULL) standard_trailer_ = new ::Session::StandardTrailer;
  return standard_trailer_;
}
inline ::Session::StandardTrailer* SecurityListUpdateReport::release_standard_trailer() {
  clear_has_standard_trailer();
  ::Session::StandardTrailer* temp = standard_trailer_;
  standard_trailer_ = NULL;
  return temp;
}
inline void SecurityListUpdateReport::set_allocated_standard_trailer(::Session::StandardTrailer* standard_trailer) {
  delete standard_trailer_;
  standard_trailer_ = standard_trailer;
  if (standard_trailer) {
    set_has_standard_trailer();
  } else {
    clear_has_standard_trailer();
  }
}

// optional sfixed64 tot_no_related_sym = 12;
inline bool SecurityListUpdateReport::has_tot_no_related_sym() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SecurityListUpdateReport::set_has_tot_no_related_sym() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SecurityListUpdateReport::clear_has_tot_no_related_sym() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SecurityListUpdateReport::clear_tot_no_related_sym() {
  tot_no_related_sym_ = GOOGLE_LONGLONG(0);
  clear_has_tot_no_related_sym();
}
inline ::google::protobuf::int64 SecurityListUpdateReport::tot_no_related_sym() const {
  return tot_no_related_sym_;
}
inline void SecurityListUpdateReport::set_tot_no_related_sym(::google::protobuf::int64 value) {
  set_has_tot_no_related_sym();
  tot_no_related_sym_ = value;
}

// optional .Common.ApplicationSequenceControl application_sequence_control = 13;
inline bool SecurityListUpdateReport::has_application_sequence_control() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SecurityListUpdateReport::set_has_application_sequence_control() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SecurityListUpdateReport::clear_has_application_sequence_control() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SecurityListUpdateReport::clear_application_sequence_control() {
  if (application_sequence_control_ != NULL) application_sequence_control_->::Common::ApplicationSequenceControl::Clear();
  clear_has_application_sequence_control();
}
inline const ::Common::ApplicationSequenceControl& SecurityListUpdateReport::application_sequence_control() const {
  return application_sequence_control_ != NULL ? *application_sequence_control_ : *default_instance_->application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* SecurityListUpdateReport::mutable_application_sequence_control() {
  set_has_application_sequence_control();
  if (application_sequence_control_ == NULL) application_sequence_control_ = new ::Common::ApplicationSequenceControl;
  return application_sequence_control_;
}
inline ::Common::ApplicationSequenceControl* SecurityListUpdateReport::release_application_sequence_control() {
  clear_has_application_sequence_control();
  ::Common::ApplicationSequenceControl* temp = application_sequence_control_;
  application_sequence_control_ = NULL;
  return temp;
}
inline void SecurityListUpdateReport::set_allocated_application_sequence_control(::Common::ApplicationSequenceControl* application_sequence_control) {
  delete application_sequence_control_;
  application_sequence_control_ = application_sequence_control;
  if (application_sequence_control) {
    set_has_application_sequence_control();
  } else {
    clear_has_application_sequence_control();
  }
}

// optional string market_id = 14;
inline bool SecurityListUpdateReport::has_market_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SecurityListUpdateReport::set_has_market_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SecurityListUpdateReport::clear_has_market_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SecurityListUpdateReport::clear_market_id() {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    market_id_->clear();
  }
  clear_has_market_id();
}
inline const ::std::string& SecurityListUpdateReport::market_id() const {
  return *market_id_;
}
inline void SecurityListUpdateReport::set_market_id(const ::std::string& value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void SecurityListUpdateReport::set_market_id(const char* value) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(value);
}
inline void SecurityListUpdateReport::set_market_id(const char* value, size_t size) {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  market_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListUpdateReport::mutable_market_id() {
  set_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    market_id_ = new ::std::string;
  }
  return market_id_;
}
inline ::std::string* SecurityListUpdateReport::release_market_id() {
  clear_has_market_id();
  if (market_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_id_;
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListUpdateReport::set_allocated_market_id(::std::string* market_id) {
  if (market_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_id_;
  }
  if (market_id) {
    set_has_market_id();
    market_id_ = market_id;
  } else {
    clear_has_market_id();
    market_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string market_segment_id = 15;
inline bool SecurityListUpdateReport::has_market_segment_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SecurityListUpdateReport::set_has_market_segment_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SecurityListUpdateReport::clear_has_market_segment_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SecurityListUpdateReport::clear_market_segment_id() {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    market_segment_id_->clear();
  }
  clear_has_market_segment_id();
}
inline const ::std::string& SecurityListUpdateReport::market_segment_id() const {
  return *market_segment_id_;
}
inline void SecurityListUpdateReport::set_market_segment_id(const ::std::string& value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void SecurityListUpdateReport::set_market_segment_id(const char* value) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(value);
}
inline void SecurityListUpdateReport::set_market_segment_id(const char* value, size_t size) {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  market_segment_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListUpdateReport::mutable_market_segment_id() {
  set_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    market_segment_id_ = new ::std::string;
  }
  return market_segment_id_;
}
inline ::std::string* SecurityListUpdateReport::release_market_segment_id() {
  clear_has_market_segment_id();
  if (market_segment_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = market_segment_id_;
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListUpdateReport::set_allocated_market_segment_id(::std::string* market_segment_id) {
  if (market_segment_id_ != &::google::protobuf::internal::kEmptyString) {
    delete market_segment_id_;
  }
  if (market_segment_id) {
    set_has_market_segment_id();
    market_segment_id_ = market_segment_id;
  } else {
    clear_has_market_segment_id();
    market_segment_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes encoded_security_list_desc = 16;
inline bool SecurityListUpdateReport::has_encoded_security_list_desc() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SecurityListUpdateReport::set_has_encoded_security_list_desc() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SecurityListUpdateReport::clear_has_encoded_security_list_desc() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SecurityListUpdateReport::clear_encoded_security_list_desc() {
  if (encoded_security_list_desc_ != &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_->clear();
  }
  clear_has_encoded_security_list_desc();
}
inline const ::std::string& SecurityListUpdateReport::encoded_security_list_desc() const {
  return *encoded_security_list_desc_;
}
inline void SecurityListUpdateReport::set_encoded_security_list_desc(const ::std::string& value) {
  set_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_ = new ::std::string;
  }
  encoded_security_list_desc_->assign(value);
}
inline void SecurityListUpdateReport::set_encoded_security_list_desc(const char* value) {
  set_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_ = new ::std::string;
  }
  encoded_security_list_desc_->assign(value);
}
inline void SecurityListUpdateReport::set_encoded_security_list_desc(const void* value, size_t size) {
  set_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_ = new ::std::string;
  }
  encoded_security_list_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListUpdateReport::mutable_encoded_security_list_desc() {
  set_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    encoded_security_list_desc_ = new ::std::string;
  }
  return encoded_security_list_desc_;
}
inline ::std::string* SecurityListUpdateReport::release_encoded_security_list_desc() {
  clear_has_encoded_security_list_desc();
  if (encoded_security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = encoded_security_list_desc_;
    encoded_security_list_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListUpdateReport::set_allocated_encoded_security_list_desc(::std::string* encoded_security_list_desc) {
  if (encoded_security_list_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete encoded_security_list_desc_;
  }
  if (encoded_security_list_desc) {
    set_has_encoded_security_list_desc();
    encoded_security_list_desc_ = encoded_security_list_desc;
  } else {
    clear_has_encoded_security_list_desc();
    encoded_security_list_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional fixed32 encoded_security_list_desc_len = 17;
inline bool SecurityListUpdateReport::has_encoded_security_list_desc_len() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SecurityListUpdateReport::set_has_encoded_security_list_desc_len() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SecurityListUpdateReport::clear_has_encoded_security_list_desc_len() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SecurityListUpdateReport::clear_encoded_security_list_desc_len() {
  encoded_security_list_desc_len_ = 0u;
  clear_has_encoded_security_list_desc_len();
}
inline ::google::protobuf::uint32 SecurityListUpdateReport::encoded_security_list_desc_len() const {
  return encoded_security_list_desc_len_;
}
inline void SecurityListUpdateReport::set_encoded_security_list_desc_len(::google::protobuf::uint32 value) {
  set_has_encoded_security_list_desc_len();
  encoded_security_list_desc_len_ = value;
}

// optional string security_list_desc = 18;
inline bool SecurityListUpdateReport::has_security_list_desc() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_list_desc() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SecurityListUpdateReport::clear_has_security_list_desc() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SecurityListUpdateReport::clear_security_list_desc() {
  if (security_list_desc_ != &::google::protobuf::internal::kEmptyString) {
    security_list_desc_->clear();
  }
  clear_has_security_list_desc();
}
inline const ::std::string& SecurityListUpdateReport::security_list_desc() const {
  return *security_list_desc_;
}
inline void SecurityListUpdateReport::set_security_list_desc(const ::std::string& value) {
  set_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_list_desc_ = new ::std::string;
  }
  security_list_desc_->assign(value);
}
inline void SecurityListUpdateReport::set_security_list_desc(const char* value) {
  set_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_list_desc_ = new ::std::string;
  }
  security_list_desc_->assign(value);
}
inline void SecurityListUpdateReport::set_security_list_desc(const char* value, size_t size) {
  set_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_list_desc_ = new ::std::string;
  }
  security_list_desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListUpdateReport::mutable_security_list_desc() {
  set_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    security_list_desc_ = new ::std::string;
  }
  return security_list_desc_;
}
inline ::std::string* SecurityListUpdateReport::release_security_list_desc() {
  clear_has_security_list_desc();
  if (security_list_desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_list_desc_;
    security_list_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListUpdateReport::set_allocated_security_list_desc(::std::string* security_list_desc) {
  if (security_list_desc_ != &::google::protobuf::internal::kEmptyString) {
    delete security_list_desc_;
  }
  if (security_list_desc) {
    set_has_security_list_desc();
    security_list_desc_ = security_list_desc;
  } else {
    clear_has_security_list_desc();
    security_list_desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_list_id = 19;
inline bool SecurityListUpdateReport::has_security_list_id() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_list_id() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SecurityListUpdateReport::clear_has_security_list_id() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SecurityListUpdateReport::clear_security_list_id() {
  if (security_list_id_ != &::google::protobuf::internal::kEmptyString) {
    security_list_id_->clear();
  }
  clear_has_security_list_id();
}
inline const ::std::string& SecurityListUpdateReport::security_list_id() const {
  return *security_list_id_;
}
inline void SecurityListUpdateReport::set_security_list_id(const ::std::string& value) {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  security_list_id_->assign(value);
}
inline void SecurityListUpdateReport::set_security_list_id(const char* value) {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  security_list_id_->assign(value);
}
inline void SecurityListUpdateReport::set_security_list_id(const char* value, size_t size) {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  security_list_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListUpdateReport::mutable_security_list_id() {
  set_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_id_ = new ::std::string;
  }
  return security_list_id_;
}
inline ::std::string* SecurityListUpdateReport::release_security_list_id() {
  clear_has_security_list_id();
  if (security_list_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_list_id_;
    security_list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListUpdateReport::set_allocated_security_list_id(::std::string* security_list_id) {
  if (security_list_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_list_id_;
  }
  if (security_list_id) {
    set_has_security_list_id();
    security_list_id_ = security_list_id;
  } else {
    clear_has_security_list_id();
    security_list_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string security_list_ref_id = 20;
inline bool SecurityListUpdateReport::has_security_list_ref_id() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_list_ref_id() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SecurityListUpdateReport::clear_has_security_list_ref_id() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SecurityListUpdateReport::clear_security_list_ref_id() {
  if (security_list_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_->clear();
  }
  clear_has_security_list_ref_id();
}
inline const ::std::string& SecurityListUpdateReport::security_list_ref_id() const {
  return *security_list_ref_id_;
}
inline void SecurityListUpdateReport::set_security_list_ref_id(const ::std::string& value) {
  set_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_ = new ::std::string;
  }
  security_list_ref_id_->assign(value);
}
inline void SecurityListUpdateReport::set_security_list_ref_id(const char* value) {
  set_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_ = new ::std::string;
  }
  security_list_ref_id_->assign(value);
}
inline void SecurityListUpdateReport::set_security_list_ref_id(const char* value, size_t size) {
  set_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_ = new ::std::string;
  }
  security_list_ref_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SecurityListUpdateReport::mutable_security_list_ref_id() {
  set_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    security_list_ref_id_ = new ::std::string;
  }
  return security_list_ref_id_;
}
inline ::std::string* SecurityListUpdateReport::release_security_list_ref_id() {
  clear_has_security_list_ref_id();
  if (security_list_ref_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = security_list_ref_id_;
    security_list_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SecurityListUpdateReport::set_allocated_security_list_ref_id(::std::string* security_list_ref_id) {
  if (security_list_ref_id_ != &::google::protobuf::internal::kEmptyString) {
    delete security_list_ref_id_;
  }
  if (security_list_ref_id) {
    set_has_security_list_ref_id();
    security_list_ref_id_ = security_list_ref_id;
  } else {
    clear_has_security_list_ref_id();
    security_list_ref_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .SecuritiesReferenceData.SecurityListTypeEnum security_list_type = 21;
inline bool SecurityListUpdateReport::has_security_list_type() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_list_type() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SecurityListUpdateReport::clear_has_security_list_type() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SecurityListUpdateReport::clear_security_list_type() {
  security_list_type_ = 0;
  clear_has_security_list_type();
}
inline ::SecuritiesReferenceData::SecurityListTypeEnum SecurityListUpdateReport::security_list_type() const {
  return static_cast< ::SecuritiesReferenceData::SecurityListTypeEnum >(security_list_type_);
}
inline void SecurityListUpdateReport::set_security_list_type(::SecuritiesReferenceData::SecurityListTypeEnum value) {
  assert(::SecuritiesReferenceData::SecurityListTypeEnum_IsValid(value));
  set_has_security_list_type();
  security_list_type_ = value;
}

// optional .SecuritiesReferenceData.SecurityListTypeSourceEnum security_list_type_source = 22;
inline bool SecurityListUpdateReport::has_security_list_type_source() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SecurityListUpdateReport::set_has_security_list_type_source() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SecurityListUpdateReport::clear_has_security_list_type_source() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SecurityListUpdateReport::clear_security_list_type_source() {
  security_list_type_source_ = 0;
  clear_has_security_list_type_source();
}
inline ::SecuritiesReferenceData::SecurityListTypeSourceEnum SecurityListUpdateReport::security_list_type_source() const {
  return static_cast< ::SecuritiesReferenceData::SecurityListTypeSourceEnum >(security_list_type_source_);
}
inline void SecurityListUpdateReport::set_security_list_type_source(::SecuritiesReferenceData::SecurityListTypeSourceEnum value) {
  assert(::SecuritiesReferenceData::SecurityListTypeSourceEnum_IsValid(value));
  set_has_security_list_type_source();
  security_list_type_source_ = value;
}

// optional sfixed64 transact_time = 23;
inline bool SecurityListUpdateReport::has_transact_time() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SecurityListUpdateReport::set_has_transact_time() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SecurityListUpdateReport::clear_has_transact_time() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SecurityListUpdateReport::clear_transact_time() {
  transact_time_ = GOOGLE_LONGLONG(0);
  clear_has_transact_time();
}
inline ::google::protobuf::int64 SecurityListUpdateReport::transact_time() const {
  return transact_time_;
}
inline void SecurityListUpdateReport::set_transact_time(::google::protobuf::int64 value) {
  set_has_transact_time();
  transact_time_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace SecuritiesReferenceData

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::SecurityResponseTypeEnum>() {
  return ::SecuritiesReferenceData::SecurityResponseTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::CorporateActionEnum>() {
  return ::SecuritiesReferenceData::CorporateActionEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::SecurityRequestTypeEnum>() {
  return ::SecuritiesReferenceData::SecurityRequestTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::TradingSessionIdEnum>() {
  return ::SecuritiesReferenceData::TradingSessionIdEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::TradingSessionSubIdEnum>() {
  return ::SecuritiesReferenceData::TradingSessionSubIdEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::ExpirationCycleEnum>() {
  return ::SecuritiesReferenceData::ExpirationCycleEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::SubscriptionRequestTypeEnum>() {
  return ::SecuritiesReferenceData::SubscriptionRequestTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::SecurityUpdateActionEnum>() {
  return ::SecuritiesReferenceData::SecurityUpdateActionEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::SecurityListTypeEnum>() {
  return ::SecuritiesReferenceData::SecurityListTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::SecurityListTypeSourceEnum>() {
  return ::SecuritiesReferenceData::SecurityListTypeSourceEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::SecurityRequestResultEnum>() {
  return ::SecuritiesReferenceData::SecurityRequestResultEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::LastFragmentEnum>() {
  return ::SecuritiesReferenceData::LastFragmentEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::SecurityListRequestTypeEnum>() {
  return ::SecuritiesReferenceData::SecurityListRequestTypeEnum_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::SecuritiesReferenceData::LegSwapTypeEnum>() {
  return ::SecuritiesReferenceData::LegSwapTypeEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_securitiesreferencedata_2eproto__INCLUDED
